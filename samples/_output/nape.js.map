{
"version":3,
"file":"nape.js",
"sourceRoot":"file:///",
"sources":["/usr/lib/haxe/std/js/_std/Std.hx","/usr/lib/haxe/std/haxe/Timer.hx","/usr/lib/haxe/std/js/Boot.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/Callback.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/BodyCallback.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/Listener.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/BodyListener.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/CbEvent.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/CbType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/CbTypeIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/CbTypeList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/ConstraintCallback.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/ConstraintListener.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/InteractionCallback.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/InteractionListener.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/InteractionType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/ListenerIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/ListenerList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/ListenerType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/OptionType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/PreCallback.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/PreFlag.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/callbacks/PreListener.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/constraint/Constraint.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/constraint/ConstraintIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/constraint/ConstraintList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/Arbiter.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/ArbiterIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/ArbiterList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/ArbiterType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/CollisionArbiter.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/Contact.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/ContactIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/ContactList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/FluidArbiter.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/InteractionFilter.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/InteractionGroup.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/InteractionGroupIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/dynamics/InteractionGroupList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/AABB.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/ConvexResult.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/ConvexResultIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/ConvexResultList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/GeomPoly.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/GeomPolyIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/GeomPolyList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/Mat23.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/MatMN.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/RayResult.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/RayResultIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/RayResultList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/Vec2.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/Vec2Iterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/Vec2List.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/Vec3.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/geom/Winding.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/Interactor.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/Body.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/BodyIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/BodyList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/BodyType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/Compound.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/CompoundIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/CompoundList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/FluidProperties.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/GravMassMode.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/InertiaMode.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/InteractorIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/InteractorList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/MassMode.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/phys/Material.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/Shape.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/Circle.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/Edge.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/EdgeIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/EdgeList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/Polygon.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/ShapeIterator.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/ShapeList.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/ShapeType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/shape/ValidationResult.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/space/Broadphase.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/space/Space.hx","/haxe/pixi-haxe/pixi/plugins/app/Application.hx","/haxe/pixi-haxe/samples/nape/Main.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/ID.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/callbacks/Callback.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/callbacks/CbSet.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/callbacks/CbSetPair.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/util/Lists.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/callbacks/CbType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/callbacks/Listener.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/callbacks/OptionType.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/constraint/Constraint.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/dynamics/Arbiter.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/dynamics/Contact.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/dynamics/InteractionFilter.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/dynamics/InteractionGroup.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/AABB.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/Collide.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/ConvexRayResult.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/GeomPoly.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/Mat23.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/MatMN.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/SweepDistance.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/Vec2.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/Vec3.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/geom/VecMath.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/phys/Interactor.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/phys/Body.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/phys/Compound.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/phys/FluidProperties.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/phys/Material.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/shape/Shape.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/shape/Circle.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/shape/Edge.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/shape/Polygon.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/space/Broadphase.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/space/DynAABBPhase.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/space/Space.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/space/SweepPhase.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/util/Math.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/util/RBTree.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/nape/Config.hx","/haxe/pixi-haxe/.haxelib/nape/2,0,19/zpp_nape/util/Flags.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2013 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tThe Timer class allows you to create asynchronous timers on platforms that\n\tsupport events.\n\n\tThe intended usage is to create an instance of the Timer class with a given\n\tinterval, set its run() method to a custom function to be invoked and\n\teventually call stop() to stop the Timer.\n\n\tNote that a running Timer may or may not prevent the program to exit\n\tautomatically when main() returns.\n\n\tIt is also possible to extend this class and override its run() method in\n\tthe child class.\n**/\nclass Timer {\n\t#if (flash || js || java || python)\n\n\t#if (flash || js)\n\t\tprivate var id : Null<Int>;\n\t#elseif java\n\t\tprivate var timer : java.util.Timer;\n\t\tprivate var task : java.util.TimerTask;\n\t#end\n\n\t/**\n\t\tCreates a new timer that will run every `time_ms` milliseconds.\n\n\t\tAfter creating the Timer instance, it calls `this].run` repeatedly,\n\t\twith delays of `time_ms` milliseconds, until `this.stop` is called.\n\n\t\tThe first invocation occurs after `time_ms` milliseconds, not\n\t\timmediately.\n\n\t\tThe accuracy of this may be platform-dependent.\n\t**/\n\tpublic function new( time_ms : Int ){\n\t\t#if flash\n\t\t\tvar me = this;\n\t\t\tid = untyped __global__[\"flash.utils.setInterval\"](function() { me.run(); },time_ms);\n\t\t#elseif js\n\t\t\tvar me = this;\n\t\t\tid = untyped setInterval(function() me.run(),time_ms);\n\t\t#elseif java\n\t\t\ttimer = new java.util.Timer();\n\t\t\ttimer.scheduleAtFixedRate(task = new TimerTask(this), haxe.Int64.ofInt(time_ms), haxe.Int64.ofInt(time_ms));\n\t\t#end\n\t}\n\n\t/**\n\t\tStops `this` Timer.\n\n\t\tAfter calling this method, no additional invocations of `this.run`\n\t\twill occur.\n\n\t\tIt is not possible to restart `this` Timer once stopped.\n\t**/\n\tpublic function stop() {\n\t\t#if (flash || js)\n\t\t\tif( id == null )\n\t\t\t\treturn;\n\t\t\t#if flash\n\t\t\t\tuntyped __global__[\"flash.utils.clearInterval\"](id);\n\t\t\t#elseif js\n\t\t\t\tuntyped clearInterval(id);\n\t\t\t#end\n\t\t\tid = null;\n\t\t#elseif java\n\t\t\ttimer.cancel();\n\t\t\ttimer = null;\n\t\t\ttask = null;\n\t\t#end\n\t}\n\n\t/**\n\t\tThis method is invoked repeatedly on `this` Timer.\n\n\t\tIt can be overridden in a subclass, or rebound directly to a custom\n\t\tfunction:\n\t\t\tvar timer = new haxe.Timer(1000); // 1000ms delay\n\t\t\ttimer.run = function() { ... }\n\n\t\tOnce bound, it can still be rebound to different functions until `this`\n\t\tTimer is stopped through a call to `this.stop`.\n\t**/\n\tpublic dynamic function run() {\n\n\t}\n\n\t/**\n\t\tInvokes `f` after `time_ms` milliseconds.\n\n\t\tThis is a convenience function for creating a new Timer instance with\n\t\t`time_ms` as argument, binding its run() method to `f` and then stopping\n\t\t`this` Timer upon the first invocation.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function delay( f : Void -> Void, time_ms : Int ) {\n\t\tvar t = new haxe.Timer(time_ms);\n\t\tt.run = function() {\n\t\t\tt.stop();\n\t\t\tf();\n\t\t};\n\t\treturn t;\n\t}\n\n\t#end\n\n\t/**\n\t\tMeasures the time it takes to execute `f`, in seconds with fractions.\n\n\t\tThis is a convenience function for calculating the difference between\n\t\tTimer.stamp() before and after the invocation of `f`.\n\n\t\tThe difference is passed as argument to Log.trace(), with \"s\" appended\n\t\tto denote the unit. The optional `pos` argument is passed through.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function measure<T>( f : Void -> T, ?pos : PosInfos ) : T {\n\t\tvar t0 = stamp();\n\t\tvar r = f();\n\t\tLog.trace((stamp() - t0) + \"s\", pos);\n\t\treturn r;\n\t}\n\n\t/**\n\t\tReturns a timestamp, in seconds with fractions.\n\n\t\tThe value itself might differ depending on platforms, only differences\n\t\tbetween two values make sense.\n\t**/\n\tpublic static function stamp() : Float {\n\t\t#if flash\n\t\t\treturn flash.Lib.getTimer() / 1000;\n\t\t#elseif (neko || php)\n\t\t\treturn Sys.time();\n\t\t#elseif js\n\t\t\treturn Date.now().getTime() / 1000;\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__time_stamp();\n\t\t#elseif sys\n\t\t\treturn Sys.time();\n\t\t#else\n\t\t\treturn 0;\n\t\t#end\n\t}\n\n}\n\n#if java\n@:nativeGen\nprivate class TimerTask extends java.util.TimerTask {\n\tvar timer:Timer;\n\tpublic function new(timer:Timer):Void {\n\t\tsuper();\n\t\tthis.timer = timer;\n\t}\n\n\t@:overload override public function run():Void {\n\t\ttimer.run();\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped __js__(\"{}.toString\");\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) untyped {\n\t\treturn untyped Function('return typeof $name != \"undefined\" ? $name : null')();\n\t}\n\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Base type for Callback event objects.\n * <br/><br/>\n * Callback objects are automatically reused and you should not keep references\n * to them.\n */\n#if nape_swc@:keep #end\nclass Callback{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Callback=null;\n    /**\n     * CbEvent type this callback was generated for.\n     */\n    #if nape_swc@:isVar #end\n    public var event(get_event,never):CbEvent;\n    inline function get_event():CbEvent{\n        return ZPP_Listener.events[zpp_inner.event];\n    }\n    /**\n     * The Listener which was responsive for this callback being generated.\n     */\n    #if nape_swc@:isVar #end\n    public var listener(get_listener,never):Listener;\n    inline function get_listener():Listener{\n        return zpp_inner.listener.outer;\n    }\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Callback.internal){\n            throw \"Error: Callback cannot be instantiated derp!\";\n        }\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString():String{\n        return \"\";\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Callback object for Body type events.\n * <br/><br/>\n * This, like all other callback objects are automatically reused\n * and you should not keep any reference to them.\n */\n@:final#if nape_swc@:keep #end\nclass BodyCallback extends Callback{\n    /**\n     * @private\n     */\n    public function new(){\n        super();\n    }\n    /**\n     * Body involved in callback event.\n     */\n    #if nape_swc@:isVar #end\n    public var body(get_body,never):Body;\n    inline function get_body():Body{\n        return zpp_inner.body.outer;\n    }\n    /**\n     * @private\n     */\n    @:keep public override function toString(){\n        var ret=\"Cb:\";\n        ret+=[\"WAKE\",\"SLEEP\"][zpp_inner.event-ZPP_Flags.id_CbEvent_WAKE];\n        ret+=\":\"+body.toString();\n        ret+=\" : listener: \"+listener;\n        return ret;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Base type for all Nape callback listeners.\n */\n#if nape_swc@:keep #end\nclass Listener{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Listener=null;\n    /**\n     * The sub-type of this listener.\n     */\n    #if nape_swc@:isVar #end\n    public var type(get_type,never):ListenerType;\n    inline function get_type():ListenerType{\n        return ZPP_Listener.types[zpp_inner.type];\n    }\n    /**\n     * The CbEvent this listener responds to.\n     */\n    #if nape_swc@:isVar #end\n    public var event(get_event,set_event):CbEvent;\n    inline function get_event():CbEvent{\n        return ZPP_Listener.events[zpp_inner.event];\n    }\n    inline function set_event(event:CbEvent):CbEvent{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(event==null){\n                throw \"Error: Cannot set listener event type to null\";\n            }\n            #end\n            if(this.event!=event){\n                var xevent=if(event==CbEvent.BEGIN)ZPP_Flags.id_CbEvent_BEGIN else if(event==CbEvent.ONGOING)ZPP_Flags.id_CbEvent_ONGOING else if(event==CbEvent.END)ZPP_Flags.id_CbEvent_END else if(event==CbEvent.SLEEP)ZPP_Flags.id_CbEvent_SLEEP else if(event==CbEvent.WAKE)ZPP_Flags.id_CbEvent_WAKE else if(event==CbEvent.PRE)ZPP_Flags.id_CbEvent_PRE else ZPP_Flags.id_CbEvent_BREAK;\n                zpp_inner.swapEvent(xevent);\n            }\n        }\n        return get_event();\n    }\n    /**\n     * The precedence of this listener.\n     * <br/><br/>\n     * In any case that there is more than one suitable listener for a situation,\n     * the listeners will be ordered by their precedence.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var precedence(get_precedence,set_precedence):Int;\n    inline function get_precedence():Int{\n        return zpp_inner.precedence;\n    }\n    inline function set_precedence(precedence:Int):Int{\n        {\n            if(this.precedence!=precedence){\n                zpp_inner.precedence=precedence;\n                zpp_inner.invalidate_precedence();\n            }\n        }\n        return get_precedence();\n    }\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Listener.internal){\n            throw \"Error: Cannot instantiate Listener derp!\";\n        }\n        #end\n    }\n    /**\n     * The Space this listener is assigned to.\n     * <br/><br/>\n     * This value can be set, with setting to null being equivalent to removing\n     * the listener from whichever Space it is presently assigned to.\n     *\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var space(get_space,set_space):Null<Space>;\n    inline function get_space():Null<Space>{\n        return if(zpp_inner.space==null)null else zpp_inner.space.outer;\n    }\n    inline function set_space(space:Null<Space>):Null<Space>{\n        {\n            if(this.space!=space){\n                if(zpp_inner.space!=null){\n                    zpp_inner.space.outer.listeners.remove(this);\n                }\n                if(space!=null){\n                    space.listeners.add(this);\n                }\n                else{\n                    zpp_inner.space=null;\n                }\n            }\n        }\n        return get_space();\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var event=[\"BEGIN\",\"END\",\"WAKE\",\"SLEEP\",\"BREAK\",\"PRE\",\"ONGOING\"][zpp_inner.event];\n        if(zpp_inner.type==ZPP_Flags.id_ListenerType_BODY){\n            var body=zpp_inner.body;\n            return \"BodyListener{\"+event+\"::\"+body.outer_zn.options+\"}\";\n        }\n        else if(zpp_inner.type==ZPP_Flags.id_ListenerType_CONSTRAINT){\n            var con=zpp_inner.constraint;\n            return \"ConstraintListener{\"+event+\"::\"+con.outer_zn.options+\"}\";\n        }\n        else{\n            var con=zpp_inner.interaction;\n            var itype=switch(con.itype){\n                case ZPP_Flags.id_InteractionType_COLLISION:\"COLLISION\";\n                case ZPP_Flags.id_InteractionType_SENSOR:\"SENSOR\";\n                case ZPP_Flags.id_InteractionType_FLUID:\"FLUID\";\n                default:\"ALL\";\n            }\n            return(if(zpp_inner.type==ZPP_Flags.id_ListenerType_INTERACTION)\"InteractionListener{\"+event+\"#\"+itype+\"::\"+con.outer_zni.options1+\":\"+con.outer_zni.options2+\"}\" else \"PreListener{\"+itype+\"::\"+con.outer_znp.options1+\":\"+con.outer_znp.options2+\"}\")+\" precedence=\"+zpp_inner.precedence;\n        }\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Event listener for Body type events.\n * <br/><br/>\n * The events that can be caught are WAKE and SLEEP type events.\n * Theses listeners will only operate on Bodys, not Interactors in general.\n */\n@:final#if nape_swc@:keep #end\nclass BodyListener extends Listener{\n    /**\n     * @private\n     */\n    public var zpp_inner_zn:ZPP_BodyListener=null;\n    /**\n     * The OptionType used to match against Bodies.\n     * <br/><br/>\n     * When added to the same Space, any Body who's CbType list matches\n     * against this OptionType will be issued a callback when the relevant\n     * event occurs.\n     */\n    #if nape_swc@:isVar #end\n    public var options(get_options,set_options):OptionType;\n    inline function get_options():OptionType{\n        return zpp_inner_zn.options.outer;\n    }\n    inline function set_options(options:OptionType):OptionType{\n        {\n            zpp_inner_zn.options.set(options.zpp_inner);\n        }\n        return get_options();\n    }\n    /**\n     * The callback handler for this listener.\n     */\n    #if nape_swc@:isVar #end\n    public var handler(get_handler,set_handler):BodyCallback->Void;\n    inline function get_handler():BodyCallback->Void{\n        return zpp_inner_zn.handler;\n    }\n    inline function set_handler(handler:BodyCallback->Void):BodyCallback->Void{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(handler==null){\n                throw \"Error: BodyListener::handler cannot be null\";\n            }\n            #end\n            zpp_inner_zn.handler=handler;\n        }\n        return get_handler();\n    }\n    /**\n     * Construct a new BodyListener.\n     * <br/><br/>\n     * The possible event types are WAKE and SLEEP.\n     * <br/><br/>\n     * The options argument is typed Dynamic, and is permitted to be either an\n     * <code>OptionType</code> or one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>\n     * In which case the input CbType's will be used to construct an OptionType\n     * whose included types will be the set of CbTypes supplied.\n     *\n     * @param event The event type to listen for.\n     * @param options The OptionType to match Bodys against, passing null\n     *                will equate to an empty OptionType.\n     * @param handler The callback handler for this listener.\n     * @param precedence The precedence of this listener used to sort\n     *                   the order of callbacks in the case of more than\n     *                   one suitable BodyListener existing for the same\n     *                   event on the same Body. (default 0)\n     * @return The newly constructed BodyListener\n     * @throws # If handler is null.\n     * @throws # If the event type is not permitted for this listener.\n     * @throws # If options is not of the expected Type.\n     */\n    #if flib@:keep function flibopts_1(){}\n    #end\n    public function new(event:CbEvent,options:Null<Dynamic>,handler:BodyCallback->Void,precedence:Int=0){\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Listener.internal=true;\n        #end\n        super();\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Listener.internal=false;\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(handler==null){\n            throw \"Error: BodyListener::handler cannot be null\";\n        }\n        #end\n        var xevent=-1;\n        if(event==CbEvent.WAKE)xevent=ZPP_Flags.id_CbEvent_WAKE;\n        else if(event==CbEvent.SLEEP)xevent=ZPP_Flags.id_CbEvent_SLEEP;\n        else{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: cbEvent '\"+event.toString()+\"' is not a valid event type for a BodyListener\";\n            #end\n        }\n        zpp_inner_zn=new ZPP_BodyListener(ZPP_OptionType.argument(options),xevent,handler);\n        zpp_inner=zpp_inner_zn;\n        zpp_inner.outer=this;\n        zpp_inner_zn.outer_zn=this;\n        zpp_inner.precedence=precedence;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of possible callback event types.\n */\n@:final#if nape_swc@:keep #end\nclass CbEvent{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"CbEvent\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==PRE)return\"PRE\";\n        else if(this==BEGIN)return\"BEGIN\";\n        else if(this==ONGOING)return\"ONGOING\";\n        else if(this==END)return\"END\";\n        else if(this==WAKE)return\"WAKE\";\n        else if(this==SLEEP)return\"SLEEP\";\n        else if(this==BREAK)return\"BREAK\";\n        else return \"\";\n    }\n    /**\n     * BEGIN event corresponds to the start of an interaction\n     */\n    #if nape_swc@:isVar #end\n    public static var BEGIN(get_BEGIN,never):CbEvent;\n    inline static function get_BEGIN(){\n        if(ZPP_Flags.CbEvent_BEGIN==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.CbEvent_BEGIN=new CbEvent();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.CbEvent_BEGIN;\n    }\n    /**\n     * ONGOING event corresponds to any step in which an interaction is occuring\n     * overlapping with the BEGIN event.\n     */\n    #if nape_swc@:isVar #end\n    public static var ONGOING(get_ONGOING,never):CbEvent;\n    inline static function get_ONGOING(){\n        if(ZPP_Flags.CbEvent_ONGOING==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.CbEvent_ONGOING=new CbEvent();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.CbEvent_ONGOING;\n    }\n    /**\n     * END event corresponds to the end of an interaction.\n     */\n    #if nape_swc@:isVar #end\n    public static var END(get_END,never):CbEvent;\n    inline static function get_END(){\n        if(ZPP_Flags.CbEvent_END==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.CbEvent_END=new CbEvent();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.CbEvent_END;\n    }\n    /**\n     * WAKE event corresponds to the waking of a Body or Constraint in the space.\n     */\n    #if nape_swc@:isVar #end\n    public static var WAKE(get_WAKE,never):CbEvent;\n    inline static function get_WAKE(){\n        if(ZPP_Flags.CbEvent_WAKE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.CbEvent_WAKE=new CbEvent();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.CbEvent_WAKE;\n    }\n    /**\n     * SLEEP event corresponds to the sleeping of a Body or Constraint in the space.\n     */\n    #if nape_swc@:isVar #end\n    public static var SLEEP(get_SLEEP,never):CbEvent;\n    inline static function get_SLEEP(){\n        if(ZPP_Flags.CbEvent_SLEEP==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.CbEvent_SLEEP=new CbEvent();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.CbEvent_SLEEP;\n    }\n    /**\n     * BREAK event corresponds to the breaking of a defined limit on a Constraint.\n     */\n    #if nape_swc@:isVar #end\n    public static var BREAK(get_BREAK,never):CbEvent;\n    inline static function get_BREAK(){\n        if(ZPP_Flags.CbEvent_BREAK==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.CbEvent_BREAK=new CbEvent();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.CbEvent_BREAK;\n    }\n    /**\n     * PRE event corresponds to a special mid-step event that occurs after it is determined\n     * that two objects 'will' begin to interact, but before any interaction commences.\n     */\n    #if nape_swc@:isVar #end\n    public static var PRE(get_PRE,never):CbEvent;\n    inline static function get_PRE(){\n        if(ZPP_Flags.CbEvent_PRE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.CbEvent_PRE=new CbEvent();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.CbEvent_PRE;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Callback Type applied to Interactors and Constraints.\n * <br/><br/>\n * Callback types are ranged over by listeners.\n */\n@:final#if nape_swc@:keep #end\nclass CbType{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_CbType=null;\n    /**\n     * Unique identifier for this CbType.\n     */\n    #if nape_swc@:isVar #end\n    public var id(get_id,never):Int;\n    inline function get_id():Int{\n        return zpp_inner.id;\n    }\n    /**\n     * Construct a new CbType object.\n     *\n     * @return A new CbType.\n     */\n    public function new(){\n        zpp_inner=new ZPP_CbType();\n        zpp_inner.outer=this;\n    }\n    \n    /**\n     * Default CbType given to all Bodys\n     *\n     * Due to the way the Callback system in Nape works, you can use this\n     * CbType to match against 'all'\n     * Bodys\n     * In a Listener (Assuming you do not 'remove' this type from the object)\n     */\n    #if nape_swc@:isVar #end\n    public static var ANY_BODY(get_ANY_BODY,never):CbType;\n    inline static function get_ANY_BODY():CbType{\n        return ZPP_CbType.ANY_BODY;\n    }\n    /**\n     * Default CbType given to all Constraints\n     *\n     * Due to the way the Callback system in Nape works, you can use this\n     * CbType to match against 'all'\n     * Constraints\n     * In a Listener (Assuming you do not 'remove' this type from the object)\n     */\n    #if nape_swc@:isVar #end\n    public static var ANY_CONSTRAINT(get_ANY_CONSTRAINT,never):CbType;\n    inline static function get_ANY_CONSTRAINT():CbType{\n        return ZPP_CbType.ANY_CONSTRAINT;\n    }\n    /**\n     * Default CbType given to all Shapes\n     *\n     * Due to the way the Callback system in Nape works, you can use this\n     * CbType to match against 'all'\n     * Shapes\n     * In a Listener (Assuming you do not 'remove' this type from the object)\n     */\n    #if nape_swc@:isVar #end\n    public static var ANY_SHAPE(get_ANY_SHAPE,never):CbType;\n    inline static function get_ANY_SHAPE():CbType{\n        return ZPP_CbType.ANY_SHAPE;\n    }\n    /**\n     * Default CbType given to all Compounds\n     *\n     * Due to the way the Callback system in Nape works, you can use this\n     * CbType to match against 'all'\n     * Compounds\n     * In a Listener (Assuming you do not 'remove' this type from the object)\n     */\n    #if nape_swc@:isVar #end\n    public static var ANY_COMPOUND(get_ANY_COMPOUND,never):CbType;\n    inline static function get_ANY_COMPOUND():CbType{\n        return ZPP_CbType.ANY_COMPOUND;\n    }\n    /**\n     * Construct OptionType with given extra includes.\n     * <br/><br/>\n     * Equivalent to <code>new OptionType(this).including(includes)</code>\n     * <br/><br/>\n     * The includes argument is typed Dynamic, and is permitted to be one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>\n     *\n     * @param includes The CbTypes to include.\n     * @return A new OptionType whose includes are equal to this CbType\n     *         and all the CbTypes given as argument.\n     * @throws # If includes is null.\n     */\n    public function including(includes:Dynamic):OptionType{\n        return(new OptionType(this)).including(includes);\n    }\n    /**\n     * Construct OptionType with given excludes.\n     * <br/><br/>\n     * Equivalent to <code>new OptionType(this).excluding(excludes)</code>\n     * <br/><br/>\n     * The excludes argument is typed Dynamic, and is permitted to be one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>\n     *\n     * @param excludes The CbTypes to exclude.\n     * @return A new OptionType whose included types are just 'this' and whose\n     *         excluded types are those given as argument.\n     * @throws # If excludes is null.\n     */\n    public function excluding(excludes:Dynamic):OptionType{\n        return(new OptionType(this)).excluding(excludes);\n    }\n    /**\n     * Dynamic object for user to store additional data.\n     * <br/><br/>\n     * This object cannot be set, only its dynamically created\n     * properties may be set. In AS3 the type of this property is &#42\n     * <br/><br/>\n     * This object will be lazily constructed so that until accessed\n     * for the first time, will be null internally.\n     *\n     * @default {}\n     */\n    #if nape_swc@:isVar #end\n    public var userData(get_userData,never):Dynamic<Dynamic>;\n    inline function get_userData():Dynamic<Dynamic>{\n        if(zpp_inner.userData==null){\n            zpp_inner.userData=cast{};\n        }\n        return zpp_inner.userData;\n    }\n    /**\n     * List of all Interactors using this CbType.\n     * <br/><br/>\n     * This list contains only those Interactors that are inside of a Space\n     * <br/><br/>\n     * This list is not only readonly, but also immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var interactors(get_interactors,never):InteractorList;\n    inline function get_interactors():InteractorList{\n        if(zpp_inner.wrap_interactors==null){\n            zpp_inner.wrap_interactors=ZPP_InteractorList.get(zpp_inner.interactors,true);\n        }\n        return zpp_inner.wrap_interactors;\n    }\n    /**\n     * List of all Constraints using this CbType.\n     * <br/><br/>\n     * This list contains only those Constraints that are inside of a Space\n     * <br/><br/>\n     * This list is not only readonly, but also immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var constraints(get_constraints,never):ConstraintList;\n    inline function get_constraints():ConstraintList{\n        if(zpp_inner.wrap_constraints==null){\n            zpp_inner.wrap_constraints=ZPP_ConstraintList.get(zpp_inner.constraints,true);\n        }\n        return zpp_inner.wrap_constraints;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString():String{\n        return if(this==ANY_BODY)\"ANY_BODY\";\n        else if(this==ANY_SHAPE)\"ANY_SHAPE\";\n        else if(this==ANY_COMPOUND)\"ANY_COMPOUND\";\n        else if(this==ANY_CONSTRAINT)\"ANY_CONSTRAINT\";\n        else \"CbType#\"+id;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass CbTypeIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:CbTypeList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:CbTypeIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:CbTypeIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_CbTypeList.internal)throw \"Error: Cannot instantiate \"+\"CbType\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:CbTypeList){\n        var ret=if(zpp_pool==null){\n            ZPP_CbTypeList.internal=true;\n            var ret=new CbTypeIterator();\n            ZPP_CbTypeList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=CbTypeIterator.zpp_pool;\n                CbTypeIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of CbType type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:CbType = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:CbType = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:CbType = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass CbTypeList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_CbTypeList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than CbType\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<CbType>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new CbTypeList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,CbType)#else Std.is(i,CbType)#end)throw \"Error: Array contains non \"+\"CbType\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<CbType>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new CbTypeList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:CbType):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):CbType{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:CbType):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"CbType\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:CbType):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"CbType\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():CbType{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"CbType\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():CbType{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"CbType\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:CbType):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:CbType):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"CbType\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"CbType\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return CbTypeIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new CbTypeList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"CbType\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:CbTypeList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_CbTypeList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:CbType->Void):CbTypeList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=CbTypeIterator.zpp_pool;\n                    CbTypeIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:CbType->Bool):CbTypeList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Callback object for Constraint type events.\n * <br/><br/>\n * This, like all other callback objects are automatically reused\n * and you should not keep any reference to them.\n */\n@:final#if nape_swc@:keep #end\nclass ConstraintCallback extends Callback{\n    /**\n     * @private\n     */\n    public function new(){\n        super();\n    }\n    /**\n     * Constraint involved in callback event.\n     */\n    #if nape_swc@:isVar #end\n    public var constraint(get_constraint,never):Constraint;\n    inline function get_constraint():Constraint{\n        return zpp_inner.constraint.outer;\n    }\n    /**\n     * @private\n     */\n    @:keep public override function toString(){\n        var ret=\"Cb:\";\n        ret+=[\"WAKE\",\"SLEEP\",\"BREAK\"][zpp_inner.event-ZPP_Flags.id_CbEvent_WAKE];\n        ret+=\":\"+constraint.toString();\n        ret+=\" : listener: \"+listener;\n        return ret;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Event listener for Constraint type events.\n * <br/><br/>\n * The events that can be caught are WAKE, SLEEP and BREAK type events.\n * Theses listeners will only operate on Constraints.\n */\n@:final#if nape_swc@:keep #end\nclass ConstraintListener extends Listener{\n    /**\n     * @private\n     */\n    public var zpp_inner_zn:ZPP_ConstraintListener=null;\n    /**\n     * The OptionType used to match against Constraints.\n     * <br/><br/>\n     * When added to the same Space, any Constraint who's CbType list matches\n     * against this OptionType will be issued a callback when the relevant\n     * event occurs.\n     */\n    #if nape_swc@:isVar #end\n    public var options(get_options,set_options):OptionType;\n    inline function get_options():OptionType{\n        return zpp_inner_zn.options.outer;\n    }\n    inline function set_options(options:OptionType):OptionType{\n        {\n            zpp_inner_zn.options.set(options.zpp_inner);\n        }\n        return get_options();\n    }\n    /**\n     * The callback handler for this event.\n     */\n    #if nape_swc@:isVar #end\n    public var handler(get_handler,set_handler):ConstraintCallback->Void;\n    inline function get_handler():ConstraintCallback->Void{\n        return zpp_inner_zn.handler;\n    }\n    inline function set_handler(handler:ConstraintCallback->Void):ConstraintCallback->Void{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(handler==null){\n                throw \"Error: ConstraintListener::handler cannot be null\";\n            }\n            #end\n            zpp_inner_zn.handler=handler;\n        }\n        return get_handler();\n    }\n    /**\n     * Construct a new ConstraintListener.\n     * <br/><br/>\n     * The possible event types are WAKE, SLEEP and BREAK.\n     * <br/><br/>\n     * The options argument is typed Dynamic, and is permitted to be either an\n     * <code>OptionType</code> or one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>\n     * In which case the input CbType's will be used to construct an OptionType\n     * whose included types will be the set of CbTypes supplied.\n     *\n     * @param event The event type to listen for.\n     * @param options The OptionType to match Constraints against, passing null\n     *                will equate to an empty OptionType.\n     * @param handler The callback handler for this listener.\n     * @param precedence The precedence of this listener used to sort\n     *                   the order of callbacks in the case of more than\n     *                   one suitable ConstraintListener existing for the same\n     *                   event on the same Constraint. (default 0)\n     * @return The newly constructed ConstraintListener\n     * @throws # If handler is null.\n     * @throws # If the event type is not permitted for this listener.\n     * @throws # If options is not of the expected Type.\n     */\n    #if flib@:keep function flibopts_1(){}\n    #end\n    public function new(event:CbEvent,options:Null<Dynamic>,handler:ConstraintCallback->Void,precedence:Int=0){\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Listener.internal=true;\n        #end\n        super();\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Listener.internal=false;\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(handler==null){\n            throw \"Error: ConstraintListener::handler cannot be null\";\n        }\n        #end\n        var xevent=-1;\n        if(event==CbEvent.WAKE)xevent=ZPP_Flags.id_CbEvent_WAKE;\n        else if(event==CbEvent.SLEEP)xevent=ZPP_Flags.id_CbEvent_SLEEP;\n        else if(event==CbEvent.BREAK)xevent=ZPP_Flags.id_CbEvent_BREAK;\n        else{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: cbEvent '\"+event.toString()+\"' is not a valid event type for a ConstraintListener\";\n            #end\n        }\n        zpp_inner_zn=new ZPP_ConstraintListener(ZPP_OptionType.argument(options),xevent,handler);\n        zpp_inner=zpp_inner_zn;\n        zpp_inner.outer=this;\n        zpp_inner_zn.outer_zn=this;\n        zpp_inner.precedence=precedence;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Callback object for Interaction type events.\n * <br/><br/>\n * This, like all other callback objects are automatically reused\n * and you should not keep any reference to them.\n */\n@:final#if nape_swc@:keep #end\nclass InteractionCallback extends Callback{\n    /**\n     * @private\n     */\n    public function new(){\n        super();\n    }\n    /**\n     * First Interactor involved in callback event.\n     * <br/><br/>\n     * This interactor will have CbType set matched by the first\n     * OptionType in InteractionListener\n     */\n    #if nape_swc@:isVar #end\n    public var int1(get_int1,never):Interactor;\n    inline function get_int1():Interactor{\n        return zpp_inner.int1.outer_i;\n    }\n    /**\n     * Second Interactor involved in callback event.\n     * <br/><br/>\n     * This interactor will have CbType set matched by the second\n     * OptionType in InteractionListener\n     */\n    #if nape_swc@:isVar #end\n    public var int2(get_int2,never):Interactor;\n    inline function get_int2():Interactor{\n        return zpp_inner.int2.outer_i;\n    }\n    /**\n     * Existing arbiters between interactors.\n     * <br/><br/>\n     * This list will at present contain 'all' arbiters, not just those matching the\n     * interactionType in the InteractionListener. (This may be subject to change).\n     */\n    #if nape_swc@:isVar #end\n    public var arbiters(get_arbiters,never):ArbiterList;\n    inline function get_arbiters():ArbiterList{\n        return zpp_inner.wrap_arbiters;\n    }\n    /**\n     * @private\n     */\n    @:keep public override function toString(){\n        var ret=\"Cb:\";\n        ret+=[\"BEGIN\",\"END\",\"\",\"\",\"\",\"\",\"ONGOING\"][zpp_inner.event];\n        ret+=\":\"+int1.toString()+\"/\"+int2.toString();\n        ret+=\" : \"+arbiters.toString();\n        ret+=\" : listener: \"+listener;\n        return ret;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Event listener for Interaction type events.\n * <br/><br/>\n * Interaction type events can occur between any two Interactors (whether they\n * be Shapes, Bodys, Compounds or a mix thereof).\n * <br/><br/>\n * The events that can be caught are BEGIN, ONGOING, and END type events.\n * Theses listeners will operate between pairs of Interactors.\n * <pre>\n *          _Space\n *         /      \\\n *     Cmp1        Cmp3\n *    /    \\         |\n * Body1  Cmp2     Body3\n *   |      |        |\n * Shp1   Body2    Shp3\n *          |\n *        Shp2\n * </pre>\n * The possible interactor pairs for callbacks are formed by finding the most\n * recent common ancestor in the world for the given pair of shapes and taking all\n * possible pairings. In the above situation we have:\n * <pre>\n * MRCA(Shp1, Shp2) = Cmp1  --> Possible pairings = [Shp1, Body1] x [Shp2, Body2, Cmp2]\n * MRCA(Shp1, Shp3) = Space --> Possible pairings = [Shp1, Body1, Cmp1] x [Shp3, Body3, Cmp3]\n * MRCA(Shp2, Shp3) = Space --> Possible pairings = [Shp2, Body2, Cmp2, Cmp1] x [Shp3, Body3, Cmp3]\n * </pre>\n * Of course, not all of these pairings will generate callbacks, only those for which\n * a valid listener exists for the event type, and for the cbtypes of each interactor.\n * <br/><br/>\n * Furthermore, the listener specifies an interaction type which works even in mixed\n * cases where many types of interaction between two objects is happening at once.\n */\n@:final#if nape_swc@:keep #end\nclass InteractionListener extends Listener{\n    /**\n     * @private\n     */\n    public var zpp_inner_zn:ZPP_InteractionListener=null;\n    /**\n     * The OptionType used to match against Interactors for the first object.\n     */\n    #if nape_swc@:isVar #end\n    public var options1(get_options1,set_options1):OptionType;\n    inline function get_options1():OptionType{\n        return zpp_inner_zn.options1.outer;\n    }\n    inline function set_options1(options1:OptionType):OptionType{\n        {\n            zpp_inner_zn.options1.set(options1.zpp_inner);\n        }\n        return get_options1();\n    }\n    /**\n     * The OptionType used to match against Interactors for the second object.\n     */\n    #if nape_swc@:isVar #end\n    public var options2(get_options2,set_options2):OptionType;\n    inline function get_options2():OptionType{\n        return zpp_inner_zn.options2.outer;\n    }\n    inline function set_options2(options2:OptionType):OptionType{\n        {\n            zpp_inner_zn.options2.set(options2.zpp_inner);\n        }\n        return get_options2();\n    }\n    /**\n     * The specific type of interaction that is to be listened for.\n     * <br/><br/>\n     * If we specify that we only want to listen for a fluid type interaction, then\n     * this listener will operate so that any other interactions for the same pair\n     * of objects is ignored.\n     */\n    #if nape_swc@:isVar #end\n    public var interactionType(get_interactionType,set_interactionType):InteractionType;\n    inline function get_interactionType():InteractionType{\n        var ret=zpp_inner_zn.itype;\n        return if(ret==ZPP_Flags.id_InteractionType_COLLISION)InteractionType.COLLISION;\n        else if(ret==ZPP_Flags.id_InteractionType_SENSOR)InteractionType.SENSOR;\n        else if(ret==ZPP_Flags.id_InteractionType_FLUID)InteractionType.FLUID;\n        else if(ret==ZPP_Flags.id_InteractionType_ANY)InteractionType.ANY;\n        else null;\n    }\n    inline function set_interactionType(interactionType:InteractionType):InteractionType{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(interactionType==null){\n                throw \"Error: Cannot set listener interaction type to null\";\n            }\n            #end\n            if(this.interactionType!=interactionType){\n                var xtype=if(interactionType==InteractionType.COLLISION)ZPP_Flags.id_InteractionType_COLLISION else if(interactionType==InteractionType.SENSOR)ZPP_Flags.id_InteractionType_SENSOR else if(interactionType==InteractionType.FLUID)ZPP_Flags.id_InteractionType_FLUID else ZPP_Flags.id_InteractionType_ANY;\n                zpp_inner_zn.setInteractionType(xtype);\n            }\n        }\n        return get_interactionType();\n    }\n    /**\n     * The callback handler for this listener.\n     */\n    #if nape_swc@:isVar #end\n    public var handler(get_handler,set_handler):InteractionCallback->Void;\n    inline function get_handler():InteractionCallback->Void{\n        return zpp_inner_zn.handleri;\n    }\n    inline function set_handler(handler:InteractionCallback->Void):InteractionCallback->Void{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(handler==null){\n                throw \"Error: InteractionListener::handler cannot be null\";\n            }\n            #end\n            zpp_inner_zn.handleri=handler;\n        }\n        return get_handler();\n    }\n    /**\n     * For ONGOING listeners only, permit ONGOING callbacks whilst sleeping.\n     * <br/><br/>\n     * This property determines whether we will still receive\n     * ONGOING callbacks between two sleeping Interactors. The default action is to\n     * inhibit callbacks between sleeping objects for performance. Setting this field to true\n     * will permit Nape to always generate callbacks.\n     */\n    #if nape_swc@:isVar #end\n    public var allowSleepingCallbacks(get_allowSleepingCallbacks,set_allowSleepingCallbacks):Bool;\n    inline function get_allowSleepingCallbacks():Bool{\n        return zpp_inner_zn.allowSleepingCallbacks;\n    }\n    inline function set_allowSleepingCallbacks(allowSleepingCallbacks:Bool):Bool{\n        {\n            zpp_inner_zn.allowSleepingCallbacks=allowSleepingCallbacks;\n        }\n        return get_allowSleepingCallbacks();\n    }\n    /**\n     * Construct a new InteractionListener.\n     * <br/><br/>\n     * The possible event types are BEGIN, ONGOING and END.\n     * <br/><br/>\n     * The options arguments are typed Dynamic, and are permitted to be either an\n     * <code>OptionType</code> or one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>\n     * In which case the input CbType's will be used to construct an OptionType\n     * whose included types will be the set of CbTypes supplied.\n     *\n     * @param event The event type to listen for.\n     * @param interactionType The interaction type to listen for.\n     * @param options1 The OptionType to match first Interactor against, passing null\n     *                will equate to an empty OptionType.\n     * @param options2 The OptionType to match second Interactor against, passing null\n     *                will equate to an empty OptionType.\n     * @param handler The callback handler for this listener.\n     * @param precedence The precedence of this listener used to sort\n     *                   the order of callbacks in the case of more than\n     *                   one suitable BodyListener existing for the same\n     *                   event on the same Body. (default 0)\n     * @return The newly constructed InteractionListener\n     * @throws # If handler is null.\n     * @throws # If the event type is not permitted for this listener.\n     * @throws # If either option is not of the expected Type.\n     */\n    #if flib@:keep function flibopts_1(){}\n    #end\n    public function new(event:CbEvent,interactionType:InteractionType,options1:Null<Dynamic>,options2:Null<Dynamic>,handler:InteractionCallback->Void,precedence:Int=0){\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Listener.internal=true;\n        #end\n        super();\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Listener.internal=false;\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(handler==null){\n            throw \"Error: InteractionListener::handler cannot be null\";\n        }\n        if(event==null){\n            throw \"Error: CbEvent cannot be null for InteractionListener\";\n        }\n        #end\n        var xevent=-1;\n        if(event==CbEvent.BEGIN)xevent=ZPP_Flags.id_CbEvent_BEGIN;\n        else if(event==CbEvent.END)xevent=ZPP_Flags.id_CbEvent_END;\n        else if(event==CbEvent.ONGOING)xevent=ZPP_Flags.id_CbEvent_ONGOING;\n        else{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: CbEvent '\"+event.toString()+\"' is not a valid event type for InteractionListener\";\n            #end\n        }\n        zpp_inner_zn=new ZPP_InteractionListener(ZPP_OptionType.argument(options1),ZPP_OptionType.argument(options2),xevent,ZPP_Flags.id_ListenerType_INTERACTION);\n        zpp_inner=zpp_inner_zn;\n        zpp_inner.outer=this;\n        zpp_inner_zn.outer_zni=this;\n        zpp_inner.precedence=precedence;\n        zpp_inner_zn.handleri=handler;\n        this.interactionType=interactionType;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of Interaction types.\n */\n@:final#if nape_swc@:keep #end\nclass InteractionType{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"InteractionType\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==COLLISION)return\"COLLISION\";\n        else if(this==SENSOR)return\"SENSOR\";\n        else if(this==FLUID)return\"FLUID\";\n        else if(this==ANY)return\"ANY\";\n        else return \"\";\n    }\n    /**\n     * Collision interaction type.\n     */\n    #if nape_swc@:isVar #end\n    public static var COLLISION(get_COLLISION,never):InteractionType;\n    inline static function get_COLLISION(){\n        if(ZPP_Flags.InteractionType_COLLISION==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.InteractionType_COLLISION=new InteractionType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.InteractionType_COLLISION;\n    }\n    /**\n     * Sensor interaction type.\n    \"\"*/#if nape_swc@:isVar #end\n    public static var SENSOR(get_SENSOR,never):InteractionType;\n    inline static function get_SENSOR(){\n        if(ZPP_Flags.InteractionType_SENSOR==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.InteractionType_SENSOR=new InteractionType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.InteractionType_SENSOR;\n    }\n    /**\n     * Fluid interaction type.\n     */\n    #if nape_swc@:isVar #end\n    public static var FLUID(get_FLUID,never):InteractionType;\n    inline static function get_FLUID(){\n        if(ZPP_Flags.InteractionType_FLUID==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.InteractionType_FLUID=new InteractionType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.InteractionType_FLUID;\n    }\n    /**\n     * Special enum corresponding to 'all' interaction types.\n     */\n    #if nape_swc@:isVar #end\n    public static var ANY(get_ANY,never):InteractionType;\n    inline static function get_ANY(){\n        if(ZPP_Flags.InteractionType_ANY==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.InteractionType_ANY=new InteractionType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.InteractionType_ANY;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ListenerIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:ListenerList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:ListenerIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:ListenerIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_ListenerList.internal)throw \"Error: Cannot instantiate \"+\"Listener\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:ListenerList){\n        var ret=if(zpp_pool==null){\n            ZPP_ListenerList.internal=true;\n            var ret=new ListenerIterator();\n            ZPP_ListenerList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=ListenerIterator.zpp_pool;\n                ListenerIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Listener type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Listener = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Listener = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Listener = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ListenerList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_ListenerList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Listener\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Listener>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new ListenerList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Listener)#else Std.is(i,Listener)#end)throw \"Error: Array contains non \"+\"Listener\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Listener>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new ListenerList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Listener):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Listener{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Listener):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Listener\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Listener):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Listener\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Listener{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Listener\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Listener{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Listener\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:Listener):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Listener):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Listener\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Listener\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return ListenerIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new ListenerList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Listener\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:ListenerList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_ListenerList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:Listener->Void):ListenerList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=ListenerIterator.zpp_pool;\n                    ListenerIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Listener->Bool):ListenerList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of Listener types.\n */\n@:final#if nape_swc@:keep #end\nclass ListenerType{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"ListenerType\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==BODY)return\"BODY\";\n        else if(this==CONSTRAINT)return\"CONSTRAINT\";\n        else if(this==INTERACTION)return\"INTERACTION\";\n        else if(this==PRE)return\"PRE\";\n        else return \"\";\n    }\n    /**\n     * Type for BodyListeners\n     */\n    #if nape_swc@:isVar #end\n    public static var BODY(get_BODY,never):ListenerType;\n    inline static function get_BODY(){\n        if(ZPP_Flags.ListenerType_BODY==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ListenerType_BODY=new ListenerType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ListenerType_BODY;\n    }\n    /**\n     * Type for ConstraintListeners\n     */\n    #if nape_swc@:isVar #end\n    public static var CONSTRAINT(get_CONSTRAINT,never):ListenerType;\n    inline static function get_CONSTRAINT(){\n        if(ZPP_Flags.ListenerType_CONSTRAINT==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ListenerType_CONSTRAINT=new ListenerType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ListenerType_CONSTRAINT;\n    }\n    /**\n     * Type for InteractionListeners\n     */\n    #if nape_swc@:isVar #end\n    public static var INTERACTION(get_INTERACTION,never):ListenerType;\n    inline static function get_INTERACTION(){\n        if(ZPP_Flags.ListenerType_INTERACTION==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ListenerType_INTERACTION=new ListenerType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ListenerType_INTERACTION;\n    }\n    /**\n     * Type for PreListeners\n     */\n    #if nape_swc@:isVar #end\n    public static var PRE(get_PRE,never):ListenerType;\n    inline static function get_PRE(){\n        if(ZPP_Flags.ListenerType_PRE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ListenerType_PRE=new ListenerType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ListenerType_PRE;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * OptionType representing matching behaviour for Listeners.\n * <br/><br/>\n * An object's set of CbType's 'matches' against an OptionType iff.\n * the OptionType's includes list intersects the object's set of CbTypes\n * and the OptionType's excludes list 'does not' intersect the object's set\n * of CbTypes.\n * <pre>\n * option = new OptionType([A, B], [C, D]);\n * obj.cbTypes = [] // => does not match option.\n * obj.cbTypes = [A] // => matches the option\n * obj.cbTypes = [A, C] // => does not match option.\n * </pre>\n * The optionType's includes and excludes list are managed to be always\n * disjoint: The action of including an already excluded type serves to\n * remove it from the excludes list, equalliy excluding an already included\n * type serves to remove it from the includes list.\n * <pre>\n * var option = new OptionType();\n * option.including(A); // option = {[A]:[]}\n * option.excluding(A); // option = {[]:[]}\n * option.excluding(A); // option = {[]:[A]}\n * option.including(A); // option = {[A]:[]}\n * </pre>\n */\n@:final#if nape_swc@:keep #end\nclass OptionType{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_OptionType=null;\n    /**\n     * List of included CbTypes.\n     * <br/><br/>\n     * This list is both readonly, and immutable. To remove an element\n     * from this list you can use: <code>option.excluding(cbType)</code>\n     *\n     * @default []\n     */\n    #if nape_swc@:isVar #end\n    public var includes(get_includes,never):CbTypeList;\n    inline function get_includes():CbTypeList{\n        if(zpp_inner.wrap_includes==null)zpp_inner.setup_includes();\n        return zpp_inner.wrap_includes;\n    }\n    /**\n     * List of excluded CbTypes.\n     * <br/><br/>\n     * This list is both readonly, and immutable. To remove an element\n     * from this list you can use: <code>option.including(cbType)</code>\n     *\n     * @default []\n     */\n    #if nape_swc@:isVar #end\n    public var excludes(get_excludes,never):CbTypeList;\n    inline function get_excludes():CbTypeList{\n        if(zpp_inner.wrap_excludes==null)zpp_inner.setup_excludes();\n        return zpp_inner.wrap_excludes;\n    }\n    /**\n     * Construct a new OptionType.\n     * <br/><br/>\n     * The type of the arguments is Dynamic, and is permitted to be one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>\n     *\n     * @param includes The set of CbTypes to be included in the matching process.\n     *                 (default null)\n     * @param excludes The set of CbTypes to be excluded in the matching process.\n     *                 (default null)\n     * @return Return new OptionType with give sets of CbTypes.\n     * @throws # If either argument is not of the expected Type.\n     */\n    #if flib@:keep function flibopts_2(){}\n    #end\n    public function new(includes:Dynamic=null,excludes:Dynamic=null){\n        zpp_inner=new ZPP_OptionType();\n        zpp_inner.outer=this;\n        if(includes!=null)including(includes);\n        if(excludes!=null)excluding(excludes);\n    }\n    /**\n     * Append set of types to includes list.\n     * <br/><br/>\n     * This method was originally named the more appropriate 'include'\n     * but this conflicted with the AS3 keyword include and had to be\n     * change.\n     * <br/><br/>\n     * The argument is typed Dynamic, and is permitted to be one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>\n     *\n     * @param includes The set of CbTypes to be included. (default null)\n     * @return A reference to this OptionType.\n     * @throws # If argument is not of the expected Type.\n     */\n    public function including(includes:Dynamic=null):OptionType{\n        zpp_inner.append(zpp_inner.includes,includes);\n        return this;\n    }\n    /**\n     * Append set of types to excludes list.\n     * <br/><br/>\n     * This method was originally named the more appropriate 'exclude'\n     * but to match the necessary change for the include function, this was\n     * renamed as excluding.\n     * <br/><br/>\n     * The argument is typed Dynamic, and is permitted to be one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt; flash.Vector&lt;CbType&gt;</code>\n     *\n     * @param excludes The set of CbTypes to be excluded. (default null)\n     * @return A reference to this OptionType.\n     * @throws # If argument is not of the expected Type.\n     */\n    public function excluding(excludes:Dynamic=null):OptionType{\n        zpp_inner.append(zpp_inner.excludes,excludes);\n        return this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString():String{\n        var inc=includes.toString();\n        var exc=excludes.toString();\n        return \"@{\"+inc+\" excluding \"+exc+\"}\";\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Callback object for Pre-Interaction type events.\n * <br/><br/>\n * This, like all other callback objects are automatically reused\n * and you should not keep any reference to them.\n */\n@:final#if nape_swc@:keep #end\nclass PreCallback extends Callback{\n    /**\n     * @private\n     */\n    public function new(){\n        super();\n    }\n    /**\n     * Arbiter related to callback event.\n     * <br/><br/>\n     * In the case that this pre-event occurs between two non-Shape's\n     * then this is the first arbiter to be created for the related\n     * interactionType\n     */\n    #if nape_swc@:isVar #end\n    public var arbiter(get_arbiter,never):Arbiter;\n    inline function get_arbiter():Arbiter{\n        return zpp_inner.pre_arbiter.wrapper();\n    }\n    /**\n     * First Interactor involved in callback event.\n     * <br/><br/>\n     * This interactor will have CbType set matched by the first\n     * OptionType in InteractionListener\n     */\n    #if nape_swc@:isVar #end\n    public var int1(get_int1,never):Interactor;\n    inline function get_int1():Interactor{\n        return zpp_inner.int1.outer_i;\n    }\n    /**\n     * Second Interactor involved in callback event.\n     * <br/><br/>\n     * This interactor will have CbType set matched by the second\n     * OptionType in InteractionListener\n     */\n    #if nape_swc@:isVar #end\n    public var int2(get_int2,never):Interactor;\n    inline function get_int2():Interactor{\n        return zpp_inner.int2.outer_i;\n    }\n    /**\n     * Describes how Arbiter's objects are related to int1/int2 properties\n     * <br/><br/>\n     * If true, then arbiter.shape1 will belong to callback.int2, and\n     * arbiter.shape2 will belong to callback.int1.\n     * <br/><br/>\n     * If you take the arbiter's normal, then if swapped is true, the normal\n     * will point from int2 towards int1 instead of from int1 towards int2.\n     */\n    #if nape_swc@:isVar #end\n    public var swapped(get_swapped,never):Bool;\n    inline function get_swapped():Bool{\n        return zpp_inner.pre_swapped;\n    }\n    /**\n     * @private\n     */\n    @:keep public override function toString(){\n        var ret=\"Cb:PRE:\";\n        ret+=\":\"+int1.toString()+\"/\"+int2.toString();\n        ret+=\" : \"+arbiter.toString();\n        ret+=\" : listnener: \"+listener;\n        return ret;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of interaction states for arbiters. These values are returned\n * by PreListener callback handlers.\n */\n@:final#if nape_swc@:keep #end\nclass PreFlag{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"PreFlag\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==ACCEPT)return\"ACCEPT\";\n        else if(this==IGNORE)return\"IGNORE\";\n        else if(this==ACCEPT_ONCE)return\"ACCEPT_ONCE\";\n        else if(this==IGNORE_ONCE)return\"IGNORE_ONCE\";\n        else return \"\";\n    }\n    /**\n     * Value denotes interaction will occur, and Nape will not ask again.\n     */\n    #if nape_swc@:isVar #end\n    public static var ACCEPT(get_ACCEPT,never):PreFlag;\n    inline static function get_ACCEPT(){\n        if(ZPP_Flags.PreFlag_ACCEPT==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.PreFlag_ACCEPT=new PreFlag();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.PreFlag_ACCEPT;\n    }\n    /**\n     * Value denotes interaction will be ignored, and Nape will not ask again.\n     */\n    #if nape_swc@:isVar #end\n    public static var IGNORE(get_IGNORE,never):PreFlag;\n    inline static function get_IGNORE(){\n        if(ZPP_Flags.PreFlag_IGNORE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.PreFlag_IGNORE=new PreFlag();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.PreFlag_IGNORE;\n    }\n    /**\n     * Value denotes interaction will occur 'this' step, and Nape will ask what\n     * to do again in the following step if interaction is still possible.\n     */\n    #if nape_swc@:isVar #end\n    public static var ACCEPT_ONCE(get_ACCEPT_ONCE,never):PreFlag;\n    inline static function get_ACCEPT_ONCE(){\n        if(ZPP_Flags.PreFlag_ACCEPT_ONCE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.PreFlag_ACCEPT_ONCE=new PreFlag();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.PreFlag_ACCEPT_ONCE;\n    }\n    /**\n     * Value denotes interaction will be ignored 'this' step, and Nape will ask what\n     * to do again in the following step if interaction is still possible.\n     */\n    #if nape_swc@:isVar #end\n    public static var IGNORE_ONCE(get_IGNORE_ONCE,never):PreFlag;\n    inline static function get_IGNORE_ONCE(){\n        if(ZPP_Flags.PreFlag_IGNORE_ONCE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.PreFlag_IGNORE_ONCE=new PreFlag();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.PreFlag_IGNORE_ONCE;\n    }\n}\n","package nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Event listener for Pre-Interaction type events.\n * <br/><br/>\n * Pre-Interaction type events can occur between any two Interactors (whether they\n * be Shapes, Bodys, Compounds or a mix thereof).\n */\n@:final#if nape_swc@:keep #end\nclass PreListener extends Listener{\n    /**\n     * @private\n     */\n    public var zpp_inner_zn:ZPP_InteractionListener=null;\n    /**\n     * The OptionType used to match against Interactors for the first object.\n     */\n    #if nape_swc@:isVar #end\n    public var options1(get_options1,set_options1):OptionType;\n    inline function get_options1():OptionType{\n        return zpp_inner_zn.options1.outer;\n    }\n    inline function set_options1(options1:OptionType):OptionType{\n        {\n            zpp_inner_zn.options1.set(options1.zpp_inner);\n        }\n        return get_options1();\n    }\n    /**\n     * The OptionType used to match against Interactors for the second object.\n     */\n    #if nape_swc@:isVar #end\n    public var options2(get_options2,set_options2):OptionType;\n    inline function get_options2():OptionType{\n        return zpp_inner_zn.options2.outer;\n    }\n    inline function set_options2(options2:OptionType):OptionType{\n        {\n            zpp_inner_zn.options2.set(options2.zpp_inner);\n        }\n        return get_options2();\n    }\n    /**\n     * Callback handler for this listener.\n     * <br/><br/>\n     * This callback handler returns a possibly null PreFlag object.\n     * <br/>\n     * Passing null is equivalent to telling nape 'ignore me' so that whatever existing\n     * decision has been made regarding the interaction is not modified.\n     * Otherwise returning a non-null PreFlag will change the current decision about what\n     * to do with the interaction.\n     * <br/><br/>\n     * Returning ACCEPT/IGNORE inform nape to take control over all subsequent interaction\n     * between the two objects until they seperate. Returning these will mean that the pre\n     * listener will not be invoked again until the objects seperate, and then begin to interact\n     * afresh.\n     * <br/><br/>\n     * Returning #_ONCE, the objects will only be effected for a single step, and the following\n     * step should they still be candidates for interaction, this handler will be invoked again.\n     * <br/>\n     * In the case of a #_ONCE, PreFlag; Nape will 'not' permit the two objects to go to sleep\n     * as Nape cannot know if this callback handler will suddenly changes its mind.\n     * <br/>\n     * If this handler is a 'pure' function, then you may mark it as such and Nape will keep you\n     * to your word and permit the objects to sleep.\n     */\n    #if nape_swc@:isVar #end\n    public var handler(get_handler,set_handler):PreCallback->Null<PreFlag>;\n    inline function get_handler():PreCallback->Null<PreFlag>{\n        return zpp_inner_zn.handlerp;\n    }\n    inline function set_handler(handler:PreCallback->Null<PreFlag>):PreCallback->Null<PreFlag>{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(handler==null){\n                throw \"Error: PreListener must take a non-null handler!\";\n            }\n            #end\n            zpp_inner_zn.handlerp=handler;\n            zpp_inner_zn.wake();\n        }\n        return get_handler();\n    }\n    /**\n     * Mark this listener as having a pure callback handler.\n     * <br/><br/>\n     * A pure callback handler is one which under no circumstances will change its behaviour.\n     * In such a (favourable) instance, marking the callback as pure will allow Nape to permit\n     * objects in interaction to go to sleep even if the handler returns an IGNORE_ONCE/ACCEPT_ONCE\n     * PreFlag.\n     *\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var pure(get_pure,set_pure):Bool;\n    inline function get_pure():Bool{\n        return zpp_inner_zn.pure;\n    }\n    inline function set_pure(pure:Bool):Bool{\n        {\n            if(!pure){\n                zpp_inner_zn.wake();\n            }\n            zpp_inner_zn.pure=pure;\n        }\n        return get_pure();\n    }\n    /**\n     * The specific type of interaction that is to be listened for.\n     * <br/><br/>\n     * If we specify that we only want to listen for a fluid type interaction, then\n     * this listener will operate so that any other interactions for the same pair\n     * of objects is ignored.\n     */\n    #if nape_swc@:isVar #end\n    public var interactionType(get_interactionType,set_interactionType):InteractionType;\n    inline function get_interactionType():InteractionType{\n        var ret=zpp_inner_zn.itype;\n        return if(ret==ZPP_Flags.id_InteractionType_COLLISION)InteractionType.COLLISION;\n        else if(ret==ZPP_Flags.id_InteractionType_SENSOR)InteractionType.SENSOR;\n        else if(ret==ZPP_Flags.id_InteractionType_FLUID)InteractionType.FLUID;\n        else if(ret==ZPP_Flags.id_InteractionType_ANY)InteractionType.ANY;\n        else null;\n    }\n    inline function set_interactionType(interactionType:InteractionType):InteractionType{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(interactionType==null){\n                throw \"Error: Cannot set listener interaction type to null\";\n            }\n            #end\n            if(this.interactionType!=interactionType){\n                var xtype=if(interactionType==InteractionType.COLLISION)ZPP_Flags.id_InteractionType_COLLISION else if(interactionType==InteractionType.SENSOR)ZPP_Flags.id_InteractionType_SENSOR else if(interactionType==InteractionType.FLUID)ZPP_Flags.id_InteractionType_FLUID else ZPP_Flags.id_InteractionType_ANY;\n                zpp_inner_zn.setInteractionType(xtype);\n            }\n        }\n        return get_interactionType();\n    }\n    /**\n     * Construct a new PreListener.\n     * <br/><br/>\n     * The options arguments are typed Dynamic, and are permitted to be either an\n     * <code>OptionType</code> or one of:\n     * <code>CbType, CbTypeList, Array&lt;CbType&gt;, flash.Vector&lt;CbType&gt;</code>\n     * In which case the input CbType's will be used to construct an OptionType\n     * whose included types will be the set of CbTypes supplied.\n     *\n     * @param interactionType The interaction type to listen for.\n     * @param options1 The OptionType to match first Interactor against, passing null\n     *                will equate to an empty OptionType.\n     * @param options2 The OptionType to match second Interactor against, passing null\n     *                will equate to an empty OptionType.\n     * @param handler The callback handler for this listener.\n     * @param precedence The precedence of this listener used to sort\n     *                   the order of callbacks in the case of more than\n     *                   one suitable BodyListener existing for the same\n     *                   event on the same Body. (default 0)\n     * @param pure If true, then the listener will be marked as having a pure handler.\n     *             (default false)\n     * @return The newly constructed InteractionListener\n     * @throws # If handler is null.\n     * @throws # If either option is not of the expected Type.\n     */\n    #if flib@:keep function flibopts_2(){}\n    #end\n    public function new(interactionType:InteractionType,options1:Null<Dynamic>,options2:Null<Dynamic>,handler:PreCallback->Null<PreFlag>,precedence=0,pure=false){\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Listener.internal=true;\n        #end\n        super();\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Listener.internal=false;\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(handler==null){\n            throw \"Error: PreListener must take a handler!\";\n        }\n        #end\n        zpp_inner_zn=new ZPP_InteractionListener(ZPP_OptionType.argument(options1),ZPP_OptionType.argument(options2),ZPP_Flags.id_CbEvent_PRE,ZPP_Flags.id_ListenerType_PRE);\n        zpp_inner=zpp_inner_zn;\n        zpp_inner.outer=this;\n        zpp_inner_zn.outer_znp=this;\n        zpp_inner.precedence=precedence;\n        zpp_inner_zn.pure=pure;\n        zpp_inner_zn.handlerp=handler;\n        this.interactionType=interactionType;\n    }\n}\n","package nape.constraint;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Base type for all Nape joints and constraints\n */\n#if nape_swc@:keep #end\nclass Constraint{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Constraint;\n    /**\n     * Dynamic object for user to store additional data.\n     * <br/><br/>\n     * This object cannot be set, only its dynamically created\n     * properties may be set. In AS3 the type of this property is &#42\n     * <br/><br/>\n     * This object will be lazily constructed so that until accessed\n     * for the first time, will be null internally.\n     *\n     * @default {}\n     */\n    #if nape_swc@:isVar #end\n    public var userData(get_userData,never):Dynamic<Dynamic>;\n    inline function get_userData():Dynamic<Dynamic>{\n        if(zpp_inner.userData==null){\n            zpp_inner.userData=cast{};\n        }\n        return zpp_inner.userData;\n    }\n    /**\n     * Set to disable debug drawing/\n     * <br/><br/>\n     * When true, this Constraint will not be drawn during debug draw operations\n     * unless specifically given as argument to Debug draw() method.\n     * @default true\n     */\n    public var debugDraw:Bool=true;\n    /**\n     * Compound this Constraints belong to.\n     * <br/><br/>\n     * If this constraint is in a Space or another Compound and you change\n     * its compound, then it will be removed from that Space or Compound.\n     *\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var compound(get_compound,set_compound):Null<Compound>;\n    inline function get_compound():Null<Compound>{\n        return if(zpp_inner.compound==null)null else zpp_inner.compound.outer;\n    }\n    inline function set_compound(compound:Null<Compound>):Null<Compound>{\n        {\n            if(this.compound!=compound){\n                if(this.compound!=null){\n                    this.compound.constraints.remove(this);\n                }\n                if(compound!=null){\n                    compound.constraints.add(this);\n                }\n            }\n        }\n        return get_compound();\n    }\n    /**\n     * Space this constraint is inside of.\n     * <br/><br/>\n     * Whether this constraint is directly in a Space, or part of a Compound\n     * which is inside of a space, this value will be equal to that Space.\n     * <br/><br/>\n     * If this constraint is inside of a Compound, then you cannot modify its\n     * Space as the constraint belongs to that Compound.\n     *\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var space(get_space,set_space):Null<Space>;\n    inline function get_space():Null<Space>{\n        return if(zpp_inner.space==null)null else zpp_inner.space.outer;\n    }\n    inline function set_space(space:Null<Space>):Null<Space>{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.compound!=null){\n                throw \"Error: Cannot set the space of a Constraint belonging to\"+\" a Compound, only the root Compound space can be set\";\n            }\n            #end\n            if(this.space!=space){\n                if(zpp_inner.component!=null)zpp_inner.component.woken=false;\n                zpp_inner.clearcache();\n                if(zpp_inner.space!=null){\n                    zpp_inner.space.outer.constraints.remove(this);\n                }\n                if(space!=null){\n                    space.constraints.add(this);\n                }\n                else{\n                    zpp_inner.space=null;\n                }\n            }\n        }\n        return get_space();\n    }\n    /**\n     * Whether this constraint is sleeping or not.\n     * <br/><br/>\n     * This property is only defined if the constraint is inside of a Space\n     * and is active, otherwise an error will be thrown should you access this\n     * property.\n     * <br/><br/>\n     * This value is immutable, In Nape you do not ever need to manually\n     * wake up a Constraint. It will always be done automatically without error.\n     * <br/><br/>\n     * To manually put a Constraint to sleep is against the very nature of Nape\n     * API and so is excluded from the core of Nape. If you really want to do this\n     * you should make use of the nape-hacks module.\n     */\n    #if nape_swc@:isVar #end\n    public var isSleeping(get_isSleeping,never):Bool;\n    inline function get_isSleeping():Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.space==null||!zpp_inner.active){\n            throw \"Error: isSleeping only makes sense if constraint is\"+\" active and inside a space\";\n        }\n        #end\n        return zpp_inner.component.sleeping;\n    }\n    /**\n     * Whether this constraint is active or not.\n     * <br/><br/>\n     * Setting a constraint to be no longer active is a useful way of\n     * temporarigly disabling a constraint without having to remove it\n     * from a Space.\n     *\n     * @default true\n     */\n    #if nape_swc@:isVar #end\n    public var active(get_active,set_active):Bool;\n    inline function get_active():Bool{\n        return zpp_inner.active;\n    }\n    inline function set_active(active:Bool):Bool{\n        {\n            if(this.active!=active){\n                if(zpp_inner.component!=null)zpp_inner.component.woken=false;\n                zpp_inner.clearcache();\n                if(active){\n                    zpp_inner.active=active;\n                    zpp_inner.activate();\n                    if(zpp_inner.space!=null){\n                        if(zpp_inner.component!=null)zpp_inner.component.sleeping=true;\n                        zpp_inner.space.wake_constraint(zpp_inner,true);\n                    }\n                }\n                else{\n                    if(zpp_inner.space!=null){\n                        zpp_inner.wake();\n                        zpp_inner.space.live_constraints.remove(zpp_inner);\n                    }\n                    zpp_inner.active=active;\n                    zpp_inner.deactivate();\n                }\n            }\n        }\n        return get_active();\n    }\n    /**\n     * Whether interactions between related Bodys will be ignored.\n     * <br/><br/>\n     * If true, then the Bodys related to this constraint will not\n     * be permitted to interact in anyway, including callbacks.\n     *\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var ignore(get_ignore,set_ignore):Bool;\n    inline function get_ignore():Bool{\n        return zpp_inner.ignore;\n    }\n    inline function set_ignore(ignore:Bool):Bool{\n        {\n            if(this.ignore!=ignore){\n                zpp_inner.ignore=ignore;\n                zpp_inner.wake();\n            }\n        }\n        return get_ignore();\n    }\n    /**\n     * Whether constraint is stiff, or elastic.\n     * <br/><br/>\n     * A stiff constraint has its positional error resolved directly\n     * as with contact penetrations. This is generally a more stable\n     * way of solving positional errors but has a side-effect that for example\n     * changing the pivot point on a constraint used for mouse control will not\n     * cause the objects to swing as the positional error is solved without\n     * effecting the velocity of the object which may not be wanted.\n     * <br/><br/>\n     * If false, then the positional error of the constraint will be\n     * resolved in an elastic way using changes in velocity.\n     *\n     * @default true\n     */\n    #if nape_swc@:isVar #end\n    public var stiff(get_stiff,set_stiff):Bool;\n    inline function get_stiff():Bool{\n        return zpp_inner.stiff;\n    }\n    inline function set_stiff(stiff:Bool):Bool{\n        {\n            if(this.stiff!=stiff){\n                zpp_inner.stiff=stiff;\n                zpp_inner.wake();\n            }\n        }\n        return get_stiff();\n    }\n    /**\n     * Frequency of elastic properties of constraint.\n     * <br/><br/>\n     * This property only has an effect when constraint is not stiff.\n     * <br/><br/>\n     * This value corresponds to in an ideal situation, the number of\n     * spring like oscillations the constraint will make per second.\n     * <br/><br/>\n     * This value must be strictly positive (0 not allowed).\n     *\n     * @default 10\n     */\n    #if nape_swc@:isVar #end\n    public var frequency(get_frequency,set_frequency):Float;\n    inline function get_frequency():Float{\n        return zpp_inner.frequency;\n    }\n    inline function set_frequency(frequency:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((frequency!=frequency)){\n                throw \"Error: Constraint::Frequency cannot be NaN\";\n            }\n            if(frequency<=0){\n                throw \"Error: Constraint::Frequency must be >0\";\n            }\n            #end\n            if(this.frequency!=frequency){\n                zpp_inner.frequency=frequency;\n                if(!zpp_inner.stiff){\n                    zpp_inner.wake();\n                }\n            }\n        }\n        return get_frequency();\n    }\n    /**\n     * Damping ratio of elastic properties of constraint.\n     * <br/><br/>\n     * This property only has an effect when constraint is not stiff.\n     * <br/><br/>\n     * This value corresponds to in the ideal situation, the damping\n     * ratio of the constraints oscillations with 1 corresponding to\n     * a total dampening, and values greater than one being over-dampening.\n     * <br/><br/>\n     * This value must be zero or positive.\n     *\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var damping(get_damping,set_damping):Float;\n    inline function get_damping():Float{\n        return zpp_inner.damping;\n    }\n    inline function set_damping(damping:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((damping!=damping)){\n                throw \"Error: Constraint::Damping cannot be Nan\";\n            }\n            if(damping<0){\n                throw \"Error: Constraint::Damping must be >=0\";\n            }\n            #end\n            if(this.damping!=damping){\n                zpp_inner.damping=damping;\n                if(!zpp_inner.stiff){\n                    zpp_inner.wake();\n                }\n            }\n        }\n        return get_damping();\n    }\n    /**\n     * The maximum amount of force this constraint is allowed to use.\n     * <br/><br/>\n     * This value, whilst still used in a stiff constraint will not work\n     * as you might hope for; since a stiff constraint resolves positional\n     * error without using impulses, the maxForce will not have any effect\n     * on how positional errors are resolved.\n     * <br/><br/>\n     * This value must be zero or positive.\n     *\n     * @default infinity\n     */\n    #if nape_swc@:isVar #end\n    public var maxForce(get_maxForce,set_maxForce):Float;\n    inline function get_maxForce():Float{\n        return zpp_inner.maxForce;\n    }\n    inline function set_maxForce(maxForce:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((maxForce!=maxForce)){\n                throw \"Error: Constraint::maxForce cannot be NaN\";\n            }\n            if(maxForce<0){\n                throw \"Error: Constraint::maxForce must be >=0\";\n            }\n            #end\n            if(this.maxForce!=maxForce){\n                zpp_inner.maxForce=maxForce;\n                zpp_inner.wake();\n            }\n        }\n        return get_maxForce();\n    }\n    /**\n     * The maximum amount of error this constraint is allowed to use.\n     * <br/><br/>\n     * For stiff constraints, this value only serves to work in conjunction\n     * with breakUnderError to permit breaking of the constraint.\n     * <br/><br/>\n     * For non-stiff constraints, this value will also effect how the constraint\n     * behaves when breakUnderError is false by restricting the amount of error\n     * that will be resolved; this will not work for stiff constraints.\n     *\n     * @default infinity\n     */\n    #if nape_swc@:isVar #end\n    public var maxError(get_maxError,set_maxError):Float;\n    inline function get_maxError():Float{\n        return zpp_inner.maxError;\n    }\n    inline function set_maxError(maxError:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((maxError!=maxError)){\n                throw \"Error: Constraint::maxError cannot be NaN\";\n            }\n            if(maxError<0){\n                throw \"Error: Constraint::maxError must be >=0\";\n            }\n            #end\n            if(this.maxError!=maxError){\n                zpp_inner.maxError=maxError;\n                zpp_inner.wake();\n            }\n        }\n        return get_maxError();\n    }\n    /**\n     * Whether constraint will break once maxForce is reached.\n     * <br/><br/>\n     * This property effects both stiff and non-stiff constraints, though\n     * for the same reasons as those of maxForce, does not make much sense\n     * to be used in stiff constraints.\n     *\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var breakUnderForce(get_breakUnderForce,set_breakUnderForce):Bool;\n    inline function get_breakUnderForce():Bool{\n        return zpp_inner.breakUnderForce;\n    }\n    inline function set_breakUnderForce(breakUnderForce:Bool):Bool{\n        {\n            if(this.breakUnderForce!=breakUnderForce){\n                zpp_inner.breakUnderForce=breakUnderForce;\n                zpp_inner.wake();\n            }\n        }\n        return get_breakUnderForce();\n    }\n    /**\n     * Whether constraint will break once maxError is reached.\n     * <br/><br/>\n     * This property effects both stiff and non-stiff constraints.\n     *\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var breakUnderError(get_breakUnderError,set_breakUnderError):Bool;\n    inline function get_breakUnderError():Bool{\n        return zpp_inner.breakUnderError;\n    }\n    inline function set_breakUnderError(breakUnderError:Bool):Bool{\n        {\n            if(this.breakUnderError!=breakUnderError){\n                zpp_inner.breakUnderError=breakUnderError;\n                zpp_inner.wake();\n            }\n        }\n        return get_breakUnderError();\n    }\n    /**\n     * Whether constraint will be removed when it breaks.\n     * <br/><br/>\n     * If true, then when constraint is broken it will be removed from\n     * the Space. Otherwise it will simple be made inactive.\n     *\n     * @default true\n     */\n    #if nape_swc@:isVar #end\n    public var removeOnBreak(get_removeOnBreak,set_removeOnBreak):Bool;\n    inline function get_removeOnBreak():Bool{\n        return zpp_inner.removeOnBreak;\n    }\n    inline function set_removeOnBreak(removeOnBreak:Bool):Bool{\n        {\n            zpp_inner.removeOnBreak=removeOnBreak;\n        }\n        return get_removeOnBreak();\n    }\n    /**\n     * Return the constraint-space impulse applied in previous step.\n     *\n     * @return A new MatMN representing the constraint space impulse.\n     */\n    public function impulse():MatMN{\n        return null;\n    }\n    /**\n     * Compute impulse that was applied to the given Body.\n     * <br/><br/>\n     * This impulse is the actual (mass weighted) change in velocity\n     * that occured due to this constraint.\n     *\n     * @param body The Body to compute impulse for.\n     * @return The impulse that was applied to the body in the previous step.\n     * @throws # If Body is not related to the Constraint.\n     */\n    public function bodyImpulse(body:Body):Vec3{\n        return null;\n    }\n    /**\n     * Apply given function to all Bodys linked to the constraint.\n     * <br/><br/>\n     * If a body is duplicated in a constraint then it will only\n     * be visited once.\n     *\n     * @param lambda The function to apply to each Body.\n     * @throws # If lambda is null.\n     */\n    public function visitBodies(lambda:Body->Void):Void{}\n    /**\n     * Set of CbTypes for this constraints for callbacks.\n     * <br/><br/>\n     * This value cannot at present be set, but can be modified.\n     *\n     * @default [CbType.ANY_CONSTRAINT]\n     */\n    #if nape_swc@:isVar #end\n    public var cbTypes(get_cbTypes,never):CbTypeList;\n    inline function get_cbTypes():CbTypeList{\n        if(zpp_inner.wrap_cbTypes==null){\n            zpp_inner.setupcbTypes();\n        }\n        return zpp_inner.wrap_cbTypes;\n    }\n    /**\n     * @private\n     */\n    #if(!NAPE_RELEASE_BUILD)\n    public static var zpp_internalAlloc=false;\n    #end\n    public function new(){\n        zpp_inner.insert_cbtype(CbType.ANY_CONSTRAINT.zpp_inner);\n        #if(!NAPE_RELEASE_BUILD)\n        if(!zpp_internalAlloc)throw \"Error: Constraint cannot be instantiated derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString():String{\n        return \"{Constraint}\";\n    }\n    /**\n     * Produce copy of constraint.\n     * <br/><br/>\n     * All constraint properties except for internal impulse cache\n     * and userData field will be copied.\n     *\n     * @return The copied Constraint.\n     */\n    public function copy():Constraint{\n        return zpp_inner.copy();\n    }\n}\n","package nape.constraint;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ConstraintIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:ConstraintList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:ConstraintIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:ConstraintIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_ConstraintList.internal)throw \"Error: Cannot instantiate \"+\"Constraint\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:ConstraintList){\n        var ret=if(zpp_pool==null){\n            ZPP_ConstraintList.internal=true;\n            var ret=new ConstraintIterator();\n            ZPP_ConstraintList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=ConstraintIterator.zpp_pool;\n                ConstraintIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.constraint;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Constraint type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Constraint = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Constraint = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Constraint = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ConstraintList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_ConstraintList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Constraint\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Constraint>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new ConstraintList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Constraint)#else Std.is(i,Constraint)#end)throw \"Error: Array contains non \"+\"Constraint\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Constraint>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new ConstraintList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Constraint):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Constraint{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Constraint):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Constraint\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Constraint):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Constraint\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Constraint{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Constraint\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Constraint{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Constraint\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:Constraint):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Constraint):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Constraint\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Constraint\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return ConstraintIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new ConstraintList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Constraint\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:ConstraintList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_ConstraintList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:Constraint->Void):ConstraintList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=ConstraintIterator.zpp_pool;\n                    ConstraintIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Constraint->Bool):ConstraintList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Arbiter representing the state of an interaction between two Bodys.\n * <br/><br/>\n * These objects are automatically reused, and you should not keep your own\n * references to them.\n */\n#if nape_swc@:keep #end\nclass Arbiter{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Arbiter=null;\n    /**\n     * Flag representing arbiter sleep state.\n     * <br/><br/>\n     * When true, this arbiter is sleeping.\n     */\n    #if nape_swc@:isVar #end\n    public var isSleeping(get_isSleeping,never):Bool;\n    inline function get_isSleeping():Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        return zpp_inner.sleeping;\n    }\n    /**\n     * The type of this Arbiter.\n     */\n    #if nape_swc@:isVar #end\n    public var type(get_type,never):ArbiterType;\n    inline function get_type():ArbiterType{\n        return ZPP_Arbiter.types[zpp_inner.type];\n    }\n    /**\n     * Equivalent to: <code>arb.type == ArbiterType.COLLISION</code>\n     * </br><br/>\n     *\n     * @return True if this Arbiter is a Collision type arbiter.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isCollisionArbiter(){\n        return zpp_inner.type==ZPP_Arbiter.COL;\n    }\n    /**\n     * Equivalent to: <code>arb.type == ArbiterType.FLUID</code>\n     * </br><br/>\n     *\n     * @return True if this Arbiter is a Fluid type arbiter.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isFluidArbiter(){\n        return zpp_inner.type==ZPP_Arbiter.FLUID;\n    }\n    /**\n     * Equivalent to: <code>arb.type == ArbiterType.SENSOR</code>\n     * </br><br/>\n     *\n     * @return True if this Arbiter is a Sensor type arbiter.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isSensorArbiter(){\n        return zpp_inner.type==ZPP_Arbiter.SENSOR;\n    }\n    /**\n     * Fast equivalent to casting this object to a CollisionArbiter.\n     * <br/><br/>\n     * This value is null when this arbiter is not a collision type.\n     */\n    #if nape_swc@:isVar #end\n    public var collisionArbiter(get_collisionArbiter,never):Null<CollisionArbiter>;\n    inline function get_collisionArbiter():Null<CollisionArbiter>{\n        return if(isCollisionArbiter())zpp_inner.colarb.outer_zn else null;\n    }\n    /**\n     * Fast equivalent to casting this object to a FluidArbiter.\n     * <br/><br/>\n     * This value is null when this arbiter is not a fluid type.\n     */\n    #if nape_swc@:isVar #end\n    public var fluidArbiter(get_fluidArbiter,never):Null<FluidArbiter>;\n    inline function get_fluidArbiter():Null<FluidArbiter>{\n        return if(isFluidArbiter())zpp_inner.fluidarb.outer_zn else null;\n    }\n    /**\n     * The first shape in Arbiter interaction.\n     * <br/><br/>\n     * It will always be the case that <code>arb.shape1.id < arb.shape2.id</code>\n     */\n    #if nape_swc@:isVar #end\n    public var shape1(get_shape1,never):Shape;\n    inline function get_shape1():Shape{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        return(zpp_inner.ws1.id>zpp_inner.ws2.id)?zpp_inner.ws2.outer:zpp_inner.ws1.outer;\n    }\n    /**\n     * The second shape in Arbiter interaction.\n     * <br/><br/>\n     * It will always be the case that <code>arb.shape1.id < arb.shape2.id</code>\n     */\n    #if nape_swc@:isVar #end\n    public var shape2(get_shape2,never):Shape;\n    inline function get_shape2():Shape{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        return(zpp_inner.ws1.id>zpp_inner.ws2.id)?zpp_inner.ws1.outer:zpp_inner.ws2.outer;\n    }\n    /**\n     * The first body in Arbiter interaction.\n     * <br/><br/>\n     * It will always be the case that <code>arb.shape1.body == arb.body1</code>\n     */\n    #if nape_swc@:isVar #end\n    public var body1(get_body1,never):Body;\n    inline function get_body1():Body{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        return(zpp_inner.ws1.id>zpp_inner.ws2.id)?zpp_inner.b2.outer:zpp_inner.b1.outer;\n    }\n    /**\n     * The second body in Arbiter interaction.\n     * <br/><br/>\n     * It will always be the case that <code>arb.shape2.body == arb.body2</code>\n     */\n    #if nape_swc@:isVar #end\n    public var body2(get_body2,never):Body;\n    inline function get_body2():Body{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        return(zpp_inner.ws1.id>zpp_inner.ws2.id)?zpp_inner.b1.outer:zpp_inner.b2.outer;\n    }\n    /**\n     * The interaction state of this Arbiter.\n     * <br/><br/>\n     * This flag will, except for in a PreListener handler, always be either\n     * <code>ImmState.ACCEPT</code> or <code>ImmState.IGNORE</code>\n     * <br/>\n     * During a PreListener handler, you can query this property to see what\n     * the current state of the arbiter has been set to, and returning null from\n     * the handler will keep the state unchanged.\n     */\n    #if nape_swc@:isVar #end\n    public var state(get_state,never):PreFlag;\n    inline function get_state():PreFlag{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        return switch(zpp_inner.immState){\n            case x if(x==ZPP_Flags.id_ImmState_ACCEPT|ZPP_Flags.id_ImmState_ALWAYS):PreFlag.ACCEPT;\n            case ZPP_Flags.id_ImmState_ACCEPT:PreFlag.ACCEPT_ONCE;\n            case x if(x==ZPP_Flags.id_ImmState_IGNORE|ZPP_Flags.id_ImmState_ALWAYS):PreFlag.IGNORE;\n            default:PreFlag.IGNORE_ONCE;\n        }\n    }\n    /**\n     * Evaluate the total impulse this arbiter applied to the given body for\n     * the previous space step including angular impulse based on things like\n     * contact position, or centre of buoyancy etc.\n     * <br/><br/>\n     * If body is null, then the constraint space impulse will be returned instead\n     *\n     * @param body The body to query impulse for. (default null)\n     * @param freshOnly If true, then only 'new' contact points will be queried for\n     *                  collision type arbiters. This field has no use on fluid type\n     *                  arbiters. (default false)\n     * @return The total impulse applied to the given body, or the constraint\n     *         space impule if the body is null.\n     * @throws # If body is non-null, but not related to this Arbiter.\n     */\n    #if nape_swc@:keep #end\n    public function totalImpulse(body:Body=null,freshOnly:Bool=false){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body!=body1&&body!=body2)throw \"Error: Arbiter does not relate to body\";\n        #end\n        return Vec3.get(0,0,0);\n    }\n    /**\n     * @private\n     */\n    public function new(){\n        if(!ZPP_Arbiter.internal){\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: Cannot instantiate Arbiter derp!\";\n            #end\n        }\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=if(isCollisionArbiter())\"CollisionArbiter\";\n        else if(isFluidArbiter())\"FluidArbiter\";\n        else \"SensorArbiter\";\n        #if NAPE_POOL_STATS ret+=\"#\"+zpp_inner.arbid;\n        #end\n        if(zpp_inner.cleared)return ret+\"(object-pooled)\";\n        else return ret+\"(\"+shape1.toString()+\"|\"+shape2.toString()+\")\"+(isCollisionArbiter()?\"[\"+[\"SD\",\"DD\"][zpp_inner.colarb.stat?0:1]+\"]\":\"\")+\"<-\"+state.toString();\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ArbiterIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:ArbiterList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:ArbiterIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:ArbiterIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_ArbiterList.internal)throw \"Error: Cannot instantiate \"+\"Arbiter\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:ArbiterList){\n        var ret=if(zpp_pool==null){\n            ZPP_ArbiterList.internal=true;\n            var ret=new ArbiterIterator();\n            ZPP_ArbiterList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=ArbiterIterator.zpp_pool;\n                ArbiterIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Arbiter type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Arbiter = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Arbiter = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Arbiter = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!true@:final #end\n#if nape_swc@:keep #end\nclass ArbiterList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_ArbiterList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if false inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(true){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(i.active)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(true){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(i.active)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Arbiter\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Arbiter>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new ArbiterList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Arbiter)#else Std.is(i,Arbiter)#end)throw \"Error: Array contains non \"+\"Arbiter\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Arbiter>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new ArbiterList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Arbiter):Bool{\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Arbiter{\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!true){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(x.active)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(x.active)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().wrapper();\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Arbiter):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Arbiter\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Arbiter):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Arbiter\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Arbiter{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Arbiter\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Arbiter{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Arbiter\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public  function add(obj:Arbiter):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Arbiter):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Arbiter\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Arbiter\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public  function empty(){\n        #if false if(true)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public  function iterator(){\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return ArbiterIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new ArbiterList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Arbiter\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:ArbiterList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_ArbiterList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public  function foreach(lambda:Arbiter->Void):ArbiterList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=ArbiterIterator.zpp_pool;\n                    ArbiterIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Arbiter->Bool):ArbiterList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of Arbiter types.\n */\n@:final#if nape_swc@:keep #end\nclass ArbiterType{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"ArbiterType\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==COLLISION)return\"COLLISION\";\n        else if(this==SENSOR)return\"SENSOR\";\n        else if(this==FLUID)return\"FLUID\";\n        else return \"\";\n    }\n    /**\n     * Collision type Arbiter.\n     */\n    #if nape_swc@:isVar #end\n    public static var COLLISION(get_COLLISION,never):ArbiterType;\n    inline static function get_COLLISION(){\n        if(ZPP_Flags.ArbiterType_COLLISION==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ArbiterType_COLLISION=new ArbiterType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ArbiterType_COLLISION;\n    }\n    /**\n     * Sensor type Arbiter.\n     */\n    #if nape_swc@:isVar #end\n    public static var SENSOR(get_SENSOR,never):ArbiterType;\n    inline static function get_SENSOR(){\n        if(ZPP_Flags.ArbiterType_SENSOR==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ArbiterType_SENSOR=new ArbiterType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ArbiterType_SENSOR;\n    }\n    /**\n     * Fluid type Arbiter.\n     */\n    #if nape_swc@:isVar #end\n    public static var FLUID(get_FLUID,never):ArbiterType;\n    inline static function get_FLUID(){\n        if(ZPP_Flags.ArbiterType_FLUID==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ArbiterType_FLUID=new ArbiterType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ArbiterType_FLUID;\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Arbiter sub type for collision interactions.\n */\n@:final#if nape_swc@:keep #end\nclass CollisionArbiter extends Arbiter{\n    /**\n     * Set of contact points for the related pairs of shapes.\n     */\n    #if nape_swc@:isVar #end\n    public var contacts(get_contacts,never):ContactList;\n    inline function get_contacts():ContactList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        if(zpp_inner.colarb.wrap_contacts==null)zpp_inner.colarb.setupcontacts();\n        return zpp_inner.colarb.wrap_contacts;\n    }\n    /**\n     * Normal of contact for collision interaction.\n     * <br/><br/>\n     * This normal will always point from arbiter's shape1, towards shape2 and\n     * corresponds to the direction of the normal before positional integration\n     * and erorr resolvement took place (Correct at time of pre-listener).\n     */\n    #if nape_swc@:isVar #end\n    public var normal(get_normal,never):Vec2;\n    inline function get_normal():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        if(zpp_inner.colarb.wrap_normal==null)zpp_inner.colarb.getnormal();\n        return zpp_inner.colarb.wrap_normal;\n    }\n    /**\n     * This radius property describes the sum of the circle's radii for the pair of shapes, with\n     * a Polygon having 0 radius. This value is used in positional iterations to resolve penetrations\n     * between the Shapes.\n     */\n    #if nape_swc@:isVar #end\n    public var radius(get_radius,never):Float;\n    inline function get_radius():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        return zpp_inner.colarb.radius;\n    }\n    /**\n     * The reference edge for the collision on the first Polygon\n     * If the first shape in Arbiter is a Circle this value is null.\n     */\n    #if nape_swc@:isVar #end\n    public var referenceEdge1(get_referenceEdge1,never):Null<Edge>;\n    inline function get_referenceEdge1():Null<Edge>{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        var edge=zpp_inner.colarb.__ref_edge1;\n        if(edge!=null&&(!shape1.isPolygon()||shape1.zpp_inner!=edge.polygon))edge=zpp_inner.colarb.__ref_edge2;\n        return(edge==null)?null:edge.wrapper();\n    }\n    /**\n     * The reference edge for the collision on the second Polygon\n     * If the second shape in Arbiter is a Circle this value is null.\n     */\n    #if nape_swc@:isVar #end\n    public var referenceEdge2(get_referenceEdge2,never):Null<Edge>;\n    inline function get_referenceEdge2():Null<Edge>{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        var edge=zpp_inner.colarb.__ref_edge1;\n        if(edge!=null&&(!shape2.isPolygon()||shape2.zpp_inner!=edge.polygon))edge=zpp_inner.colarb.__ref_edge2;\n        return(edge==null)?null:edge.wrapper();\n    }\n    /**\n     * In the case that we have a Circle-Polygon collision, then this\n     * function will return true, if the circle collided with the first\n     * vertex of edge.\n     * <br/><br/>\n     * If both firstVertex() and secondVertex() are false, it indicates\n     * the Circle collided with the edge.\n     *\n     * @returns True if Circle collided with first reference vertex.\n     */\n    public function firstVertex(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        var poly2circle=(zpp_inner.colarb.__ref_edge1!=null)!=(zpp_inner.colarb.__ref_edge2!=null);\n        return if(poly2circle)(zpp_inner.colarb.__ref_vertex==-1)else false;\n    }\n    /**\n     * Check if colliding Circle hit second vertex of reference edge.\n     * <br/><br/>\n     * In the case that we have a Circle-Polygon collision, then this\n     * function will return true, if the circle collided with the second\n     * vertex of edge.\n     * <br/><br/>\n     * If both firstVertex() and secondVertex() are false, it indicates\n     * the Circle collided with the edge.\n     *\n     * @returns True if Circle collided with second reference vertex.\n     */\n    public function secondVertex(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        var poly2circle=(zpp_inner.colarb.__ref_edge1!=null)!=(zpp_inner.colarb.__ref_edge2!=null);\n        return if(poly2circle)(zpp_inner.colarb.__ref_vertex==1)else false;\n    }\n    /**\n     * Evaluate normal reactive impulses for collision interaction for a given body.\n     * <br/><br/>\n     * If body argument is null, then the sum of the contact normal impulses will be returned instead\n     * with no angular impulse derivable, the direction of this impulse will be the direction of the normal.\n     * <br/>\n     * If body argument is not null, then this will return the actual impulse applied to that specific body\n     * rather than simply the sum of contact normal impulses, this will include angular impulses due to\n     * positions of contact points and normal.\n     *\n     * @param body The Body to query normal impulse for. (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered in computation.\n     *                  (default false)\n     * @return The impulse applied to the given body, considering normal reactive forces.\n     * @throws # If body is non-null, and unrelated to this Arbiter.\n     */\n    #if nape_swc@:keep #end\n    public function normalImpulse(body:Body=null,freshOnly:Bool=false):Vec3{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body!=body1&&body!=body2)throw \"Error: Arbiter does not relate to body\";\n        #end\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        var colarb=zpp_inner.colarb;\n        {\n            if(!freshOnly||colarb.oc1.fresh){\n                var imp=colarb.oc1.wrapper().normalImpulse(body);\n                {\n                    var t=(1);\n                    {\n                        var t=(t);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                            #end\n                        };\n                        retx+=imp.x*t;\n                        rety+=imp.y*t;\n                    };\n                    retz+=imp.z*t;\n                };\n                imp.dispose();\n            }\n        };\n        if(colarb.hc2){\n            if(!freshOnly||colarb.oc2.fresh){\n                var imp=colarb.oc2.wrapper().normalImpulse(body);\n                {\n                    var t=(1);\n                    {\n                        var t=(t);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                            #end\n                        };\n                        retx+=imp.x*t;\n                        rety+=imp.y*t;\n                    };\n                    retz+=imp.z*t;\n                };\n                imp.dispose();\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate tangent impulses for collision interaction.\n     * <br/><br/>\n     * If body argument is null, then the sum of the contact friction impulses is returned with\n     * no angular impulse derivable, the direction of this impulse will be against the relative\n     * velocity of the first body against the second.\n     * <br/>\n     * If the body argument is non-null, then the actual impulse applied to that body due to tangent\n     * frictino impulses will be returned, including angular effects due to contact positions and normal.\n     * <br/><br/>\n     * These tangent impulses correspond to the forces of static and dynamic friction.\n     *\n     * @param body The Body to query tangent impulse for. (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered in computation.\n     *                  (default false)\n     * @return The impulse applied to the given body, considering standard frictional forces.\n     * @throws # If body is non-null, and unrelated to this Arbiter.\n     */\n    #if nape_swc@:keep #end\n    public function tangentImpulse(body:Body=null,freshOnly:Bool=false):Vec3{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body!=body1&&body!=body2)throw \"Error: Arbiter does not relate to body\";\n        #end\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        var colarb=zpp_inner.colarb;\n        {\n            if(!freshOnly||colarb.oc1.fresh){\n                var imp=colarb.oc1.wrapper().tangentImpulse(body);\n                {\n                    var t=(1);\n                    {\n                        var t=(t);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                            #end\n                        };\n                        retx+=imp.x*t;\n                        rety+=imp.y*t;\n                    };\n                    retz+=imp.z*t;\n                };\n                imp.dispose();\n            }\n        };\n        if(colarb.hc2){\n            if(!freshOnly||colarb.oc2.fresh){\n                var imp=colarb.oc2.wrapper().tangentImpulse(body);\n                {\n                    var t=(1);\n                    {\n                        var t=(t);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                            #end\n                        };\n                        retx+=imp.x*t;\n                        rety+=imp.y*t;\n                    };\n                    retz+=imp.z*t;\n                };\n                imp.dispose();\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate total contact impulses for collision interaction.\n     * <br/><br/>\n     * If body argument is null, then this will return the sum of linear contact impulses, and the sum\n     * of contact rolling impulses.\n     * <br/>\n     * When body argument is non-null, this impulse will be the actual change in (mass weighted)\n     * velocity that this collision caused to the Body in the previous time step.\n     *\n     * @param body The Body to query total impulse for. (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered in computation.\n     *                  (default false)\n     * @return The impulse applied to the given body\n     * @throws # If body is non-null, and unrelated to this Arbiter.\n     */\n    #if nape_swc@:keep #end\n    public override function totalImpulse(body:Body=null,freshOnly:Bool=false):Vec3{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body!=body1&&body!=body2)throw \"Error: Arbiter does not relate to body\";\n        #end\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        var colarb=zpp_inner.colarb;\n        {\n            if(!freshOnly||colarb.oc1.fresh){\n                var imp=colarb.oc1.wrapper().totalImpulse(body);\n                {\n                    var t=(1);\n                    {\n                        var t=(t);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                            #end\n                        };\n                        retx+=imp.x*t;\n                        rety+=imp.y*t;\n                    };\n                    retz+=imp.z*t;\n                };\n                imp.dispose();\n            }\n        };\n        if(colarb.hc2){\n            if(!freshOnly||colarb.oc2.fresh){\n                var imp=colarb.oc2.wrapper().totalImpulse(body);\n                {\n                    var t=(1);\n                    {\n                        var t=(t);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                            #end\n                        };\n                        retx+=imp.x*t;\n                        rety+=imp.y*t;\n                    };\n                    retz+=imp.z*t;\n                };\n                imp.dispose();\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate rolling friction impulses for collision interaction.\n     * <br/><br/>\n     * If body argument is null, then the sum of the rolling impulses of each contact will be returned\n     * instead of the angular impulse applied to the specific body as a result of the rolling impulses.\n     *\n     * @param body The Body to query rolling impulse for. (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered in computation.\n     *                  (default false)\n     * @return The angular impulse applied to the given body.\n     * @throws # If body is non-null, and unrelated to this Arbiter.\n     */\n    #if nape_swc@:keep #end\n    public function rollingImpulse(body:Body=null,freshOnly:Bool=false):Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body!=body1&&body!=body2)throw \"Error: Arbiter does not relate to body\";\n        #end\n        var colarb=zpp_inner.colarb;\n        if(!freshOnly||colarb.oc1.fresh)return colarb.oc1.wrapper().rollingImpulse(body);\n        else return 0.0;\n    }\n    /**\n     * Coeffecient of combined elasticity for collision interaction.\n     * <br/><br/>\n     * The value is computed as the average of the Shape Material's elasticities\n     * clamped to be in the range [0,1]\n     * <br/><br/>\n     * This value may be modified only during a PreListener, and once modified\n     * will no longer be under Nape's control. Values must be in the range 0\n     * to 1.\n     */\n    #if nape_swc@:isVar #end\n    public var elasticity(get_elasticity,set_elasticity):Float;\n    inline function get_elasticity():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        var colarb=zpp_inner.colarb;\n        colarb.validate_props();\n        return colarb.restitution;\n    }\n    inline function set_elasticity(elasticity:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(!zpp_inner.colarb.mutable)throw \"Error: CollisionArbiter::\"+\"elasticity\"+\" is only mutable during a pre-handler\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((elasticity!=elasticity))throw \"Error: CollisionArbiter::\"+\"elasticity\"+\" cannot be NaN\";\n            if(elasticity<0)throw \"Error: CollisionArbiter::\"+\"elasticity\"+\" cannot be negative\";\n            if(\"elasticity\"==\"restitution\"&&elasticity>1)throw \"Error: CollisionArbiter::restitution cannot be greater than 1\";\n            #end\n            var colarb=zpp_inner.colarb;\n            colarb.restitution=elasticity;\n            colarb.userdef_restitution=true;\n        }\n        return get_elasticity();\n    }\n    /**\n     * Coeffecient of combined dynamic friction for collision interaction.\n     * <br/><br/>\n     * The value is computed as the square root of the product of the Shape\n     * Material's dynamicFriction coeffecients.\n     * <br/><br/>\n     * This value may be modified only during a PreListener, and once modified\n     * will no longer be under Nape's control. Values must not be negative.\n     */\n    #if nape_swc@:isVar #end\n    public var dynamicFriction(get_dynamicFriction,set_dynamicFriction):Float;\n    inline function get_dynamicFriction():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        var colarb=zpp_inner.colarb;\n        colarb.validate_props();\n        return colarb.dyn_fric;\n    }\n    inline function set_dynamicFriction(dynamicFriction:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(!zpp_inner.colarb.mutable)throw \"Error: CollisionArbiter::\"+\"dynamicFriction\"+\" is only mutable during a pre-handler\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((dynamicFriction!=dynamicFriction))throw \"Error: CollisionArbiter::\"+\"dynamicFriction\"+\" cannot be NaN\";\n            if(dynamicFriction<0)throw \"Error: CollisionArbiter::\"+\"dynamicFriction\"+\" cannot be negative\";\n            if(\"dynamicFriction\"==\"restitution\"&&dynamicFriction>1)throw \"Error: CollisionArbiter::restitution cannot be greater than 1\";\n            #end\n            var colarb=zpp_inner.colarb;\n            colarb.dyn_fric=dynamicFriction;\n            colarb.userdef_dyn_fric=true;\n        }\n        return get_dynamicFriction();\n    }\n    /**\n     * Coeffecient of combined static friction for collision interaction.\n     * <br/><br/>\n     * The value is computed as the square root of the product of the Shape\n     * Material's staticFriction coeffecients.\n     * <br/><br/>\n     * This value may be modified only during a PreListener, and once modified\n     * will no longer be under Nape's control. Values must not be negative.\n     */\n    #if nape_swc@:isVar #end\n    public var staticFriction(get_staticFriction,set_staticFriction):Float;\n    inline function get_staticFriction():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        var colarb=zpp_inner.colarb;\n        colarb.validate_props();\n        return colarb.stat_fric;\n    }\n    inline function set_staticFriction(staticFriction:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(!zpp_inner.colarb.mutable)throw \"Error: CollisionArbiter::\"+\"staticFriction\"+\" is only mutable during a pre-handler\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((staticFriction!=staticFriction))throw \"Error: CollisionArbiter::\"+\"staticFriction\"+\" cannot be NaN\";\n            if(staticFriction<0)throw \"Error: CollisionArbiter::\"+\"staticFriction\"+\" cannot be negative\";\n            if(\"staticFriction\"==\"restitution\"&&staticFriction>1)throw \"Error: CollisionArbiter::restitution cannot be greater than 1\";\n            #end\n            var colarb=zpp_inner.colarb;\n            colarb.stat_fric=staticFriction;\n            colarb.userdef_stat_fric=true;\n        }\n        return get_staticFriction();\n    }\n    /**\n     * Coeffecient of combined rolling friction for collision interaction.\n     * <br/><br/>\n     * The value is computed as the square root of the product of the Shape\n     * Material's rollingFriction coeffecients.\n     * <br/><br/>\n     * This value may be modified only during a PreListener, and once modified\n     * will no longer be under Nape's control. Values must not be negative.\n     */\n    #if nape_swc@:isVar #end\n    public var rollingFriction(get_rollingFriction,set_rollingFriction):Float;\n    inline function get_rollingFriction():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        var colarb=zpp_inner.colarb;\n        colarb.validate_props();\n        return colarb.rfric;\n    }\n    inline function set_rollingFriction(rollingFriction:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(!zpp_inner.colarb.mutable)throw \"Error: CollisionArbiter::\"+\"rollingFriction\"+\" is only mutable during a pre-handler\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((rollingFriction!=rollingFriction))throw \"Error: CollisionArbiter::\"+\"rollingFriction\"+\" cannot be NaN\";\n            if(rollingFriction<0)throw \"Error: CollisionArbiter::\"+\"rollingFriction\"+\" cannot be negative\";\n            if(\"rollingFriction\"==\"restitution\"&&rollingFriction>1)throw \"Error: CollisionArbiter::restitution cannot be greater than 1\";\n            #end\n            var colarb=zpp_inner.colarb;\n            colarb.rfric=rollingFriction;\n            colarb.userdef_rfric=true;\n        }\n        return get_rollingFriction();\n    }\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Arbiter.internal)throw \"Error: Cannot instantiate CollisionArbiter derp!\";\n        #end\n        super();\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Contact point for collision interactions\n * <br/><br/>\n * These objects are automatically reused and you should not keep references to them.\n */\n@:final#if nape_swc@:keep #end\nclass Contact{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Contact=null;\n    /**\n     * Reference to the CollisionArbiter this contact belongs to\n     */\n    #if nape_swc@:isVar #end\n    public var arbiter(get_arbiter,never):CollisionArbiter;\n    inline function get_arbiter():CollisionArbiter{\n        return if(zpp_inner.arbiter==null)null else zpp_inner.arbiter.outer.collisionArbiter;\n    }\n    /**\n     * Penetration of bodies along normal for this contact.\n     * <br/><br/>\n     * This value may be negative and corresponds to the penetration (if at all)\n     * of the contact point before positional integration and error resolvement\n     * took place (correct at time of pre-listeners).\n     */\n    #if nape_swc@:isVar #end\n    public var penetration(get_penetration,never):Float;\n    inline function get_penetration():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        return(-zpp_inner.dist);\n    }\n    /**\n     * The world-space position of contact.\n     * <br/><br/>\n     * This value corresponds to the position\n     * of the contact point before positional integration and error resolvement\n     * took place (correct at time of pre-listeners).\n     */\n    #if nape_swc@:isVar #end\n    public var position(get_position,never):Vec2;\n    inline function get_position():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        if(zpp_inner.wrap_position==null)zpp_inner.getposition();\n        return zpp_inner.wrap_position;\n    }\n    /**\n     * Whether this contact is newly generated, or persistant from previous step.\n     */\n    #if nape_swc@:isVar #end\n    public var fresh(get_fresh,never):Bool;\n    inline function get_fresh():Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        return zpp_inner.fresh;\n    }\n    /**\n     * Evaluate normal reactive impulses for this contact for a given body.\n     * <br/><br/>\n     * If body argument is null, then the contact normal impulses will be returned instead\n     * with no angular impulse derivable, the direction of this impulse will be the direction of the normal.\n     * <br/>\n     * If body argument is not null, then this will return the actual impulse applied to that specific body\n     * for this contact this will include angular impulses due to position of contact point and normal.\n     *\n     * @param body The Body to query normal impulse for. (default null)\n     * @return The impulse applied to the given body, considering normal reactive forces.\n     * @throws # If body is non-null, and unrelated to this Contact.\n     */\n    #if nape_swc@:keep #end\n    public function normalImpulse(body:Body=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        var colarb=zpp_inner.arbiter.colarb;\n        var cin=zpp_inner.inner;\n        var jnAcc=cin.jnAcc;\n        if(body==null)return Vec3.get(colarb.nx*jnAcc,colarb.ny*jnAcc);\n        else{\n            #if(!NAPE_RELEASE_BUILD)\n            if(body!=colarb.b1.outer&&body!=colarb.b2.outer)throw \"Error: Contact does not relate to the given body\";\n            #end\n            if(body==colarb.b1.outer)return Vec3.get(colarb.nx*-jnAcc,colarb.ny*-jnAcc,-(colarb.ny*cin.r1x-colarb.nx*cin.r1y)*jnAcc);\n            else return Vec3.get(colarb.nx*jnAcc,colarb.ny*jnAcc,(colarb.ny*cin.r2x-colarb.nx*cin.r2y)*jnAcc);\n        }\n    }\n    /**\n     * Evaluate tangent impulses for this contact for a given body.\n     * <br/><br/>\n     * If body argument is null, then the contact friction impulses is returned with\n     * no angular impulse derivable, the direction of this impulse will be against the relative\n     * velocity of the first body against the second.\n     * <br/>\n     * If the body argument is non-null, then the actual impulse applied to that body due to tangent\n     * frictino impulses will be returned, including angular effects due to contact position and normal.\n     * <br/><br/>\n     * These tangent impulses correspond to the forces of static and dynamic friction for this contact.\n     *\n     * @param body The Body to query tangent impulse for. (default null)\n     * @return The impulse applied to the given body, considering standard frictional forces.\n     * @throws # If body is non-null, and unrelated to this Contact.\n     */\n    #if nape_swc@:keep #end\n    public function tangentImpulse(body:Body=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        var colarb=zpp_inner.arbiter.colarb;\n        var cin=zpp_inner.inner;\n        var jtAcc=cin.jtAcc;\n        if(body==null)return Vec3.get(-colarb.ny*jtAcc,colarb.nx*jtAcc);\n        else{\n            #if(!NAPE_RELEASE_BUILD)\n            if(body!=colarb.b1.outer&&body!=colarb.b2.outer)throw \"Error: Contact does not relate to the given body\";\n            #end\n            if(body==colarb.b1.outer)return Vec3.get(colarb.ny*jtAcc,-colarb.nx*jtAcc,-(cin.r1x*colarb.nx+cin.r1y*colarb.ny)*jtAcc);\n            else return Vec3.get(-colarb.ny*jtAcc,colarb.nx*jtAcc,(cin.r2x*colarb.nx+cin.r2y*colarb.ny)*jtAcc);\n        }\n    }\n    /**\n     * Evaluate rolling friction impulses for this contact for a given body.\n     * <br/><br/>\n     * If body argument is null, then the rolling impulse of this contact will be returned\n     * instead of the angular impulse applied to the specific body as a result of the rolling impulse.\n     *\n     * @param body The Body to query rolling impulse for. (default null)\n     * @return The angular impulse applied to the given body.\n     * @throws # If body is non-null, and unrelated to this Contact.\n     */\n    #if nape_swc@:keep #end\n    public function rollingImpulse(body:Body=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        var colarb=zpp_inner.arbiter.colarb;\n        var jrAcc=zpp_inner.arbiter.colarb.jrAcc;\n        if(body==null)return jrAcc;\n        else{\n            #if(!NAPE_RELEASE_BUILD)\n            if(body!=colarb.b1.outer&&body!=colarb.b2.outer)throw \"Error: Contact does not relate to the given body\";\n            #end\n            if(body==colarb.b1.outer)return-jrAcc;\n            else return jrAcc;\n        }\n    }\n    /**\n     * Evaluate total contact impulse for a given body.\n     * <br/><br/>\n     * If body argument is null, then this will return the sum of normal and tangent contact impulse, and the contact\n     * rolling impulse.\n     * <br/>\n     * When body argument is non-null, this impulse will be the actual change in (mass weighted)\n     * velocity that this contact caused to the Body in the previous time step.\n     *\n     * @param body The Body to query total impulse for. (default null)\n     * @return The impulse applied to the given body\n     * @throws # If body is non-null, and unrelated to this Contact.\n     */\n    #if nape_swc@:keep #end\n    public function totalImpulse(body:Body=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        var colarb=zpp_inner.arbiter.colarb;\n        var cin=zpp_inner.inner;\n        var jnAcc=cin.jnAcc;\n        var jtAcc=cin.jtAcc;\n        var jrAcc=colarb.jrAcc;\n        if(body==null){\n            return Vec3.get(colarb.nx*jnAcc-colarb.ny*jtAcc,colarb.ny*jnAcc+colarb.nx*jtAcc,jrAcc);\n        }\n        else{\n            #if(!NAPE_RELEASE_BUILD)\n            if(body!=colarb.b1.outer&&body!=colarb.b2.outer)throw \"Error: Contact does not relate to the given body\";\n            #end\n            var jx:Float=colarb.nx*jnAcc-colarb.ny*jtAcc;\n            var jy:Float=colarb.ny*jnAcc+colarb.nx*jtAcc;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((jx!=jx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(jx)\"+\") :: \"+(\"vec_new(in n: \"+\"j\"+\",in x: \"+\"colarb.nx*jnAcc-colarb.ny*jtAcc\"+\",in y: \"+\"colarb.ny*jnAcc+colarb.nx*jtAcc\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((jy!=jy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(jy)\"+\") :: \"+(\"vec_new(in n: \"+\"j\"+\",in x: \"+\"colarb.nx*jnAcc-colarb.ny*jtAcc\"+\",in y: \"+\"colarb.ny*jnAcc+colarb.nx*jtAcc\"+\")\");\n                #end\n            };\n            if(body==colarb.b1.outer)return Vec3.get(-jx,-jy,-(jy*cin.r1x-jx*cin.r1y)-jrAcc);\n            else return Vec3.get(jx,jy,(jy*cin.r2x-jx*cin.r2y)+jrAcc);\n        }\n    }\n    /**\n     * The specific coeffecient of friction for this contact.\n     * <br/><br/>\n     * This value is equal either to the static or dynamic friction coeffecient of the arbiter\n     * based on the relative velocity at contact point.\n     * <br/><br/>\n     * This value cannot be set, though you may implicitly set it exactly by modifying\n     * the arbiter to have the same static and dynamic friction in the PreListener.\n     */\n    #if nape_swc@:isVar #end\n    public var friction(get_friction,never):Float;\n    inline function get_friction():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        return zpp_inner.inner.friction;\n    }\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Contact.internal)throw \"Error: Cannot instantiate Contact derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(zpp_inner.arbiter==null||zpp_inner.arbiter.cleared)return \"{object-pooled}\";\n        else return \"{Contact}\";\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ContactIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:ContactList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:ContactIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:ContactIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_ContactList.internal)throw \"Error: Cannot instantiate \"+\"Contact\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:ContactList){\n        var ret=if(zpp_pool==null){\n            ZPP_ContactList.internal=true;\n            var ret=new ContactIterator();\n            ZPP_ContactList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=ContactIterator.zpp_pool;\n                ContactIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Contact type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Contact = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Contact = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Contact = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ContactList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_ContactList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(true){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(i.active&&i.arbiter.active)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(true){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(i.active&&i.arbiter.active)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Contact\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Contact>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new ContactList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Contact)#else Std.is(i,Contact)#end)throw \"Error: Array contains non \"+\"Contact\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Contact>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new ContactList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Contact):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Contact{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!true){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(x.active&&x.arbiter.active)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(x.active&&x.arbiter.active)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().wrapper();\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Contact):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Contact\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Contact):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Contact\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Contact{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Contact\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Contact{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Contact\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:Contact):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Contact):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Contact\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Contact\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(true)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return ContactIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new ContactList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Contact\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:ContactList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_ContactList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:Contact->Void):ContactList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=ContactIterator.zpp_pool;\n                    ContactIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Contact->Bool):ContactList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Fluid interaction subtype for Arbiter.\n */\n@:final#if nape_swc@:keep #end\nclass FluidArbiter extends Arbiter{\n    /**\n     * Centre of buoyancy for fluid interaction.\n     * <br/><br/>\n     * This value can be modified during a related PreListener handler.\n     */\n    #if nape_swc@:isVar #end\n    public var position(get_position,set_position):Vec2;\n    inline function get_position():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        if(zpp_inner.fluidarb.wrap_position==null)zpp_inner.fluidarb.getposition();\n        return zpp_inner.fluidarb.wrap_position;\n    }\n    inline function set_position(position:Vec2):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(!zpp_inner.fluidarb.mutable)throw \"Error: Arbiter is mutable only within a pre-handler\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if(position==null)throw \"Error: FluidArbiter::position cannot be null\";\n            #end\n            this.position.set(position);\n        }\n        return get_position();\n    }\n    /**\n     * Overlap area of Shapes in fluid interaction.\n     * <br/><br/>\n     * This value is strictly positive, and represents the amount of overlap between the Shapes\n     * used in buoyancy computations.\n     * <br/><br/>\n     * This value can be modified during a related PreListener handler.\n     */\n    #if nape_swc@:isVar #end\n    public var overlap(get_overlap,set_overlap):Float;\n    inline function get_overlap():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        return zpp_inner.fluidarb.overlap;\n    }\n    inline function set_overlap(overlap:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(!zpp_inner.fluidarb.mutable)throw \"Error: Arbiter is mutable only within a pre-handler\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((overlap!=overlap))throw \"Error: FluidArbiter::overlap cannot be NaN\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if(overlap<=0||overlap==Math.POSITIVE_INFINITY)throw \"Error: FluidArbiter::overlap must be strictly positive and non infinite\";\n            #end\n            zpp_inner.fluidarb.overlap=overlap;\n        }\n        return get_overlap();\n    }\n    /**\n     * Determine impulse on a given body due to buoyancy.\n     * <br/><br/>\n     * If the body is null, then the buoyancy impulse will be returned without consideration to any specific\n     * body involved, and no angular impulses can be derived.\n     *\n     * @param body The body to query impulse for. (default null)\n     * @return The buoyancy impulse for given body.\n     * @throws # If body is non-null, and unrelated to this Arbiter.\n     */\n    #if nape_swc@:keep #end\n    public function buoyancyImpulse(body:Body=null):Vec3{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body!=body1&&body!=body2)throw \"Error: Arbiter does not relate to body\";\n        #end\n        var farb=zpp_inner.fluidarb;\n        if(body==null){\n            return Vec3.get(farb.buoyx,farb.buoyy,0);\n        }\n        else if(body.zpp_inner==zpp_inner.b2){\n            return Vec3.get(farb.buoyx,farb.buoyy,(farb.buoyy*farb.r2x-farb.buoyx*farb.r2y));\n        }\n        else{\n            return Vec3.get(-farb.buoyx,-farb.buoyy,-(farb.buoyy*farb.r1x-farb.buoyx*farb.r1y));\n        }\n    }\n    /**\n     * Determine impulse on a given body due to fluid drag.\n     * <br/><br/>\n     * If the body is null, then the drag impulse will be returned without consideration to any specific\n     * body involved.\n     *\n     * @param body The body to query impulse for. (default null)\n     * @return The drag impulse for given body.\n     * @throws # If body is non-null, and unrelated to this Arbiter.\n     */\n    #if nape_swc@:keep #end\n    public function dragImpulse(body:Body=null):Vec3{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body!=body1&&body!=body2)throw \"Error: Arbiter does not relate to body\";\n        #end\n        var farb=zpp_inner.fluidarb;\n        var scale=(body==null||body.zpp_inner==zpp_inner.b2?1:-1);\n        return Vec3.get(farb.dampx*scale,farb.dampy*scale,farb.adamp*scale);\n    }\n    /**\n     * Determine total impulse on a given body due to fluid interaction.\n     * <br/><br/>\n     * If the body is null, then the total impulse will be computed without consideration to any specific\n     * body involved, and no angular impulses can be derived for the linear portion of the impulses.\n     *\n     * @param body The body to query impulse for. (default null)\n     * @param freshOnly This parameter is unused for FluidArbiters. (default false)\n     * @return The total impulse for given body.\n     * @throws # If body is non-null, and unrelated to this Arbiter.\n     */\n    #if nape_swc@:keep #end\n    public override function totalImpulse(body:Body=null,freshOnly:Bool=false){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body!=body1&&body!=body2)throw \"Error: Arbiter does not relate to body\";\n        #end\n        var tmp=this.buoyancyImpulse(body);\n        var ret=this.dragImpulse(body);\n        ret.x+=tmp.x;\n        ret.y+=tmp.y;\n        ret.z+=tmp.z;\n        tmp.dispose();\n        return ret;\n    }\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Arbiter.internal)throw \"Error: Cannot instantiate FluidArbiter derp!\";\n        #end\n        super();\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * InteractionFilter provides bit flags for low-level filtering of interactions.\n * <br/><br/>\n * For a given interaction type, two Shapes will be permitted to interact only if\n * <code>(shape1.group & shape2.mask) != 0 && (shape2.group & shape1.mask) != 0</code>\n * <br/><br/>\n * There are 32 real groups corresponding to a set bit in the group/mask fields. For instance\n * a group value of 0x120 corresponds to the 'real' groups 5 and 8 as <code>0x120 = (1<<5) | (1<<8)</code>\n * <br/><br/>\n * Nape provides group/mask for each interaction type. The actual precedence of interactions\n * is further defined simply as: Sensor > Fluid > Collision.\n * <br/>\n * Two static bodies can never interact, and with the exception of sensor interaction, at least one\n * of the two bodies must be dynamic.\n * <br/>\n * Sensor interactions have the highest precedence, followed by fluid and then collisions.\n * Sensor interaction is permitted only if one of the shapes is sensorEnabled, whilst fluid\n * is permitted only if one of the shapes is fluidEnabled.\n * <pre>\n * if ((shapeA.sensorEnabled || shapeB.sensorEnabled) && shapeA.filter.shouldSense(shapeB.filter)) {\n *     SENSOR INTERACTION!!\n * }\n * else if (bodyA.isDynamic() || bodyB.isDynamic()) {\n *     if ((shapeA.fluidEnabled || shapeB.fluidEnabled) && shapeA.filter.shouldFlow(shapeB.filter)) {\n *         FLUID INTERACTION!!\n *     }\n *     else if (shapeA.filter.shouldCollide(shapeB.filter)) {\n *         COLLISION INTERACTION!!\n *     }\n * }\n * </pre>\n */\n@:final#if nape_swc@:keep #end\nclass InteractionFilter{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_InteractionFilter=null;\n    /**\n     * Dynamic object for user to store additional data.\n     * <br/><br/>\n     * This object cannot be set, only its dynamically created\n     * properties may be set. In AS3 the type of this property is &#42\n     * <br/><br/>\n     * This object will be lazily constructed so that until accessed\n     * for the first time, will be null internally.\n     *\n     * @default {}\n     */\n    #if nape_swc@:isVar #end\n    public var userData(get_userData,never):Dynamic<Dynamic>;\n    inline function get_userData():Dynamic<Dynamic>{\n        if(zpp_inner.userData==null){\n            zpp_inner.userData=cast{};\n        }\n        return zpp_inner.userData;\n    }\n    /**\n     * Set of all active shapes using this object.\n     * <br/><br/>\n     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var shapes(get_shapes,never):ShapeList;\n    inline function get_shapes():ShapeList{\n        if(zpp_inner.wrap_shapes==null)zpp_inner.wrap_shapes=ZPP_ShapeList.get(zpp_inner.shapes,true);\n        return zpp_inner.wrap_shapes;\n    }\n    /**\n     * Group bitfield for Collision type interactions.\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var collisionGroup(get_collisionGroup,set_collisionGroup):Int;\n    inline function get_collisionGroup():Int{\n        return zpp_inner.collisionGroup;\n    }\n    inline function set_collisionGroup(collisionGroup:Int):Int{\n        {\n            if(this.collisionGroup!=collisionGroup){\n                zpp_inner.collisionGroup=collisionGroup;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_collisionGroup();\n    }\n    /**\n     * Mask bitfield for Collision type interactions.\n     * @default -1 (all bits set)\n     */\n    #if nape_swc@:isVar #end\n    public var collisionMask(get_collisionMask,set_collisionMask):Int;\n    inline function get_collisionMask():Int{\n        return zpp_inner.collisionMask;\n    }\n    inline function set_collisionMask(collisionMask:Int):Int{\n        {\n            if(this.collisionMask!=collisionMask){\n                zpp_inner.collisionMask=collisionMask;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_collisionMask();\n    }\n    /**\n     * Group bitfield for Sensor type interactions.\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var sensorGroup(get_sensorGroup,set_sensorGroup):Int;\n    inline function get_sensorGroup():Int{\n        return zpp_inner.sensorGroup;\n    }\n    inline function set_sensorGroup(sensorGroup:Int):Int{\n        {\n            if(this.sensorGroup!=sensorGroup){\n                zpp_inner.sensorGroup=sensorGroup;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_sensorGroup();\n    }\n    /**\n     * Mask bitfield for Sensor type interactions.\n     * @default -1 (all bits set)\n     */\n    #if nape_swc@:isVar #end\n    public var sensorMask(get_sensorMask,set_sensorMask):Int;\n    inline function get_sensorMask():Int{\n        return zpp_inner.sensorMask;\n    }\n    inline function set_sensorMask(sensorMask:Int):Int{\n        {\n            if(this.sensorMask!=sensorMask){\n                zpp_inner.sensorMask=sensorMask;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_sensorMask();\n    }\n    /**\n     * Group bitfield for Fluid type interactions.\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var fluidGroup(get_fluidGroup,set_fluidGroup):Int;\n    inline function get_fluidGroup():Int{\n        return zpp_inner.fluidGroup;\n    }\n    inline function set_fluidGroup(fluidGroup:Int):Int{\n        {\n            if(this.fluidGroup!=fluidGroup){\n                zpp_inner.fluidGroup=fluidGroup;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_fluidGroup();\n    }\n    /**\n     * Mask bitfield for Fluid type interactions.\n     * @default -1 (all bits set)\n     */\n    #if nape_swc@:isVar #end\n    public var fluidMask(get_fluidMask,set_fluidMask):Int;\n    inline function get_fluidMask():Int{\n        return zpp_inner.fluidMask;\n    }\n    inline function set_fluidMask(fluidMask:Int):Int{\n        {\n            if(this.fluidMask!=fluidMask){\n                zpp_inner.fluidMask=fluidMask;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_fluidMask();\n    }\n    /**\n     * Construct a new InteractionFilter.\n     *\n     * @param collisionGroup The Group bitfield for Collision interactions. (default 1)\n     * @param collisionMask  The Mask bitfield for Collision interactions. (default -1)\n     * @param sensorGroup    The Group bitfield for Sensor interactions. (default 1)\n     * @param sensorMask     The Mask bitfield for Sensor interactions. (default -1)\n     * @param fluidGroup     The Group bitfield for Fluid interactions. (default 1)\n     * @param fluidMask      The Mask bitfield for Fluid interactions. (default -1)\n     * @return The newly constructed InteractionFilter.\n     */\n    #if flib@:keep function flibopts_6(){}\n    #end\n    public function new(collisionGroup=1,collisionMask=-1,sensorGroup=1,sensorMask=-1,fluidGroup=1,fluidMask=-1){\n        {\n            if(ZPP_InteractionFilter.zpp_pool==null){\n                zpp_inner=new ZPP_InteractionFilter();\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_TOT++;\n                ZPP_InteractionFilter.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                zpp_inner=ZPP_InteractionFilter.zpp_pool;\n                ZPP_InteractionFilter.zpp_pool=zpp_inner.next;\n                zpp_inner.next=null;\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_CNT--;\n                ZPP_InteractionFilter.POOL_ADD++;\n                #end\n            }\n            zpp_inner.alloc();\n        };\n        zpp_inner.outer=this;\n        this.collisionGroup=collisionGroup;\n        this.collisionMask=collisionMask;\n        this.sensorGroup=sensorGroup;\n        this.sensorMask=sensorMask;\n        this.fluidGroup=fluidGroup;\n        this.fluidMask=fluidMask;\n    }\n    /**\n     * Determine if objects are permitted to collide based on InteractionFilters\n     * <br/><br/>\n     * A collision type interaction can occur only if this returns True.\n     *\n     * @param filter The filter to evaluate possibility of collision with.\n     * @return True, if based on interaction filters only the two objects would be able to collide.\n     * @throws # If filter is null.\n     */\n    #if nape_swc@:keep #end\n    public function shouldCollide(filter:InteractionFilter){\n        #if(!NAPE_RELEASE_BUILD)\n        if(filter==null)throw \"Error: filter argument cannot be null for shouldCollide\";\n        #end\n        return zpp_inner.shouldCollide(filter.zpp_inner);\n    }\n    /**\n     * Determine if objects are permitted to sense based on InteractionFilters\n     * <br/><br/>\n     * A sensor type interaction can occur only if this returns True.\n     *\n     * @param filter The filter to evaluate possibility of sensor with.\n     * @return True, if based on interaction filters only the two objects would be able to sense.\n     * @throws # If filter is null.\n     */\n    #if nape_swc@:keep #end\n    public function shouldSense(filter:InteractionFilter){\n        #if(!NAPE_RELEASE_BUILD)\n        if(filter==null)throw \"Error: filter argument cannot be null for shouldSense\";\n        #end\n        return zpp_inner.shouldSense(filter.zpp_inner);\n    }\n    /**\n     * Determine if objects are permitted to interact as fluids based on InteractionFilters\n     * <br/><br/>\n     * A fluid type interaction can occur only if this returns True.\n     *\n     * @param filter The filter to evaluate possibility of fluid with.\n     * @return True, if based on interaction filters only the two objects would be able to interact as fluids.\n     * @throws # If filter is null.\n     */\n    #if nape_swc@:keep #end\n    public function shouldFlow(filter:InteractionFilter){\n        #if(!NAPE_RELEASE_BUILD)\n        if(filter==null)throw \"Error: filter argument cannot be null for shouldFlow\";\n        #end\n        return zpp_inner.shouldFlow(filter.zpp_inner);\n    }\n    /**\n     * Produce a copy of this InteractionFilter\n     *\n     * @return The copy of this filter.\n     */\n    #if nape_swc@:keep #end\n    public function copy(){\n        return new InteractionFilter(collisionGroup,collisionMask,sensorGroup,sensorMask,fluidGroup,fluidMask);\n    }\n    /**\n     * @private\n     */\n    #if nape_swc@:keep #end\n    public function toString(){\n        return \"{ collision: \"+StringTools.hex(collisionGroup,8)+\"~\"+StringTools.hex(collisionMask,8)+\" sensor: \"+StringTools.hex(sensorGroup,8)+\"~\"+StringTools.hex(sensorMask,8)+\" fluid: \"+StringTools.hex(fluidGroup,8)+\"~\"+StringTools.hex(fluidMask,8)+\" }\";\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * InteractionGroups are another way of filtering interactions.\n * <br/><br/>\n * InteractionGroups form tree structures which are checked along side InteractionFilters\n * when deciding if two Shapes should interact.\n * <br/><br/>\n * InteractionGroups are assigned to any Interactor (not just Shapes), and two Shapes will\n * interact only if the most recent common ancestor in the InteractionGroup tree permits it.\n * <br/><br/>\n * For the purposes of the search, if any Interactor has no InteractionGroup assigned, we\n * search up the Compound tree first.\n * <pre>\n *            _Group1\n *           /   |\n *          /  Group2      Group3\n *         /    |    \\       |                 Group1\n *     Body1   /      Cmp1   |                 /   \\           Group3\n *    /    \\  /      /    \\  |      ==>    Shp1    Group2        |\n * Shp1   Shp2   Body2     Cmp2                    /    \\      Shp4\n *                 |         |                  Shp2    Shp3\n *                Shp3     Body3\n *                           |\n *                         Shp4\n * </pre>\n * If we look at which InteractionGroup is used for which Shape following this rule, then\n * the left graph can be transformed into an InteractionGroup tree on the right and we get\n * that the MRCA (Most recent common ancestors) are such that:\n * <pre>\n * MRCA(Shp1, Shp3) == Group1;\n * MRCA(Shp2, Shp3) == Group2;\n * MRCA(Shp4,   # ) == null;\n * </pre>\n * If we were to set up the groups such that <code>Group1.ignore = false</code> and\n * <code>Group2.ignore = true</code>; then shapes 1 and 3 would not be permitted to\n * interact, whilst shapes 2 and 3 would be permitted.\n * <br/>\n * As the MRCA for shape 4 with any other is null, then the value of Group3's ignore field\n * is irrelevant, but the existance of Group3 is not as it serves to otherwise prevent Shape 4\n * from being permitted to interact with shapes 2 and 3.\n * <br/><br/>\n * InteractionGroup's can be fairly expressive, but they are strictly less powerful than\n * InteractionFilters. InteractionGroup's have their place however as there is no limit\n * to the number of Groups you can use.\n */\n@:final#if nape_swc@:keep #end\nclass InteractionGroup{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_InteractionGroup=null;\n    /**\n     * Parent group in InteractionGroup tree.\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var group(get_group,set_group):Null<InteractionGroup>;\n    inline function get_group():Null<InteractionGroup>{\n        return if(zpp_inner.group==null)null else zpp_inner.group.outer;\n    }\n    inline function set_group(group:Null<InteractionGroup>):Null<InteractionGroup>{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(group==this)throw \"Error: Cannot assign InteractionGroup to itself\";\n            #end\n            zpp_inner.setGroup(group==null?null:group.zpp_inner);\n        }\n        return get_group();\n    }\n    /**\n     * Ignore property, set to true so that objects will not interact.\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var ignore(get_ignore,set_ignore):Bool;\n    inline function get_ignore():Bool{\n        return zpp_inner.ignore;\n    }\n    inline function set_ignore(ignore:Bool):Bool{\n        {\n            if(this.ignore!=ignore){\n                zpp_inner.invalidate(true);\n                zpp_inner.ignore=ignore;\n            }\n        }\n        return get_ignore();\n    }\n    /**\n     * Set of active interactors using this group.\n     * <br/><br/>\n     * Active interactors meaning those that are part of a Space.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var interactors(get_interactors,never):InteractorList;\n    inline function get_interactors():InteractorList{\n        if(zpp_inner.wrap_interactors==null)zpp_inner.wrap_interactors=ZPP_InteractorList.get(zpp_inner.interactors,true);\n        return zpp_inner.wrap_interactors;\n    }\n    /**\n     * Immutable set of children of Interaction groups.\n     * <br/><br/>\n     * You cannot assign or remove children in this manner, you must do it via setting\n     * the childs parent group to this/null.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var groups(get_groups,never):InteractionGroupList;\n    inline function get_groups():InteractionGroupList{\n        if(zpp_inner.wrap_groups==null)zpp_inner.wrap_groups=ZPP_InteractionGroupList.get(zpp_inner.groups,true);\n        return zpp_inner.wrap_groups;\n    }\n    /**\n     * Construct a new InteractionGroup.\n     *\n     * @param ignore Whether interactors should be ignored. (default false)\n     */\n    public function new(ignore=false){\n        zpp_inner=new ZPP_InteractionGroup();\n        zpp_inner.outer=this;\n        this.ignore=ignore;\n    }\n    /**\n     * @private\n     */\n    public function toString(){\n        var ret=\"InteractionGroup\";\n        if(ignore)ret+=\":ignore\";\n        return ret;\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass InteractionGroupIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:InteractionGroupList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:InteractionGroupIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:InteractionGroupIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_InteractionGroupList.internal)throw \"Error: Cannot instantiate \"+\"InteractionGroup\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:InteractionGroupList){\n        var ret=if(zpp_pool==null){\n            ZPP_InteractionGroupList.internal=true;\n            var ret=new InteractionGroupIterator();\n            ZPP_InteractionGroupList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=InteractionGroupIterator.zpp_pool;\n                InteractionGroupIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of InteractionGroup type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:InteractionGroup = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:InteractionGroup = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:InteractionGroup = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass InteractionGroupList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_InteractionGroupList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than InteractionGroup\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<InteractionGroup>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new InteractionGroupList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,InteractionGroup)#else Std.is(i,InteractionGroup)#end)throw \"Error: Array contains non \"+\"InteractionGroup\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<InteractionGroup>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new InteractionGroupList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:InteractionGroup):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):InteractionGroup{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:InteractionGroup):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"InteractionGroup\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:InteractionGroup):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"InteractionGroup\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():InteractionGroup{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"InteractionGroup\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():InteractionGroup{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"InteractionGroup\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:InteractionGroup):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:InteractionGroup):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"InteractionGroup\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"InteractionGroup\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return InteractionGroupIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new InteractionGroupList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"InteractionGroup\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:InteractionGroupList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_InteractionGroupList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:InteractionGroup->Void):InteractionGroupList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=InteractionGroupIterator.zpp_pool;\n                    InteractionGroupIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:InteractionGroup->Bool):InteractionGroupList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Axis Aligned Bounding Box (AABB)\n * <br/><br/>\n * Note that in many cases of an AABB object being returned by a Nape function\n * the AABB object will be marked internally as an 'immutable' AABB. This will\n * always be documented and trying to mutate such an AABB will result in an\n * error being thrown.\n */\n@:final#if nape_swc@:keep #end\nclass AABB{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_AABB=null;\n    /**\n     * Construct a new AABB.\n     * <br/><br/>\n     * As input width/height are permitted to be negative it is not guaranteed\n     * that the resultant AABB will have the same parameters as those\n     * specified as the AABB parameters are guaranteed to always have positive\n     * width/height, and for x/y to always be the top-left corner.\n     *\n     * @param x      The x coordinate of the top-left corner of the AABB.\n     *               (default 0)\n     * @param y      The y coordinate of the top-left corner of the AABB\n     *               (default 0)\n     * @param width  The width of the AABB. This value may be negative.\n     *               (default 0)\n     * @param height The height of the AABB. This value may be negative.\n     *               (default 0)\n     * @return       The newly constructed AABB object.\n     */\n    public function new(x:Float=0,y:Float=0,width:Float=0,height:Float=0){\n        #if(!NAPE_RELEASE_BUILD)\n        if((x!=x)||(y!=y)){\n            throw \"Error: AABB position cannot be NaN\";\n        }\n        if((width!=width)||(height!=height)){\n            throw \"Error: AABB dimensions cannot be NaN\";\n        }\n        #end\n        zpp_inner=ZPP_AABB.get(x,y,x+width,y+height);\n        zpp_inner.outer=this;\n    }\n    /**\n     * Produce a copy of this AABB.\n     * <br/><br/>\n     * As would be expected, if you produce a copy of an 'immutable' AABB then\n     * the copy will be 'mutable'.\n     *\n     * @return The copy of this AABB.\n     */\n    #if nape_swc@:keep #end\n    public function copy(){\n        zpp_inner.validate();\n        return zpp_inner.copy().wrapper();\n    }\n    #if(flash9||openfl||nme)\n    /**\n     * Construct an AABB from an AS3 Rectangle object.\n     * <br/><br/>\n     * This method is only available on <code>flash</code> and\n     * <code>openfl||nme</code> targets.\n     *\n     * @param rect The AS3 Rectangle to construct AABB from, this value\n     *             must not be null.\n     * @return The constructed AABB matching the input Rectangle.\n     * @throws # If the input rectangle is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromRect(rect:flash.geom.Rectangle):AABB{\n        #if(!NAPE_RELEASE_BUILD)\n        if(rect==null){\n            throw \"Error: Cannot create AABB from null Rectangle\";\n        }\n        #end\n        return new AABB(rect.x,rect.y,rect.width,rect.height);\n    }\n    /**\n     * Create an AS3 Rectangle object from AABB.\n     * <br/><br/>\n     * This method is available only on <code>flash</code> and\n     * <code>openfl||nme</code> targets.\n     *\n     * @return The AS3 Rectangle object representing AABB.\n     */\n    #if nape_swc@:keep #end\n    public function toRect():flash.geom.Rectangle{\n        return new flash.geom.Rectangle(x,y,width,height);\n    }\n    #end\n    /**\n     * The minimum bounds for the AABB.\n     * <br/><br/>\n     * Euivalent to the top-left corner.\n     * <br/>\n     * This Vec2 is intrinsically linked to the AABB so that modifications\n     * to this object are reflected in changes to the AABB and vice-versa.\n     * <br/><br/>\n     * If the AABB is immutable, then this Vec2 will also be immutable.\n     * <br/><br/>\n     * This value can be set with the = operator, equivalent to performing\n     * <code>aabb.min.set(value)</code>.\n     * @default (0, 0)\n     */\n    #if nape_swc@:isVar #end\n    public var min(get_min,set_min):Vec2;\n    inline function get_min():Vec2{\n        return zpp_inner.getmin();\n    }\n    inline function set_min(min:Vec2):Vec2{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(min!=null&&min.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner._immutable){\n                throw \"Error: AABB is immutable\";\n            }\n            if(min==null){\n                throw \"Error: Cannot assign null to AABB::\"+\"min\";\n            }\n            if((x!=x)||(y!=y)){\n                throw \"Error: AABB::\"+\"min\"+\" components cannot be NaN\";\n            }\n            if(\"min\"==\"min\"){\n                if(min.x>max.x)throw \"Error: Assignment would cause negative width\";\n                if(min.y>max.y)throw \"Error: Assignment would cause negative height\";\n            }\n            else{\n                if(min.x<min.x)throw \"Error: Assignment would cause negative width\";\n                if(min.y<min.y)throw \"Error: Assignment would cause negative height\";\n            }\n            #end\n            this.min.set(min);\n        }\n        return get_min();\n    }\n    /**\n     * The maximum bounds for the AABB.\n     * <br/><br/>\n     * Euivalent to the bottom-right corner.\n     * <br/>\n     * This Vec2 is intrinsically linked to the AABB so that modifications\n     * to this object are reflected in changes to the AABB and vice-versa.\n     * <br/><br/>\n     * If the AABB is immutable, then this Vec2 will also be immutable.\n     * <br/><br/>\n     * This value can be set with the = operator, equivalent to performing\n     * <code>aabb.max.set(value)</code>.\n     * @default (0, 0)\n     */\n    #if nape_swc@:isVar #end\n    public var max(get_max,set_max):Vec2;\n    inline function get_max():Vec2{\n        return zpp_inner.getmax();\n    }\n    inline function set_max(max:Vec2):Vec2{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(max!=null&&max.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner._immutable){\n                throw \"Error: AABB is immutable\";\n            }\n            if(max==null){\n                throw \"Error: Cannot assign null to AABB::\"+\"max\";\n            }\n            if((x!=x)||(y!=y)){\n                throw \"Error: AABB::\"+\"max\"+\" components cannot be NaN\";\n            }\n            if(\"max\"==\"min\"){\n                if(max.x>max.x)throw \"Error: Assignment would cause negative width\";\n                if(max.y>max.y)throw \"Error: Assignment would cause negative height\";\n            }\n            else{\n                if(max.x<min.x)throw \"Error: Assignment would cause negative width\";\n                if(max.y<min.y)throw \"Error: Assignment would cause negative height\";\n            }\n            #end\n            this.max.set(max);\n        }\n        return get_max();\n    }\n    /**\n     * The x coordinate of the AABB's top-left corner.\n     * <br/><br/>\n     * Equivalent to accessing/mutating min.x.\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var x(get_x,set_x):Float;\n    inline function get_x():Float{\n        zpp_inner.validate();\n        return zpp_inner.minx;\n    }\n    inline function set_x(x:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner._immutable){\n                throw \"Error: AABB is immutable\";\n            }\n            #end\n            if(this.x!=x){\n                #if(!NAPE_RELEASE_BUILD)\n                if((x!=x))throw \"Error: AABB::\"+\"x\"+\" cannot be NaN\";\n                #end\n                zpp_inner.maxx+=x-zpp_inner.minx;\n                zpp_inner.minx=x;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_x();\n    }\n    /**\n     * The y coordinate of the AABB's top-left corner.\n     * <br/><br/>\n     * Equivalent to accessing/mutating min.y.\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var y(get_y,set_y):Float;\n    inline function get_y():Float{\n        zpp_inner.validate();\n        return zpp_inner.miny;\n    }\n    inline function set_y(y:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner._immutable){\n                throw \"Error: AABB is immutable\";\n            }\n            #end\n            if(this.y!=y){\n                #if(!NAPE_RELEASE_BUILD)\n                if((y!=y))throw \"Error: AABB::\"+\"y\"+\" cannot be NaN\";\n                #end\n                zpp_inner.maxy+=y-zpp_inner.miny;\n                zpp_inner.miny=y;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_y();\n    }\n    /**\n     * width of AABB.\n     * <br/><br/>\n     * This value is and must always be positive.\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var width(get_width,set_width):Float;\n    inline function get_width():Float{\n        zpp_inner.validate();\n        return zpp_inner.width();\n    }\n    inline function set_width(width:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner._immutable){\n                throw \"Error: AABB is immutable\";\n            }\n            #end\n            if(this.width!=width){\n                #if(!NAPE_RELEASE_BUILD)\n                if((width!=width)){\n                    throw \"Error: AABB::\"+\"width\"+\" cannot be NaN\";\n                }\n                if(width<0){\n                    throw \"Error: AABB::\"+\"width\"+\" (\"+width+\") must be >= 0\";\n                }\n                #end\n                zpp_inner.maxx=this.x+width;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_width();\n    }\n    /**\n     * height of AABB.\n     * <br/><br/>\n     * This value is and must always be positive.\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var height(get_height,set_height):Float;\n    inline function get_height():Float{\n        zpp_inner.validate();\n        return zpp_inner.height();\n    }\n    inline function set_height(height:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner._immutable){\n                throw \"Error: AABB is immutable\";\n            }\n            #end\n            if(this.height!=height){\n                #if(!NAPE_RELEASE_BUILD)\n                if((height!=height)){\n                    throw \"Error: AABB::\"+\"height\"+\" cannot be NaN\";\n                }\n                if(height<0){\n                    throw \"Error: AABB::\"+\"height\"+\" (\"+height+\") must be >= 0\";\n                }\n                #end\n                zpp_inner.maxy=this.y+height;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_height();\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        zpp_inner.validate();\n        return zpp_inner.toString();\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Class representing the results of a convex cast operation.\n * <br/><br/>\n * These objects are allocated from an object pool and can\n * be released back to that pool by calling its dispose method.\n */\n@:final#if nape_swc@:keep #end\nclass ConvexResult{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_ConvexRayResult=null;\n    /**\n     * The normal of the surface at collision.\n     */\n    #if nape_swc@:isVar #end\n    public var normal(get_normal,never):Vec2;\n    inline function get_normal():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return zpp_inner.normal;\n    }\n    /**\n     * The position of the collision.\n     */\n    #if nape_swc@:isVar #end\n    public var position(get_position,never):Vec2;\n    inline function get_position():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return zpp_inner.position;\n    }\n    /**\n     * The time of impact to the collision\n     */\n    #if nape_swc@:isVar #end\n    public var toi(get_toi,never):Float;\n    inline function get_toi():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return zpp_inner.toiDistance;\n    }\n    /**\n     * The shape which was collided against.\n     */\n    #if nape_swc@:isVar #end\n    public var shape(get_shape,never):Shape;\n    inline function get_shape():Shape{\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return zpp_inner.shape;\n    }\n    /**\n     * @private\n     */\n    #if flib@:keep function flibopts_0(){}\n    #end\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_ConvexRayResult.internal)throw \"Error: ConvexResult cannot be instantiated derp!\";\n        #end\n    }\n    /**\n     * Release ConvexResult object to pool.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function dispose(){\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        zpp_inner.free();\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return \"{ shape: \"+shape+\" toi: \"+toi+\" }\";\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ConvexResultIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:ConvexResultList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:ConvexResultIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:ConvexResultIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_ConvexResultList.internal)throw \"Error: Cannot instantiate \"+\"ConvexResult\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:ConvexResultList){\n        var ret=if(zpp_pool==null){\n            ZPP_ConvexResultList.internal=true;\n            var ret=new ConvexResultIterator();\n            ZPP_ConvexResultList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=ConvexResultIterator.zpp_pool;\n                ConvexResultIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of ConvexResult type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:ConvexResult = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:ConvexResult = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:ConvexResult = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ConvexResultList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_ConvexResultList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than ConvexResult\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<ConvexResult>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new ConvexResultList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,ConvexResult)#else Std.is(i,ConvexResult)#end)throw \"Error: Array contains non \"+\"ConvexResult\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<ConvexResult>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new ConvexResultList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:ConvexResult):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):ConvexResult{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem();\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:ConvexResult):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"ConvexResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:ConvexResult):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"ConvexResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj);\n            }\n            else zpp_inner.inner.add(obj);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():ConvexResult{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"ConvexResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():ConvexResult{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"ConvexResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:ConvexResult):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:ConvexResult):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"ConvexResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"ConvexResult\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return ConvexResultIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new ConvexResultList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"ConvexResult\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:ConvexResultList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_ConvexResultList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:ConvexResult->Void):ConvexResultList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=ConvexResultIterator.zpp_pool;\n                    ConvexResultIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:ConvexResult->Bool):ConvexResultList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Polygon class with various geometric methods\n * <br/><br/>\n * This class represents a general Polygon, rather than the Polygon class\n * which is physics shape.\n * <br/><br/>\n * Internally this polygon is stored as a circularly linked list of special\n * vertex types that are exposed via a Vec2 that is lazily constructed whenever\n * necessary to the API.\n */\n@:final#if nape_swc@:keep #end\nclass GeomPoly{\n    /**\n     * @private\n     */\n    public var zpp_pool:GeomPoly=null;\n    #if(!NAPE_RELEASE_BUILD)\n    /**\n     * @private\n     */\n    public var zpp_disp:Bool;\n    #end\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_GeomPoly=null;\n    /**\n     * Determine if polygon is empty.\n     *\n     * @return True if polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return(zpp_inner.vertices==null);\n    }\n    /**\n     * Determine number of vertices in polygon\n     *\n     * @return The number of vertices.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function size():Int{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return({\n            var ret=0;\n            {\n                var F=zpp_inner.vertices;\n                var L=zpp_inner.vertices;\n                if(F!=null){\n                    var nite=F;\n                    do{\n                        var i=nite;\n                        {\n                            ret++;\n                        }\n                        nite=nite.next;\n                    }\n                    while(nite!=L);\n                }\n            };\n            ret;\n        });\n    }\n    /**\n     * Haxe iterator over vertices of polygon.\n     *\n     * @return A Haxe iterator over the vertices of the polygon.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function iterator():GeomVertexIterator{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return ZPP_GeomVertexIterator.get(zpp_inner.vertices,true);\n    }\n    /**\n     * Haxe iterator over vertices of polygon.\n     *\n     * @return A Haxe iterator over the vertices of the polygon.\n     *         Iterating in a forward direction.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function forwardIterator():GeomVertexIterator{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return ZPP_GeomVertexIterator.get(zpp_inner.vertices,true);\n    }\n    /**\n     * Haxe iterator over vertices of polygon.\n     *\n     * @return A Haxe iterator over the vertices of the polygon.\n     *         Iterating in a backwards direction.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function backwardsIterator():GeomVertexIterator{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return ZPP_GeomVertexIterator.get(zpp_inner.vertices,false);\n    }\n    /**\n     * Current vertex at head of polygon.\n     * <br/><br/>\n     * The current vertex will not be changed by this access.\n     * <br/><br/>\n     * This function returns a Vec2 which will be intrinsically tied\n     * to the values of the internal vertex so that modifications to\n     * this Vec2 will be reflected in the vertex of the polygon.\n     * <br/><br/>\n     * If invoked again with the head of the polygon pointing to the\n     * same vertex, then the same Vec2 will be returned; this Vec2 is\n     * not able to be disposed of.\n     *\n     * @return A Vec2 representing the current vertex of polygon.\n     * @throws # If polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function current():Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty()){\n            throw \"Error: GeomPoly is empty\";\n        }\n        #end\n        return zpp_inner.vertices.wrapper();\n    }\n    /**\n     * Push vertex to polygon.\n     * <br/><br/>\n     * A vertex will be allocated from a global object pool, and initialised\n     * with the values of the given Vec2.\n     * <br/><br/>\n     * This vertex will be inserted after the current head, and the head\n     * advanced to the newly inserted vertex, in this way successive pushes\n     * will insert elements in order.\n     * <br/><br/>\n     * Note that the Vec2 supplied as argument is only used to initialise the\n     * inner Vertex.\n     * <pre>\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                (head)\n     *\n     * poly.push(X);\n     *\n     * poly := -> A <-> B <-> X <-> C <-> D <-> E <-\n     *                      (head)\n     * </pre>\n     *\n     * @param vertex The Vec2 to be used in initialising the inner vertex.\n     * @return A reference to this polygon.\n     * @throws # If Vec2 is null, or has been disposed.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function push(vertex:Vec2):GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vertex!=null&&vertex.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vertex==null){\n            throw \"Error: Cannot push null vertex\";\n        }\n        #end\n        zpp_inner.vertices={\n            var obj=ZPP_GeomVert.get(vertex.x,vertex.y);\n            if(zpp_inner.vertices==null)zpp_inner.vertices=obj.prev=obj.next=obj;\n            else{\n                obj.prev=zpp_inner.vertices;\n                obj.next=zpp_inner.vertices.next;\n                zpp_inner.vertices.next.prev=obj;\n                zpp_inner.vertices.next=obj;\n            }\n            obj;\n        };\n        ({\n            if(({\n                vertex.zpp_inner.weak;\n            })){\n                vertex.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Pop vertex from polygon.\n     * <br/><br/>\n     * Pop the current vertex at head of polygon, retreating the 'current'\n     * vertex to point to the previous vertex in polygon. This inner vertex\n     * will be released to the global object pool.\n     * <br/><br/>\n     * In this way a pop which follows a push will act to reset the push.\n     * <pre>\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                (head)\n     *\n     * poly.pop();\n     *\n     * poly := -> A <-> C <-> D <-> E <-\n     *          (head)\n     * </pre>\n     *\n     * @return A reference to this polygon.\n     * @throws # If polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function pop():GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if((zpp_inner.vertices==null)){\n            throw \"Error: Cannot pop from empty polygon\";\n        }\n        #end\n        var retv=zpp_inner.vertices;\n        zpp_inner.vertices={\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !(zpp_inner.vertices==null);\n                };\n                if(!res)throw \"assert(\"+\"!(zpp_inner.vertices==null)\"+\") :: \"+(\"can't pop from empty list derpiderp\");\n                #end\n            };\n            if((zpp_inner.vertices!=null&&zpp_inner.vertices.prev==zpp_inner.vertices)){\n                zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                {};\n                null;\n            }\n            else{\n                var retnodes=zpp_inner.vertices.prev;\n                zpp_inner.vertices.prev.next=zpp_inner.vertices.next;\n                zpp_inner.vertices.next.prev=zpp_inner.vertices.prev;\n                zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                {};\n                zpp_inner.vertices=null;\n                retnodes;\n            }\n        };\n        {\n            var o=retv;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_GeomVert\"+\", in obj: \"+\"retv\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_GeomVert.zpp_pool;\n            ZPP_GeomVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_GeomVert.POOL_CNT++;\n            ZPP_GeomVert.POOL_SUB++;\n            #end\n        };\n        return this;\n    }\n    /**\n     * Unshift vertex to polygon.\n     * <br/><br/>\n     * A vertex will be allocated from a global object pool, and initialised\n     * with the values of the given Vec2.\n     * <br/><br/>\n     * This vertex will be inserted before the current head, and the head\n     * retreated to the newly inserted vertex, in this way successive unshifts\n     * will insert elements in the expected reverse order.\n     * <br/><br/>\n     * Note that the Vec2 supplied as argument is only used to initialise the\n     * inner Vertex.\n     * <pre>\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                (head)\n     *\n     * poly.unshift(X);\n     *\n     * poly := -> A <-> X <-> B <-> C <-> D <-> E <-\n     *                (head)\n     * </pre>\n     *\n     * @param vertex The Vec2 to be used in initialising the inner vertex.\n     * @return A reference to this polygon.\n     * @throws # If Vec2 is null, or has been disposed.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function unshift(vertex:Vec2):GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vertex!=null&&vertex.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vertex==null){\n            throw \"Error: Cannot unshift null vertex\";\n        }\n        #end\n        zpp_inner.vertices={\n            var obj=ZPP_GeomVert.get(vertex.x,vertex.y);\n            if(zpp_inner.vertices==null)zpp_inner.vertices=obj.prev=obj.next=obj;\n            else{\n                obj.next=zpp_inner.vertices;\n                obj.prev=zpp_inner.vertices.prev;\n                zpp_inner.vertices.prev.next=obj;\n                zpp_inner.vertices.prev=obj;\n            }\n            obj;\n        };\n        ({\n            if(({\n                vertex.zpp_inner.weak;\n            })){\n                vertex.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Shift vertex from polygon.\n     * <br/><br/>\n     * Shift the current vertex at head of polygon, advancing the 'current'\n     * vertex to point to the next vertex in polygon. This inner vertex\n     * will be released to the global object pool.\n     * <br/><br/>\n     * In this way a shift which follows an unshift will act to reset the\n     * unshift operation.\n     * <pre>\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                (head)\n     *\n     * poly.shift();\n     *\n     * poly := -> A <-> C <-> D <-> E <-\n     *                (head)\n     * </pre>\n     *\n     * @return A reference to this polygon.\n     * @throws # If polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function shift():GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if((zpp_inner.vertices==null)){\n            throw \"Error: Cannot shift from empty polygon\";\n        }\n        #end\n        var retv=zpp_inner.vertices;\n        zpp_inner.vertices={\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !(zpp_inner.vertices==null);\n                };\n                if(!res)throw \"assert(\"+\"!(zpp_inner.vertices==null)\"+\") :: \"+(\"can't pop from empty list herpaderp\");\n                #end\n            };\n            if((zpp_inner.vertices!=null&&zpp_inner.vertices.prev==zpp_inner.vertices)){\n                zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                {};\n                zpp_inner.vertices=null;\n            }\n            else{\n                var retnodes=zpp_inner.vertices.next;\n                zpp_inner.vertices.prev.next=zpp_inner.vertices.next;\n                zpp_inner.vertices.next.prev=zpp_inner.vertices.prev;\n                zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                {};\n                zpp_inner.vertices=null;\n                retnodes;\n            }\n        };\n        {\n            var o=retv;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_GeomVert\"+\", in obj: \"+\"retv\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_GeomVert.zpp_pool;\n            ZPP_GeomVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_GeomVert.POOL_CNT++;\n            ZPP_GeomVert.POOL_SUB++;\n            #end\n        };\n        return this;\n    }\n    /**\n     * Advance head of polygon forward.\n     * <br/><br/>\n     * The current head of polygon will be moved forwards\n     * the given number of times, with a negative value\n     * being equivalent to performing a backwards advance.\n     * <br/><br/>\n     * <code>poly.skip_forwards(times)</code> is equivalent to\n     * <code>poly.skip_backwards(-times)</code>\n     * <pre>\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                (head)\n     *\n     * poly.skipForwards(2);\n     *\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                            (head)\n     * </pre>\n     *\n     * @params times The number of times to advance head forward.\n     *               This value can be negative indicating a backwards\n     *               advance.\n     * @return A reference to this polygon.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function skipForward(times:Int):GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        if(!(zpp_inner.vertices==null)){\n            if(times>0){\n                while(times-->0)zpp_inner.vertices=zpp_inner.vertices.next;\n            }\n            else if(times<0){\n                while(times++<0)zpp_inner.vertices=zpp_inner.vertices.prev;\n            }\n        }\n        return this;\n    }\n    /**\n     * Advance head of polygon backwards.\n     * <br/><br/>\n     * The current head of polygon will be moved backwards\n     * the given number of times, with a negative value\n     * being equivalent to performing a forwards advance.\n     * <br/><br/>\n     * <code>poly.skip_backwards(times)</code> is equivalent to\n     * <code>poly.skip_forwards(-times)</code>\n     * <pre>\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                (head)\n     *\n     * poly.skipBackwards(2);\n     *\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                                  (head)\n     * </pre>\n     *\n     * @params times The number of times to advance head backwards.\n     *               This value can be negative indicating a forwards\n     *               advance.\n     * @return A reference to this polygon.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function skipBackwards(times:Int){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return skipForward(-times);\n    }\n    /**\n     * Erase count number of elements\n     * <br/><br/>\n     * For positive values of count, this is equivalent to successive\n     * unshift operations.\n     * <br/><br/>\n     * For negative values of count, this is equivalent to successive\n     * pop operations.\n     * <pre>\n     * poly := -> A <-> B <-> C <-> D <-> E <-> F <-> G <-\n     *                (head)\n     *\n     * poly.erase(2);\n     *\n     * poly := -> A <-> D <-> E <-> F <-> G <-\n     *                (head)\n     *\n     * poly.erase(-3);\n     *\n     * poly := -> E <-> F <-\n     *                (head)\n     * </pre>\n     * In this case that the specified number of elements to erase is\n     * greater than the size of the polygon, the method will simply\n     * terminate with the polygon being empty.\n     *\n     * @param count The number of vertices to erase, with sign indicating\n     *              the direction for erasing.\n     * @return A reference to this polygon.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function erase(count:Int):GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        while(count!=0&&!(zpp_inner.vertices==null)){\n            var retv=zpp_inner.vertices;\n            if(count>0){\n                zpp_inner.vertices={\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !(zpp_inner.vertices==null);\n                        };\n                        if(!res)throw \"assert(\"+\"!(zpp_inner.vertices==null)\"+\") :: \"+(\"can't pop from empty list herpaderp\");\n                        #end\n                    };\n                    if((zpp_inner.vertices!=null&&zpp_inner.vertices.prev==zpp_inner.vertices)){\n                        zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                        {};\n                        zpp_inner.vertices=null;\n                    }\n                    else{\n                        var retnodes=zpp_inner.vertices.next;\n                        zpp_inner.vertices.prev.next=zpp_inner.vertices.next;\n                        zpp_inner.vertices.next.prev=zpp_inner.vertices.prev;\n                        zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                        {};\n                        zpp_inner.vertices=null;\n                        retnodes;\n                    }\n                };\n                count--;\n            }\n            else if(count<0){\n                zpp_inner.vertices={\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !(zpp_inner.vertices==null);\n                        };\n                        if(!res)throw \"assert(\"+\"!(zpp_inner.vertices==null)\"+\") :: \"+(\"can't pop from empty list derpiderp\");\n                        #end\n                    };\n                    if((zpp_inner.vertices!=null&&zpp_inner.vertices.prev==zpp_inner.vertices)){\n                        zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                        {};\n                        null;\n                    }\n                    else{\n                        var retnodes=zpp_inner.vertices.prev;\n                        zpp_inner.vertices.prev.next=zpp_inner.vertices.next;\n                        zpp_inner.vertices.next.prev=zpp_inner.vertices.prev;\n                        zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                        {};\n                        zpp_inner.vertices=null;\n                        retnodes;\n                    }\n                };\n                count++;\n            }\n            {\n                var o=retv;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_GeomVert\"+\", in obj: \"+\"retv\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_GeomVert.zpp_pool;\n                ZPP_GeomVert.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_GeomVert.POOL_CNT++;\n                ZPP_GeomVert.POOL_SUB++;\n                #end\n            };\n        }\n        return this;\n    }\n    /**\n     * Clear all vertices from polygon.\n     * <br/><br/>\n     * All of the vertices will be released to the global object pool.\n     *\n     * @return A reference to this polygon.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function clear():GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            while(!(zpp_inner.vertices==null)){\n                var tmp=zpp_inner.vertices;\n                zpp_inner.vertices={\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !(zpp_inner.vertices==null);\n                        };\n                        if(!res)throw \"assert(\"+\"!(zpp_inner.vertices==null)\"+\") :: \"+(\"can't pop from empty list herpaderp\");\n                        #end\n                    };\n                    if((zpp_inner.vertices!=null&&zpp_inner.vertices.prev==zpp_inner.vertices)){\n                        zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                        {};\n                        zpp_inner.vertices=null;\n                    }\n                    else{\n                        var retnodes=zpp_inner.vertices.next;\n                        zpp_inner.vertices.prev.next=zpp_inner.vertices.next;\n                        zpp_inner.vertices.next.prev=zpp_inner.vertices.prev;\n                        zpp_inner.vertices.next=zpp_inner.vertices.prev=null;\n                        {};\n                        zpp_inner.vertices=null;\n                        retnodes;\n                    }\n                };\n                {\n                    var o=tmp;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_GeomVert\"+\", in obj: \"+\"tmp\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_GeomVert.zpp_pool;\n                    ZPP_GeomVert.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_GeomVert.POOL_CNT++;\n                    ZPP_GeomVert.POOL_SUB++;\n                    #end\n                };\n            }\n        };\n        return this;\n    }\n    /**\n     * Copy this polygon.\n     * <br/><br/>\n     * The copy will have its vertices in the same order as 'this' polygon.\n     * It will also have its current vertex at head, as the same vertex\n     * this polygon has.\n     * <br/><br/>\n     * This polygon will not be modified in any way.\n     * <pre>\n     * poly := -> A <-> B <-> C <-> D <-> E <-\n     *                (head)\n     *\n     * poly2 = poly.copy();\n     *\n     * poly2 := -> A' <-> B' <-> C' <-> D' <-> E' <-\n     *                  (head)\n     * </pre>\n     *\n     * @return The new GeomPoly representing the copy.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function copy():GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        var ret=GeomPoly.get();\n        {\n            var F=zpp_inner.vertices;\n            var L=zpp_inner.vertices;\n            if(F!=null){\n                var nite=F;\n                do{\n                    var v=nite;\n                    {\n                        {\n                            ret.zpp_inner.vertices={\n                                var obj=ZPP_GeomVert.get(v.x,v.y);\n                                if(ret.zpp_inner.vertices==null)ret.zpp_inner.vertices=obj.prev=obj.next=obj;\n                                else{\n                                    obj.prev=ret.zpp_inner.vertices;\n                                    obj.next=ret.zpp_inner.vertices.next;\n                                    ret.zpp_inner.vertices.next.prev=obj;\n                                    ret.zpp_inner.vertices.next=obj;\n                                }\n                                obj;\n                            };\n                        };\n                    }\n                    nite=nite.next;\n                }\n                while(nite!=L);\n            }\n        };\n        return ret.skipForward(1);\n    }\n    /**\n     * Create a new GeomPoly polygon.\n     * <br/><br/>\n     * The vertices argument is typed Dynamic (* in AS3), and is permitted\n     * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>\n     * <br/><br/>\n     * The input will be used to initialise the vertices of the polygon with\n     * the head of the polygon pointing to the first vertex in input with vertices\n     * inserted in forward order.\n     * <br/><br/>\n     * You should use the static 'get' method in preference to make use of object pool.\n     *\n     * @param vertices Vertex data to initialise polygon, or null for empty polygon.\n     * @return New GeomPoly representing input vertex data.\n     * @throws # If input data is not of an expected Type.\n     */\n    public function new(vertices:Dynamic=null){\n        zpp_inner=new ZPP_GeomPoly(this);\n        if(vertices!=null){\n            {\n                if(#if flash untyped __is__(vertices,Array)#else Std.is(vertices,Array)#end){\n                    var lv:Array<Dynamic>=vertices;\n                    for(vite in lv){\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(vite==null)throw \"Error: Array<Vec2> contains null objects\";\n                        #end\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(!#if flash untyped __is__(vite,Vec2)#else Std.is(vite,Vec2)#end)throw \"Error: Array<Vec2> contains non Vec2 objects\";\n                        #end\n                        var v:Vec2=vite;\n                        {\n                            #if(!NAPE_RELEASE_BUILD)\n                            if(v!=null&&v.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                            #end\n                        };\n                        {\n                            zpp_inner.vertices={\n                                var obj=ZPP_GeomVert.get(v.x,v.y);\n                                if(zpp_inner.vertices==null)zpp_inner.vertices=obj.prev=obj.next=obj;\n                                else{\n                                    obj.prev=zpp_inner.vertices;\n                                    obj.next=zpp_inner.vertices.next;\n                                    zpp_inner.vertices.next.prev=obj;\n                                    zpp_inner.vertices.next=obj;\n                                }\n                                obj;\n                            };\n                        };\n                    }\n                }\n                else if(#if flash10 untyped __is__(vertices,ZPP_Const.vec2vector)#else false #end){\n                    #if flash10 var lv:flash.Vector<Vec2>=vertices;\n                    for(vite in lv){\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(vite==null)throw \"Error: flash.Vector<Vec2> contains null objects\";\n                        #end\n                        var v:Vec2=vite;\n                        {\n                            #if(!NAPE_RELEASE_BUILD)\n                            if(v!=null&&v.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                            #end\n                        };\n                        {\n                            zpp_inner.vertices={\n                                var obj=ZPP_GeomVert.get(v.x,v.y);\n                                if(zpp_inner.vertices==null)zpp_inner.vertices=obj.prev=obj.next=obj;\n                                else{\n                                    obj.prev=zpp_inner.vertices;\n                                    obj.next=zpp_inner.vertices.next;\n                                    zpp_inner.vertices.next.prev=obj;\n                                    zpp_inner.vertices.next=obj;\n                                }\n                                obj;\n                            };\n                        };\n                    }\n                    #end\n                }\n                else if(#if flash untyped __is__(vertices,Vec2List)#else Std.is(vertices,Vec2List)#end){\n                    var lv:Vec2List=vertices;\n                    for(v in lv){\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(v==null)throw \"Error: Vec2List contains null objects\";\n                        #end\n                        {\n                            #if(!NAPE_RELEASE_BUILD)\n                            if(v!=null&&v.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                            #end\n                        };\n                        {\n                            zpp_inner.vertices={\n                                var obj=ZPP_GeomVert.get(v.x,v.y);\n                                if(zpp_inner.vertices==null)zpp_inner.vertices=obj.prev=obj.next=obj;\n                                else{\n                                    obj.prev=zpp_inner.vertices;\n                                    obj.next=zpp_inner.vertices.next;\n                                    zpp_inner.vertices.next.prev=obj;\n                                    zpp_inner.vertices.next=obj;\n                                }\n                                obj;\n                            };\n                        };\n                    }\n                }\n                else if(#if flash untyped __is__(vertices,GeomPoly)#else Std.is(vertices,GeomPoly)#end){\n                    var lv:GeomPoly=vertices;\n                    {\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(lv!=null&&lv.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n                        #end\n                    };\n                    var verts:ZPP_GeomVert=lv.zpp_inner.vertices;\n                    if(verts!=null){\n                        var vite=verts;\n                        do{\n                            var v=Vec2.get(vite.x,vite.y);\n                            vite=vite.next;\n                            {\n                                zpp_inner.vertices={\n                                    var obj=ZPP_GeomVert.get(v.x,v.y);\n                                    if(zpp_inner.vertices==null)zpp_inner.vertices=obj.prev=obj.next=obj;\n                                    else{\n                                        obj.prev=zpp_inner.vertices;\n                                        obj.next=zpp_inner.vertices.next;\n                                        zpp_inner.vertices.next.prev=obj;\n                                        zpp_inner.vertices.next=obj;\n                                    }\n                                    obj;\n                                };\n                            };\n                            v.dispose();\n                        }\n                        while(vite!=verts);\n                    }\n                }\n                else{\n                    #if(!NAPE_RELEASE_BUILD)\n                    throw \"Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>\";\n                    #end\n                }\n            };\n            skipForward(1);\n            {\n                if(#if flash untyped __is__(vertices,Array)#else Std.is(vertices,Array)#end){\n                    var lv:Array<Vec2>=vertices;\n                    var i=0;\n                    while(i<lv.length){\n                        var cur=lv[i];\n                        if(({\n                            if(({\n                                cur.zpp_inner.weak;\n                            })){\n                                cur.dispose();\n                                true;\n                            }\n                            else{\n                                false;\n                            }\n                        })){\n                            lv.splice(i,1);\n                            continue;\n                        }\n                        i++;\n                    }\n                }\n                else if(#if flash10 untyped __is__(vertices,ZPP_Const.vec2vector)#else false #end){\n                    #if flash10 var lv:flash.Vector<Vec2>=vertices;\n                    if(!lv.fixed){\n                        var i:Int=0;\n                        while(i<cast lv.length){\n                            var cur=lv[i];\n                            if(({\n                                if(({\n                                    cur.zpp_inner.weak;\n                                })){\n                                    cur.dispose();\n                                    true;\n                                }\n                                else{\n                                    false;\n                                }\n                            })){\n                                lv.splice(i,1);\n                                continue;\n                            }\n                            i++;\n                        }\n                    }\n                    #end\n                }\n                else if(#if flash untyped __is__(vertices,Vec2List)#else Std.is(vertices,Vec2List)#end){\n                    var lv:Vec2List=vertices;\n                    if(lv.zpp_inner._validate!=null)lv.zpp_inner._validate();\n                    var ins=lv.zpp_inner.inner;\n                    var pre=null;\n                    var cur=ins.begin();\n                    while(cur!=null){\n                        var x=cur.elem();\n                        if(({\n                            x.outer.zpp_inner.weak;\n                        })){\n                            cur=ins.erase(pre);\n                            ({\n                                if(({\n                                    x.outer.zpp_inner.weak;\n                                })){\n                                    x.outer.dispose();\n                                    true;\n                                }\n                                else{\n                                    false;\n                                }\n                            });\n                        }\n                        else{\n                            pre=cur;\n                            cur=cur.next;\n                        }\n                    }\n                }\n            };\n        }\n    }\n    /**\n     * Allocate GeomPoly from object pool.\n     * <br/><br/>\n     * The vertices argument is typed Dynamic (* in AS3), and is permitted\n     * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>\n     * <br/><br/>\n     * The input will be used to initialise the vertices of the polygon with\n     * the head of the polygon pointing to the first vertex in input with vertices\n     * inserted in forward order.\n     *\n     * @param vertices Vertex data to initialise polygon, or null for empty polygon.\n     * @return New GeomPoly representing input vertex data, allocated from object pool.\n     * @throws # If input data is not of an expected Type.\n     */\n    public static function get(vertices:Dynamic=null){\n        var ret;\n        {\n            if(ZPP_PubPool.poolGeomPoly==null){\n                ret=new GeomPoly();\n                #if NAPE_POOL_STATS GeomPoly.POOL_TOT++;\n                GeomPoly.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_PubPool.poolGeomPoly;\n                ZPP_PubPool.poolGeomPoly=ret.zpp_pool;\n                ret.zpp_pool=null;\n                #if(!NAPE_RELEASE_BUILD)\n                ret.zpp_disp=false;\n                if(ret==ZPP_PubPool.nextGeomPoly)ZPP_PubPool.nextGeomPoly=null;\n                #end\n                #if NAPE_POOL_STATS GeomPoly.POOL_CNT--;\n                GeomPoly.POOL_ADD++;\n                #end\n            }\n        };\n        if(vertices!=null){\n            {\n                if(#if flash untyped __is__(vertices,Array)#else Std.is(vertices,Array)#end){\n                    var lv:Array<Dynamic>=vertices;\n                    for(vite in lv){\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(vite==null)throw \"Error: Array<Vec2> contains null objects\";\n                        #end\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(!#if flash untyped __is__(vite,Vec2)#else Std.is(vite,Vec2)#end)throw \"Error: Array<Vec2> contains non Vec2 objects\";\n                        #end\n                        var v:Vec2=vite;\n                        {\n                            #if(!NAPE_RELEASE_BUILD)\n                            if(v!=null&&v.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                            #end\n                        };\n                        {\n                            ret.zpp_inner.vertices={\n                                var obj=ZPP_GeomVert.get(v.x,v.y);\n                                if(ret.zpp_inner.vertices==null)ret.zpp_inner.vertices=obj.prev=obj.next=obj;\n                                else{\n                                    obj.prev=ret.zpp_inner.vertices;\n                                    obj.next=ret.zpp_inner.vertices.next;\n                                    ret.zpp_inner.vertices.next.prev=obj;\n                                    ret.zpp_inner.vertices.next=obj;\n                                }\n                                obj;\n                            };\n                        };\n                    }\n                }\n                else if(#if flash10 untyped __is__(vertices,ZPP_Const.vec2vector)#else false #end){\n                    #if flash10 var lv:flash.Vector<Vec2>=vertices;\n                    for(vite in lv){\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(vite==null)throw \"Error: flash.Vector<Vec2> contains null objects\";\n                        #end\n                        var v:Vec2=vite;\n                        {\n                            #if(!NAPE_RELEASE_BUILD)\n                            if(v!=null&&v.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                            #end\n                        };\n                        {\n                            ret.zpp_inner.vertices={\n                                var obj=ZPP_GeomVert.get(v.x,v.y);\n                                if(ret.zpp_inner.vertices==null)ret.zpp_inner.vertices=obj.prev=obj.next=obj;\n                                else{\n                                    obj.prev=ret.zpp_inner.vertices;\n                                    obj.next=ret.zpp_inner.vertices.next;\n                                    ret.zpp_inner.vertices.next.prev=obj;\n                                    ret.zpp_inner.vertices.next=obj;\n                                }\n                                obj;\n                            };\n                        };\n                    }\n                    #end\n                }\n                else if(#if flash untyped __is__(vertices,Vec2List)#else Std.is(vertices,Vec2List)#end){\n                    var lv:Vec2List=vertices;\n                    for(v in lv){\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(v==null)throw \"Error: Vec2List contains null objects\";\n                        #end\n                        {\n                            #if(!NAPE_RELEASE_BUILD)\n                            if(v!=null&&v.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                            #end\n                        };\n                        {\n                            ret.zpp_inner.vertices={\n                                var obj=ZPP_GeomVert.get(v.x,v.y);\n                                if(ret.zpp_inner.vertices==null)ret.zpp_inner.vertices=obj.prev=obj.next=obj;\n                                else{\n                                    obj.prev=ret.zpp_inner.vertices;\n                                    obj.next=ret.zpp_inner.vertices.next;\n                                    ret.zpp_inner.vertices.next.prev=obj;\n                                    ret.zpp_inner.vertices.next=obj;\n                                }\n                                obj;\n                            };\n                        };\n                    }\n                }\n                else if(#if flash untyped __is__(vertices,GeomPoly)#else Std.is(vertices,GeomPoly)#end){\n                    var lv:GeomPoly=vertices;\n                    {\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(lv!=null&&lv.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n                        #end\n                    };\n                    var verts:ZPP_GeomVert=lv.zpp_inner.vertices;\n                    if(verts!=null){\n                        var vite=verts;\n                        do{\n                            var v=Vec2.get(vite.x,vite.y);\n                            vite=vite.next;\n                            {\n                                ret.zpp_inner.vertices={\n                                    var obj=ZPP_GeomVert.get(v.x,v.y);\n                                    if(ret.zpp_inner.vertices==null)ret.zpp_inner.vertices=obj.prev=obj.next=obj;\n                                    else{\n                                        obj.prev=ret.zpp_inner.vertices;\n                                        obj.next=ret.zpp_inner.vertices.next;\n                                        ret.zpp_inner.vertices.next.prev=obj;\n                                        ret.zpp_inner.vertices.next=obj;\n                                    }\n                                    obj;\n                                };\n                            };\n                            v.dispose();\n                        }\n                        while(vite!=verts);\n                    }\n                }\n                else{\n                    #if(!NAPE_RELEASE_BUILD)\n                    throw \"Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>\";\n                    #end\n                }\n            };\n            ret.skipForward(1);\n            {\n                if(#if flash untyped __is__(vertices,Array)#else Std.is(vertices,Array)#end){\n                    var lv:Array<Vec2>=vertices;\n                    var i=0;\n                    while(i<lv.length){\n                        var cur=lv[i];\n                        if(({\n                            if(({\n                                cur.zpp_inner.weak;\n                            })){\n                                cur.dispose();\n                                true;\n                            }\n                            else{\n                                false;\n                            }\n                        })){\n                            lv.splice(i,1);\n                            continue;\n                        }\n                        i++;\n                    }\n                }\n                else if(#if flash10 untyped __is__(vertices,ZPP_Const.vec2vector)#else false #end){\n                    #if flash10 var lv:flash.Vector<Vec2>=vertices;\n                    if(!lv.fixed){\n                        var i:Int=0;\n                        while(i<cast lv.length){\n                            var cur=lv[i];\n                            if(({\n                                if(({\n                                    cur.zpp_inner.weak;\n                                })){\n                                    cur.dispose();\n                                    true;\n                                }\n                                else{\n                                    false;\n                                }\n                            })){\n                                lv.splice(i,1);\n                                continue;\n                            }\n                            i++;\n                        }\n                    }\n                    #end\n                }\n                else if(#if flash untyped __is__(vertices,Vec2List)#else Std.is(vertices,Vec2List)#end){\n                    var lv:Vec2List=vertices;\n                    if(lv.zpp_inner._validate!=null)lv.zpp_inner._validate();\n                    var ins=lv.zpp_inner.inner;\n                    var pre=null;\n                    var cur=ins.begin();\n                    while(cur!=null){\n                        var x=cur.elem();\n                        if(({\n                            x.outer.zpp_inner.weak;\n                        })){\n                            cur=ins.erase(pre);\n                            ({\n                                if(({\n                                    x.outer.zpp_inner.weak;\n                                })){\n                                    x.outer.dispose();\n                                    true;\n                                }\n                                else{\n                                    false;\n                                }\n                            });\n                        }\n                        else{\n                            pre=cur;\n                            cur=cur.next;\n                        }\n                    }\n                }\n            };\n        }\n        return ret;\n    }\n    /**\n     * Release this GeomPoly to global object pool.\n     * <br/><br/>\n     * Once disposed this GeomPoly will be accessible to Nape internals for re-allocation\n     * and should not be touched (Good practice would be to set any references to this\n     * GeomPoly to null to help ensure this).\n     * <br/><br/>\n     * In debug mode, should you attempt to access this GeomPoly after disposal\n     * and the GeomPoly is still in the object pool, you will be given an Error.\n     * The object pool operates on a First-In-Last-Out principal in debug mode to help\n     * catch these sort of errors.\n     * @throws # If this GeomPoly has already been disposed.\n     */\n    public function dispose():Void{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        clear();\n        {\n            var o=this;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"PublicFree(in T: \"+\"GeomPoly\"+\", in obj: \"+\"this\"+\")\");\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            o.zpp_pool=null;\n            if(ZPP_PubPool.nextGeomPoly!=null)ZPP_PubPool.nextGeomPoly.zpp_pool=o;\n            else ZPP_PubPool.poolGeomPoly=o;\n            ZPP_PubPool.nextGeomPoly=o;\n            #end\n            #if NAPE_RELEASE_BUILD \n            o.zpp_pool=ZPP_PubPool.poolGeomPoly;\n            ZPP_PubPool.poolGeomPoly=o;\n            #end\n            #if NAPE_POOL_STATS GeomPoly.POOL_CNT++;\n            GeomPoly.POOL_SUB++;\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            o.zpp_disp=true;\n            #end\n        };\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString():String{\n        var ret=\"GeomPoly[\";\n        {\n            {\n                var F=zpp_inner.vertices;\n                var L=zpp_inner.vertices;\n                if(F!=null){\n                    var nite=F;\n                    do{\n                        var v=nite;\n                        {\n                            {\n                                if(v!=zpp_inner.vertices)ret+=\",\";\n                                ret+=\"{\"+v.x+\",\"+v.y+\"}\";\n                            };\n                        }\n                        nite=nite.next;\n                    }\n                    while(nite!=L);\n                }\n            };\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Compute area of weakly-simple polygon.\n     * <br/><br/>\n     * For complex polygons, this function will return an underestimate\n     * to the true area.\n     *\n     * @return The area of the polygon.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function area():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        }))0.0 else({\n            var ret=({\n                {\n                    #if NAPE_ASSERT if(({\n                        var ret=0;\n                        {\n                            var F=zpp_inner.vertices;\n                            var L=zpp_inner.vertices;\n                            if(F!=null){\n                                var nite=F;\n                                do{\n                                    var i=nite;\n                                    {\n                                        ret++;\n                                    }\n                                    nite=nite.next;\n                                }\n                                while(nite!=L);\n                            }\n                        };\n                        ret;\n                    })<3){\n                        throw \"Error: Method requires that polygon has atleast 3 vertices\";\n                    }\n                    #end\n                };\n                var area=0.0;\n                {\n                    var F=zpp_inner.vertices;\n                    var L=zpp_inner.vertices;\n                    if(F!=null){\n                        var nite=F;\n                        do{\n                            var v=nite;\n                            {\n                                {\n                                    area+=v.x*(v.next.y-v.prev.y);\n                                };\n                            }\n                            nite=nite.next;\n                        }\n                        while(nite!=L);\n                    }\n                };\n                area*0.5;\n            });\n            if(ret<0)(-ret)else ret;\n        });\n    }\n    /**\n     * Compute the winding order for this polygon.\n     * <br/><br/>\n     * The winding order can be conceptualised by thinking of an analog\n     * clock face, if your polygon is the numbers on the clock then a\n     * clockwise winding would have your polygon's vertices in numerical\n     * order.\n     * <br/><br/>\n     * In the case of a non-simple polygon with self intersections then the\n     * winding order is decided by how 'much' of the polygon is locally\n     * clockwise wound, and how much is locally anti-clockwise wound.\n     * <br/>\n     * (Think of a figure 8 style polygon where one loop is larger than the\n     * other. This larger loop will dictate the winding of the polygon.)\n     * <br/><br/>\n     * If no winding can be computed, then <code>Winding.UNDEFINED</code>\n     * will be returned.\n     *\n     * @return The winding of the polygon.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function winding():Winding{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        })){\n            return Winding.UNDEFINED;\n        }\n        else{\n            var area=({\n                {\n                    #if NAPE_ASSERT if(({\n                        var ret=0;\n                        {\n                            var F=zpp_inner.vertices;\n                            var L=zpp_inner.vertices;\n                            if(F!=null){\n                                var nite=F;\n                                do{\n                                    var i=nite;\n                                    {\n                                        ret++;\n                                    }\n                                    nite=nite.next;\n                                }\n                                while(nite!=L);\n                            }\n                        };\n                        ret;\n                    })<3){\n                        throw \"Error: Method requires that polygon has atleast 3 vertices\";\n                    }\n                    #end\n                };\n                var area=0.0;\n                {\n                    var F=zpp_inner.vertices;\n                    var L=zpp_inner.vertices;\n                    if(F!=null){\n                        var nite=F;\n                        do{\n                            var v=nite;\n                            {\n                                {\n                                    area+=v.x*(v.next.y-v.prev.y);\n                                };\n                            }\n                            nite=nite.next;\n                        }\n                        while(nite!=L);\n                    }\n                };\n                area*0.5;\n            });\n            return if(area>0)Winding.CLOCKWISE else if(area==0)Winding.UNDEFINED else Winding.ANTICLOCKWISE;\n        }\n    }\n    /**\n     * Determine if point is contained in polygon.\n     * <br/><br/>\n     * Polygon containment is performed with a ray cast through polygon\n     * from the vertex and counting the number of intersections. In this\n     * way containment will be defined for self-intersecting polygons based\n     * on how such a polygon would be rendered with areas of self-intersection\n     * treat as being 'outside' the polygon.\n     * <br/><br/>\n     * This algorithm operates in O(n) time.\n     *\n     * @param point The point to test for containment.\n     * @return True if point is contained in the polygon.\n     * @throws # If point is null or has been disposed.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function contains(point:Vec2):Bool{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null){\n            throw \"Error: GeomPoly::contains point cannot be null\";\n        }\n        #end\n        var ret=({\n            var x=point.x;\n            var y=point.y;\n            var ret=false;\n            {\n                var F=zpp_inner.vertices;\n                var L=zpp_inner.vertices;\n                if(F!=null){\n                    var nite=F;\n                    do{\n                        var p=nite;\n                        {\n                            {\n                                var q=p.prev;\n                                if((p.y<y&&q.y>=y||q.y<y&&p.y>=y)&&(p.x<=x||q.x<=x)){\n                                    if((p.x+(y-p.y)/(q.y-p.y)*(q.x-p.x))<x){\n                                        ret=!ret;\n                                    }\n                                }\n                            };\n                        }\n                        nite=nite.next;\n                    }\n                    while(nite!=L);\n                }\n            };\n            ret;\n        });\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Determine if polygon is clockwise wound.\n     * <br/><br/>\n     * This is equivalent to <code>poly.winding() == Winding.CLOCKWISE</code>.\n     *\n     * @return True if polygon is clockwise wound.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function isClockwise():Bool{\n        return winding()==Winding.CLOCKWISE;\n    }\n    /**\n     * Determine if weakly-simple polygon is convex.\n     * <br/><br/>\n     * This algorithm assumes that the polygon is weakly-simple. Otherwise it may\n     * fail (It is very easy to construct a self intersecting polygon which\n     * will return True for isConvex()).\n     * <br/><br/>\n     * You may wish to instead use <code>isSimple() && isConvex()</code> if\n     * you cannot be sure of the polygon being simple, noting that this will\n     * of course return false in the case of a weakly-simple polygon.\n     * <pre>\n     *  _____\n     * |     |\n     * |     |  <-- convex\n     * |____/\n     *  __\n     * |  &#92;___\n     * |     /  <-- concave\n     * |____/\n     * </pre>\n     * This algorithm operates in O(n) time.\n     *\n     * @return True if polygon is found to be convex.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function isConvex():Bool{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        }))true else({\n            {\n                #if NAPE_ASSERT if(({\n                    var ret=0;\n                    {\n                        var F=zpp_inner.vertices;\n                        var L=zpp_inner.vertices;\n                        if(F!=null){\n                            var nite=F;\n                            do{\n                                var i=nite;\n                                {\n                                    ret++;\n                                }\n                                nite=nite.next;\n                            }\n                            while(nite!=L);\n                        }\n                    };\n                    ret;\n                })<3){\n                    throw \"Error: Method requires that polygon has atleast 3 vertices\";\n                }\n                #end\n            };\n            var neg=false;\n            var pos=false;\n            var ret=true;\n            {\n                var F=zpp_inner.vertices;\n                var L=zpp_inner.vertices;\n                if(F!=null){\n                    var nite=F;\n                    do{\n                        var v=nite;\n                        {\n                            {\n                                var u=v.prev;\n                                var w=v.next;\n                                var ax:Float=0.0;\n                                var ay:Float=0.0;\n                                {\n                                    ax=w.x-v.x;\n                                    ay=w.y-v.y;\n                                };\n                                var bx:Float=0.0;\n                                var by:Float=0.0;\n                                {\n                                    bx=v.x-u.x;\n                                    by=v.y-u.y;\n                                };\n                                var dot=(by*ax-bx*ay);\n                                if(dot>0.0){\n                                    pos=true;\n                                }\n                                else if(dot<0.0){\n                                    neg=true;\n                                }\n                                if(pos&&neg){\n                                    ret=false;\n                                    break;\n                                }\n                            };\n                        }\n                        nite=nite.next;\n                    }\n                    while(nite!=L);\n                }\n            };\n            ret;\n        });\n    }\n    /**\n     * Determine if polygon is strictly simple.\n     * <br/><br/>\n     * By strict simplicity, we refer to not permitting 'glancing'\n     * self intersections (where boundary of polygon 'touches' but does not\n     * pass through another area of the polygon's boundary). This property\n     * is instead referred to as being 'weakly simple' for which there is no\n     * easy test!\n     * <pre>\n     *  _______\n     * |   __  |  <-- strictly simple polygon.\n     * |   &#92; &#92;_|\n     *  &#92;__/\n     *  _______\n     * |   |   |\n     * |  /_&#92;  | <-- weakly simple polygon.\n     *  &#92;_____/\n     *  ____\n     * | __/\n     *  X_  __   <-- complex polygon.\n     * |  &#92;/  &#92;\n     * &#92;__/&#92;__|\n     * </pre>\n     * This algorithm operates in O(n.log(n)) time.\n     *\n     * @return True if polygon is strictly simple.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function isSimple():Bool{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        }))true else ZPP_Simple.isSimple(zpp_inner.vertices);\n    }\n    /**\n     * Determine if polygon is y-monotone.\n     * <br/><br/>\n     * To be classed as y-monotone, the polygon must be such that any horizontal\n     * line intersects the polygon in at most 2 intersections.\n     * <pre>\n     *  ___\n     * |   |\n     * |   |  <-- y-monotone\n     * |___|\n     *\n     * |&#92;\n     * | &#92;/|  <-- not y-monotone, offending vertex at bottom of the V.\n     * |___|\n     * </pre>\n     * This algorithm operates in O(n) time.\n     *\n     * @return True if polygon is y-monotone.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function isMonotone():Bool{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        }))true else ZPP_Monotone.isMonotone(zpp_inner.vertices);\n    }\n    /**\n     * Determine if weakly-simple polygon is degenerate.\n     * <br/><br/>\n     * Degeneracy is determined by having a zero area, if polygon is complex,\n     * then this function may report degeneracy erroneously.\n     *\n     * @return True if polygon is degenerate.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function isDegenerate():Bool{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        }))true else area()<Config.epsilon;\n    }\n    /**\n     * Simplify polygon.\n     * <br/><br/>\n     * Simplification is performed with an implementation of the Ramer-Douglas-Peucker\n     * algorithm. The output polygon is formed via subset of the vertices in\n     * the input polygon such that any discarded vertex is at most 'epsilon' pixels\n     * away from the local output polygon.\n     * <br/><br/>\n     * This algorithm works on both simple and complex polygons, but please note\n     * that this algorithm makes no guarantees on a simple polygon remaining simple\n     * after simplification. This should not generally be a problem unless the epsilon\n     * value is large with respect to the size of the features on the polygon.\n     * <br/><br/>\n     * Many of the geometric algorithms will mark vertices as important, such that\n     * they will be guaranteed to exist after simplification (Such as preventing\n     * gaps from opening up in marching squares when simplifying output polygons).\n     * <br/><br/>\n     * The average runtime of this algorithm is O(n.log(n)). This algorithm is\n     * not stable in the sense that adding a new vertex to the polygon may drastically\n     * change the result of simplifying the polygon.\n     *\n     * @param epsilon The distance from polygon at which vertices are ignored.\n     * @return A new GeomPoly representing the result of the simplification.\n     * @throws # If epsilon is <= 0.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function simplify(epsilon:Float):GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(epsilon<=0.0){\n            throw \"Error: Epsilon should be > 0 for simplifying a GeomPoly\";\n        }\n        #end\n        if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        })){\n            return copy();\n        }\n        else{\n            var x=ZPP_Simplify.simplify(zpp_inner.vertices,epsilon);\n            var ret=GeomPoly.get();\n            ret.zpp_inner.vertices=x;\n            return ret;\n        }\n    }\n    /**\n     * Produce a decomposition of complex polygon into simple components.\n     * <br/><br/>\n     * WARNING: This method is 'not' 100% robust. It may fail!\n     * <br/><br/>\n     * Produce a decomposition of a self intersecting, complex polygon into\n     * a set of weakly-simple components.\n     * <br/><br/>\n     * This algorithm operates in O(n.log(n)) time and is based on the\n     * Bentley-Ottmann algorithm.\n     *\n     * @param output If supplied, polygons will be appended to this list via 'add'\n     *        instead of a new list being constructed.\n     * @return A Nape list of GeomPoly's representing the decomposition.\n     * @throws # If polygon is degenerate.\n     * @throws # Any other error may be thrown if algorithm has failed, even\n     *           in release builds!\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function simpleDecomposition(output:GeomPolyList=null):GeomPolyList{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        })){\n            throw \"Error: Cannot decompose a degenerate polygon\";\n        }\n        #end\n        var MPs=ZPP_Simple.decompose(zpp_inner.vertices,ZPP_PartitionedPoly.getShared());\n        var ret=(output==null?new GeomPolyList():output);\n        while(!MPs.empty()){\n            var MP=MPs.pop_unsafe();\n            var x=GeomPoly.get();\n            x.zpp_inner.vertices=MP;\n            ret.add(x);\n        }\n        return ret;\n    }\n    /**\n     * Produce a decomposition of weakly-simple polygon into monotone components.\n     * <br/><br/>\n     * This algorithm 'should' be 100% robust and has been well tested on for\n     * example, the output of the Marching Squares utility which produces many\n     * degenerate cases of weakly-simple polygons that have not yet broken this\n     * algorithm!.\n     * <br/><br/>\n     * This algorithm operates in O(n.log(n)) time and may strip vertices from\n     * the polygon in degenerate cases where vertex is not needed to define the\n     * polygon.\n     * <br/><br/>\n     * This algorithm is an improved version of the one presented in: Mark de\n     * Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf.\n     * Computational Geometry: Algorithms and Applications. Springer-Verlag,\n     * Berlin, 1997.\n    \n     * @param output If supplied, polygons will be appended to this list via 'add'\n     *        instead of a new list being constructed.\n     * @return A Nape list of GeomPoly's defining the decomposition.\n     * @throws # If polygon is degenerate.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function monotoneDecomposition(output:GeomPolyList=null):GeomPolyList{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        })){\n            throw \"Error: Cannot decompose a degenerate polygon\";\n        }\n        #end\n        var poly=ZPP_Monotone.decompose(zpp_inner.vertices,ZPP_Monotone.getShared());\n        var MPs=poly.extract(ZPP_PartitionedPoly.getShared());\n        var ret=(output==null?new GeomPolyList():output);\n        while(!MPs.empty()){\n            var MP=MPs.pop_unsafe();\n            var x=GeomPoly.get();\n            x.zpp_inner.vertices=MP;\n            ret.add(x);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    x.isMonotone();\n                };\n                if(!res)throw \"assert(\"+\"x.isMonotone()\"+\") :: \"+(\"monotone decomposition gave non-monotone output?\");\n                #end\n            };\n        }\n        return ret;\n    }\n    /**\n     * Produce a decomposition of weakly-simple polygon into convex components.\n     * <br/><br/>\n     * This algorithm 'should' be 100% robust and has been well test on for\n     * example, the output of the Marching Squars utility which produces many\n     * degenerate cases of weakly-simple polygons that have not yet broken this\n     * algorithm!.\n     * <br/><br/>\n     * This algorithm operates in O(n.log(n)) time and will produce no more than\n     * 4 times the number of convex poylgons in a minimal decomposition in the\n     * worst case scenario.\n     * <br/><br/>\n     * Vertices may be stripped from the polygon that are found to not be\n     * necessary as part of making this algorithm robust.\n     *\n     * @param delaunay This algorithm first performs a triangulation, if this field\n     *                 is true, then this triangulation will be made delaunay and may\n     *                 produce better convex polygons resultanly (default false).\n     * @param output If supplied, polygons will be appended to this list via 'add'\n     *        instead of a new list being constructed.\n     * @return A Nape list of GeomPoly's defining the decomposition.\n     * @throws # If polygon is degenerate.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function convexDecomposition(delaunay:Bool=false,output:GeomPolyList=null):GeomPolyList{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        })){\n            throw \"Error: Cannot decompose a degenerate polygon\";\n        }\n        #end\n        var poly=ZPP_Monotone.decompose(zpp_inner.vertices,ZPP_Monotone.getShared());\n        var MPs=poly.extract_partitions(ZPP_PartitionedPoly.getSharedPP());\n        var ret=(output==null?new GeomPolyList():output);\n        while(!MPs.empty()){\n            var MP=MPs.pop_unsafe();\n            ZPP_Triangular.triangulate(MP);\n            if(delaunay){\n                ZPP_Triangular.optimise(MP);\n            }\n            ZPP_Convex.optimise(MP);\n            var MQs=MP.extract(ZPP_PartitionedPoly.getShared());\n            {\n                var o=MP;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_PartitionedPoly\"+\", in obj: \"+\"MP\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_PartitionedPoly.zpp_pool;\n                ZPP_PartitionedPoly.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_PartitionedPoly.POOL_CNT++;\n                ZPP_PartitionedPoly.POOL_SUB++;\n                #end\n            };\n            while(!MQs.empty()){\n                var MQ=MQs.pop_unsafe();\n                var x=GeomPoly.get();\n                x.zpp_inner.vertices=MQ;\n                ret.add(x);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        x.isConvex();\n                    };\n                    if(!res)throw \"assert(\"+\"x.isConvex()\"+\") :: \"+(\"convex decomposition gave non-convex output?\");\n                    #end\n                };\n            }\n        }\n        return ret;\n    }\n    /**\n     * Produce a decomposition of weakly-simple polygon into triangles.\n     * <br/><br/>\n     * This algorithm 'should' be 100% robust and has been well test on for\n     * example, the output of the Marching Squars utility which produces many\n     * degenerate cases of weakly-simple polygons that have not yet broken this\n     * algorithm!.\n     * <br/><br/>\n     * This algorithm operates in O(n.log(n)) time.\n     * <br/><br/>\n     * Vertices may be stripped from the polygon that are found to not be\n     * necessary as part of making this algorithm robust.\n     *\n     * @param delaunay If true, then an O(n^2) pass will be made to mutate the original\n     *                 triangulation to push it into a delanuay triangulation. (default false)\n     * @param output If supplied, polygons will be appended to this list via 'add'\n     *        instead of a new list being constructed.\n     * @return A Nape list of GeomPoly's defining the decomposition.\n     * @throws # If polygon is degenerate.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function triangularDecomposition(delaunay:Bool=false,output:GeomPolyList=null):GeomPolyList{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(({\n            zpp_inner.vertices==null||zpp_inner.vertices.next==null||zpp_inner.vertices.prev==zpp_inner.vertices.next;\n        })){\n            throw \"Error: Cannot decompose a degenerate polygon\";\n        }\n        #end\n        var poly=ZPP_Monotone.decompose(zpp_inner.vertices,ZPP_Monotone.getShared());\n        var MPs=poly.extract_partitions(ZPP_PartitionedPoly.getSharedPP());\n        var ret=(output==null?new GeomPolyList():output);\n        while(!MPs.empty()){\n            var MP=MPs.pop_unsafe();\n            ZPP_Triangular.triangulate(MP);\n            if(delaunay){\n                ZPP_Triangular.optimise(MP);\n            }\n            var MQs=MP.extract(ZPP_PartitionedPoly.getShared());\n            {\n                var o=MP;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_PartitionedPoly\"+\", in obj: \"+\"MP\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_PartitionedPoly.zpp_pool;\n                ZPP_PartitionedPoly.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_PartitionedPoly.POOL_CNT++;\n                ZPP_PartitionedPoly.POOL_SUB++;\n                #end\n            };\n            while(!MQs.empty()){\n                var MQ=MQs.pop_unsafe();\n                var x=GeomPoly.get();\n                x.zpp_inner.vertices=MQ;\n                ret.add(x);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        x.size()==3;\n                    };\n                    if(!res)throw \"assert(\"+\"x.size()==3\"+\") :: \"+(\"triangular decomosition gave non-triangle output?\");\n                    #end\n                };\n            }\n        }\n        return ret;\n    }\n    /**\n     * Inflate/Deflate polygon.\n     * <br/><br/>\n     * This algorithm does not attempt to deal with any self-intersections which may\n     * result from the process. Gaps are joined with a miter joint.\n     * <br/><br/>\n     * This algorithm will work for self-intersecting polygons, though the results\n     * may not be what you expect; some parts will be inflated, and some deflated\n     * depending on the local winding. You should probably avoid using this on\n     * self-intersecting polygons.\n     *\n     * @param inflation The number of pixels to inflate polygon by. To deflate\n     *                  use a negative value.\n     * @return The inflated polygon.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function inflate(inflation:Float):GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        var ret=GeomPoly.get();\n        if(isClockwise())inflation=-inflation;\n        {\n            var F=zpp_inner.vertices;\n            var L=zpp_inner.vertices;\n            if(F!=null){\n                var nite=F;\n                do{\n                    var p=nite;\n                    {\n                        {\n                            var prev=p.prev;\n                            var next=p.next;\n                            var ax:Float=0.0;\n                            var ay:Float=0.0;\n                            var bx:Float=0.0;\n                            var by:Float=0.0;\n                            {\n                                ax=p.x-prev.x;\n                                ay=p.y-prev.y;\n                            };\n                            {\n                                bx=next.x-p.x;\n                                by=next.y-p.y;\n                            };\n                            var apx:Float=0.0;\n                            var apy:Float=0.0;\n                            var bpx:Float=0.0;\n                            var bpy:Float=0.0;\n                            {\n                                apx=ax;\n                                apy=ay;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((apx!=apx));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(apx)\"+\") :: \"+(\"vec_set(in n: \"+\"ap\"+\",in x: \"+\"ax\"+\",in y: \"+\"ay\"+\")\");\n                                    #end\n                                };\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((apy!=apy));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(apy)\"+\") :: \"+(\"vec_set(in n: \"+\"ap\"+\",in x: \"+\"ax\"+\",in y: \"+\"ay\"+\")\");\n                                    #end\n                                };\n                            };\n                            {\n                                {\n                                    var d=(apx*apx+apy*apy);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            d!=0.0;\n                                        };\n                                        if(!res)throw \"assert(\"+\"d!=0.0\"+\") :: \"+(\"vec_normalise(in n: \"+\"ap\"+\")\");\n                                        #end\n                                    };\n                                    var imag=ZPP_Math.invsqrt(d);\n                                    {\n                                        var t=(imag);\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !((t!=t));\n                                            };\n                                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"ap\"+\",in s: \"+\"imag\"+\")\");\n                                            #end\n                                        };\n                                        apx*=t;\n                                        apy*=t;\n                                    };\n                                };\n                                {\n                                    var t=apx;\n                                    apx=-apy;\n                                    apy=t;\n                                };\n                            };\n                            {\n                                var t=(inflation);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"ap\"+\",in s: \"+\"inflation\"+\")\");\n                                    #end\n                                };\n                                apx*=t;\n                                apy*=t;\n                            };\n                            {\n                                bpx=bx;\n                                bpy=by;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((bpx!=bpx));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(bpx)\"+\") :: \"+(\"vec_set(in n: \"+\"bp\"+\",in x: \"+\"bx\"+\",in y: \"+\"by\"+\")\");\n                                    #end\n                                };\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((bpy!=bpy));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(bpy)\"+\") :: \"+(\"vec_set(in n: \"+\"bp\"+\",in x: \"+\"bx\"+\",in y: \"+\"by\"+\")\");\n                                    #end\n                                };\n                            };\n                            {\n                                {\n                                    var d=(bpx*bpx+bpy*bpy);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            d!=0.0;\n                                        };\n                                        if(!res)throw \"assert(\"+\"d!=0.0\"+\") :: \"+(\"vec_normalise(in n: \"+\"bp\"+\")\");\n                                        #end\n                                    };\n                                    var imag=ZPP_Math.invsqrt(d);\n                                    {\n                                        var t=(imag);\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !((t!=t));\n                                            };\n                                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"bp\"+\",in s: \"+\"imag\"+\")\");\n                                            #end\n                                        };\n                                        bpx*=t;\n                                        bpy*=t;\n                                    };\n                                };\n                                {\n                                    var t=bpx;\n                                    bpx=-bpy;\n                                    bpy=t;\n                                };\n                            };\n                            {\n                                var t=(inflation);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"bp\"+\",in s: \"+\"inflation\"+\")\");\n                                    #end\n                                };\n                                bpx*=t;\n                                bpy*=t;\n                            };\n                            var bapx:Float=0.0;\n                            var bapy:Float=0.0;\n                            {\n                                bapx=bpx-apx;\n                                bapy=bpy-apy;\n                            };\n                            var num=(by*bapx-bx*bapy);\n                            var t=if(num==0)0 else(num/(by*ax-bx*ay));\n                            var px:Float=0.0;\n                            var py:Float=0.0;\n                            {\n                                px=p.x+apx;\n                                py=p.y+apy;\n                            };\n                            {\n                                var t=(t);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"p\"+\",in b: \"+\"a\"+\",in s: \"+\"t\"+\")\");\n                                    #end\n                                };\n                                px+=ax*t;\n                                py+=ay*t;\n                            };\n                            ret.push(Vec2.get(px,py));\n                        };\n                    }\n                    nite=nite.next;\n                }\n                while(nite!=L);\n            }\n        };\n        return ret.skipForward(1);\n    }\n    /**\n     * Cut simple polygon with line.\n     * <br/><br/>\n     * The result of this operation will be a list of new GeomPoly representing\n     * the connected regions of the polygon after an imaginary cut is made.\n     * <pre>\n     * (Result of cut assuming\n     *  boundedStart = true)       _\n     *   /&#92;    _             /&#92;   / &#92;\n     *  /  &#92;  / &#92;           /  &#92; '---'\n     * / o--&#92;/---&#92;-->  =>  /    &#92;,---,\n     * &#92;_________/         &#92;_________/\n     * </pre>\n     * This algorithm runs in average case O(n.log(n)) time and worst case O(n^2).\n     * For convex polygons, this algorithm runs in guaranteed O(n) time.\n     *\n     * @param start The start point for line segment\n     * @param end The end point for line segment.\n     * @param boundedStart If true, then the cut will not extend\n     *                     beyond the start of the line segment.\n     *                     (default false)\n     * @param boundedEnd   If true, then the cut will not extend\n     *                     beyond the end of the line segment.\n     *                     (default false)\n     * @param output A GeomPolyList to append results to if supplied,\n     *               otherwise a new list is created (default null)\n     * @return A list of GeomPoly representing the result of the cut.\n     * @throws # If polygon is not simple.\n     * @throws # If start or end Vec2 are null or disposed of.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function cut(start:Vec2,end:Vec2,boundedStart:Bool=false,boundedEnd:Bool=false,output:GeomPolyList=null):GeomPolyList{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(!isSimple()){\n            throw \"Error: Cut requires a truly simple polygon\";\n        }\n        if(start==null||end==null){\n            throw \"Error: Cannot cut with null start/end's\";\n        }\n        #end\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(start!=null&&start.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(end!=null&&end.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        var ret=ZPP_Cutter.run(zpp_inner.vertices,start,end,boundedStart,boundedEnd,output);\n        ({\n            if(({\n                start.zpp_inner.weak;\n            })){\n                start.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        ({\n            if(({\n                end.zpp_inner.weak;\n            })){\n                end.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Transform polygon by given matrix.\n     * <br/><br/>\n     * Any transformation (not just equiorthogonal ones) are permitted, though\n     * a transformation that causes polygon to be come degenerate is a bit\n     * pointless.\n     *\n     * @param matrix The matrix to transform polygon by.\n     * @return A reference to this polygon.\n     * @throws # If matrix is null.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function transform(matrix:Mat23):GeomPoly{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(matrix==null){\n            throw \"Error: Cannot transform by null matrix\";\n        }\n        #end\n        {\n            var F=zpp_inner.vertices;\n            var L=zpp_inner.vertices;\n            if(F!=null){\n                var nite=F;\n                do{\n                    var v=nite;\n                    {\n                        {\n                            {\n                                var t=matrix.a*v.x+matrix.b*v.y+matrix.tx;\n                                v.y=matrix.c*v.x+matrix.d*v.y+matrix.ty;\n                                v.x=t;\n                            };\n                        };\n                    }\n                    nite=nite.next;\n                }\n                while(nite!=L);\n            }\n        };\n        return this;\n    }\n    /**\n     * Determine bounds of polygon.\n     *\n     * @return A new AABB representing bounds of polygon.\n     * @throws # If polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function bounds():AABB{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty()){\n            throw \"Error: empty GeomPoly has no defineable bounds\";\n        }\n        #end\n        var minx:Float=ZPP_Const.FMAX;\n        var miny:Float=ZPP_Const.FMAX;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((minx!=minx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(minx)\"+\") :: \"+(\"vec_new(in n: \"+\"min\"+\",in x: \"+\"ZPP_Const.FMAX\"+\",in y: \"+\"ZPP_Const.FMAX\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((miny!=miny));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(miny)\"+\") :: \"+(\"vec_new(in n: \"+\"min\"+\",in x: \"+\"ZPP_Const.FMAX\"+\",in y: \"+\"ZPP_Const.FMAX\"+\")\");\n            #end\n        };\n        var maxx:Float=-ZPP_Const.FMAX;\n        var maxy:Float=-ZPP_Const.FMAX;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((maxx!=maxx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(maxx)\"+\") :: \"+(\"vec_new(in n: \"+\"max\"+\",in x: \"+\"-ZPP_Const.FMAX\"+\",in y: \"+\"-ZPP_Const.FMAX\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((maxy!=maxy));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(maxy)\"+\") :: \"+(\"vec_new(in n: \"+\"max\"+\",in x: \"+\"-ZPP_Const.FMAX\"+\",in y: \"+\"-ZPP_Const.FMAX\"+\")\");\n            #end\n        };\n        {\n            var F=zpp_inner.vertices;\n            var L=zpp_inner.vertices;\n            if(F!=null){\n                var nite=F;\n                do{\n                    var v=nite;\n                    {\n                        {\n                            if(v.x<minx)minx=v.x;\n                            if(v.y<miny)miny=v.y;\n                            if(v.x>maxx)maxx=v.x;\n                            if(v.y>maxy)maxy=v.y;\n                        };\n                    }\n                    nite=nite.next;\n                }\n                while(nite!=L);\n            }\n        };\n        return new AABB(minx,miny,maxx-minx,maxy-miny);\n    }\n    /**\n     * Find top most vertex of polygon.\n     * <br/><br/>\n     * If there is more than one such vertex then the result is indeterminate.\n     * <br/><br/>\n     * The Vec2 returned is intrinsically tied to the inner vertex like that\n     * returned by current(). This method will not alter the current vertex.\n     * This Vec2 is not able to be disposed of.\n     *\n     * @return A Vec2 representing the top most vertex.\n     * @throws # If polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function top():Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty()){\n            throw \"Error: empty GeomPoly has no defineable topmost vertex\";\n        }\n        #end\n        var min=zpp_inner.vertices;\n        {\n            var F=zpp_inner.vertices.next;\n            var L=zpp_inner.vertices;\n            if(F!=null){\n                var nite=F;\n                do{\n                    var v=nite;\n                    {\n                        if(v.y<min.y)min=v;\n                    }\n                    nite=nite.next;\n                }\n                while(nite!=L);\n            }\n        };\n        return min.wrapper();\n    }\n    /**\n     * Find bottom most vertex of polygon.\n     * <br/><br/>\n     * If there is more than one such vertex then the result is indeterminate.\n     * <br/><br/>\n     * The Vec2 returned is intrinsically tied to the inner vertex like that\n     * returned by current(). This method will not alter the current vertex.\n     * This Vec2 is not able to be disposed of.\n     *\n     * @return A Vec2 representing the bottom most vertex.\n     * @throws # If polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function bottom():Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty()){\n            throw \"Error: empty GeomPoly has no defineable bottommost vertex\";\n        }\n        #end\n        var max=zpp_inner.vertices;\n        {\n            var F=zpp_inner.vertices.next;\n            var L=zpp_inner.vertices;\n            if(F!=null){\n                var nite=F;\n                do{\n                    var v=nite;\n                    {\n                        if(v.y>max.y)max=v;\n                    }\n                    nite=nite.next;\n                }\n                while(nite!=L);\n            }\n        };\n        return max.wrapper();\n    }\n    /**\n     * Find left most vertex of polygon.\n     * <br/><br/>\n     * If there is more than one such vertex then the result is indeterminate.\n     * <br/><br/>\n     * The Vec2 returned is intrinsically tied to the inner vertex like that\n     * returned by current(). This method will not alter the current vertex.\n     * This Vec2 is not able to be disposed of.\n     *\n     * @return A Vec2 representing the left most vertex.\n     * @throws # If polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function left():Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty()){\n            throw \"Error: empty GeomPoly has no defineable leftmost vertex\";\n        }\n        #end\n        var min=zpp_inner.vertices;\n        {\n            var F=zpp_inner.vertices.next;\n            var L=zpp_inner.vertices;\n            if(F!=null){\n                var nite=F;\n                do{\n                    var v=nite;\n                    {\n                        if(v.x<min.x)min=v;\n                    }\n                    nite=nite.next;\n                }\n                while(nite!=L);\n            }\n        };\n        return min.wrapper();\n    }\n    /**\n     * Find right most vertex of polygon.\n     * <br/><br/>\n     * If there is more than one such vertex then the result is indeterminate.\n     * <br/><br/>\n     * The Vec2 returned is intrinsically tied to the inner vertex like that\n     * returned by current(). This method will not alter the current vertex.\n     * This Vec2 is not able to be disposed of.\n     *\n     * @return A Vec2 representing the right most vertex.\n     * @throws # If polygon is empty.\n     * @throws # If this GeomPoly has been disposed.\n     */\n    public function right():Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty()){\n            throw \"Error: empty GeomPoly has no defineable rightmmost vertex\";\n        }\n        #end\n        var max=zpp_inner.vertices;\n        {\n            var F=zpp_inner.vertices.next;\n            var L=zpp_inner.vertices;\n            if(F!=null){\n                var nite=F;\n                do{\n                    var v=nite;\n                    {\n                        if(v.x>max.x)max=v;\n                    }\n                    nite=nite.next;\n                }\n                while(nite!=L);\n            }\n        };\n        return max.wrapper();\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass GeomPolyIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:GeomPolyList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:GeomPolyIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:GeomPolyIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_GeomPolyList.internal)throw \"Error: Cannot instantiate \"+\"GeomPoly\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:GeomPolyList){\n        var ret=if(zpp_pool==null){\n            ZPP_GeomPolyList.internal=true;\n            var ret=new GeomPolyIterator();\n            ZPP_GeomPolyList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=GeomPolyIterator.zpp_pool;\n                GeomPolyIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of GeomPoly type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:GeomPoly = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:GeomPoly = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:GeomPoly = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass GeomPolyList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_GeomPolyList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than GeomPoly\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<GeomPoly>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new GeomPolyList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,GeomPoly)#else Std.is(i,GeomPoly)#end)throw \"Error: Array contains non \"+\"GeomPoly\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<GeomPoly>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new GeomPolyList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:GeomPoly):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):GeomPoly{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:GeomPoly):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"GeomPoly\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:GeomPoly):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"GeomPoly\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():GeomPoly{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"GeomPoly\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():GeomPoly{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"GeomPoly\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:GeomPoly):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:GeomPoly):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"GeomPoly\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"GeomPoly\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return GeomPolyIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new GeomPolyList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"GeomPoly\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:GeomPolyList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_GeomPolyList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:GeomPoly->Void):GeomPolyList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=GeomPolyIterator.zpp_pool;\n                    GeomPolyIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:GeomPoly->Bool):GeomPolyList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * 2D Matrix class representing affine transformations:\n * <pre>\n * [ a  b  tx ]\n * [ c  d  ty ]\n * [ 0  0  1  ]\n * </pre>\n *\n * Note that in AS3, flash.geom.Matrix has 'b' and 'c' swapped! so if you are\n * converting between flash.geom.Matrix and nape.geom.Mat23 you should use the\n * methods provided to avoid any mistakes with this.\n *\n */\n@:final#if nape_swc@:keep #end\nclass Mat23{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Mat23=null;\n    /**\n     * The (1,1) entry in Mat23:\n     * <br/><br/>\n     * <pre>\n     * [ a  .  . ]\n     * [ .  .  . ]\n     * </pre>\n     *\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var a(get_a,set_a):Float;\n    inline function get_a():Float{\n        return zpp_inner.a;\n    }\n    inline function set_a(a:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((a!=a)){\n                throw \"Error: Mat23::\"+\"a\"+\" cannot be NaN\";\n            }\n            #end\n            zpp_inner.a=a;\n            zpp_inner.invalidate();\n        }\n        return get_a();\n    }\n    /**\n     * The (1,2) entry in Mat23:\n     * <br/><br/>\n     * <pre>\n     * [ .  b  . ]\n     * [ .  .  . ]\n     * </pre>\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var b(get_b,set_b):Float;\n    inline function get_b():Float{\n        return zpp_inner.b;\n    }\n    inline function set_b(b:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((b!=b)){\n                throw \"Error: Mat23::\"+\"b\"+\" cannot be NaN\";\n            }\n            #end\n            zpp_inner.b=b;\n            zpp_inner.invalidate();\n        }\n        return get_b();\n    }\n    /**\n     * The (2,1) entry in Mat23:\n     * <br/><br/>\n     * <pre>\n     * [ .  .  . ]\n     * [ c  .  . ]\n     * </pre>\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var c(get_c,set_c):Float;\n    inline function get_c():Float{\n        return zpp_inner.c;\n    }\n    inline function set_c(c:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((c!=c)){\n                throw \"Error: Mat23::\"+\"c\"+\" cannot be NaN\";\n            }\n            #end\n            zpp_inner.c=c;\n            zpp_inner.invalidate();\n        }\n        return get_c();\n    }\n    /**\n     * The (2,2) entry in Mat23:\n     * <br/><br/>\n     * <pre>\n     * [ .  .  . ]\n     * [ .  d  . ]\n     * </pre>\n     *\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var d(get_d,set_d):Float;\n    inline function get_d():Float{\n        return zpp_inner.d;\n    }\n    inline function set_d(d:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((d!=d)){\n                throw \"Error: Mat23::\"+\"d\"+\" cannot be NaN\";\n            }\n            #end\n            zpp_inner.d=d;\n            zpp_inner.invalidate();\n        }\n        return get_d();\n    }\n    /**\n     * The (1,3) entry in Mat23 which represents x translation\n     * <br/><br/>\n     * <pre>\n     * [ .  .  tx ]\n     * [ .  .  .  ]\n     * </pre>\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var tx(get_tx,set_tx):Float;\n    inline function get_tx():Float{\n        return zpp_inner.tx;\n    }\n    inline function set_tx(tx:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((tx!=tx)){\n                throw \"Error: Mat23::\"+\"tx\"+\" cannot be NaN\";\n            }\n            #end\n            zpp_inner.tx=tx;\n            zpp_inner.invalidate();\n        }\n        return get_tx();\n    }\n    /**\n     * The (2,3) entry in Mat23 which represents y translation\n     * <br/><br/>\n     * <pre>\n     * [ .  .  .  ]\n     * [ .  .  ty ]\n     * </pre>\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var ty(get_ty,set_ty):Float;\n    inline function get_ty():Float{\n        return zpp_inner.ty;\n    }\n    inline function set_ty(ty:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if((ty!=ty)){\n                throw \"Error: Mat23::\"+\"ty\"+\" cannot be NaN\";\n            }\n            #end\n            zpp_inner.ty=ty;\n            zpp_inner.invalidate();\n        }\n        return get_ty();\n    }\n    /**\n     * Construct new Mat23.\n     * <br/><br/>\n     * <pre>\n     * [ a  b  tx ]\n     * [ c  d  ty ]\n     * </pre>\n     *\n     * @param a  The (1,1) entry in matrix (default 1)\n     * @param b  The (1,2) entry in matrix (default 0)\n     * @param c  The (2,1) entry in matrix (default 0)\n     * @param d  The (2,2) entry in matrix (default 1)\n     * @param tx The (1,3) entry in matrix (default 0)\n     * @param ty The (2,3) entry in matrix (default 0)\n     * @return   The newly constructed Mat23.\n     */\n    public function new(a:Float=1.0,b:Float=0.0,c:Float=0.0,d:Float=1.0,tx:Float=0.0,ty:Float=0.0){\n        zpp_inner=ZPP_Mat23.get();\n        zpp_inner.outer=this;\n        this.a=a;\n        this.b=b;\n        this.tx=tx;\n        this.c=c;\n        this.d=d;\n        this.ty=ty;\n    }\n    /**\n     * Produce copy of this Mat23\n     *\n     * @return The new Mat23 representing copy of this.\n     */\n    #if nape_swc@:keep #end\n    public function copy(){\n        return new Mat23(a,b,c,d,tx,ty);\n    }\n    /**\n     * Set values of matrix from another.\n     *\n     * @param matrix The matrix to copy values from.\n     * @return       A reference to this Mat23.\n     * @throws # if matrix argument is null.\n     */\n    public function set(matrix:Mat23):Mat23{\n        #if(!NAPE_RELEASE_BUILD)\n        if(matrix==null){\n            throw \"Error: Cannot set form null matrix\";\n        }\n        #end\n        zpp_inner.set(matrix.zpp_inner);\n        zpp_inner.invalidate();\n        return this;\n    }\n    /**\n     * Set values of matrix from numbers.\n     * <br/><br/>\n     * So that: <code>mat.setAs(...)</code> is\n     * semantically equivalent to: <code>mat.set(new Mat23(...))</code>\n     * <br/><br/>\n     * @param a  The value to which the (1,1) entry will be set (default 1)\n     * @param b  The value to which the (1,2) entry will be set (default 0)\n     * @param c  The value to which the (2,1) entry will be set (default 0)\n     * @param d  The value to which the (2,2) entry will be set (default 1)\n     * @param tx The value to which the (1,3) entry will be set (default 0)\n     * @param ty The value to which the (2,3) entry will be set (default 0)\n     * @return   A reference to this Mat23.\n     */\n    public function setAs(a:Float=1.0,b:Float=0.0,c:Float=0.0,d:Float=1.0,tx:Float=0.0,ty:Float=0.0):Mat23{\n        zpp_inner.setas(a,b,c,d,tx,ty);\n        zpp_inner.invalidate();\n        return this;\n    }\n    /**\n     * Reset matrix to identity.\n     * <br/><br/>\n     * Equivalent to calling setAs with default argument values.\n     * <br/><br/>\n     * @return A reference to this Mat23.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function reset():Mat23{\n        return setAs();\n    }\n    #if(flash9||openfl||nme)/**\n     * Create a Mat23 matrix from a given AS3 flash.geom.Matrix.\n     * <br/><br/>\n     * This method should be used in preference to doing so manually\n     * as the allocation of matrix entries to name is different and\n     * it is easy to make this mistake!\n     * <br/><br/>\n     * This method is only available on <code>flash</code> and\n     * <code>openfl||nme</code> targets.\n     *\n     * @param matrix The AS3 Matrix to create Mat23 from. This value must\n     *               not be null.\n     * @return       The constructed Mat23 matching AS3 Matrix.\n     */\n    #if nape_swc@:keep #end\n    public static function fromMatrix(matrix:flash.geom.Matrix):Mat23{\n        var m=matrix;\n        return new Mat23(m.a,m.c,m.b,m.d,m.tx,m.ty);\n    }\n    /**\n     * Create an AS3 flash.geom.Matrix from this Mat23.\n     * <br/><br/>\n     * This method should be used in preference to doing so manually\n     * as the allocation of matrix entries to name is different and\n     * it is easy to make this mistake!\n     *\n     * @param output If supplied, this Matrix will have its properties\n     *               populated insteaad of creating a new Matrix.\n     * @preturn The constructed AS3 Matrix.\n     */\n    #if nape_swc@:keep #end\n    public function toMatrix(output:flash.geom.Matrix=null):flash.geom.Matrix{\n        if(output==null)output=new flash.geom.Matrix();\n        output.a=a;\n        output.b=c;\n        output.c=b;\n        output.d=d;\n        output.tx=tx;\n        output.ty=ty;\n        return output;\n    }\n    #end\n    /**\n     * Construct a Mat23 representing a clockwise rotation.\n     *\n     * <pre>\n     * [ cos angle  -sin angle  0 ]\n     * [ sin angle   cos angle  0 ]\n     * </pre>\n     *\n     * @param angle The clockwise rotation in radians\n     * @return      The rotation matrix.\n     */\n    #if nape_swc@:keep #end\n    public static function rotation(angle:Float):Mat23{\n        #if(!NAPE_RELEASE_BUILD)\n        if((angle!=angle)){\n            throw \"Error: Cannot create rotation matrix with NaN angle\";\n        }\n        #end\n        var cos=Math.cos(angle);\n        var sin=Math.sin(angle);\n        return new Mat23(cos,-sin,sin,cos,0,0);\n    }\n    /**\n     * Construct a Mat23 representing a translation\n     *\n     * <pre>\n     * [ 1  0  tx ]\n     * [ 0  1  ty ]\n     * </pre>\n     *\n     * @param tx The x translation.\n     * @param ty The y translation.\n     * @return   The translation matrix.\n     */\n    #if nape_swc@:keep #end\n    public static function translation(tx:Float,ty:Float):Mat23{\n        return new Mat23(1,0,0,1,tx,ty);\n    }\n    /**\n     * Construct a Mat23 representing a scaling\n     *\n     * <pre>\n     * [ sx  0  0 ]\n     * [ 0  sy  0 ]\n     * </pre>\n     *\n     * @param sx The x factor of scaling.\n     * @param sy The y factor of scaling.\n     * @return   The scaling matrix.\n     */\n    #if nape_swc@:keep #end\n    public static function scale(sx:Float,sy:Float):Mat23{\n        return new Mat23(sx,0,0,sy,0,0);\n    }\n    /**\n     * (readonly) The determinant of this matrix.\n     * <br/><br/>\n     * This represents the factor of change in area\n     * for a region of the plane after transformation by matrix.\n     * <br/><br/>\n     * A determinant of 0 signifies that the matrix is not invertible.\n     * <br/><br/>\n     * A negative determinant signifies that for example, a clockwise wound\n     * polygon would be transformed into a counter-clockwise polygon.\n     *\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var determinant(get_determinant,never):Float;\n    inline function get_determinant():Float{\n        return(a*d)-(b*c);\n    }\n    /**\n     * Determine if the matrix is singular.\n     * This check is based on computing the condition number of the matrix\n     * by the Frobenius norm, and comparing against 2 / epsilon.\n     * <br/><br/>\n     * If matrix is singular, then inversion of the matrix cannot be performed\n     *\n     * @return True, if matrix is singular.\n     */\n    #if nape_swc@:keep #end\n    public function singular():Bool{\n        var norm=(a*a)+(b*b)+(c*c)+(d*d);\n        var limit=determinant;\n        if(limit<0)limit=-limit;\n        return(norm>(Config.illConditionedThreshold*limit));\n    }\n    /**\n     * Compute the inverse of this matrix, returning the inverse in a new\n     * Mat23 object.\n     * <br/><br/>\n     * The inverse is such that mat.concat(mat.inverse()) is the identity\n     * matrix, as well as mat.inverse().concat(mat)\n     *\n     * @return The inverse matrix.\n     * @throws # If matrix is singular.\n     */\n    #if nape_swc@:keep #end\n    public function inverse():Mat23{\n        #if(!NAPE_RELEASE_BUILD)\n        if(singular()){\n            throw \"Error: Matrix is singular and cannot be inverted\";\n        }\n        #end\n        var idet=1.0/determinant;\n        return new Mat23((d*idet),(-b*idet),(-c*idet),(a*idet),((b*ty)-(d*tx))*idet,((c*tx)-(a*ty))*idet);\n    }\n    /**\n     * Compute the transpose of this matrix, returning the transpose in a new\n     * Mat23 object.\n     * <br/><br/>\n     * Technically speaking, we cannot transpose a matrix if the tx/ty values\n     * are non-zero as the implicit bottom row of matrix must be (0, 0, 1)\n     * so the tx/ty values of output matrix are set so that should the main\n     * 2x2 block of the matrix be orthogonal (Representing a rotation), then\n     * the transpose will be able to act as the matrix inverse.\n     * <pre>\n     * var mat = Mat23.rotation(..).concat(Mat23.translation(...));\n     * trace(mat.concat(mat.transpose())); // Identity matrix\n     * trace(mat.concat(mat.inverse())); // Identity matrix\n     * </pre>\n     * If the main 2x2 block of matrix is 'not' orthogonal, then the transpose\n     * will not be equal to the inverse.\n     *\n     * @return The transposed matrix.\n     */\n    #if nape_swc@:keep #end\n    public function transpose():Mat23{\n        return new Mat23(a,c,b,d,-a*tx-c*ty,-b*tx-d*ty);\n    }\n    /**\n     * Concatenate matrices (left-multiplication), returning new Mat23.\n     * <br/><br/>\n     * <code>mat1.concat(mat2)</code> is the transformation that first\n     * performs transformation represented by mat1, followed by transformation\n     * represented by mat2.\n     * <br/>\n     *\n     * @param matrix Matrix to concatenate with.\n     * @return       The result of the concatenation.\n     * @throws # If matrix argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function concat(matrix:Mat23):Mat23{\n        var m=matrix;\n        #if(!NAPE_RELEASE_BUILD)\n        if(m==null){\n            throw \"Error: Cannot concatenate with null Mat23\";\n        }\n        #end\n        return new Mat23(((m.a*a)+(m.b*c)),((m.a*b)+(m.b*d)),((m.c*a)+(m.d*c)),((m.c*b)+(m.d*d)),(m.a*tx)+(m.b*ty)+m.tx,(m.c*tx)+(m.d*ty)+m.ty);\n    }\n    /**\n     * Transform a Vec2 by this matrix in new Vec2.\n     * <br/><br/>\n     * The Vec2 object will be allocated form the global object pool.\n     *\n     * @param point         The Vec2 to transform by this matrix.\n     * @param noTranslation If true, then the input Vec2 will be treat as a\n     *                      vector, rather than a point with the tx/ty values\n     *                      treat as 0. (default false)\n     * @param weak          If true, then the allocated Vec2 will be\n     *                      automatically released to global object pool when\n     *                      used as an argument to a Nape function.\n     * @return              The result of the transformation as a newly\n     *                      allocated (possibly weak) Vec2. (default false)\n     * @throws # If point argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function transform(point:Vec2,noTranslation:Bool=false,weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null){\n            throw \"Error: Cannot transform null Vec2\";\n        }\n        #end\n        var ret:Vec2;\n        if(noTranslation){\n            ret=Vec2.get((point.x*a)+(point.y*b),(point.x*c)+(point.y*d),weak);\n        }\n        else{\n            ret=Vec2.get((point.x*a)+(point.y*b)+tx,(point.x*c)+(point.y*d)+ty,weak);\n        }\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Perform inverse transformation with Vec2, returning new Vec2.\n     * <br/><br/>\n     * The matrix inverse will be performed implicitly and should this\n     * method be called many times for the same Mat23, it would be better\n     * to instead compute the matrix inverse only once.\n     * <br/><br/>\n     * The new Vec2 will be allocated from the global object pool.\n     *\n     * @param point         The Vec2 to transform.\n     * @param noTranslation If true then the input Vec2 will be treat as a\n     *                      vector instead of a point, treating the tx/ty\n     *                      values of this Mat23 as though they were 0.\n     *                      (default false)\n     * @param weak          If true, then the allocated Vec2 will be\n     *                      automatically released to global object pool when\n     *                      used as an argument to a Nape function.\n     * @return              The result of the transformation as a newly\n     *                      allocated (possibly weak) Vec2. (default false)\n     * @throws # If matrix is singular.\n     * @throws # If point argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function inverseTransform(point:Vec2,noTranslation:Bool=false,weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null){\n            throw \"Error: Cannot transform null Vec2\";\n        }\n        if(singular()){\n            throw \"Error: Matrix is singular and inverse transformation cannot be performed\";\n        }\n        #end\n        var idet=1.0/determinant;\n        var ret:Vec2;\n        if(noTranslation){\n            ret=Vec2.get(((point.x*d)-(point.y*b))*idet,((point.y*a)-(point.x*c))*idet,weak);\n        }\n        else{\n            var dx=point.x-tx;\n            var dy=point.y-ty;\n            ret=Vec2.get(((dx*d)-(dy*b))*idet,((dy*a)-(dx*c))*idet,weak);\n        }\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString():String{\n        return \"{ a: \"+a+\" b: \"+b+\" c: \"+c+\" d: \"+d+\" tx: \"+tx+\" ty: \"+ty+\" }\";\n    }\n    /**\n     * Determine if matrix is equiorthogonal\n     * <br/><br/>\n     * This is a term I invented after\n     * failing to find an existing name. It describes that this matrix maps\n     * circles into other circles (of not necessarigly the same radius). In\n     * otherwords the matrix can be decomposed into a rotation, translation\n     * and scaling of equal x/y factors.\n     * <br/><br/>\n     * This property is required for any Mat23 that is used to transform a\n     * Circle, or any Body containing a Circle, or to transform a Debug view.\n     * <br/><br/>\n     * This is a weaker property than orthogonality which describes a mapping\n     * to a circle of equal radius.\n     * <br/><br/>\n     * Mathematically speaking a matrix is equiorthogonal iff.\n     * <code>transpose(M) * M = kI</code> for some non-zero scalar k.\n     *\n     * @return True if matrix is equiorthogonal.\n     */\n    #if nape_swc@:keep #end\n    public function equiorthogonal():Bool{\n        if(singular()){\n            return false;\n        }\n        else{\n            var x=(a*b)+(c*d);\n            if((x*x)<Config.epsilon){\n                var y=(a*a)+(b*b)-(c*c)-(d*d);\n                return(y*y)<Config.epsilon;\n            }\n            else{\n                return false;\n            }\n        }\n    }\n    /**\n     * Determine if matrix is orthogonal\n     * <br/><br/>\n     * This property describes a matrix\n     * which maps circles into other circles of equal radius. In otherwords\n     * the matrix can be decomposed into a rotation and a translation.\n     * <br/><br/>\n     * Mathematically speaking a matrix is orthogonal iff.\n     * <code>transpose(M) * M = I</code>.\n     *\n     * @return True if matrix is orthogonal.\n     */\n    #if nape_swc@:keep #end\n    public function orthogonal():Bool{\n        var x=(a*b)+(c*d);\n        if((x*x)<Config.epsilon){\n            var y=(a*a)+(b*b)-1;\n            var z=(c*c)+(d*d)-1;\n            return(y*y)<Config.epsilon&&(z*z)<Config.epsilon;\n        }\n        else{\n            return false;\n        }\n    }\n    /**\n     * Equiorthogonalise matrix.\n     * <br/><br/>\n     * We do this by finding the 'nearest' orthogonal matrix;\n     * scaling the basis vectors of matrix to their mean length\n     * and applying an equal and opposite rotation to each basis vector to\n     * make them perpendicular.\n     *\n     * @return A reference to this Mat23.\n     * @throws # If matrix is singular.\n     */\n    #if nape_swc@:keep #end\n    public function equiorthogonalise():Mat23{\n        if(!equiorthogonal()){\n            var k1=Math.sqrt((a*a)+(c*c));\n            var k2=Math.sqrt((b*b)+(d*d));\n            #if(!NAPE_RELEASE_BUILD)\n            if((k1*k1)<Config.epsilon||(k2*k2)<Config.epsilon){\n                throw \"Error: Matrix is singular and cannot be \"+\"equiorthogonal\"+\"ised\";\n            }\n            #end\n            var k=(k1+k2)/2;\n            k1=k/k1;\n            k2=k/k2;\n            a*=k1;\n            c*=k1;\n            b*=k2;\n            d*=k2;\n            var dot=(a*b)+(c*d);\n            var ang=0.25*Math.PI-0.5*Math.acos(dot/(k*k));\n            if(determinant>0){\n                ang=-ang;\n            }\n            var sin=Math.sin(ang);\n            var cos=Math.cos(ang);\n            var a2=(a*cos)-(c*sin);\n            var b2=(b*cos)+(d*sin);\n            c=(c*cos)+(a*sin);\n            a=a2;\n            d=(d*cos)-(b*sin);\n            b=b2;\n            zpp_inner.invalidate();\n        }\n        return this;\n    }\n    /**\n     * Orthogonalise matrix.\n     * <br/><br/>\n     * We do this by finding the 'nearest' orthogonal matrix;\n     * normalising the basis vectors of matrix\n     * and applying an equal and opposite rotation to each basis vector to\n     * make them perpendicular.\n     *\n     * @return A reference to this Mat23.\n     * @throws # If matrix is singular.\n     */\n    #if nape_swc@:keep #end\n    public function orthogonalise():Mat23{\n        if(!orthogonal()){\n            var k1=Math.sqrt((a*a)+(c*c));\n            var k2=Math.sqrt((b*b)+(d*d));\n            #if(!NAPE_RELEASE_BUILD)\n            if((k1*k1)<Config.epsilon||(k2*k2)<Config.epsilon){\n                throw \"Error: Matrix is singular and cannot be \"+\"orthogonal\"+\"ised\";\n            }\n            #end\n            var k=1;\n            k1=k/k1;\n            k2=k/k2;\n            a*=k1;\n            c*=k1;\n            b*=k2;\n            d*=k2;\n            var dot=(a*b)+(c*d);\n            var ang=0.25*Math.PI-0.5*Math.acos(dot/(k*k));\n            if(determinant>0){\n                ang=-ang;\n            }\n            var sin=Math.sin(ang);\n            var cos=Math.cos(ang);\n            var a2=(a*cos)-(c*sin);\n            var b2=(b*cos)+(d*sin);\n            c=(c*cos)+(a*sin);\n            a=a2;\n            d=(d*cos)-(b*sin);\n            b=b2;\n            zpp_inner.invalidate();\n        }\n        return this;\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n /**\n * A general MxN dimensional matrix.\n * <br/><br/>\n * This object is not often used in Nape :)\n */\n@:final#if nape_swc@:keep #end\nclass MatMN{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_MatMN=null;\n    /**\n     * The number of rows in the matrix.\n     */\n    #if nape_swc@:isVar #end\n    public var rows(get_rows,never):Int;\n    inline function get_rows():Int{\n        return zpp_inner.m;\n    }\n    /**\n     * The number of columns in the matrix.\n     */\n    #if nape_swc@:isVar #end\n    public var cols(get_cols,never):Int;\n    inline function get_cols():Int{\n        return zpp_inner.n;\n    }\n    /**\n     * Access element at index.\n     *\n     * @param row The row of the matrix to access.\n     * @param col the column of the matrix to access.\n     * @return The element at given (row,col) index.\n     * @throws # If access is out of range.\n     */\n    #if NAPE_NO_INLINE#else inline #end\n    public function x(row:Int,col:Int):Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(row<0||col<0||row>=rows||col>=cols){\n            throw \"Error: MatMN indices out of range\";\n        }\n        #end\n        return zpp_inner.x[(row*cols)+col];\n    }\n    /**\n     * Set element at index.\n     *\n     * @param row The row of the matrix to set.\n     * @param col The column of the matrix to set.\n     * @param x The value to set at given (row,col) index.\n     * @return The value of matrix at given index after set. (Always\n     *         equal to the x parameter)\n     * @throws # If index is out of range.\n     */\n    #if NAPE_NO_INLINE#else inline #end\n    public function setx(row:Int,col:Int,x:Float):Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(row<0||col<0||row>=rows||col>=cols){\n            throw \"Error: MatMN indices out of range\";\n        }\n        #end\n        return zpp_inner.x[(row*cols)+col]=x;\n    }\n    /**\n     * Construct a new Matrix.\n     *\n     * @param rows The number of rows in matrix.\n     * @param cols The number of columns in matrix.\n     * @return The constructed Matrix.\n     * @throws # If rows or columns is negative or 0.\n     */\n    #if flib@:keep function flibopts_0(){}\n    #end\n    public function new(rows:Int,cols:Int){\n        #if(!NAPE_RELEASE_BUILD)\n        if(rows<=0||cols<=0){\n            throw \"Error: MatMN::dimensions cannot be < 1\";\n        }\n        #end\n        zpp_inner=new ZPP_MatMN(rows,cols);\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"{ \";\n        var fst=true;\n        for(i in 0...rows){\n            if(!fst)ret+=\"; \";\n            fst=false;\n            for(j in 0...cols)ret+=x(i,j)+\" \";\n        }\n        ret+=\"}\";\n        return ret;\n    }\n    /**\n     * Transpose matrix, returning a new Matrix.\n     *\n     * @return The transposed matrix.\n     */\n    public function transpose():MatMN{\n        var ret=new MatMN(cols,rows);\n        for(i in 0...rows){\n            for(j in 0...cols)ret.setx(j,i,x(i,j));\n        }\n        return ret;\n    }\n    /**\n     * Multiple this matrix with another.\n     * <br/><br/>\n     * This operation is only valid if the number of columns\n     * in this matrix, is equal to the number of rows in the input\n     * matrix.\n     * <br/>\n     * The result of the multiplication is returned as a new matrix.\n     *\n     * @param matrix The matrix to multiple with.\n     * @return The result of the multiplication\n     * @throws If matrix dimensions are not compatible.\n     */\n    public function mul(matrix:MatMN):MatMN{\n        var y=matrix;\n        #if(!NAPE_RELEASE_BUILD)\n        if(cols!=y.rows){\n            throw \"Error: Matrix dimensions aren't compatible\";\n        }\n        #end\n        var ret=new MatMN(rows,y.cols);\n        for(i in 0...rows){\n            for(j in 0...y.cols){\n                var v=0.0;\n                for(k in 0...cols)v+=x(i,k)*y.x(k,j);\n                ret.setx(i,j,v);\n            }\n        }\n        return ret;\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Class representing the results of a ray cast operation.\n * <br/><br/>\n * These objects are allocated from an object pool and can\n * be released back to that pool by calling its dispose method.\n */\n@:final#if nape_swc@:keep #end\nclass RayResult{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_ConvexRayResult=null;\n    /**\n     * The normal of the surface at intersection.\n     */\n    #if nape_swc@:isVar #end\n    public var normal(get_normal,never):Vec2;\n    inline function get_normal():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return zpp_inner.normal;\n    }\n    /**\n     * The distance to the intersection.\n     */\n    #if nape_swc@:isVar #end\n    public var distance(get_distance,never):Float;\n    inline function get_distance():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return zpp_inner.toiDistance;\n    }\n    /**\n     * Whether this intersection is with the inner surface of an object.\n     */\n    #if nape_swc@:isVar #end\n    public var inner(get_inner,never):Bool;\n    inline function get_inner():Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return zpp_inner.inner;\n    }\n    /**\n     * The shape which was intersected.\n     */\n    #if nape_swc@:isVar #end\n    public var shape(get_shape,never):Shape;\n    inline function get_shape():Shape{\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return zpp_inner.shape;\n    }\n    /**\n     * @private\n     */\n    #if flib@:keep function flibopts_0(){}\n    #end\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_ConvexRayResult.internal)throw \"Error: RayResult cannot be instantiated derp!\";\n        #end\n    }\n    /**\n     * Release RayResult object to pool.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function dispose(){\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        zpp_inner.free();\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        #if(!NAPE_RELEASE_BUILD)\n        zpp_inner.disposed();\n        #end\n        return \"{ shape: \"+shape+\" distance: \"+distance+\" ?inner: \"+inner+\" }\";\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass RayResultIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:RayResultList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:RayResultIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:RayResultIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_RayResultList.internal)throw \"Error: Cannot instantiate \"+\"RayResult\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:RayResultList){\n        var ret=if(zpp_pool==null){\n            ZPP_RayResultList.internal=true;\n            var ret=new RayResultIterator();\n            ZPP_RayResultList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=RayResultIterator.zpp_pool;\n                RayResultIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of RayResult type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:RayResult = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:RayResult = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:RayResult = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass RayResultList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_RayResultList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than RayResult\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<RayResult>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new RayResultList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,RayResult)#else Std.is(i,RayResult)#end)throw \"Error: Array contains non \"+\"RayResult\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<RayResult>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new RayResultList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:RayResult):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):RayResult{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem();\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:RayResult):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"RayResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:RayResult):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"RayResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj);\n            }\n            else zpp_inner.inner.add(obj);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():RayResult{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"RayResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():RayResult{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"RayResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:RayResult):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:RayResult):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"RayResult\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"RayResult\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return RayResultIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new RayResultList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"RayResult\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:RayResultList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_RayResultList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:RayResult->Void):RayResultList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=RayResultIterator.zpp_pool;\n                    RayResultIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:RayResult->Bool):RayResultList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * 2 Dimensional vector.\n * <br/><br/>\n * Note that in many cases of a Vec2 object being returned by a Nape function\n * the Vec2 object will be marked internally as an 'immutable' Vec2. This will\n * always be documented and trying to mutate such a Vec2 will result in an\n * error being thrown.\n * <br/><br/>\n * Vec2 objects can make use of a global object pool, attempting to make use\n * of a disposed Vec2 will also result in an error with the object pool\n * working in a FILO order to increase the likelihood of such misuse being\n * caught.\n * <br/><br/>\n * Additionally Vec2 objects can be created as 'weak'. Passing a weak Vec2 to\n * any Nape function as an argument will result in the automatic disposal of\n * the Vec2 once the method has finished with it. There may be exceptions to\n * this rule which will also be documented; a notable case being the appending\n * of a weak Vec2 to a Nape Vec2List in which case the disposal of the weak\n * Vec2 is performed when that Vec2List is handed to a Nape function instead.\n * <br/><br/>\n * Example:\n * <pre>\n * var vertices = Polygon.box(20, 20, true);\n * var polygon = new Polygon(vertices);\n * </pre>\n * In this example, passing <code>true</code> to the Polygon.box method means\n * that we will be returned a Vec2List containing only 'weak' Vec2s. Upon\n * passing this Vec2List to the Polygon constructor, all of the Vec2s from\n * that list will be automatically disposed.\n */\n@:final#if nape_swc@:keep #end\nclass Vec2{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Vec2=null;\n    /**\n     * @private\n     */\n    public var zpp_pool:Vec2=null;\n    #if(!NAPE_RELEASE_BUILD)\n    /**\n     * @private\n     */\n    public var zpp_disp:Bool;\n    #end\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    /**\n     * Allocate a weak Vec2 from global object pool.\n     * <br/><br/>\n     * This object which will be automaticaly released back to the object pool\n     * when supplied as an argument to a Nape function.\n     * <br/><br/>\n     * Note that <code>Vec2.weak(x, y)</code> is exactly equivalent to <code>\n     * Vec2.get(x, y, true)</code>.\n     *\n     * @param x The x coordinate for the vector. (default 0)\n     * @param y The y coordiante for the vector. (default 0)\n     * @return  The allocated weak Vec2 with given x/y values.\n     */\n    public static#if NAPE_NO_INLINE#else inline #end\n    function weak(x:Float=0,y:Float=0):Vec2{\n        return get(x,y,true);\n    }\n    /**\n     * Allocates a Vec2 from the global object pool.\n     * <br/><br/>\n     * Note that <code>Vec2.get(x, y, true)</code> is exactly equivalent to\n     * <code>Vec2.weak(x, y)</code> and should be preferred.\n     *\n     * @param x    The x coordinate for the vector. (default 0)\n     * @param y    The y coordinate for the vector. (default 0)\n     * @param weak If true, then a weak Vec2 will be allocated which will be\n     *             automatically released to object pool when passed as an\n     *             argument to a Nape function. (default false)\n     * @return     The allocated, possibly weak Vec2 with given x/y values.\n     */\n    public static#if NAPE_NO_INLINE#else inline #end\n    function get(x:Float=0,y:Float=0,weak:Bool=false):Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if((x!=x)||(y!=y)){\n            throw \"Error: Vec2 components cannot be NaN\";\n        }\n        #end\n        var ret;\n        {\n            if(ZPP_PubPool.poolVec2==null){\n                ret=new Vec2();\n                #if NAPE_POOL_STATS Vec2.POOL_TOT++;\n                Vec2.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_PubPool.poolVec2;\n                ZPP_PubPool.poolVec2=ret.zpp_pool;\n                ret.zpp_pool=null;\n                #if(!NAPE_RELEASE_BUILD)\n                ret.zpp_disp=false;\n                if(ret==ZPP_PubPool.nextVec2)ZPP_PubPool.nextVec2=null;\n                #end\n                #if NAPE_POOL_STATS Vec2.POOL_CNT--;\n                Vec2.POOL_ADD++;\n                #end\n            }\n        };\n        if(ret.zpp_inner==null){\n            ret.zpp_inner=ZPP_Vec2.get(x,y);\n            ret.zpp_inner.outer=ret;\n        }\n        else{\n            ret.setxy(x,y);\n        }\n        ret.zpp_inner.weak=weak;\n        return ret;\n    }\n    /**\n     * Release this Vec2 to global object pool.\n     * <br/><br/>\n     * Once diposed this Vec2\n     * will be accessible to Nape internals for re-allocation and should\n     * not be touched (Good practice would be to set any references to this\n     * Vec2 to null to help ensure this).\n     * <br/><br/>\n     * In debug mode, should you attempt to access this Vec2 after disposal\n     * and the Vec2 is still in the object pool, you will be given an Error.\n     * The object pool operates on a First-In-Last-Out principal in debug\n     * mode to help catch these sort of errors.\n     * @throws # If this vector has already been disposed.\n     * @throws # If this vector is immutable.\n     * @throws # If this vector is in use in some other manner, such as being\n     *           an element of a Polygon's vertex list.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function dispose():Void{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.immutable();\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner._inuse){\n            throw \"Error: This Vec2 is not disposable\";\n        }\n        #end\n        var inner=zpp_inner;\n        zpp_inner.outer=null;\n        zpp_inner=null;\n        {\n            var o=this;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"PublicFree(in T: \"+\"Vec2\"+\", in obj: \"+\"this\"+\")\");\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            o.zpp_pool=null;\n            if(ZPP_PubPool.nextVec2!=null)ZPP_PubPool.nextVec2.zpp_pool=o;\n            else ZPP_PubPool.poolVec2=o;\n            ZPP_PubPool.nextVec2=o;\n            #end\n            #if NAPE_RELEASE_BUILD \n            o.zpp_pool=ZPP_PubPool.poolVec2;\n            ZPP_PubPool.poolVec2=o;\n            #end\n            #if NAPE_POOL_STATS Vec2.POOL_CNT++;\n            Vec2.POOL_SUB++;\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            o.zpp_disp=true;\n            #end\n        };\n        {\n            var o=inner;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"inner\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n    }\n    /**\n     * Construct a new Vec2.\n     * <br/><br/>\n     * This constructor will obviously not make use of\n     * the global object pool: <code>Vec2.get</code> should be used in\n     * preference noting that <code>new Vec2(x, y)</code> is semantically\n     * equivalent to <code>Vec2.get(x, y)</code>.\n     *\n     * @param x The x coordinate for the vector. (default 0)\n     * @param y The y coordinate for the vector. (default 0)\n     * @return  The newly constructed Vec2 object with given x/y values.\n     */\n    public function new(x:Float=0,y:Float=0){\n        #if(!NAPE_RELEASE_BUILD)\n        if((x!=x)||(y!=y)){\n            throw \"Error: Vec2 components cannot be NaN\";\n        }\n        #end\n        zpp_inner=ZPP_Vec2.get(x,y);\n        zpp_inner.outer=this;\n    }\n    /**\n     * Produce a copy of this Vec2.\n     * <br/><br/>\n     * The Vec2 will be allocated from the global object pool.\n     * <br/><br/>\n     * As would be expected, if you produce a copy of an 'immutable' Vec2, then\n     * the copy will be 'mutable'.\n     *\n     * @param weak If true, then a weak Vec2 will be allocated which will be\n     *             automatically released to the object pool when passed as an\n     *             argument to any Nape function. (default false)\n     * @return     The possibly weak copy of this Vec2.\n     * @throws # If this vector has been disposed.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function copy(weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return Vec2.get(x,y,weak);\n    }\n    #if(flash9||openfl||nme)\n    /**\n     * Allocate a Vec2 from AS3 Point object.\n     * <br/><br/>\n     * This Vec2 will be allocated from the global object pool.\n     * <br/><br/>\n     * This method is only available on <code>flash</code> and\n     * <code>openfl||nme</code> targets.\n     *\n     * @param point The AS3 Point to initialise Vec2 with\n     * @param weak  If true, then a weak Vec2 will be allocated which will\n     *              be automatically released to the object pool when\n     *              pass as an argument to any Nape function.\n     *              (default false)\n     * @return      The possibly weak Vec2 allocated with same values as\n     *              input Point object.\n     * @throws # If the point argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromPoint(point:flash.geom.Point,weak:Bool=false):Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null){\n            throw \"Error: Cannot create Vec2 from null Point object\";\n        }\n        if((point.x!=point.x)||(point.y!=point.y)){\n            throw \"Error: Error: Vec2 components cannot be NaN\";\n        }\n        #end\n        return Vec2.get(point.x,point.y,weak);\n    }\n    /**\n     * Create an AS3 Point object from Vec2.\n     * <br/><br/>\n     * This method is only available on <code>flash</code> and\n     * <code>openfl||nme</code> targets.\n     *\n     * @param output If supplied, this Point will have its x/y\n     *               set instead of creating a new Point.\n     * @return    The AS3 Point object representing Vec2.\n     * @throws # If this vector has been disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function toPoint(output:flash.geom.Point=null):flash.geom.Point{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        if(output==null)output=new flash.geom.Point();\n        output.x=x;\n        output.y=y;\n        return output;\n    }\n    #end\n    /**\n     * Allocate a Vec2 given polar coordinates.\n     * <br/><br/>\n     * This Vec2 will be allocated from the global object pool.\n     * <br/><br/>\n     * This method will assign x/y values equal respectively to:\n     * <code>length&#42Math.cos(angle)</code>,\n     * <code>length&#42Math.sin(angle)</code>\n     *\n     * @param length The length of the Vec2. This value may be negative.\n     * @param angle  The angle of the Vec2 as measured in radians clockwise\n     *               from the positive x axis.\n     * @param weak   If true, then a weak Vec2 will be allocated which will be\n     *               automatically released to the object pool when passed as\n     *               an argument to any Nape function. (default false)\n     * @return       The possibly weak Vec2 allocated with given polar values.\n     */\n    #if nape_swc@:keep #end\n    public static function fromPolar(length:Float,angle:Float,weak:Bool=false):Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if((length!=length)){\n            throw \"Error: Vec2::length cannot be NaN\";\n        }\n        if((angle!=angle)){\n            throw \"Error: Vec2::angle cannot be NaN\";\n        }\n        #end\n        return Vec2.get(length*Math.cos(angle),length*Math.sin(angle),weak);\n    }\n    /**\n     * x coordinate of vector.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var x(get_x,set_x):Float;\n    inline function get_x():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.validate();\n        return zpp_inner.x;\n    }\n    inline function set_x(x:Float):Float{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            zpp_inner.immutable();\n            if(this.x!=x){\n                #if(!NAPE_RELEASE_BUILD)\n                if((x!=x)){\n                    throw \"Error: Vec2::\"+\"x\"+\" cannot be NaN\";\n                }\n                #end\n                zpp_inner.x=x;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_x();\n    }\n    /**\n     * y coordinate of vector.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var y(get_y,set_y):Float;\n    inline function get_y():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.validate();\n        return zpp_inner.y;\n    }\n    inline function set_y(y:Float):Float{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            zpp_inner.immutable();\n            if(this.y!=y){\n                #if(!NAPE_RELEASE_BUILD)\n                if((y!=y)){\n                    throw \"Error: Vec2::\"+\"y\"+\" cannot be NaN\";\n                }\n                #end\n                zpp_inner.y=y;\n                zpp_inner.invalidate();\n            }\n        }\n        return get_y();\n    }\n    /**\n     * Length of this Vec2.\n     * <br/><br/>\n     * This value can be set and may be set to negative values so that\n     * <code>vec.length &#42= -1</code> is a valid - if sub-optimal - way of\n     * negating a Vec2.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,set_length):Float;\n    inline function get_length():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return Math.sqrt((this.x*this.x+this.y*this.y));\n    }\n    inline function set_length(length:Float):Float{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            zpp_inner.immutable();\n            #if(!NAPE_RELEASE_BUILD)\n            if((length!=length)){\n                throw \"Error: Vec2::length cannot be NaN\";\n            }\n            if((this.x*this.x+this.y*this.y)==0){\n                throw \"Error: Cannot set length of a zero vector\";\n            }\n            #end\n            {\n                var t=(length/Math.sqrt((this.x*this.x+this.y*this.y)));\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"this.\"+\",in s: \"+\"length/Math.sqrt((this.x*this.x+this.y*this.y))\"+\")\");\n                    #end\n                };\n                this.x*=t;\n                this.y*=t;\n            };\n            zpp_inner.invalidate();\n        }\n        return get_length();\n    }\n    /**\n     * Compute squared length of this Vec2.\n     * <br/><br/>\n     * This is exactly the same as performing <code>vec.length &#42\n     * vec.length</code> except for being more effecient.\n     *\n     * @return The squared length of this Vec2.\n     * @throws # If this vector has been disposed.\n     */\n    #if nape_swc@:keep #end\n    public function lsq():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return(this.x*this.x+this.y*this.y);\n    }\n    /**\n     * Set values of this Vec2 to those of the argument.\n     * <br/><br/>\n     * Note that <code>vec.set(p)</code> is semantically equivalent to\n     * <code>vec.setxy(p.x, p.y)</code>.\n     *\n     * @param vector The Vec2 to set the values of this Vec2 with.\n     * @return       A reference to 'this' Vec2.\n     * @throws # If this vector, or vector argument  has been disposed.\n     * @throws # If this vector is immutable.\n     * @throws # If the vector passed as argument is null.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function set(vector:Vec2):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.immutable();\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot assign null Vec2\";\n        }\n        #end\n        var ret=setxy(vector.x,vector.y);\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Compute square distance between two points.\n     *\n     * @param a The first point Vec2.\n     * @param b The second point Vec2.\n     * @return Squared distance between points.\n     * @throws # If a, b are disposed of or null.\n     */\n    public static#if NAPE_NO_INLINE#else inline #end\n    function dsq(a:Vec2,b:Vec2){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(a!=null&&a.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(b!=null&&b.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(a==null||b==null)throw \"Error: Cannot compute squared distance between null Vec2\";\n        #end\n        var ret=ZPP_VecMath.vec_dsq(a.x,a.y,b.x,b.y);\n        ({\n            if(({\n                a.zpp_inner.weak;\n            })){\n                a.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        ({\n            if(({\n                b.zpp_inner.weak;\n            })){\n                b.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Compute distance between two points.\n     *\n     * @param a The first point Vec2.\n     * @param b The second point Vec2.\n     * @return Distance between points.\n     * @throws # If a, b are disposed of or null.\n     */\n    public static#if NAPE_NO_INLINE#else inline #end\n    function distance(a:Vec2,b:Vec2){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(a!=null&&a.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(b!=null&&b.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(a==null||b==null)throw \"Error: Cannot compute squared distance between null Vec2\";\n        #end\n        var ret=Math.sqrt(ZPP_VecMath.vec_dsq(a.x,a.y,b.x,b.y));\n        ({\n            if(({\n                a.zpp_inner.weak;\n            })){\n                a.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        ({\n            if(({\n                b.zpp_inner.weak;\n            })){\n                b.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Set values of this Vec2 given pair of x/y values.\n     *\n     * @param x The x value to set this Vec2's x value to.\n     * @param y The y value to set this Vec2's y value to.\n     * @return  A reference to 'this' Vec2.\n     * @throws # If this vector has been disposed.\n     * @throws # If this vector is immutable.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function setxy(x:Float,y:Float):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.immutable();\n        #if(!NAPE_RELEASE_BUILD)\n        if((x!=x)||(y!=y)){\n            throw \"Error: Vec2 components cannot be NaN\";\n        }\n        #end\n        if(!(this.x==x&&this.y==y)){\n            {\n                zpp_inner.x=x;\n                zpp_inner.y=y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((zpp_inner.x!=zpp_inner.x));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((zpp_inner.y!=zpp_inner.y));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                    #end\n                };\n            };\n            zpp_inner.invalidate();\n        }\n        return this;\n    }\n    /**\n     * Angle of this Vec2.\n     *\n     * Measured in radians as measured clockwise from the positive x axis.\n     * The value will be given in the range -pi to pi.\n     * <br/><br/>\n     * If the x/y values of this Vec2 are both 0, then the angle value will\n     * default to 0.\n     * <br/><br/>\n     * This value can also be set (to any value) so that <code>vec.angle +=\n     * Math.PI</code> is a valid - if sub-optimial - way of negating a Vec2.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var angle(get_angle,set_angle):Float;\n    inline function get_angle():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        if(x==y&&x==0){\n            return 0.0;\n        }\n        else{\n            return Math.atan2(y,x);\n        }\n    }\n    inline function set_angle(angle:Float):Float{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            zpp_inner.immutable();\n            #if(!NAPE_RELEASE_BUILD)\n            if((angle!=angle)){\n                throw \"Error: Vec2::angle cannot be NaN\";\n            }\n            #end\n            var l=length;\n            setxy(l*Math.cos(angle),l*Math.sin(angle));\n        }\n        return get_angle();\n    }\n    /**\n     * Rotate Vec2 in-place by given number of radians..\n     * <br/><br/>\n     * Rotation performed in the clockwise direction.\n     * <br/><br/>\n     * The Vec2 will be mutated, with it's new x/y values being the result\n     * of the rotation.\n     *\n     * @param angle The number of radians to rotate Vec2 by in the clockwise\n     *              direction.\n     * @return A reference to 'this' Vec2.\n     * @throws # If this vector has been disposed.\n     * @throws # If this vector is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function rotate(angle:Float):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.immutable();\n        #if(!NAPE_RELEASE_BUILD)\n        if((angle!=angle)){\n            throw \"Error: Cannot rotate Vec2 by NaN\";\n        }\n        #end\n        if((angle%(Math.PI*2))!=0){\n            var ax=Math.sin(angle);\n            var ay=Math.cos(angle);\n            {\n                var t=(ay*zpp_inner.x-ax*zpp_inner.y);\n                zpp_inner.y=(zpp_inner.x*ax+zpp_inner.y*ay);\n                zpp_inner.x=t;\n            };\n            zpp_inner.invalidate();\n        }\n        return this;\n    }\n    /**\n     * Reflect given Vec2 in plane whose normal is this Vec2.\n     * <br/><br/>\n     * @param vec The vector to be reflected.\n     * @param weak If true, the returned Vec2 will be automatically released\n     *             to object pool when used in another Nape function (default false)\n     * @return The reflected Vec2.\n     * @throws # If this vector or argument has been disposed.\n     * @throws # If this vector has zero length.\n     */\n    #if nape_swc@:keep #end\n    public function reflect(vec:Vec2,weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vec!=null&&vec.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(this.length==0){\n            throw \"Error: Cannot reflect in zero vector\";\n        }\n        #end\n        var normal=this.copy(true).normalise();\n        var ret=vec.sub(normal.muleq(2*normal.dot(vec)),weak);\n        ({\n            if(({\n                vec.zpp_inner.weak;\n            })){\n                vec.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Normalise this vector.\n     * <br/><br/>\n     * Equivalent to setting the length of the vector to 1, and also to the\n     * (less-optimal) <code>this.set(this.unit())</code>.\n     *\n     * @return A reference to 'this' vector.\n     * @throws # If this vector has been disposed of or is immutable.\n     * @throws # If length of this vector is 0.\n     */\n    #if nape_swc@:keep #end\n    public function normalise():Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.immutable();\n        #if(!NAPE_RELEASE_BUILD)\n        if(this.length==0){\n            throw \"Error: Cannot normalise vector of length 0\";\n        }\n        #end\n        {\n            var d=(this.x*this.x+this.y*this.y);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    d!=0.0;\n                };\n                if(!res)throw \"assert(\"+\"d!=0.0\"+\") :: \"+(\"vec_normalise(in n: \"+\"this.\"+\")\");\n                #end\n            };\n            var imag=1.0/Math.sqrt(d);\n            {\n                var t=(imag);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"this.\"+\",in s: \"+\"imag\"+\")\");\n                    #end\n                };\n                this.x*=t;\n                this.y*=t;\n            };\n        };\n        zpp_inner.invalidate();\n        return this;\n    }\n    /**\n     * Return normalisation of this vector.\n     *\n     * @param weak If true then the allocated Vec2 will be automatically\n     *             released to the global object pool when used as an argument\n     *             to a Nape function. (default false)\n     * @return A copy of this vector, normalised.\n     * @throws # If this vector has been disposed of.\n     * @throws # If length of this vector is 0.\n     */\n    #if nape_swc@:keep #end\n    public function unit(weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(this.length==0){\n            throw \"Error: Cannot normalise vector of length 0\";\n        }\n        #end\n        var scale=1/ZPP_Math.sqrt((this.x*this.x+this.y*this.y));\n        return Vec2.get(x*scale,y*scale,weak);\n    }\n    /**\n     * Add another vector to this vector.\n     * <br/><br/>\n     * Returns a newly allocated vector so that\n     * this vector is not modified.\n     * <br/><br/>\n     * @param vector The vector to add to this vector. This value can not be\n     *               null\n     * @param weak   If true then the returned vector will be automatically\n     *               released to the global object pool when used as an\n     *               argument to another Nape function. (default false)\n     * @return       The possibly weak vector representing the sum of this\n     *               and the input vector.\n     * @throws # If this vector, or the vector argument has been disposed.\n     * @throws # If the vector passed as argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function add(vector:Vec2,weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot add null vectors\";\n        }\n        #end\n        var ret=Vec2.get(x+vector.x,y+vector.y,weak);\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Add a multiple of a vector to this vector.\n     * <br/><br/>\n     * This operation is equivalent to:\n     * <pre>\n     * this.add(vector.mul(scalar, true));\n     * </pre>\n     * <br/><br/>\n     * Returns a newly allocated vector so that\n     * this vector is not modified.\n     * <br/><br/>\n     * @param vector The vector to add to this vector. This value can not be\n     *               null\n     * @param scalar The scalar multiplier for the vector being added.\n     * @param weak   If true then the returned vector will be automatically\n     *               released to the global object pool when used as an\n     *               argument to another Nape function. (default false)\n     * @return       The possibly weak vector representing the sum of this\n     *               and the input vector by scalar multiplier.\n     * @throws # If this vector, or the vector argument has been disposed.\n     * @throws # If the vector passed as argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function addMul(vector:Vec2,scalar:Float,weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot add null vectors\";\n        }\n        #end\n        var ret=Vec2.get(x+(vector.x*scalar),y+(vector.y*scalar),weak);\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Subtract another vector from this vector.\n     * <br/><br/>\n     * Returns a newly allocated vector so that this vector is not mutated.\n     *\n     * @param vector The vector to subtract from this vector. This value can\n     *               not be null\n     * @param weak   If true then the returned vector will be automatically\n     *               released to the global object pool when used as an\n     *               argument to another Nape function. (default false)\n     * @return       The possibly weak vector representing the subtraction of\n     *               the input vector from this vector.\n     * @throws # If this vector, or the vector argument has been disposed.\n     * @throws # If the vector passed as argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function sub(vector:Vec2,weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot subtract null vectors\";\n        }\n        #end\n        var ret=Vec2.get(x-vector.x,y-vector.y,weak);\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Multiply this vector with a number.\n     * <br/><br/>\n     * Returns a newly allocated vector so that this vector is not mutated.\n     *\n     * @param scalar The number to multiply this vector with.\n     * @param weak   If true then the returned vector will be automatically\n     *               released to the global object pool when used as an\n     *               argument to another Nape function. (default false)\n     * @return       The possibly weak vector representing the multiplication\n     *               of this vector and the input number.\n     * @throws # If this vector has been disposed.\n     */\n    #if nape_swc@:keep #end\n    public function mul(scalar:Float,weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if((scalar!=scalar)){\n            throw \"Error: Cannot multiply with NaN\";\n        }\n        #end\n        return Vec2.get(x*scalar,y*scalar,weak);\n    }\n    /**\n     * Add another vector into this vector.\n     * <br/><br/>\n     * This vector is mutated to be the result of the operation.\n     * <br/><br/>\n     * Semantically equivalent to (the less optimal)\n     * <code>vec1.set(vec1.add(vec2))</code>\n     *\n     * @param vector The vector to add into this vector.\n     * @return       A reference to this vector.\n     * @throws # If this vector, or the vector argument has been disposed.\n     * @throws # If this vector is immutable.\n     * @throws # If the vector passed as argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function addeq(vector:Vec2):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.immutable();\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot add null vectors\";\n        }\n        #end\n        setxy(x+vector.x,y+vector.y);\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Subtract another vector from this vector.\n     * <br/><br/>\n     * This vector is mutated to be the result of the operation.\n     * <br/><br/>\n     * Semantically equivalent to (the less optimal)\n     * <code>vec1.set(vec1.sub(vec2))</code>\n     *\n     * @param vector The vector to subtract from this vector.\n     * @return       A reference to this vector.\n     * @throws # If this vector, or the vector argument has been disposed.\n     * @throws # If this vector is immutable.\n     * @throws # If the vector passed as argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function subeq(vector:Vec2):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.immutable();\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot subtract null vectors\";\n        }\n        #end\n        setxy(x-vector.x,y-vector.y);\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Multiply this vector with a number.\n     * <br/><br/>\n     * This vector is mutated to be the result of the operation.\n     * <br/><br/>\n     * Semantically equivalent to (the less optimal)\n     * <code>vec.set(vec.mul(scalar))</code>\n     *\n     * @param scalar The number to multiply this vector with.\n     * @return       A reference to this vector.\n     * @throws # If this vector has been disposed.\n     * @throws # If this vector is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function muleq(scalar:Float):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.immutable();\n        #if(!NAPE_RELEASE_BUILD)\n        if((scalar!=scalar)){\n            throw \"Error: Cannot multiply with NaN\";\n        }\n        #end\n        return setxy(x*scalar,y*scalar);\n    }\n    /**\n     * Dot product with another vector.\n     * <br/><br/>\n     * The dot product is equal to the product of the length of each\n     * vector, multiplied by the cosine of the smallest angle between them.\n     * <br/><br/>\n     * If one of the vectors is of length 1. Then the dot product is the\n     * length of the projection of the other vector onto it which may be\n     * computed (assuming 'this' is of length 1) like:\n     * <code>vec1.mul(vec1.dot(vec2))</code>\n     *\n     * @param vector The vector to compute dot product with.\n     * @return       The dot product of this vector and the other.\n     * @throws # If this vector, or the vector argument has been disposed.\n     * @throws # If the vector passed as argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function dot(vector:Vec2):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot take dot product with null vector\";\n        }\n        #end\n        var ret=(x*vector.x+y*vector.y);\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Cross product with another vector.\n     * <br/><br/>\n     * Also known as the perp-dot product, this operation represents\n     * the determinant of the matrix formed by having the 2 columns\n     * as the two vectors. This is also the z-value of a 3D cross product\n     * if you extend the input vectors with a z-value of 0.\n     * <br/><br/>\n     * Though not technically a cross-product in the way a 3D cross product\n     * is, it shares many mathematical similarities.\n     * <br/><br/>\n     * If one of the vectors is of length 1. Then the cross product is the\n     * length of the projection of the other vector onto the\n     * right-perpendicular of the unit vector.\n     * <br/><br/>\n     * The cross and dot product are related like:\n     * <code>vec1.cross(vec2) == vec1.perp().dot(vec2)</code>\n     * Hence the name 'perp-dot'\n     * <br/><br/>\n     * Another useful property is that if the cross-product of two vectors\n     * is 0, then the vectors are collinear, if positive then the second\n     * vector is 'to the right' of the first vector, and if negative then\n     * the second vector is 'to the left' of the first vector.\n     *\n     * @param vector The vector to compute cross product with.\n     * @return       The cross product of this vector and the other.\n     * @throws # If this vector, or the vector argument has been disposed.\n     * @throws # If the vector passed as argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function cross(vector:Vec2):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot take cross product with null vector\";\n        }\n        #end\n        var ret=(vector.y*x-vector.x*y);\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * The right-perpendicular to this vector.\n     * <br/><br/>\n     * Computes the result of rotating this vector by 90 degrees clockwise\n     * returning a newly allocated vector.\n     * <br/><br/>\n     * This is semantically equivalent to (the less optimal)\n     * <code>vec.copy().rotate(Math.PI/2)</code>\n     * <br/><br/>\n     * The cross and dot product are related like:\n     * <code>vec1.cross(vec2) == vec1.perp().dot(vec2)</code>\n     * Hence the name 'perp-dot'\n     *\n     * @param weak If true then the returned vector will be automatically\n     *             released to the global object pool when used as an argument\n     *             to another Nape function. (default false)\n     * @return     The possibly weakly allocated, right-perpendicular to this\n     *             vector.\n     * @throws # If this vector has been disposed.\n     */\n    #if nape_swc@:keep #end\n    public function perp(weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return Vec2.get(-y,x,weak);\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString():String{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.validate();\n        return zpp_inner.toString();\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass Vec2Iterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:Vec2List=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:Vec2Iterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:Vec2Iterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Vec2List.internal)throw \"Error: Cannot instantiate \"+\"Vec2\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:Vec2List){\n        var ret=if(zpp_pool==null){\n            ZPP_Vec2List.internal=true;\n            var ret=new Vec2Iterator();\n            ZPP_Vec2List.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=Vec2Iterator.zpp_pool;\n                Vec2Iterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Vec2 type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Vec2 = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Vec2 = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Vec2 = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!true@:final #end\n#if nape_swc@:keep #end\nclass Vec2List{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Vec2List=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if false inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Vec2\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Vec2>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new Vec2List();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Vec2)#else Std.is(i,Vec2)#end)throw \"Error: Array contains non \"+\"Vec2\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Vec2>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new Vec2List();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Vec2):Bool{\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Vec2{\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().wrapper();\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Vec2):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Vec2):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public  function add(obj:Vec2):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Vec2):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public  function empty(){\n        #if false if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public  function iterator(){\n        #if false zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return Vec2Iterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new Vec2List();\n        for(i in this)ret.push(deep?i.copy():i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:Vec2List):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_Vec2List();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public  function foreach(lambda:Vec2->Void):Vec2List{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=Vec2Iterator.zpp_pool;\n                    Vec2Iterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Vec2->Bool):Vec2List{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * A 3 dimensional vector object.\n * <br/><br/>\n * In many instances a Vec3 will be accessible from Nape which is marked\n * as immutable, these cases will be documented and modifying such a Vec3\n * will result in an error.\n */\n@:final#if nape_swc@:keep #end\nclass Vec3{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Vec3=null;\n    /**\n     * @private\n     */\n    public var zpp_pool:Vec3=null;\n    #if(!NAPE_RELEASE_BUILD)\n    /**\n     * @private\n     */\n    public var zpp_disp:Bool;\n    #end\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    /**\n     * The x component of Vec3.\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var x(get_x,set_x):Float;\n    inline function get_x():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.validate();\n        return zpp_inner.x;\n    }\n    inline function set_x(x:Float):Float{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.immutable){\n                throw \"Error: Vec3 is immutable\";\n            }\n            #end\n            zpp_inner.x=x;\n        }\n        return get_x();\n    }\n    /**\n     * The y component of Vec3.\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var y(get_y,set_y):Float;\n    inline function get_y():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.validate();\n        return zpp_inner.y;\n    }\n    inline function set_y(y:Float):Float{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.immutable){\n                throw \"Error: Vec3 is immutable\";\n            }\n            #end\n            zpp_inner.y=y;\n        }\n        return get_y();\n    }\n    /**\n     * The z component of Vec3.\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var z(get_z,set_z):Float;\n    inline function get_z():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner.validate();\n        return zpp_inner.z;\n    }\n    inline function set_z(z:Float):Float{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.immutable){\n                throw \"Error: Vec3 is immutable\";\n            }\n            #end\n            zpp_inner.z=z;\n        }\n        return get_z();\n    }\n    /**\n     * Allocate a Vec3 from the global object pool.\n     * <br/><br/>\n     * Use of this method should always be preferred to the constructor.\n     *\n     * @param x The x component of Vec3. (default 0)\n     * @param y The y component of Vec3. (default 0)\n     * @param z The z component of Vec3. (default 0)\n     * @return A Vec3 allocated from global object pool with given components.\n     */\n    public static function get(x:Float=0,y:Float=0,z:Float=0):Vec3{\n        var ret;\n        {\n            if(ZPP_PubPool.poolVec3==null){\n                ret=new Vec3();\n                #if NAPE_POOL_STATS Vec3.POOL_TOT++;\n                Vec3.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_PubPool.poolVec3;\n                ZPP_PubPool.poolVec3=ret.zpp_pool;\n                ret.zpp_pool=null;\n                #if(!NAPE_RELEASE_BUILD)\n                ret.zpp_disp=false;\n                if(ret==ZPP_PubPool.nextVec3)ZPP_PubPool.nextVec3=null;\n                #end\n                #if NAPE_POOL_STATS Vec3.POOL_CNT--;\n                Vec3.POOL_ADD++;\n                #end\n            }\n        };\n        ret.setxyz(x,y,z);\n        ret.zpp_inner.immutable=false;\n        ret.zpp_inner._validate=null;\n        return ret;\n    }\n    /**\n     * Construct a new Vec3.\n     * <br/><br/>\n     * This method should not generally be used with preference for the\n     * static get method which will make use of the global object pool.\n     *\n     * @param x The x component of Vec3. (default 0)\n     * @param y The y component of Vec3. (default 0)\n     * @param z The z component of Vec3. (default 0)\n     * @return A newly constructed Vec3 with given components.\n     */\n    public function new(x:Float=0,y:Float=0,z:Float=0){\n        zpp_inner=new ZPP_Vec3();\n        zpp_inner.outer=this;\n        {\n            {\n                this.x=x;\n                this.y=y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((this.x!=this.x));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(this.x)\"+\") :: \"+(\"vec_set(in n: \"+\"this.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((this.y!=this.y));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(this.y)\"+\") :: \"+(\"vec_set(in n: \"+\"this.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                    #end\n                };\n            };\n            this.z=z;\n        };\n    }\n    /**\n     * Produce a copy of this Vec3.\n     *\n     * @return The copy of this Vec3.\n     * @throws # If this Vec3 has been disposed of.\n    public function copy():Vec3{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return Vec3.get(x,y,z);\n    }\n    /**\n     * Release Vec3 object to global object pool.\n     *\n     * @throws # If this Vec3 has already been disposed of.\n     * @throws # If this Vec3 is immutable.\n     */\n    public function dispose():Void{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable){\n            throw \"Error: This Vec3 is not disposable\";\n        }\n        #end\n        {\n            var o=this;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"PublicFree(in T: \"+\"Vec3\"+\", in obj: \"+\"this\"+\")\");\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            o.zpp_pool=null;\n            if(ZPP_PubPool.nextVec3!=null)ZPP_PubPool.nextVec3.zpp_pool=o;\n            else ZPP_PubPool.poolVec3=o;\n            ZPP_PubPool.nextVec3=o;\n            #end\n            #if NAPE_RELEASE_BUILD \n            o.zpp_pool=ZPP_PubPool.poolVec3;\n            ZPP_PubPool.poolVec3=o;\n            #end\n            #if NAPE_POOL_STATS Vec3.POOL_CNT++;\n            Vec3.POOL_SUB++;\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            o.zpp_disp=true;\n            #end\n        };\n    }\n    /**\n     * Length of Vec3.\n     * <br/><br/>\n     * This value may also be set to any value including negatives, though\n     * an error will be thrown if length of the Vec3 is already 0 as such\n     * a scaling would be undefined. As well as if this Vec3 has been disposed\n     * of, or is immutable.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,set_length):Float;\n    inline function get_length():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return Math.sqrt(((this.x*this.x+this.y*this.y)+this.z*this.z));\n    }\n    inline function set_length(length:Float):Float{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if((length!=length)){\n                throw \"Error: Vec3::length cannot be NaN\";\n            }\n            if(((this.x*this.x+this.y*this.y)+this.z*this.z)==0){\n                throw \"Error: Cannot set length of a zero vector\";\n            }\n            #end\n            {\n                var t=((length/this.length));\n                {\n                    var t=(t);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"this.\"+\",in s: \"+\"t\"+\")\");\n                        #end\n                    };\n                    this.x*=t;\n                    this.y*=t;\n                };\n                this.z*=t;\n            };\n        }\n        return get_length();\n    }\n    /**\n     * Compute squared length of Vec3.\n     *\n     * @return The squared length of this Vec3.\n     * @throws # If the Vec3 has been disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function lsq():Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return((this.x*this.x+this.y*this.y)+this.z*this.z);\n    }\n    /**\n     * Set values of this Vec3 from another.\n     *\n     * @param vector The vector to set values from.\n     * @return A reference to this Vec3.\n     * @throws # If the vector argument is null.\n     * @throws # If this, or the vector argument are disposed of.\n     * @throws # If this Vec3 is immutable.\n     */\n    public function set(vector:Vec3):Vec3{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot assign null Vec3\";\n        }\n        #end\n        return setxyz(vector.x,vector.y,vector.z);\n    }\n    /**\n     * Set values of this Vec3 from numbers.\n     *\n     * @param x The new x component value for this vector.\n     * @param y The new y component value for this vector.\n     * @param z The new z component value for this vector.\n     * @return A reference to this Vec3.\n     * @throws # If this Vec3 has been disposed of.\n     * @throws # If this Vec3 is immutable.\n     */\n    public function setxyz(x:Float,y:Float,z:Float):Vec3{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            {\n                this.x=x;\n                this.y=y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((this.x!=this.x));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(this.x)\"+\") :: \"+(\"vec_set(in n: \"+\"this.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((this.y!=this.y));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(this.y)\"+\") :: \"+(\"vec_set(in n: \"+\"this.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                    #end\n                };\n            };\n            this.z=z;\n        };\n        return this;\n    }\n    /**\n     * Produce copy of the xy components of Vec3.\n     * <br/><br/>\n     * This function will return a new Vec2 completely seperate\n     * from this Vec3 with values equal to the xy components of\n     * this Vec3.\n     *\n     * @param weak If true, then the allocated Vec2 will be weak\n     *             so that when used as an argument to a Nape\n     *             function it will be automatically released back\n     *             to the global object pool. (default false)\n     * @return An allocated Vec2 representing the xy components of\n     *         this vector.\n     */\n    public function xy(weak:Bool=false):Vec2{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return Vec2.get(x,y,weak);\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString():String{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(this!=null&&this.zpp_disp)throw \"Error: \"+\"Vec3\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        return \"{ x: \"+x+\" y: \"+y+\" z: \"+z+\" }\";\n    }\n}\n","package nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration represents the winding of a Polygon.\n * <br/><br/>\n * To appreciate what the winding of a polygon means, think of a polygon who's\n * vertices are the numbers on a clock face.\n *\n * If the vertices are ordered <code>12 -&gt; 1 -&gt; 2 ... -&gt; 12</code>\n * then this polygon is clockwise wound. The reverse order would mean the\n * polygon is wound anticlockwise.\n */\n@:final#if nape_swc@:keep #end\nclass Winding{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"Winding\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==UNDEFINED)return\"UNDEFINED\";\n        else if(this==CLOCKWISE)return\"CLOCKWISE\";\n        else if(this==ANTICLOCKWISE)return\"ANTICLOCKWISE\";\n        else return \"\";\n    }\n    /**\n     * Value represents that the polygon has no discernible, or ambiguous winding\n     * <br/><br/>\n     * This may be because the polygon is degenerate, or because it is self\n     * intersecting. In either case it is not well defined to say that the winding\n     * is either clockwise or anticlockwise.\n     */\n    #if nape_swc@:isVar #end\n    public static var UNDEFINED(get_UNDEFINED,never):Winding;\n    inline static function get_UNDEFINED(){\n        if(ZPP_Flags.Winding_UNDEFINED==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.Winding_UNDEFINED=new Winding();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.Winding_UNDEFINED;\n    }\n    /**\n     * Value represents that the polygon is wound clockwise.\n     */\n    #if nape_swc@:isVar #end\n    public static var CLOCKWISE(get_CLOCKWISE,never):Winding;\n    inline static function get_CLOCKWISE(){\n        if(ZPP_Flags.Winding_CLOCKWISE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.Winding_CLOCKWISE=new Winding();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.Winding_CLOCKWISE;\n    }\n    /**\n     * Value represents that the polygon is wound anticlockwise.\n     */\n    #if nape_swc@:isVar #end\n    public static var ANTICLOCKWISE(get_ANTICLOCKWISE,never):Winding;\n    inline static function get_ANTICLOCKWISE(){\n        if(ZPP_Flags.Winding_ANTICLOCKWISE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.Winding_ANTICLOCKWISE=new Winding();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.Winding_ANTICLOCKWISE;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass Interactor{\n    /**\n     * @private\n     */\n    public var zpp_inner_i:ZPP_Interactor=null;\n    /**\n     * Unique id of this Interactor.\n     */\n    #if nape_swc@:isVar #end\n    public var id(get_id,never):Int;\n    inline function get_id():Int{\n        return zpp_inner_i.id;\n    }\n    /**\n     * Dynamic object for user to store additional data.\n     * <br/><br/>\n     * This object cannot be set, only its dynamically created\n     * properties may be set. In AS3 the type of this property is &#42\n     * <br/><br/>\n     * This object will be lazily constructed so that until accessed\n     * for the first time, will be null internally.\n     *\n     * @default {}\n     */\n    #if nape_swc@:isVar #end\n    public var userData(get_userData,never):Dynamic<Dynamic>;\n    inline function get_userData():Dynamic<Dynamic>{\n        if(zpp_inner_i.userData==null){\n            zpp_inner_i.userData=cast{};\n        }\n        return zpp_inner_i.userData;\n    }\n    /**\n     * Fast equivalent to <code>Std.is(interactor, Shape)</code>\n     * @return true if this Interactor is a Shape.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function isShape(){\n        return zpp_inner_i.ishape!=null;\n    }\n    /**\n     * Fast equivalent to <code>Std.is(interactor, Body)</code>\n     * @return true if this Interactor is a Body.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function isBody(){\n        return zpp_inner_i.ibody!=null;\n    }\n    /**\n     * Fast equivalent to <code>Std.is(interactor, Compound)</code>\n     * @return true if this Interactor is a Compound.\n     */\n    public#if NAPE_NO_INLINE#else inline #end\n    function isCompound(){\n        return zpp_inner_i.icompound!=null;\n    }\n    /**\n     * Fast equivalent to <code>cast(interactor, Shape)</code>\n     */\n    #if nape_swc@:isVar #end\n    public var castShape(get_castShape,never):Null<Shape>;\n    inline function get_castShape():Null<Shape>{\n        return if(isShape())zpp_inner_i.ishape.outer else null;\n    }\n    /**\n     * Fast equivalent to <code>cast(interactor, Body)</code>\n     */\n    #if nape_swc@:isVar #end\n    public var castBody(get_castBody,never):Null<Body>;\n    inline function get_castBody():Null<Body>{\n        return if(isBody())zpp_inner_i.ibody.outer else null;\n    }\n    /**\n     * Fast equivalent to <code>cast(interactor, Compound)</code>\n     */\n    #if nape_swc@:isVar #end\n    public var castCompound(get_castCompound,never):Null<Compound>;\n    inline function get_castCompound():Null<Compound>{\n        return if(isCompound())zpp_inner_i.icompound.outer else null;\n    }\n    /**\n     * InteractionGroup assigned to this Interactor.\n     *\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var group(get_group,set_group):Null<InteractionGroup>;\n    inline function get_group():Null<InteractionGroup>{\n        return if(zpp_inner_i.group==null)null else zpp_inner_i.group.outer;\n    }\n    inline function set_group(group:Null<InteractionGroup>):Null<InteractionGroup>{\n        {\n            zpp_inner_i.immutable_midstep(\"Interactor::group\");\n            zpp_inner_i.setGroup(group==null?null:group.zpp_inner);\n        }\n        return get_group();\n    }\n    /**\n     * Set of CbType's assigned to this Interactor.\n     *\n     * @default []\n     */\n    #if nape_swc@:isVar #end\n    public var cbTypes(get_cbTypes,never):CbTypeList;\n    inline function get_cbTypes():CbTypeList{\n        if(zpp_inner_i.wrap_cbTypes==null)zpp_inner_i.setupcbTypes();\n        return zpp_inner_i.wrap_cbTypes;\n    }\n    /**\n     * @private\n     */\n    #if(!NAPE_RELEASE_BUILD)\n    public static var zpp_internalAlloc=false;\n    #end\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!zpp_internalAlloc)throw \"Error: Cannot instantiate an Interactor, only Shape/Body/Compound\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        return \"\";\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Class representing a physics Rigid Body.\n */\n@:final#if nape_swc@:keep #end\nclass Body extends Interactor{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Body=null;\n    /**\n     * Set to disable debug drawing/\n     * <br/><br/>\n     * When true, this Body will not be drawn during debug draw operations\n     * unless specifically given as argument to Debug draw() method.\n     * @default true\n     */\n    public var debugDraw:Bool=true;\n    /**\n     * Type of body.\n     * <br/><br/>\n     * This value can be changed even if Body is inside of a Space.\n     */\n    #if nape_swc@:isVar #end\n    public var type(get_type,set_type):BodyType;\n    inline function get_type():BodyType{\n        return ZPP_Body.types[zpp_inner.type];\n    }\n    inline function set_type(type:BodyType):BodyType{\n        {\n            zpp_inner.immutable_midstep(\"Body::type\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            if(this.type!=type){\n                #if(!NAPE_RELEASE_BUILD)\n                if(type==null)throw \"Error: Cannot use null BodyType\";\n                #end\n                var ntype=type==BodyType.DYNAMIC?ZPP_Flags.id_BodyType_DYNAMIC:type==BodyType.KINEMATIC?ZPP_Flags.id_BodyType_KINEMATIC:ZPP_Flags.id_BodyType_STATIC;\n                if(ntype==ZPP_Flags.id_BodyType_STATIC&&zpp_inner.space!=null){\n                    {\n                        zpp_inner.velx=0;\n                        zpp_inner.vely=0;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((zpp_inner.velx!=zpp_inner.velx));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.velx)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.vel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((zpp_inner.vely!=zpp_inner.vely));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.vely)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.vel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                            #end\n                        };\n                    };\n                    zpp_inner.angvel=0;\n                }\n                zpp_inner.invalidate_type();\n                if(zpp_inner.space!=null)zpp_inner.space.transmitType(zpp_inner,ntype);\n                else zpp_inner.type=ntype;\n            }\n        }\n        return get_type();\n    }\n    /**\n     * Mark object for continuous collisions against other dynamic Bodies\n     * <br/><br/>\n     * If true, then this Body will undergo continuous collisions with other\n     * dynamic Bodies. This flag has no effect for non-dynamic Bodies.\n     * <br/><br/>\n     * This flag should only be set for very fast, small moving dynamic bodies,\n     * and due to the way continuous collisions are resolved it is not wise to\n     * enable this for a large group of bodies that interact together as it\n     * will lead to visual stalling.\n     * <br/>\n     * Bullets also do not play well when existing in a group with respect to\n     * continuous collisions against kinematic objects and may cause\n     * tunnelling against the kinematic.\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var isBullet(get_isBullet,set_isBullet):Bool;\n    inline function get_isBullet():Bool{\n        return zpp_inner.bulletEnabled;\n    }\n    inline function set_isBullet(isBullet:Bool):Bool{\n        {\n            zpp_inner.bulletEnabled=isBullet;\n        }\n        return get_isBullet();\n    }\n    /**\n     * Declare object should never be collided continuously\n     * <br/><br/>\n     * When performing continuous collisions, Nape will check both Bodies to see\n     * if either has opted-out of CCD. If either Body has this flag true, then\n     * no CCD will be performed for that pair.\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var disableCCD(get_disableCCD,set_disableCCD):Bool;\n    inline function get_disableCCD():Bool{\n        return zpp_inner.disableCCD;\n    }\n    inline function set_disableCCD(disableCCD:Bool):Bool{\n        {\n            zpp_inner.disableCCD=disableCCD;\n        }\n        return get_disableCCD();\n    }\n    /**\n     * Integrate body forward in time, taking only velocities into account.\n     *\n     * @param deltaTime The time to integrate body by. This value may be negative to\n     *                  integrate back in time.\n     * @return A refernce to 'this' Body\n     */\n    #if nape_swc@:keep #end\n    public function integrate(deltaTime:Float){\n        #if(!NAPE_RELEASE_BUILD)\n        if((deltaTime!=deltaTime))throw \"Cannot integrate by NaN time\";\n        #end\n        zpp_inner.immutable_midstep(\"Body::space\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        if(deltaTime==0)return this;\n        var cur=this.zpp_inner;\n        cur.sweepTime=0;\n        cur.sweep_angvel=cur.angvel;\n        cur.sweepIntegrate(deltaTime);\n        cur.invalidate_pos();\n        cur.invalidate_rot();\n        cur.sweepTime=0;\n        return this;\n    }\n    /**\n     * Fast equivalent to <code>body.type == BodyType.STATIC</code>\n     * @return True if body is Static.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isStatic(){\n        return zpp_inner.isStatic();\n    }\n    /**\n     * Fast equivalent to <code>body.type == BodyType.DYNAMIC</code>\n     * @return True if body is Dynamic.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isDynamic(){\n        return zpp_inner.isDynamic();\n    }\n    /**\n     * Fast equivalent to <code>body.type == BodyType.KINEMATIC</code>\n     * @return True if body is Kinematic.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isKinematic(){\n        return zpp_inner.isKinematic();\n    }\n    /**\n     * List of shapes owned by Body.\n     * <br/><br/>\n     * Appending a Shape to this list is equivalent to <code>shape.body = this</code>\n     *\n     * @default []\n     */\n    #if nape_swc@:isVar #end\n    public var shapes(get_shapes,never):ShapeList;\n    inline function get_shapes():ShapeList{\n        return zpp_inner.wrap_shapes;\n    }\n    /**\n     * Compound this Body belongs to.\n     * <br/><br/>\n     * If this Body belongs to a Compound, then the Compound 'owns' this Body and\n     * it is the Compound which would be added/removed from a Space rather than\n     * this Body.\n     *\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var compound(get_compound,set_compound):Null<Compound>;\n    inline function get_compound():Null<Compound>{\n        return if(zpp_inner.compound==null)null else zpp_inner.compound.outer;\n    }\n    inline function set_compound(compound:Null<Compound>):Null<Compound>{\n        {\n            if(this.compound!=compound){\n                if(this.compound!=null)this.compound.bodies.remove(this);\n                if(compound!=null)compound.bodies.add(this);\n            }\n        }\n        return get_compound();\n    }\n    /**\n     * Space this Body is assigned to.\n     * <br/><br/>\n     * When this Body is part of a Compound, this value is immutable.\n     * <br/>\n     * When a Body is part of a Compound it is owned by that Compound and it\n     * is the Compound that is added/removed from a Space.\n     */\n    #if nape_swc@:isVar #end\n    public var space(get_space,set_space):Null<Space>;\n    inline function get_space():Null<Space>{\n        return if(zpp_inner.space==null)null else zpp_inner.space.outer;\n    }\n    inline function set_space(space:Null<Space>):Null<Space>{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.compound!=null)throw \"Error: Cannot set the space of a Body belonging to a Compound, only the root Compound space can be set\";\n            #end\n            zpp_inner.immutable_midstep(\"Body::space\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            if(this.space!=space){\n                if(this.space!=null)zpp_inner.component.woken=false;\n                if(this.space!=null)this.space.bodies.remove(this);\n                if(space!=null)space.bodies.add(this);\n            }\n        }\n        return get_space();\n    }\n    /**\n     * Set of active arbiters related to this Body.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var arbiters(get_arbiters,never):ArbiterList;\n    inline function get_arbiters():ArbiterList{\n        if(zpp_inner.wrap_arbiters==null)zpp_inner.wrap_arbiters=ZPP_ArbiterList.get(zpp_inner.arbiters,true);\n        return zpp_inner.wrap_arbiters;\n    }\n    /**\n     * Whether this body is sleeping.\n     * <br/><br/>\n     * This value is immutable, In Nape you do not ever need to manually wake up a Body.\n     * It will always be done automatically without error.\n     * <br/><br/>\n     * To manually put a Body to sleep is against the very nature of Nape API\n     * and so is excluded from the core of Nape. If you really want to do this\n     * then you should make use of the nape-hacks module.\n     */\n    #if nape_swc@:isVar #end\n    public var isSleeping(get_isSleeping,never):Bool;\n    inline function get_isSleeping():Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.space==null)throw \"Error: isSleeping makes no sense if the object is not contained within a Space\";\n        #end\n        return zpp_inner.component.sleeping;\n    }\n    /**\n     * Set of constraints using this Body.\n     * <br/><br/>\n     * This list contains those constraints that are inside of a Space only.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var constraints(get_constraints,never):ConstraintList;\n    inline function get_constraints():ConstraintList{\n        if(zpp_inner.wrap_constraints==null)zpp_inner.wrap_constraints=ZPP_ConstraintList.get(zpp_inner.constraints,true);\n        return zpp_inner.wrap_constraints;\n    }\n    /**\n     * Construct a new Body.\n     * <br/><br/>\n     * @param type The type of Body to create. (default DYNAMIC)\n     * @param position The initial position for object. (default &#40;0,0&#41;)\n     * @return The newly constructed Body.\n     * @throws # If position is non-null, and has been disposed of.\n     */\n    #if flib@:keep function flibopts_2(){}\n    #end\n    public function new(type:BodyType=null,position:Vec2=null){\n        #if(!NAPE_RELEASE_BUILD)\n        Interactor.zpp_internalAlloc=true;\n        super();\n        Interactor.zpp_internalAlloc=false;\n        #end\n        #if NAPE_RELEASE_BUILD \n        super();\n        #end\n        zpp_inner=new ZPP_Body();\n        zpp_inner.outer=this;\n        zpp_inner.outer_i=this;\n        zpp_inner_i=zpp_inner;\n        if(position!=null){\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(position!=null&&position.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            {\n                zpp_inner.posx=position.x;\n                zpp_inner.posy=position.y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((zpp_inner.posx!=zpp_inner.posx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.posx)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.pos\"+\",in x: \"+\"position.x\"+\",in y: \"+\"position.y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((zpp_inner.posy!=zpp_inner.posy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.posy)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.pos\"+\",in x: \"+\"position.x\"+\",in y: \"+\"position.y\"+\")\");\n                    #end\n                };\n            };\n        }\n        else{\n            zpp_inner.posx=0;\n            zpp_inner.posy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((zpp_inner.posx!=zpp_inner.posx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.posx)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.pos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((zpp_inner.posy!=zpp_inner.posy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.posy)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.pos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        this.type=type==null?BodyType.DYNAMIC:type;\n        if(position!=null)({\n            if(({\n                position.zpp_inner.weak;\n            })){\n                position.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        zpp_inner_i.insert_cbtype(CbType.ANY_BODY.zpp_inner);\n    }\n    /**\n     * Construct an exact copy of this Body.\n     * <br/><br/>\n     * All properties will be exactly copied, with Shapes also\n     * being copied with the copied Body's and Shape's userData\n     * objects being assigned the same fields as the existing ones with\n     * values copied over by reference for object types.\n     *\n     * @return A copy of this Body.\n     */\n    #if nape_swc@:keep #end\n    public function copy(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world cannot be copied\";\n        #end\n        return zpp_inner.copy();\n    }\n    /**\n     * Position of Body's origin in px.\n     * <br/><br/>\n     * This value can be set and is equivalent to: <code>this.position.set(value)</code>\n     * <br/><br/>\n     * Attempting to set this value on a static Body that is in a Space will result\n     * in a debug build error.\n     * <br/><br/>\n     * Please note that for kinematic objects, setting this value is equiavalent\n     * to 'teleporting' the object, and for normal movement you should be using\n     * the kinematic body's velocity.\n     *\n     * @default (0,0)\n     */\n    #if nape_swc@:isVar #end\n    public var position(get_position,set_position):Vec2;\n    inline function get_position():Vec2{\n        if(zpp_inner.wrap_pos==null)zpp_inner.setupPosition();\n        return zpp_inner.wrap_pos;\n    }\n    inline function set_position(position:Vec2):Vec2{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(position!=null&&position.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(position==null)throw \"Error: Body::\"+\"position\"+\" cannot be null\";\n            #end\n            this.position.set(position);\n        }\n        return get_position();\n    }\n    /**\n     * Linear velocity of Body's origin in px/s.\n     * <br/><br/>\n     * This value can be set and is equivalent to: <code>this.velocity.set(value)</code>\n     * <br/><br/>\n     * A static body cannot have its velocity set.\n     *\n     * @default (0,0)\n     */\n    #if nape_swc@:isVar #end\n    public var velocity(get_velocity,set_velocity):Vec2;\n    inline function get_velocity():Vec2{\n        if(zpp_inner.wrap_vel==null)zpp_inner.setupVelocity();\n        return zpp_inner.wrap_vel;\n    }\n    inline function set_velocity(velocity:Vec2):Vec2{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(velocity!=null&&velocity.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(velocity==null)throw \"Error: Body::\"+\"velocity\"+\" cannot be null\";\n            #end\n            this.velocity.set(velocity);\n        }\n        return get_velocity();\n    }\n    /**\n     * Set velocities to achieve desired position at end of time step.\n     * <br/><br/>\n     * This function is a utility to help with animating kinematic bodies.\n     * Kinematic bodies should be moved through velocity, but it is often\n     * easier to think in terms of position.\n     * <br/><br/>\n     * This method will set linear and angular velocities so that the target\n     * position/rotation is achieved at end of time step.\n     *\n     * @param targetPosition The target position for Body.\n     * @param targetRotation The target rotation for Body.\n     * @param deltaTime The time step for next call to space.step().\n     * @throws # If targetPosition is null or disposed of.\n     * @returns A reference to 'this' Body.\n     */\n    #if nape_swc@:keep #end\n    public function setVelocityFromTarget(targetPosition:Vec2,targetRotation:Float,deltaTime:Float){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(targetPosition!=null&&targetPosition.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(targetPosition==null)throw \"Cannot set velocity for null target position\";\n        if(deltaTime==0)throw \"deltaTime cannot be 0 for setVelocityFromTarget\";\n        #end\n        var idt=(1/deltaTime);\n        this.velocity.set(targetPosition.sub(this.position,true).muleq(idt));\n        this.angularVel=(targetRotation-this.rotation)*idt;\n        ({\n            if(({\n                targetPosition.zpp_inner.weak;\n            })){\n                targetPosition.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Additional kinematic velocity of Body in px/s.\n     * <br/><br/>\n     * A bodies 'kinematic' velocity is an added velocity bias used in all physics\n     * computations but that will not effect how the Body moves directly.\n     * <br/><br/>\n     * Even a static body can be given a kinematic velocity, and can be used for\n     * such things as giving a body of water a fluid-velocity for fluid drag\n     * computations.\n     *\n     * @default (0,0)\n     */\n    #if nape_swc@:isVar #end\n    public var kinematicVel(get_kinematicVel,set_kinematicVel):Vec2;\n    inline function get_kinematicVel():Vec2{\n        if(zpp_inner.wrap_kinvel==null)zpp_inner.setupkinvel();\n        return zpp_inner.wrap_kinvel;\n    }\n    inline function set_kinematicVel(kinematicVel:Vec2):Vec2{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(kinematicVel!=null&&kinematicVel.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(kinematicVel==null)throw \"Error: Body::\"+\"kinematicVel\"+\" cannot be null\";\n            #end\n            this.kinematicVel.set(kinematicVel);\n        }\n        return get_kinematicVel();\n    }\n    /**\n     * Additional surface velocity for Body in px/s.\n     * <br/><br/>\n     * A bodies 'surface' velocity is an added velocity bias that is rotated to match\n     * the angle of the contact surface used in contact physics and will not\n     * effect how the Body moves directly.\n     * <br/><br/>\n     * Even a static body can be given a surface velocity, and can be used for\n     * such things as conveyor belts (By setting the x-component of surfaceVel).\n     *\n     * @default (0,0)\n     */\n    #if nape_swc@:isVar #end\n    public var surfaceVel(get_surfaceVel,set_surfaceVel):Vec2;\n    inline function get_surfaceVel():Vec2{\n        if(zpp_inner.wrap_svel==null)zpp_inner.setupsvel();\n        return zpp_inner.wrap_svel;\n    }\n    inline function set_surfaceVel(surfaceVel:Vec2):Vec2{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(surfaceVel!=null&&surfaceVel.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(surfaceVel==null)throw \"Error: Body::\"+\"surfaceVel\"+\" cannot be null\";\n            #end\n            this.surfaceVel.set(surfaceVel);\n        }\n        return get_surfaceVel();\n    }\n    /**\n     * Accumulated force acting on body in px.kg/s/s\n     * <br/><br/>\n     * This value is not used internally for any physics computations.\n     * <br/><br/>\n     * You may set this property only on dynamic bodies.\n     *\n     * @default (0,0)\n     */\n    #if nape_swc@:isVar #end\n    public var force(get_force,set_force):Vec2;\n    inline function get_force():Vec2{\n        if(zpp_inner.wrap_force==null)zpp_inner.setupForce();\n        return zpp_inner.wrap_force;\n    }\n    inline function set_force(force:Vec2):Vec2{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(force!=null&&force.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(force==null)throw \"Error: Body::\"+\"force\"+\" cannot be null\";\n            #end\n            this.force.set(force);\n        }\n        return get_force();\n    }\n    /**\n     * This property represents the velocity seen by constraint physics.\n     * <br/><br/>\n     * You should not need to use this property unless writing your own\n     * constraints using the UserConstraint API.\n     */\n    #if nape_swc@:isVar #end\n    public var constraintVelocity(get_constraintVelocity,never):Vec3;\n    inline function get_constraintVelocity():Vec3{\n        if(zpp_inner.wrapcvel==null)zpp_inner.setup_cvel();\n        return zpp_inner.wrapcvel;\n    }\n    /**\n     * Rotation of Body in clockwise rad.\n     * <br/><br/>\n     * Attempting to set this value on a static Body that is in a Space will result\n     * in a debug build error.\n     * <br/><br/>\n     * Please note that for kinematic objects, setting this value is equiavalent\n     * to 'teleporting' the object, and for normal movement you should be using\n     * the kinematic body's angularVel.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var rotation(get_rotation,set_rotation):Float;\n    inline function get_rotation():Float{\n        return zpp_inner.rot;\n    }\n    inline function set_rotation(rotation:Float):Float{\n        {\n            zpp_inner.immutable_midstep(\"Body::rotation\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if(isStatic()&&zpp_inner.space!=null)throw \"Error: Static objects cannot be rotated once inside a Space\";\n            #end\n            if(this.rotation!=rotation){\n                #if(!NAPE_RELEASE_BUILD)\n                if((rotation!=rotation))throw \"Error: Body::rotation cannot be NaN\";\n                #end\n                zpp_inner.rot=rotation;\n                zpp_inner.invalidate_rot();\n                zpp_inner.wake();\n            }\n        }\n        return get_rotation();\n    }\n    /**\n     * Angular velocity of Body in clockwise rad/s\n     * <br/><br/>\n     * A static body cannot have its angular velocity set.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var angularVel(get_angularVel,set_angularVel):Float;\n    inline function get_angularVel():Float{\n        return zpp_inner.angvel;\n    }\n    inline function set_angularVel(angularVel:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            if(this.angularVel!=angularVel){\n                #if(!NAPE_RELEASE_BUILD)\n                if((angularVel!=angularVel))throw \"Error: Body::angularVel cannot be NaN\";\n                #end\n                #if(!NAPE_RELEASE_BUILD)\n                if(zpp_inner.isStatic())throw \"Error: A static object cannot be given a velocity\";\n                #end\n                zpp_inner.angvel=angularVel;\n                zpp_inner.invalidate_wake();\n            }\n        }\n        return get_angularVel();\n    }\n    /**\n     * Additional kinematic angular velocity of Body in rad/s.\n     * <br/><br/>\n     * A bodies 'kinematic' velocity is an added velocity bias used in all physics\n     * computations but that will not effect how the Body moves directly.\n     * <br/><br/>\n     * Even a static body can be given a kinematic velocity, and can be used for\n     * such things as giving a body of water a fluid-velocity for fluid drag\n     * computations.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var kinAngVel(get_kinAngVel,set_kinAngVel):Float;\n    inline function get_kinAngVel():Float{\n        return zpp_inner.kinangvel;\n    }\n    inline function set_kinAngVel(kinAngVel:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            if(this.kinAngVel!=kinAngVel){\n                #if(!NAPE_RELEASE_BUILD)\n                if((kinAngVel!=kinAngVel))throw \"Error: Body::kinAngVel cannot be NaN\";\n                #end\n                zpp_inner.kinangvel=kinAngVel;\n                zpp_inner.invalidate_wake();\n            }\n        }\n        return get_kinAngVel();\n    }\n    /**\n     * Accumulated torque acting on body in px.px.kg/s/s\n     * <br/><br/>\n     * This value is not used internally for any physics computations.\n     * <br/><br/>\n     * You may set this property only on dynamic bodies.\n     *\n     * @default 0\n     */\n    #if nape_swc@:isVar #end\n    public var torque(get_torque,set_torque):Float;\n    inline function get_torque():Float{\n        return zpp_inner.torque;\n    }\n    inline function set_torque(torque:Float):Float{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if(!isDynamic())throw \"Error: Non-dynamic body cannot have torque applied.\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((torque!=torque))throw \"Error: Body::torque cannot be NaN\";\n            #end\n            if(this.torque!=torque){\n                zpp_inner.torque=torque;\n                zpp_inner.invalidate_wake();\n            }\n        }\n        return get_torque();\n    }\n    /**\n     * Bounding box of Body in world space.\n     * <br/><br/>\n     * This value can be accessed even if there are no Shapes in the Body, but\n     * attempting to query its values whilst there are no Shapes will result\n     * in a debug build error.\n     * <br/><br/>\n     * This AABB is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var bounds(get_bounds,never):AABB;\n    inline function get_bounds():AABB{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world has no bounds\";\n        #end\n        return zpp_inner.aabb.wrapper();\n    }\n    /**\n     * Whether dynamic Body is permitted to be moved by physics linearly.\n     * <br/><br/>\n     * When this field is false, no physics will be able to cause a change in the\n     * bodies linear velocity (It can still move, but only if you tell it to like\n     * a kinematic body).\n     *\n     * @default true\n     */\n    #if nape_swc@:isVar #end\n    public var allowMovement(get_allowMovement,set_allowMovement):Bool;\n    inline function get_allowMovement():Bool{\n        return!zpp_inner.nomove;\n    }\n    inline function set_allowMovement(allowMovement:Bool):Bool{\n        {\n            zpp_inner.immutable_midstep(\"Body::\"+allowMovement);\n            if(this.allowMovement!=allowMovement){\n                zpp_inner.nomove=!allowMovement;\n                zpp_inner.invalidate_mass();\n            }\n        }\n        return get_allowMovement();\n    }\n    /**\n     * Whether dynamic Body is permitted to be rotated by physics.\n     * <br/><br/>\n     * When this field is false, no physics will be able to cause a change in the\n     * bodies angular velocity (It can still rotate, but only if you tell it to like\n     * a kinematic body).\n     *\n     * @default true\n     */\n    #if nape_swc@:isVar #end\n    public var allowRotation(get_allowRotation,set_allowRotation):Bool;\n    inline function get_allowRotation():Bool{\n        return!zpp_inner.norotate;\n    }\n    inline function set_allowRotation(allowRotation:Bool):Bool{\n        {\n            zpp_inner.immutable_midstep(\"Body::\"+allowRotation);\n            if(this.allowRotation!=allowRotation){\n                zpp_inner.norotate=!allowRotation;\n                zpp_inner.invalidate_inertia();\n            }\n        }\n        return get_allowRotation();\n    }\n    /**\n     * Method of mass computation for Body.\n     * <br/><br/>\n     * This value will be set implicitly to FIXED when mass property is set.\n     * <br/>Setting back to DEFAULT will then set mass implicitly back to the default\n     * computed mass.\n     *\n     * @default MassMode.DEFAULT\n     */\n    #if nape_swc@:isVar #end\n    public var massMode(get_massMode,set_massMode):MassMode;\n    inline function get_massMode():MassMode{\n        return[MassMode.DEFAULT,MassMode.FIXED][zpp_inner.massMode];\n    }\n    inline function set_massMode(massMode:MassMode):MassMode{\n        {\n            zpp_inner.immutable_midstep(\"Body::massMode\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if(massMode==null)throw \"Error: cannot use null massMode\";\n            #end\n            zpp_inner.massMode=massMode==MassMode.DEFAULT?ZPP_Flags.id_MassMode_DEFAULT:ZPP_Flags.id_MassMode_FIXED;\n            zpp_inner.invalidate_mass();\n        }\n        return get_massMode();\n    }\n    /**\n     * Mass to be used for a Body in User built constraints.\n     * <br/><br/>\n     * This value is given as the inverse mass of the Body taking into account\n     * Body type (Static and Kinematic Bodies will have constraintMass of 0)\n     * as well as properties like allowMovement.\n     */\n    #if nape_swc@:isVar #end\n    public var constraintMass(get_constraintMass,never):Float;\n    inline function get_constraintMass():Float{\n        if(!zpp_inner.world)zpp_inner.validate_mass();\n        return zpp_inner.smass;\n    }\n    /**\n     * Mass of the Body.\n     * <br/><br/>\n     * This value is computed by default based on the Body's Shape's areas and\n     * Material densities.\n     * <br/>\n     * When massMode is DEFAULT, accessing this value for an empty Body will thus\n     * give an error as the value is undefined.\n     * <br/><br/>\n     * Setting this value will permit you to give a fixed mass to the Body\n     * implicitly changing the massMode to MassMode.FIXED\n     */\n    #if nape_swc@:isVar #end\n    public var mass(get_mass,set_mass):Float;\n    inline function get_mass():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world has no mass\";\n        #end\n        zpp_inner.validate_mass();\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.massMode==ZPP_Flags.id_MassMode_DEFAULT&&zpp_inner.shapes.empty())throw \"Error: Given current mass mode, Body::mass only makes sense if it contains shapes\";\n        #end\n        return zpp_inner.cmass;\n    }\n    inline function set_mass(mass:Float):Float{\n        {\n            zpp_inner.immutable_midstep(\"Body::mass\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((mass!=mass))throw \"Error: Mass cannot be NaN\";\n            if(mass<=0)throw \"Error: Mass must be strictly positive\";\n            if(mass>=ZPP_Const.POSINF())throw \"Error: Mass cannot be infinite, use allowMovement = false instead\";\n            #end\n            zpp_inner.massMode=ZPP_Flags.id_MassMode_FIXED;\n            zpp_inner.cmass=mass;\n            zpp_inner.invalidate_mass();\n        }\n        return get_mass();\n    }\n    /**\n     * Method of computing mass as seen by gravity.\n     * <br/><br/>\n     * This value will be implicitly set by modifying gravMass or gravMassScale properties.\n     *\n     * @default GravMassMode.DEFAULT\n     */\n    #if nape_swc@:isVar #end\n    public var gravMassMode(get_gravMassMode,set_gravMassMode):GravMassMode;\n    inline function get_gravMassMode():GravMassMode{\n        return[GravMassMode.DEFAULT,GravMassMode.FIXED,GravMassMode.SCALED][zpp_inner.massMode];\n    }\n    inline function set_gravMassMode(gravMassMode:GravMassMode):GravMassMode{\n        {\n            zpp_inner.immutable_midstep(\"Body::gravMassMode\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if(gravMassMode==null)throw \"Error: Cannot use null gravMassMode\";\n            #end\n            zpp_inner.gravMassMode=gravMassMode==GravMassMode.SCALED?ZPP_Flags.id_GravMassMode_SCALED:gravMassMode==GravMassMode.DEFAULT?ZPP_Flags.id_GravMassMode_DEFAULT:ZPP_Flags.id_GravMassMode_FIXED;\n            zpp_inner.invalidate_gravMass();\n        }\n        return get_gravMassMode();\n    }\n    /**\n     * Mass used in gravity computations in a Space.\n     * <br/><br/>\n     * Setting this value will implicitly change the gravMassMode to FIXED.\n     * <br/>\n     * Set to 0 to disable gravity for this Body.\n     */\n    #if nape_swc@:isVar #end\n    public var gravMass(get_gravMass,set_gravMass):Float;\n    inline function get_gravMass():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world has no gravMass\";\n        #end\n        zpp_inner.validate_gravMass();\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.shapes.empty()){\n            if(zpp_inner.massMode==ZPP_Flags.id_MassMode_DEFAULT&&zpp_inner.gravMassMode!=ZPP_Flags.id_GravMassMode_FIXED)throw \"Error: Given current mass/gravMass modes; Body::gravMass only makes sense if it contains Shapes\";\n        }\n        #end\n        return zpp_inner.gravMass;\n    }\n    inline function set_gravMass(gravMass:Float):Float{\n        {\n            zpp_inner.immutable_midstep(\"Body::gravMass\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((gravMass!=gravMass))throw \"Error: gravMass cannot be NaN\";\n            #end\n            zpp_inner.gravMassMode=ZPP_Flags.id_GravMassMode_FIXED;\n            zpp_inner.gravMass=gravMass;\n            zpp_inner.invalidate_gravMass();\n        }\n        return get_gravMass();\n    }\n    /**\n     * Mass scale used in computation of gravity for Body in Space.\n     * <br/><br/>\n     * Setting this value will implicitly change the gravMassMode to SCALED.\n     * <br/>\n     * When set, the gravMass of Body will be computed as this scaling factor\n     * multiplied with the Body's mass.\n     */\n    #if nape_swc@:isVar #end\n    public var gravMassScale(get_gravMassScale,set_gravMassScale):Float;\n    inline function get_gravMassScale():Float{\n        zpp_inner.validate_gravMassScale();\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.shapes.empty()){\n            if(zpp_inner.massMode==ZPP_Flags.id_MassMode_DEFAULT&&zpp_inner.gravMassMode!=ZPP_Flags.id_GravMassMode_SCALED)throw \"Error: Given current mass/gravMass modes; Body::gravMassScale only makes sense if it contains Shapes\";\n        }\n        #end\n        return zpp_inner.gravMassScale;\n    }\n    inline function set_gravMassScale(gravMassScale:Float):Float{\n        {\n            zpp_inner.immutable_midstep(\"Body::gravMassScale\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((gravMassScale!=gravMassScale))throw \"Error: gravMassScale cannot be NaN\";\n            #end\n            zpp_inner.gravMassMode=ZPP_Flags.id_GravMassMode_SCALED;\n            zpp_inner.gravMassScale=gravMassScale;\n            zpp_inner.invalidate_gravMassScale();\n        }\n        return get_gravMassScale();\n    }\n    /**\n     * Method of computing Body moment of inertia.\n     * <br/><br/>\n     * This value will be set implicitly by modifying Body inertia property.\n     *\n     * @default InertiaMode.DEFAULT\n     */\n    #if nape_swc@:isVar #end\n    public var inertiaMode(get_inertiaMode,set_inertiaMode):InertiaMode;\n    inline function get_inertiaMode():InertiaMode{\n        return[InertiaMode.DEFAULT,InertiaMode.FIXED][zpp_inner.inertiaMode];\n    }\n    inline function set_inertiaMode(inertiaMode:InertiaMode):InertiaMode{\n        {\n            zpp_inner.immutable_midstep(\"Body::inertiaMode\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if(inertiaMode==null)throw \"Error: Cannot use null InertiaMode\";\n            #end\n            zpp_inner.inertiaMode=inertiaMode==InertiaMode.FIXED?ZPP_Flags.id_InertiaMode_FIXED:ZPP_Flags.id_InertiaMode_DEFAULT;\n            zpp_inner.invalidate_inertia();\n        }\n        return get_inertiaMode();\n    }\n    /**\n     * Moment of inertia to be used in user defined Constraints.\n     * <br/><br/>\n     * This value is equal to the inverse inertia of the Body taking into account\n     * Body type (Static and Kinematic bodies will have constraintInertia of 0).\n     * As well as properties like allowRotation.\n     */\n    #if nape_swc@:isVar #end\n    public var constraintInertia(get_constraintInertia,never):Float;\n    inline function get_constraintInertia():Float{\n        if(!zpp_inner.world)zpp_inner.validate_inertia();\n        return zpp_inner.sinertia;\n    }\n    /**\n     * Moment of inertia of this Body.\n     * <br/><br/>\n     * Setting this value will implicitly change the inertiaMode to FIXED.\n     */\n    #if nape_swc@:isVar #end\n    public var inertia(get_inertia,set_inertia):Float;\n    inline function get_inertia():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world has no inertia\";\n        #end\n        zpp_inner.validate_inertia();\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.inertiaMode==ZPP_Flags.id_InertiaMode_DEFAULT&&shapes.empty())throw \"Error: Given current inertia mode flag, Body::inertia only makes sense if Body contains Shapes\";\n        #end\n        return zpp_inner.cinertia;\n    }\n    inline function set_inertia(inertia:Float):Float{\n        {\n            zpp_inner.immutable_midstep(\"Body::inertia\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n            #end\n            #if(!NAPE_RELEASE_BUILD)\n            if((inertia!=inertia))throw \"Error: Inertia cannot be NaN\";\n            if(inertia<=0)throw \"Error: Inertia must be strictly positive\";\n            if(inertia>=ZPP_Const.POSINF())throw \"Error: Inertia cannot be infinite, use allowRotation = false instead\";\n            #end\n            zpp_inner.inertiaMode=ZPP_Flags.id_InertiaMode_FIXED;\n            zpp_inner.cinertia=inertia;\n            zpp_inner.invalidate_inertia();\n        }\n        return get_inertia();\n    }\n    /**\n     * Compute set of bodies connected via constraints.\n     * <br/><br/>\n     * Only constraints that are inside of a Space will be considered the\n     * same way that the body's constraints list only tracks constraints\n     * that are part of a simulation.\n     *\n     * @param depth Control the depth limit of the graph search. Negative\n     *              values indicate an unlimited search. A depth value of\n     *              0 would cause only the current Body to be returned.\n     *              (default -1)\n     * @param output An optional list to append results to, if left as null\n     *               then a new list is created.\n     * @return A list of the connected bodies up to\n     *         the given graph depth.\n     */\n    #if nape_swc@:keep #end\n    public function connectedBodies(depth:Int=-1,output:BodyList=null):BodyList{\n        return zpp_inner.connectedBodies(depth,output);\n    }\n    /**\n     * Compute set of bodies interacting with this body.\n     *\n     * @param type When not equal to null, this parameter controls what sort\n     *             of interaction we permit in the search.\n     * @param depth Control the depth limit of the graph search. Negative\n     *              values indicate an unlimited search. A depth value of\n     *              0 would cause only the current Body to be returned.\n     *              (default -1)\n     * @param output An optional list to append results to, if left as null\n     *               then a new list is created.\n     * @return A list of the interacting bodies up to\n     *         the given graph depth.\n     */\n    #if nape_swc@:keep #end\n    public function interactingBodies(type:InteractionType=null,depth:Int=-1,output:BodyList=null){\n        var arbiter_type=if(type==null){\n            ZPP_Arbiter.COL|ZPP_Arbiter.SENSOR|ZPP_Arbiter.FLUID;\n        }\n        else if(type==InteractionType.COLLISION)ZPP_Arbiter.COL else if(type==InteractionType.SENSOR)ZPP_Arbiter.SENSOR else ZPP_Arbiter.FLUID;\n        return zpp_inner.interactingBodies(arbiter_type,depth,output);\n    }\n    /**\n     * Determine how much this body is being crushed.\n     * <br/><br/>\n     * This is an approximate value, computed as:\n     * <code>crushFactor = (sum(magnitude(impulse)) - magnitude(sum(impulse))) / mass</code>\n     * <br/><br/>\n     * In this way, it is a mass and time step invariant value which is 0 when all impulses\n     * are acting on body in the same direction, and has maximum value when impulses\n     * act in opposing directions 'crushing' the Body.\n     *\n     * @return A positive value representing an approximation to how much the\n     *         body is being crushed.\n     * @throws # If body is not in a Space.\n     */\n    #if nape_swc@:keep #end\n    public function crushFactor():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(space==null)throw \"Error: Makes no sense to see how much an object not taking part in a simulation is being crushed\";\n        #end\n        var msum=0.0;\n        var jsum=Vec2.get();\n        for(arb in arbiters){\n            var imp3=arb.totalImpulse(this);\n            var imp=imp3.xy();\n            jsum.addeq(imp);\n            msum+=imp.length;\n            imp.dispose();\n            imp3.dispose();\n        }\n        for(con in constraints){\n            var imp3=con.bodyImpulse(this);\n            var imp=imp3.xy();\n            jsum.addeq(imp);\n            msum+=imp.length;\n            imp.dispose();\n            imp3.dispose();\n        }\n        var ret=(msum-jsum.length)/(this.mass*space.zpp_inner.pre_dt);\n        jsum.dispose();\n        return ret;\n    }\n    /**\n     * Transform a point from Body's local coordinates to world coordinates.\n     *\n     * @param point The point to transform.\n     * @param weak If true the returned Vec2 will be automatically released\n     *             back to object pool when used as an argument to a Nape function.\n     *             (default false)\n     * @return The result of the transformation.\n     * @throws # If point is null or disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function localPointToWorld(point:Vec2,weak:Bool=false){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null)throw \"Error: Cannot transform null Vec2\";\n        #end\n        zpp_inner.validate_axis();\n        var tempx:Float=0.0;\n        var tempy:Float=0.0;\n        {\n            tempx=(zpp_inner.axisy*point.x-zpp_inner.axisx*point.y);\n            tempy=(point.x*zpp_inner.axisx+point.y*zpp_inner.axisy);\n        };\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return Vec2.get(tempx+zpp_inner.posx,tempy+zpp_inner.posy,weak);\n    }\n    /**\n     * Transform a point from world coordinates to Body's local coordinates.\n     *\n     * @param point The point to transform.\n     * @param weak If true the returned Vec2 will be automatically released\n     *             back to object pool when used as an argument to a Nape function.\n     *             (default false)\n     * @return The result of the transformation.\n     * @throws # If point is null or disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function worldPointToLocal(point:Vec2,weak:Bool=false){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null)throw \"Error: Cannot transform null Vec2\";\n        #end\n        zpp_inner.validate_axis();\n        var tempx:Float=0.0;\n        var tempy:Float=0.0;\n        var pointx:Float=0.0;\n        var pointy:Float=0.0;\n        {\n            pointx=point.x-zpp_inner.posx;\n            pointy=point.y-zpp_inner.posy;\n        };\n        {\n            tempx=pointx*zpp_inner.axisy+pointy*zpp_inner.axisx;\n            tempy=pointy*zpp_inner.axisy-pointx*zpp_inner.axisx;\n        };\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return Vec2.get(tempx,tempy,weak);\n    }\n    /**\n     * Transform vector from Body's local coordinates into world coordinates.\n     * <br/><br/>\n     *\n     * @param vector The vector to transform.\n     * @param weak If true the returned Vec2 will be automatically released\n     *             back to object pool when used as an argument to a Nape function.\n     *             (default false)\n     * @return The result of the transformation.\n     * @throws # If vector is null or disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function localVectorToWorld(vector:Vec2,weak:Bool=false){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null)throw \"Error: Cannot transform null Vec2\";\n        #end\n        zpp_inner.validate_axis();\n        var tempx:Float=0.0;\n        var tempy:Float=0.0;\n        {\n            tempx=(zpp_inner.axisy*vector.x-zpp_inner.axisx*vector.y);\n            tempy=(vector.x*zpp_inner.axisx+vector.y*zpp_inner.axisy);\n        };\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return Vec2.get(tempx,tempy,weak);\n    }\n    /**\n     * Transform vector from world coordinates to Body's local coordinates\n     * <br/><br/>\n     *\n     * @param vector The vector to transform.\n     * @param weak If true the returned Vec2 will be automatically released\n     *             back to object pool when used as an argument to a Nape function.\n     *             (default false)\n     * @return The result of the transformation.\n     * @throws # If vector is null or disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function worldVectorToLocal(vector:Vec2,weak:Bool=false){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(vector!=null&&vector.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null)throw \"Error: Cannot transform null Vec2\";\n        #end\n        zpp_inner.validate_axis();\n        var tempx:Float=0.0;\n        var tempy:Float=0.0;\n        {\n            tempx=vector.x*zpp_inner.axisy+vector.y*zpp_inner.axisx;\n            tempy=vector.y*zpp_inner.axisy-vector.x*zpp_inner.axisx;\n        };\n        ({\n            if(({\n                vector.zpp_inner.weak;\n            })){\n                vector.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return Vec2.get(tempx,tempy,weak);\n    }\n    /**\n     * Apply impulse to a point on Body.\n     * <br/><br/>\n     * If position argument is not given, then body.position is assumed so that impulse\n     * is applied at centre of Body.\n     *\n     * @param impulse The impulse to apply given in world coordinates.\n     * @param pos The position to apply impulse given in world coordinates.\n     *            (default body.position)\n     * @param sleepable This parameter can be set to true, in the case that you\n     *                  are constantly applying an impulse which is dependent only\n     *                  on the position/velocity of the body meaning that application\n     *                  of this impulse does not need to prevent the object from sleeping.\n     *                  When true, and the body is sleeping, this method call will not\n     *                  apply any impulse.\n     *                  (default false).\n     * @throws # If impulse is null or disposed of.\n     * @throws # If pos is non-null and disposed of.\n     * @returns A reference to 'this' Body.\n     */\n    #if nape_swc@:keep #end\n    public function applyImpulse(impulse:Vec2,pos:Vec2=null,sleepable:Bool=false){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(impulse!=null&&impulse.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(pos!=null&&pos.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(impulse==null)throw \"Error: Cannot apply null impulse to Body\";\n        #end\n        if(sleepable&&isSleeping){\n            ({\n                if(({\n                    impulse.zpp_inner.weak;\n                })){\n                    impulse.dispose();\n                    true;\n                }\n                else{\n                    false;\n                }\n            });\n            if(pos!=null){\n                ({\n                    if(({\n                        pos.zpp_inner.weak;\n                    })){\n                        pos.dispose();\n                        true;\n                    }\n                    else{\n                        false;\n                    }\n                });\n            }\n            return this;\n        }\n        zpp_inner.validate_mass();\n        {\n            var t=(zpp_inner.imass);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((t!=t));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"zpp_inner.vel\"+\",in b: \"+\"impulse.\"+\",in s: \"+\"zpp_inner.imass\"+\")\");\n                #end\n            };\n            zpp_inner.velx+=impulse.x*t;\n            zpp_inner.vely+=impulse.y*t;\n        };\n        if(pos!=null){\n            var rx:Float=0.0;\n            var ry:Float=0.0;\n            {\n                rx=pos.x-zpp_inner.posx;\n                ry=pos.y-zpp_inner.posy;\n            };\n            zpp_inner.validate_inertia();\n            zpp_inner.angvel+=(impulse.y*rx-impulse.x*ry)*zpp_inner.iinertia;\n            ({\n                if(({\n                    pos.zpp_inner.weak;\n                })){\n                    pos.dispose();\n                    true;\n                }\n                else{\n                    false;\n                }\n            });\n        }\n        if(!sleepable){\n            if(isDynamic())zpp_inner.invalidate_wake();\n        }\n        ({\n            if(({\n                impulse.zpp_inner.weak;\n            })){\n                impulse.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Apply a pure angular impulse to Body.\n     *\n     * @param impulse The angular impulse to apply.\n     * @param sleepable This parameter can be set to true, in the case that you\n     *                  are constantly applying an impulse which is dependent only\n     *                  on the position/velocity of the body meaning that application\n     *                  of this impulse does not need to prevent the object from sleeping.\n     *                  When true, and the body is sleeping, this method call will not\n     *                  apply any impulse.\n     *                  (default false).\n     * @returns A reference to 'this' Body.\n     */\n    #if nape_swc@:keep #end\n    public function applyAngularImpulse(impulse:Float,sleepable:Bool=false){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        if(sleepable&&isSleeping){\n            return this;\n        }\n        zpp_inner.validate_inertia();\n        zpp_inner.angvel+=impulse*zpp_inner.iinertia;\n        if(!sleepable){\n            if(isDynamic())zpp_inner.invalidate_wake();\n        }\n        return this;\n    }\n    /**\n     * Translate each shape in local coordinates.\n     * <br/><br/>\n     * This operation does not effect the Body's position, but the position\n     * of the shapes 'inside' of the Body.\n     *\n     * @param translation The local translation to apply to Shapes.\n     * @return A reference to this Body.\n     * @throws # If translation is null or has been disposed of.\n     * @throws # If this Body is static, and inside of a Space.\n     */\n    #if nape_swc@:keep #end\n    public function translateShapes(translation:Vec2){\n        zpp_inner.immutable_midstep(\"Body::translateShapes()\");\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(translation!=null&&translation.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(translation==null)throw \"Error: Cannot displace by null Vec2\";\n        #end\n        var weak=translation.zpp_inner.weak;\n        translation.zpp_inner.weak=false;\n        {\n            var cx_ite=zpp_inner.shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.outer.translate(translation);\n                cx_ite=cx_ite.next;\n            }\n        };\n        translation.zpp_inner.weak=weak;\n        ({\n            if(({\n                translation.zpp_inner.weak;\n            })){\n                translation.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Rotate each shape in local coordinates.\n     * <br/><br/>\n     * This operation does not effect the Body's rotation, but rotates\n     * each of the shapes 'inside' of the Body.\n     *\n     * @param angle The angle to rotate shapes by in clockwise radians.\n     * @return A reference to this Body.\n     * @throws # If this Body is static, and inside of a Space.\n     */\n    #if nape_swc@:keep #end\n    public function rotateShapes(angle:Float){\n        zpp_inner.immutable_midstep(\"Body::rotateShapes()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        {\n            var cx_ite=zpp_inner.shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.outer.rotate(angle);\n                cx_ite=cx_ite.next;\n            }\n        };\n        return this;\n    }\n    /**\n     * Scale each shape in local coordinates.\n     * <br/><br/>\n     * This operation does not affect the Body itself, but affects each\n     * Shape 'inside' of the Body instead.\n     *\n     * @param scaleX The x-coordinate factor of scaling.\n     * @param scaleY The y-coordinate factor of scaling.\n     * @return A reference to this Body.\n     * @throws # If this Body is static, and inside of a Space.\n     * @throws # If Body contains Circle shapes, and scaleX != scaleY\n     */\n    #if nape_swc@:keep #end\n    public function scaleShapes(scaleX:Float,scaleY:Float){\n        zpp_inner.immutable_midstep(\"Body::scaleShapes()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        {\n            var cx_ite=zpp_inner.shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.outer.scale(scaleX,scaleY);\n                cx_ite=cx_ite.next;\n            }\n        };\n        return this;\n    }\n    /**\n     * Transform each shape in local coordiantes.\n     * <br/><br/>\n     * This operation does not affect the Body itself, but affects each\n     * Shape 'inside' of the Body instead.\n     *\n     * @param matrix The transformation matrix to apply to each Shape.\n     * @return A reference to this Body.\n     * @throws # If this Body is static, and inside of a Space.\n     * @throws # If matrix is null or singular.\n     * @throws # If Body contains Circle shapes, and input matrix is\n     *           not equiorthogonal.\n     */\n    #if nape_swc@:keep #end\n    public function transformShapes(matrix:Mat23){\n        zpp_inner.immutable_midstep(\"Body::transformShapes()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        {\n            var cx_ite=zpp_inner.shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.outer.transform(matrix);\n                cx_ite=cx_ite.next;\n            }\n        };\n        return this;\n    }\n    /**\n     * Align rigid body so that its origin is also its centre of mass.\n     * <br/><br/>\n     * This operation will both translate the Shapes inside of the Body,\n     * as well as translating the Body itself so that its 'apparent' position\n     * has not been modified.\n     * <br/><br/>\n     * Alignment of Rigid bodies is necessary for dynamic bodies so that\n     * they will interact and rotate as expected.\n     * <br/><br/>\n     * Simple Body's created with a single Polygon.box() or basic Circle\n     * will already be aligned.\n     *\n     * @return A reference to this Body.\n     */\n    #if nape_swc@:keep #end\n    public function align(){\n        zpp_inner.immutable_midstep(\"Body::align()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.shapes.empty())throw \"Error: Cannot align empty Body\";\n        #end\n        zpp_inner.validate_localCOM();\n        var dx=Vec2.get(-zpp_inner.localCOMx,-zpp_inner.localCOMy);\n        translateShapes(dx);\n        var dx2=localVectorToWorld(dx);\n        position.subeq(dx2);\n        if(zpp_inner.pre_posx<ZPP_Const.POSINF()){\n            var t=(1.0);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((t!=t));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"zpp_inner.pre_pos\"+\",in b: \"+\"dx2.\"+\",in s: \"+\"1.0\"+\")\");\n                #end\n            };\n            zpp_inner.pre_posx-=dx2.x*t;\n            zpp_inner.pre_posy-=dx2.y*t;\n        };\n        dx.dispose();\n        dx2.dispose();\n        return this;\n    }\n    /**\n     * Rotate body about about given point.\n     * <br/><br/>\n     * Please note that this method is equivalent to teleporting the body,\n     * the same way direct manipulation of position and rotation is.\n     *\n     * @param centre The centre of rotation in world coordinates.\n     * @param angle The angle to rotate body by in clockwise radians.\n     * @return A reference to this Body.\n     * @throws # If this Body is static, and inside of a Space.\n     * @throws # If centre is null or disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function rotate(centre:Vec2,angle:Float){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(centre!=null&&centre.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(centre==null)throw \"Error: Cannot rotate about a null Vec2\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if((angle!=angle))throw \"Error: Cannot rotate by NaN radians\";\n        #end\n        var weak=centre.zpp_inner.weak;\n        centre.zpp_inner.weak=false;\n        var del=position.sub(centre);\n        del.rotate(angle);\n        position=centre.add(del,true);\n        del.dispose();\n        rotation+=angle;\n        centre.zpp_inner.weak=weak;\n        ({\n            if(({\n                centre.zpp_inner.weak;\n            })){\n                centre.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Set material of all shapes.\n     * <br/><br/>\n     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.material = material)</code>\n     *\n     * @param material The material to set Shape's material to.\n     * @return A reference to this Body.\n     */\n    #if nape_swc@:keep #end\n    public function setShapeMaterials(material:Material){\n        zpp_inner.immutable_midstep(\"Body::setShapeMaterials()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        {\n            var cx_ite=zpp_inner.shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.outer.material=material;\n                cx_ite=cx_ite.next;\n            }\n        };\n        return this;\n    }\n    /**\n     * Set interaction filter of all shapes.\n     * <br/><br/>\n     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.filter = filter)</code>\n     *\n     * @param filter The filter to set Shape's filter to.\n     * @return A reference to this Body.\n     */\n    #if nape_swc@:keep #end\n    public function setShapeFilters(filter:InteractionFilter){\n        zpp_inner.immutable_midstep(\"Body::setShapeFilters()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        {\n            var cx_ite=zpp_inner.shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.outer.filter=filter;\n                cx_ite=cx_ite.next;\n            }\n        };\n        return this;\n    }\n    /**\n     * Set fluidProperties of all shapes.\n     * <br/><br/>\n     * Equivalent to: <code>body.shapes.foreach(function (shape) shape.fluidProperties = fluidProperties)</code>\n     *\n     * @param fluidProperties The fluidProperties to set Shape's fluidProperties to.\n     * @return A reference to this Body.\n     */\n    #if nape_swc@:keep #end\n    public function setShapeFluidProperties(fluidProperties:FluidProperties){\n        zpp_inner.immutable_midstep(\"Body::setShapeFluidProperties()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world is immutable\";\n        #end\n        {\n            var cx_ite=zpp_inner.shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.outer.fluidProperties=fluidProperties;\n                cx_ite=cx_ite.next;\n            }\n        };\n        return this;\n    }\n    /**\n     * Local centre of mass of Body.\n     * <br/><br/>\n     * This value can be accessed even if Body has no shapes, but attempting\n     * to query its values will result in a debug build error.\n     * <br/><br/>\n     * This Vec2 is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var localCOM(get_localCOM,never):Vec2;\n    inline function get_localCOM():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world has no \"+\"localCOM\";\n        #end\n        if(zpp_inner.wrap_localCOM==null){\n            zpp_inner.wrap_localCOM=Vec2.get(zpp_inner.localCOMx,zpp_inner.localCOMy);\n            zpp_inner.wrap_localCOM.zpp_inner._inuse=true;\n            zpp_inner.wrap_localCOM.zpp_inner._immutable=true;\n            zpp_inner.wrap_localCOM.zpp_inner._validate=zpp_inner.getlocalCOM;\n        }\n        return zpp_inner.wrap_localCOM;\n    }\n    /**\n     * World centre of mass of Body.\n     * <br/><br/>\n     * This value can be accessed even if Body has no shapes, but attempting\n     * to query its values will result in a debug build error.\n     * <br/><br/>\n     * This Vec2 is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var worldCOM(get_worldCOM,never):Vec2;\n    inline function get_worldCOM():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.world)throw \"Error: Space::world has no \"+\"worldCOM\";\n        #end\n        if(zpp_inner.wrap_worldCOM==null){\n            zpp_inner.wrap_worldCOM=Vec2.get(zpp_inner.worldCOMx,zpp_inner.worldCOMy);\n            zpp_inner.wrap_worldCOM.zpp_inner._inuse=true;\n            zpp_inner.wrap_worldCOM.zpp_inner._immutable=true;\n            zpp_inner.wrap_worldCOM.zpp_inner._validate=zpp_inner.getworldCOM;\n        }\n        return zpp_inner.wrap_worldCOM;\n    }\n    /**\n     * Evaluate sum effect of all normal contact impulses on Body.\n     * <br/><br/>\n     * If the body argument is non-null, then only impulses between 'this' and\n     * the given Body will be considered.\n     *\n     * @param body The Body to restrict consideration of impulses with.\n     *             (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered.\n     *             (default false)\n     * @return The summed effect of impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function normalImpulse(body:Body=null,freshOnly:Bool=false){\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        {\n            var arbs=zpp_inner.arbiters;\n            for(oarb in arbiters){\n                var arb=oarb.zpp_inner;\n                if(arb.type!=ZPP_Arbiter.COL)continue;\n                if(body!=null&&arb.b2!=body.zpp_inner&&arb.b1!=body.zpp_inner)continue;\n                {\n                    var imp=arb.wrapper().collisionArbiter.normalImpulse(this,freshOnly);\n                    {\n                        var t=(1);\n                        {\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            retx+=imp.x*t;\n                            rety+=imp.y*t;\n                        };\n                        retz+=imp.z*t;\n                    };\n                    imp.dispose();\n                };\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate sum effect of all tangent contact impulses on Body.\n     * <br/><br/>\n     * If the body argument is non-null, then only impulses between 'this' and\n     * the given Body will be considered.\n     *\n     * @param body The Body to restrict consideration of impulses with.\n     *             (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered.\n     *             (default false)\n     * @return The summed effect of impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function tangentImpulse(body:Body=null,freshOnly:Bool=false){\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        {\n            var arbs=zpp_inner.arbiters;\n            for(oarb in arbiters){\n                var arb=oarb.zpp_inner;\n                if(arb.type!=ZPP_Arbiter.COL)continue;\n                if(body!=null&&arb.b2!=body.zpp_inner&&arb.b1!=body.zpp_inner)continue;\n                {\n                    var imp=arb.wrapper().collisionArbiter.tangentImpulse(this,freshOnly);\n                    {\n                        var t=(1);\n                        {\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            retx+=imp.x*t;\n                            rety+=imp.y*t;\n                        };\n                        retz+=imp.z*t;\n                    };\n                    imp.dispose();\n                };\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate sum effect of all contact impulses on Body.\n     * <br/><br/>\n     * If the body argument is non-null, then only impulses between 'this' and\n     * the given Body will be considered.\n     *\n     * @param body The Body to restrict consideration of impulses with.\n     *             (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered.\n     *             (default false)\n     * @return The summed effect of impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function totalContactsImpulse(body:Body=null,freshOnly:Bool=false){\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        {\n            var arbs=zpp_inner.arbiters;\n            for(oarb in arbiters){\n                var arb=oarb.zpp_inner;\n                if(arb.type!=ZPP_Arbiter.COL)continue;\n                if(body!=null&&arb.b2!=body.zpp_inner&&arb.b1!=body.zpp_inner)continue;\n                {\n                    var imp=arb.wrapper().collisionArbiter.totalImpulse(this,freshOnly);\n                    {\n                        var t=(1);\n                        {\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            retx+=imp.x*t;\n                            rety+=imp.y*t;\n                        };\n                        retz+=imp.z*t;\n                    };\n                    imp.dispose();\n                };\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate sum effect of all rolling friction contact impulses on Body.\n     * <br/><br/\n     * If the body argument is non-null, then only impulses between 'this' and\n     * the given Body will be considered.\n     *\n     * @param body The Body to restrict consideration of impulses with.\n     *             (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered.\n     *             (default false)\n     * @return The summed effect of impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function rollingImpulse(body:Body=null,freshOnly:Bool=false){\n        var ret=0.0;\n        {\n            var arbs=zpp_inner.arbiters;\n            for(oarb in arbiters){\n                var arb=oarb.zpp_inner;\n                if(arb.type!=ZPP_Arbiter.COL)continue;\n                if(body!=null&&arb.b2!=body.zpp_inner&&arb.b1!=body.zpp_inner)continue;\n                {\n                    ret+=arb.wrapper().collisionArbiter.rollingImpulse(this,freshOnly);\n                };\n            }\n        };\n        return ret;\n    }\n    /**\n     * Evaluate sum effect of all buoyancy impulses acting on Body.\n     * <br/><br/\n     * If the body argument is non-null, then only impulses between 'this' and\n     * the given Body will be considered.\n     *\n     * @param body The Body to restrict consideration of impulses with.\n     *             (default null)\n     * @return The summed effect of impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function buoyancyImpulse(body:Body=null){\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        {\n            var arbs=zpp_inner.arbiters;\n            for(oarb in arbiters){\n                var arb=oarb.zpp_inner;\n                if(arb.type!=ZPP_Arbiter.FLUID)continue;\n                if(body!=null&&arb.b2!=body.zpp_inner&&arb.b1!=body.zpp_inner)continue;\n                {\n                    var imp=arb.wrapper().fluidArbiter.buoyancyImpulse(this);\n                    {\n                        var t=(1);\n                        {\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            retx+=imp.x*t;\n                            rety+=imp.y*t;\n                        };\n                        retz+=imp.z*t;\n                    };\n                    imp.dispose();\n                };\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate sum effect of all fluid drag impulses acting on Body.\n     * <br/><br/\n     * If the body argument is non-null, then only impulses between 'this' and\n     * the given Body will be considered.\n     *\n     * @param body The Body to restrict consideration of impulses with.\n     *             (default null)\n     * @return The summed effect of impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function dragImpulse(body:Body=null){\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        {\n            var arbs=zpp_inner.arbiters;\n            for(oarb in arbiters){\n                var arb=oarb.zpp_inner;\n                if(arb.type!=ZPP_Arbiter.FLUID)continue;\n                if(body!=null&&arb.b2!=body.zpp_inner&&arb.b1!=body.zpp_inner)continue;\n                {\n                    var imp=arb.wrapper().fluidArbiter.dragImpulse(this);\n                    {\n                        var t=(1);\n                        {\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            retx+=imp.x*t;\n                            rety+=imp.y*t;\n                        };\n                        retz+=imp.z*t;\n                    };\n                    imp.dispose();\n                };\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate sum effect of all fluid impulses acting on Body.\n     * <br/><br/\n     * If the body argument is non-null, then only impulses between 'this' and\n     * the given Body will be considered.\n     *\n     * @param body The Body to restrict consideration of impulses with.\n     *             (default null)\n     * @return The summed effect of impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function totalFluidImpulse(body:Body=null){\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        {\n            var arbs=zpp_inner.arbiters;\n            for(oarb in arbiters){\n                var arb=oarb.zpp_inner;\n                if(arb.type!=ZPP_Arbiter.FLUID)continue;\n                if(body!=null&&arb.b2!=body.zpp_inner&&arb.b1!=body.zpp_inner)continue;\n                {\n                    var imp=arb.wrapper().fluidArbiter.totalImpulse(this);\n                    {\n                        var t=(1);\n                        {\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            retx+=imp.x*t;\n                            rety+=imp.y*t;\n                        };\n                        retz+=imp.z*t;\n                    };\n                    imp.dispose();\n                };\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate sum effect of all constraint impulses on this Body.\n     *\n     * @return The summed effect of constraint impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function constraintsImpulse(){\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        {\n            var cx_ite=zpp_inner.constraints.begin();\n            while(cx_ite!=null){\n                var con=cx_ite.elem();\n                {\n                    var imp=con.outer.bodyImpulse(this);\n                    {\n                        var t=(1);\n                        {\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            retx+=imp.x*t;\n                            rety+=imp.y*t;\n                        };\n                        retz+=imp.z*t;\n                    };\n                    imp.dispose();\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Evaluate sum effect of all impulses on Body.\n     * <br/><br/\n     * If the body argument is non-null, then only impulses between 'this' and\n     * the given Body will be considered when evaluating interaction impulses.\n     * <br/>\n     * Constraint impulses are not effected by the body argument.\n     *\n     * @param body The Body to restrict consideration of impulses with.\n     *             (default null)\n     * @param freshOnly If true, then only 'new' contact points will be considered\n     *             when evaluating contact impulses.\n     *             (default false)\n     * @return The summed effect of impulses acting on Body.\n     */\n    #if nape_swc@:keep #end\n    public function totalImpulse(body:Body=null,freshOnly:Bool=false){\n        var retx:Float=0;\n        var rety:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((retx!=retx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(retx)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rety!=rety));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rety)\"+\") :: \"+(\"vec_new(in n: \"+\"ret\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        var retz:Float=0;\n        var arbs=zpp_inner.arbiters;\n        for(oarb in arbiters){\n            var arb=oarb.zpp_inner;\n            if(arb.type==ZPP_Arbiter.SENSOR)continue;\n            if(body!=null&&arb.b2!=body.zpp_inner&&arb.b1!=body.zpp_inner)continue;\n            var imp=arb.wrapper().totalImpulse(this,freshOnly);\n            {\n                var t=(1);\n                {\n                    var t=(t);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                        #end\n                    };\n                    retx+=imp.x*t;\n                    rety+=imp.y*t;\n                };\n                retz+=imp.z*t;\n            };\n            imp.dispose();\n        }\n        {\n            var cx_ite=zpp_inner.constraints.begin();\n            while(cx_ite!=null){\n                var con=cx_ite.elem();\n                {\n                    if(con.active){\n                        var imp=con.outer.bodyImpulse(this);\n                        {\n                            var t=(1);\n                            {\n                                var t=(t);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"ret\"+\",in b: \"+\"imp.\"+\",in s: \"+\"t\"+\")\");\n                                    #end\n                                };\n                                retx+=imp.x*t;\n                                rety+=imp.y*t;\n                            };\n                            retz+=imp.z*t;\n                        };\n                        imp.dispose();\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        return Vec3.get(retx,rety,retz);\n    }\n    /**\n     * Determine if point is contained in Body.\n     *\n     * @param point The point to test containment for in world coordinates.\n     * @return True if point is contained.\n     * @throws # If point is null or has been disposed.\n     */\n    #if nape_swc@:keep #end\n    public function contains(point:Vec2){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null)throw \"Error: Cannot check containment of null point\";\n        #end\n        var wasWeak=point.zpp_inner.weak;\n        point.zpp_inner.weak=false;\n        var retvar;\n        {\n            retvar=false;\n            {\n                var cx_ite=zpp_inner.shapes.begin();\n                while(cx_ite!=null){\n                    var s=cx_ite.elem();\n                    {\n                        if(s.outer.contains(point)){\n                            retvar=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        point.zpp_inner.weak=wasWeak;\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return retvar;\n    }\n    /**\n     * @private\n     */\n    @:keep public override function toString(){\n        return(zpp_inner.world?\"(space::world\":(\"(\"+(isDynamic()?\"dynamic\":isStatic()?\"static\":\"kinematic\")))+\")#\"+id;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass BodyIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:BodyList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:BodyIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:BodyIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_BodyList.internal)throw \"Error: Cannot instantiate \"+\"Body\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:BodyList){\n        var ret=if(zpp_pool==null){\n            ZPP_BodyList.internal=true;\n            var ret=new BodyIterator();\n            ZPP_BodyList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=BodyIterator.zpp_pool;\n                BodyIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Body type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Body = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Body = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Body = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass BodyList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_BodyList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Body\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Body>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new BodyList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Body)#else Std.is(i,Body)#end)throw \"Error: Array contains non \"+\"Body\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Body>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new BodyList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Body):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Body{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Body):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Body\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Body):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Body\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Body{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Body\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Body{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Body\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:Body):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Body):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Body\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Body\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return BodyIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new BodyList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Body\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:BodyList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_BodyList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:Body->Void):BodyList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=BodyIterator.zpp_pool;\n                    BodyIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Body->Bool):BodyList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of rigid body types.\n */\n@:final#if nape_swc@:keep #end\nclass BodyType{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"BodyType\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==STATIC)return\"STATIC\";\n        else if(this==DYNAMIC)return\"DYNAMIC\";\n        else if(this==KINEMATIC)return\"KINEMATIC\";\n        else return \"\";\n    }\n    /**\n     * Static objects are not permitted to move, and due to this several\n     * optimisatinos can be made for them.\n     */\n    #if nape_swc@:isVar #end\n    public static var STATIC(get_STATIC,never):BodyType;\n    inline static function get_STATIC(){\n        if(ZPP_Flags.BodyType_STATIC==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.BodyType_STATIC=new BodyType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.BodyType_STATIC;\n    }\n    /**\n     * Standard dynamic object, this object will be effected by the physics\n     * as usual.\n     */\n    #if nape_swc@:isVar #end\n    public static var DYNAMIC(get_DYNAMIC,never):BodyType;\n    inline static function get_DYNAMIC(){\n        if(ZPP_Flags.BodyType_DYNAMIC==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.BodyType_DYNAMIC=new BodyType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.BodyType_DYNAMIC;\n    }\n    /**\n     * Kinematic objects are static objects which 'are' permitted to move,\n     * you have complete control over their velocity to make them move how\n     * you wish and are not effected by any physics.\n     */\n    #if nape_swc@:isVar #end\n    public static var KINEMATIC(get_KINEMATIC,never):BodyType;\n    inline static function get_KINEMATIC(){\n        if(ZPP_Flags.BodyType_KINEMATIC==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.BodyType_KINEMATIC=new BodyType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.BodyType_KINEMATIC;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Compound represents a grouping of physics objects into a single object.\n * <br/><br/>\n * This compound owns its constituents and works in the callback system and with\n * respect to adding/removing from a Space as a single object.\n * <pre>\n *       ____Cmp1_____\n *      /    /    &#92;   &#92;\n * Body1 Body2--Joint Cmp2\n *   |     |        &#92;  |\n * Shp1  Shp2        Body3\n *                     |\n *                    Shp3\n * </pre>\n * For example if you have a complex car built with several bodies and\n * constraints you might store this in a Compound providing an easy way\n * of removing/adding/copying the Car as well as being able to get a single\n * callback for when the car collides with something.\n * <br/><br/>\n * When you add a compound to a Space, all of it's constituents get added\n * and furthermore, those constituents cannot be added seperately.\n */\n@:final#if nape_swc@:keep #end\nclass Compound extends Interactor{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Compound=null;\n    /**\n     * List of bodies directly owned by this Compound.\n     * <br/><br/>\n     * This list does not include those bodies belonging to sub-compounds.\n     *\n     * @default []\n     */\n    #if nape_swc@:isVar #end\n    public var bodies(get_bodies,never):BodyList;\n    inline function get_bodies():BodyList{\n        return zpp_inner.wrap_bodies;\n    }\n    /**\n     * List of constraints directly owned by this Compound.\n     * <br/><br/>\n     * This list does not include those constraints belonging to sub-compounds.\n     *\n     * @default []\n     */\n    #if nape_swc@:isVar #end\n    public var constraints(get_constraints,never):ConstraintList;\n    inline function get_constraints():ConstraintList{\n        return zpp_inner.wrap_constraints;\n    }\n    /**\n     * List of compounds directly owned by this Compound.\n     * <br/><br/>\n     * This list does not include those compounds belonging to sub-compounds.\n     *\n     * @default []\n     */\n    #if nape_swc@:isVar #end\n    public var compounds(get_compounds,never):CompoundList;\n    inline function get_compounds():CompoundList{\n        return zpp_inner.wrap_compounds;\n    }\n    /**\n     * Compound that this compound belongs to.\n     *\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var compound(get_compound,set_compound):Null<Compound>;\n    inline function get_compound():Null<Compound>{\n        return if(zpp_inner.compound==null)null else zpp_inner.compound.outer;\n    }\n    inline function set_compound(compound:Null<Compound>):Null<Compound>{\n        {\n            zpp_inner.immutable_midstep(\"Compound::compound\");\n            if(this.compound!=compound){\n                if(this.compound!=null)this.compound.compounds.remove(this);\n                if(compound!=null)compound.compounds.add(this);\n            }\n        }\n        return get_compound();\n    }\n    /**\n     * Space this compound belongs to.\n     * <br/><br/>\n     * This value is immutable when this compound belongs to another parent Compound.\n     *\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var space(get_space,set_space):Null<Space>;\n    inline function get_space():Null<Space>{\n        return if(zpp_inner.space==null)null else zpp_inner.space.outer;\n    }\n    inline function set_space(space:Null<Space>):Null<Space>{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.compound!=null)throw \"Error: Cannot set the space of an inner Compound, only the root Compound space can be set\";\n            #end\n            zpp_inner.immutable_midstep(\"Compound::space\");\n            if(this.space!=space){\n                if(this.space!=null)this.space.compounds.remove(this);\n                if(space!=null)space.compounds.add(this);\n            }\n        }\n        return get_space();\n    }\n    /**\n     * Construct a new Compound.\n     *\n     * @result The constructed Compound.\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        Interactor.zpp_internalAlloc=true;\n        super();\n        Interactor.zpp_internalAlloc=false;\n        #end\n        #if NAPE_RELEASE_BUILD \n        super();\n        #end\n        zpp_inner=new ZPP_Compound();\n        zpp_inner.outer=this;\n        zpp_inner.outer_i=this;\n        zpp_inner_i=zpp_inner;\n        zpp_inner.insert_cbtype(CbType.ANY_COMPOUND.zpp_inner);\n    }\n    /**\n     * @private\n     */\n    @:keep public override function toString(){\n        return \"Compound\"+this.id;\n    }\n    /**\n     * Produce an exact copy of this Compound.\n     * <br/><br/>\n     * This copy will remap owned constraints so that their body properties\n     * refer to the newly copied bodies also owned by this compound.\n     * <br/><br/>\n     * If this compound tree contains any constraints that make references\n     * to outside of this compound; then these properties will be made null.\n     * <pre>\n     *       ____Cmp1____               [Cmp2.copy()]\n     *      /    /        &#92;\n     * Body1 Body2___     Cmp2        null    Cmp2'\n     *   |     |     &#92;     /  &#92;         &#92;    /    &#92;\n     * Shp1  Shp2     Joint--Body3       Joint'--Body3'\n     *                         |                   |\n     *                        Shp3               Shp3'\n     * </pre>\n     * For instance if copying Cmp1 then all is well, but if we copy Cmp2 the\n     * copied Joint will have one of it's body references null as that body is\n     * not owned directly, or indirectly by the compound.\n     */\n    public function copy(){\n        return zpp_inner.copy();\n    }\n    /**\n     * Breaking compound apart in-place.\n     * <br/><br/>\n     * This method will destroy the compound, moving all of it's components\n     * to the assigned Space if this is the root compound, otherwise to the\n     * parent compound.\n     * <br/><br/>\n     * Apart from being easier than doing this manually it also means that we\n     * do not have to temporarigly remove objects from the space meaning that\n     * things like PreListener ignored interactions will be unaffected.\n     */\n    public function breakApart(){\n        zpp_inner.breakApart();\n    }\n    /**\n     * Method to iterate over all bodies contained directly or indirectly by\n     * this Compound.\n     *\n     * @param lambda The method to apply to each Body.\n     * @throws # If lambda is null.\n     */\n    public function visitBodies(lambda:Body->Void){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: lambda cannot be null for Compound::visitBodies\";\n        #end\n        for(b in bodies)lambda(b);\n        for(c in compounds)c.visitBodies(lambda);\n    }\n    /**\n     * Method to iterate over all constraints contained directly or indirectly by\n     * this Compound.\n     *\n     * @param lambda The method to apply to each Constraint.\n     * @throws # If lambda is null.\n     */\n    public function visitConstraints(lambda:Constraint->Void){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: lambda cannot be null for Compound::visitConstraints\";\n        #end\n        for(c in constraints)lambda(c);\n        for(c in compounds)c.visitConstraints(lambda);\n    }\n    /**\n     * Method to iterate over all compounds contained directly or indirectly by\n     * this Compound.\n     *\n     * @param lambda The method to apply to each Compound.\n     * @throws # If lambda is null.\n     */\n    public function visitCompounds(lambda:Compound->Void){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: lambda cannot be null for Compound::visitConstraints\";\n        #end\n        for(c in compounds){\n            lambda(c);\n            c.visitCompounds(lambda);\n        }\n    }\n    /**\n     * Compute centre of mass of Compound.\n     *\n     * @param weak If true, the returned Vec2 will be automatically released\n     *             to the object pool when passed as an argument to a Nape\n     *             function. (default false)\n     * @return The centre of mass of compound.\n     * @throws # If Compound has no Bodies contained directly or indirectly\n     *           that contain at least one Shape.\n     */\n    public function COM(weak:Bool=false){\n        var ret=Vec2.get(0,0,weak);\n        var total=0.0;\n        visitBodies(function(b){\n            if(!b.shapes.empty()){\n                ret.addeq(b.worldCOM.mul(b.mass,true));\n                total+=b.mass;\n            }\n        });\n        #if(!NAPE_RELEASE_BUILD)\n        if(total==0.0)throw \"Error: COM of an empty Compound is undefined silly\";\n        #end\n        ret.muleq(1/total);\n        return ret;\n    }\n    /**\n     * Translate entire compound.\n     * <br/><br/>\n     * This is equivalent to: <code>compound.visitBodies(function (b) b.translate(translation))</code>\n     *\n     * @param translation The translation to apply to the Compound.\n     * @return A reference to this Compound.\n     * @throws # If translation is null or disposed of.\n     * @throws # If any Body in the compound is static, and this compound is in a Space.\n     */\n    public function translate(translation:Vec2){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(translation!=null&&translation.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(translation==null)throw \"Error: Cannot translate by null Vec2\";\n        #end\n        var weak=translation.zpp_inner.weak;\n        translation.zpp_inner.weak=false;\n        visitBodies(function(b)b.position.addeq(translation));\n        translation.zpp_inner.weak=weak;\n        ({\n            if(({\n                translation.zpp_inner.weak;\n            })){\n                translation.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Rotate entire compound about a point.\n     * <br/><br/>\n     * This is equivalent to: <code>compound.visitBodies(function (b) b.rotate(centre, angle))</code>\n     *\n     * @param centre The centre of rotation in world coordinates.\n     * @param angle The clockwise angle of rotation in radians.\n     * @return A reference to this Compound.\n     * @throws # If centre is null or disposed of.\n     * @throws # If any Body in the compound is static, and this compound is in a Space.\n     */\n    public function rotate(centre:Vec2,angle:Float){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(centre!=null&&centre.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(centre==null)throw \"Error: Cannot rotate about a null Vec2\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if((angle!=angle))throw \"Error: Cannot rotate by NaN radians\";\n        #end\n        var weak=centre.zpp_inner.weak;\n        centre.zpp_inner.weak=false;\n        visitBodies(function(b)b.rotate(centre,angle));\n        centre.zpp_inner.weak=weak;\n        ({\n            if(({\n                centre.zpp_inner.weak;\n            })){\n                centre.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass CompoundIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:CompoundList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:CompoundIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:CompoundIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_CompoundList.internal)throw \"Error: Cannot instantiate \"+\"Compound\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:CompoundList){\n        var ret=if(zpp_pool==null){\n            ZPP_CompoundList.internal=true;\n            var ret=new CompoundIterator();\n            ZPP_CompoundList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=CompoundIterator.zpp_pool;\n                CompoundIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Compound type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Compound = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Compound = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Compound = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass CompoundList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_CompoundList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Compound\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Compound>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new CompoundList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Compound)#else Std.is(i,Compound)#end)throw \"Error: Array contains non \"+\"Compound\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Compound>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new CompoundList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Compound):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Compound{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Compound):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Compound\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Compound):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Compound\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Compound{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Compound\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Compound{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Compound\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:Compound):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Compound):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Compound\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Compound\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return CompoundIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new CompoundList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Compound\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:CompoundList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_CompoundList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:Compound->Void):CompoundList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=CompoundIterator.zpp_pool;\n                    CompoundIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Compound->Bool):CompoundList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * FluidProperties providing shared parameters for fluid interaction.\n */\n@:final#if nape_swc@:keep #end\nclass FluidProperties{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_FluidProperties=null;\n    /**\n     * Dynamic object for user to store additional data.\n     * <br/><br/>\n     * This object cannot be set, only its dynamically created\n     * properties may be set. In AS3 the type of this property is &#42\n     * <br/><br/>\n     * This object will be lazily constructed so that until accessed\n     * for the first time, will be null internally.\n     *\n     * @default {}\n     */\n    #if nape_swc@:isVar #end\n    public var userData(get_userData,never):Dynamic<Dynamic>;\n    inline function get_userData():Dynamic<Dynamic>{\n        if(zpp_inner.userData==null){\n            zpp_inner.userData=cast{};\n        }\n        return zpp_inner.userData;\n    }\n    /**\n     * Set of all active shapes using this object.\n     * <br/><br/>\n     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var shapes(get_shapes,never):ShapeList;\n    inline function get_shapes():ShapeList{\n        if(zpp_inner.wrap_shapes==null)zpp_inner.wrap_shapes=ZPP_ShapeList.get(zpp_inner.shapes,true);\n        return zpp_inner.wrap_shapes;\n    }\n    /**\n     * Construct a new FluidProperties objects.\n     *\n     * @param density The density of the fluid in g/px/px. (default 1)\n     * @param viscosity The viscosity of the fluid for drag computations in kg/px/s\n     *                  (default 1)\n     * @return The constructed FluidProperties object.\n     */\n    public function new(density:Float=1,viscosity:Float=1){\n        {\n            if(ZPP_FluidProperties.zpp_pool==null){\n                zpp_inner=new ZPP_FluidProperties();\n                #if NAPE_POOL_STATS ZPP_FluidProperties.POOL_TOT++;\n                ZPP_FluidProperties.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                zpp_inner=ZPP_FluidProperties.zpp_pool;\n                ZPP_FluidProperties.zpp_pool=zpp_inner.next;\n                zpp_inner.next=null;\n                #if NAPE_POOL_STATS ZPP_FluidProperties.POOL_CNT--;\n                ZPP_FluidProperties.POOL_ADD++;\n                #end\n            }\n            zpp_inner.alloc();\n        };\n        zpp_inner.outer=this;\n        this.density=density;\n        this.viscosity=viscosity;\n    }\n    /**\n     * Produce a copy of this FluidProperties object.\n     * <br/><br/>\n     * The copied object will be identical in all properties with the the\n     * copied userData being assigned the same fields as 'this' Shape with the\n     * same values copied over by reference for object types.\n     *\n     * @return The copied FluidProperties.\n     */\n    #if nape_swc@:keep #end\n    public function copy(){\n        var ret=new FluidProperties(density,viscosity);\n        if(zpp_inner.userData!=null)ret.zpp_inner.userData=Reflect.copy(zpp_inner.userData);\n        ret.gravity=this.gravity;\n        return ret;\n    }\n    /**\n     * Density of fluid.\n     * <br/><br/>\n     * This value, like Material density is of g/pixel/pixel.\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var density(get_density,set_density):Float;\n    inline function get_density():Float{\n        return zpp_inner.density*(\"density\"==\"density\"?1000:1);\n    }\n    inline function set_density(density:Float):Float{\n        {\n            if(density!=this.density){\n                #if(!NAPE_RELEASE_BUILD)\n                if((density!=density))throw \"Error: FluidProperties::\"+\"density\"+\" cannot be NaN\";\n                if(\"density\"!=\"density\"&&density<0)throw \"Error: FluidProperties::\"+\"density\"+\" (\"+density+\") must be >= 0\";\n                #end\n                zpp_inner.density=density/(\"density\"==\"density\"?1000:1);\n                zpp_inner.invalidate();\n            }\n        }\n        return get_density();\n    }\n    /**\n     * Viscosity of fluid.\n     * <br/><br/>\n     * This value is used in drag comutations, the higher the viscosity the\n     * more quickly objects will come to rest in the fluid.\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var viscosity(get_viscosity,set_viscosity):Float;\n    inline function get_viscosity():Float{\n        return zpp_inner.viscosity*(\"viscosity\"==\"density\"?1000:1);\n    }\n    inline function set_viscosity(viscosity:Float):Float{\n        {\n            if(viscosity!=this.viscosity){\n                #if(!NAPE_RELEASE_BUILD)\n                if((viscosity!=viscosity))throw \"Error: FluidProperties::\"+\"viscosity\"+\" cannot be NaN\";\n                if(\"viscosity\"!=\"density\"&&viscosity<0)throw \"Error: FluidProperties::\"+\"viscosity\"+\" (\"+viscosity+\") must be >= 0\";\n                #end\n                zpp_inner.viscosity=viscosity/(\"viscosity\"==\"density\"?1000:1);\n                zpp_inner.invalidate();\n            }\n        }\n        return get_viscosity();\n    }\n    /**\n     * Local gravity for buoyancy computations.\n     * <br/><br/>\n     * When this value is not null, it will be used in place of the Space gravity\n     * when performing buoyancy computations.\n     */\n    #if nape_swc@:isVar #end\n    public var gravity(get_gravity,set_gravity):Null<Vec2>;\n    inline function get_gravity():Null<Vec2>{\n        return zpp_inner.wrap_gravity;\n    }\n    inline function set_gravity(gravity:Null<Vec2>):Null<Vec2>{\n        {\n            if(gravity==null){\n                if(zpp_inner.wrap_gravity!=null){\n                    zpp_inner.wrap_gravity.zpp_inner._inuse=false;\n                    zpp_inner.wrap_gravity.dispose();\n                    zpp_inner.wrap_gravity=null;\n                }\n            }\n            else{\n                {\n                    #if(!NAPE_RELEASE_BUILD)\n                    if(gravity!=null&&gravity.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                    #end\n                };\n                if(zpp_inner.wrap_gravity==null)zpp_inner.getgravity();\n                this.gravity.set(gravity);\n            }\n        }\n        return get_gravity();\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        return \"{ density: \"+density+\" viscosity: \"+viscosity+\" gravity: \"+gravity+\" }\";\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of GravMassMode values for a Body.\n */\n@:final#if nape_swc@:keep #end\nclass GravMassMode{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"GravMassMode\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==DEFAULT)return\"DEFAULT\";\n        else if(this==FIXED)return\"FIXED\";\n        else if(this==SCALED)return\"SCALED\";\n        else return \"\";\n    }\n    /**\n     * Default method of computation.\n     * <br/><br/>\n     * Mass seen by gravity equal to the Body mass.\n     */\n    #if nape_swc@:isVar #end\n    public static var DEFAULT(get_DEFAULT,never):GravMassMode;\n    inline static function get_DEFAULT(){\n        if(ZPP_Flags.GravMassMode_DEFAULT==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.GravMassMode_DEFAULT=new GravMassMode();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.GravMassMode_DEFAULT;\n    }\n    /**\n     * Fixed method of computation.\n     * <br/><br/>\n     * Mass seen by gravity set by user.\n     */\n    #if nape_swc@:isVar #end\n    public static var FIXED(get_FIXED,never):GravMassMode;\n    inline static function get_FIXED(){\n        if(ZPP_Flags.GravMassMode_FIXED==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.GravMassMode_FIXED=new GravMassMode();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.GravMassMode_FIXED;\n    }\n    /**\n     * Scaled method of computation.\n     * <br/><br/>\n     * Mass seen by gravity computed as a factor of the Body mass with\n     * scaling factor set by user.\n     */\n    #if nape_swc@:isVar #end\n    public static var SCALED(get_SCALED,never):GravMassMode;\n    inline static function get_SCALED(){\n        if(ZPP_Flags.GravMassMode_SCALED==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.GravMassMode_SCALED=new GravMassMode();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.GravMassMode_SCALED;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of InertiaMode values for a Body.\n */\n@:final#if nape_swc@:keep #end\nclass InertiaMode{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"InertiaMode\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==DEFAULT)return\"DEFAULT\";\n        else if(this==FIXED)return\"FIXED\";\n        else return \"\";\n    }\n    /**\n     * Default method of computation.\n     * <br/><br/>\n     * Moment of inertia will be computed based on Body's Shape's inertias and densities.\n     */\n    #if nape_swc@:isVar #end\n    public static var DEFAULT(get_DEFAULT,never):InertiaMode;\n    inline static function get_DEFAULT(){\n        if(ZPP_Flags.InertiaMode_DEFAULT==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.InertiaMode_DEFAULT=new InertiaMode();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.InertiaMode_DEFAULT;\n    }\n    /**\n     * Fixed method of computation.\n     * <br/><br/>\n     * Moment of inertia set by user.\n     */\n    #if nape_swc@:isVar #end\n    public static var FIXED(get_FIXED,never):InertiaMode;\n    inline static function get_FIXED(){\n        if(ZPP_Flags.InertiaMode_FIXED==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.InertiaMode_FIXED=new InertiaMode();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.InertiaMode_FIXED;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass InteractorIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:InteractorList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:InteractorIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:InteractorIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_InteractorList.internal)throw \"Error: Cannot instantiate \"+\"Interactor\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:InteractorList){\n        var ret=if(zpp_pool==null){\n            ZPP_InteractorList.internal=true;\n            var ret=new InteractorIterator();\n            ZPP_InteractorList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=InteractorIterator.zpp_pool;\n                InteractorIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Interactor type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Interactor = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Interactor = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Interactor = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass InteractorList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_InteractorList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Interactor\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Interactor>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new InteractorList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Interactor)#else Std.is(i,Interactor)#end)throw \"Error: Array contains non \"+\"Interactor\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Interactor>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new InteractorList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Interactor):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner_i);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Interactor{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer_i;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Interactor):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Interactor\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner_i);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner_i);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Interactor):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Interactor\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner_i);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner_i);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Interactor{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Interactor\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer_i;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer_i;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer_i;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Interactor{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Interactor\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer_i;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer_i;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer_i;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:Interactor):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Interactor):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Interactor\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner_i){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner_i);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Interactor\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return InteractorIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new InteractorList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Interactor\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:InteractorList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_InteractorList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:Interactor->Void):InteractorList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=InteractorIterator.zpp_pool;\n                    InteractorIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Interactor->Bool):InteractorList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of MassMode values for a Body.\n */\n@:final#if nape_swc@:keep #end\nclass MassMode{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"MassMode\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==DEFAULT)return\"DEFAULT\";\n        else if(this==FIXED)return\"FIXED\";\n        else return \"\";\n    }\n    /**\n     * Default method of computation.\n     * <br/><br/>\n     * Mass will be computed based on Body's Shape's areas and densities.\n     */\n    #if nape_swc@:isVar #end\n    public static var DEFAULT(get_DEFAULT,never):MassMode;\n    inline static function get_DEFAULT(){\n        if(ZPP_Flags.MassMode_DEFAULT==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.MassMode_DEFAULT=new MassMode();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.MassMode_DEFAULT;\n    }\n    /**\n     * Fixed method of computation.\n     * <br/><br/>\n     * Mass set by user.\n     */\n    #if nape_swc@:isVar #end\n    public static var FIXED(get_FIXED,never):MassMode;\n    inline static function get_FIXED(){\n        if(ZPP_Flags.MassMode_FIXED==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.MassMode_FIXED=new MassMode();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.MassMode_FIXED;\n    }\n}\n","package nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Material property providing physical attributes to a Shape.\n */\n@:final#if nape_swc@:keep #end\nclass Material{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Material=null;\n    /**\n     * Dynamic object for user to store additional data.\n     * <br/><br/>\n     * This object cannot be set, only its dynamically created\n     * properties may be set. In AS3 the type of this property is &#42\n     * <br/><br/>\n     * This object will be lazily constructed so that until accessed\n     * for the first time, will be null internally.\n     *\n     * @default {}\n     */\n    #if nape_swc@:isVar #end\n    public var userData(get_userData,never):Dynamic<Dynamic>;\n    inline function get_userData():Dynamic<Dynamic>{\n        if(zpp_inner.userData==null){\n            zpp_inner.userData=cast{};\n        }\n        return zpp_inner.userData;\n    }\n    /**\n     * Set of all active shapes using this object.\n     * <br/><br/>\n     * Activeness of a shape in the sense that the Shape's Body is inside of a Space.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var shapes(get_shapes,never):ShapeList;\n    inline function get_shapes():ShapeList{\n        if(zpp_inner.wrap_shapes==null)zpp_inner.wrap_shapes=ZPP_ShapeList.get(zpp_inner.shapes,true);\n        return zpp_inner.wrap_shapes;\n    }\n    /**\n     * Construct a new Material object.\n     *\n     * @param elasticity The coeffecient of elasticity for material.\n     *                   (default 0.0)\n     * @param dynamicFriction The coeffecient of dynamic friction for\n     *                        material. (default 1.0)\n     * @param staticFriction The coeffecient of static friction for\n     *                       material. (default 2.0)\n     * @param density The density of the shape using this material in units\n     *                of g/pixel/pixel. (default 1.0)\n     * @param rollingFriction The coeffecient of rolling friction for material\n     *                        used in circle friction computations. (default 0.001)\n     * @return The constructed Material object.\n     */\n    public function new(elasticity:Float=0.0,dynamicFriction:Float=1.0,staticFriction:Float=2.0,density:Float=1,rollingFriction:Float=0.001){\n        {\n            if(ZPP_Material.zpp_pool==null){\n                zpp_inner=new ZPP_Material();\n                #if NAPE_POOL_STATS ZPP_Material.POOL_TOT++;\n                ZPP_Material.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                zpp_inner=ZPP_Material.zpp_pool;\n                ZPP_Material.zpp_pool=zpp_inner.next;\n                zpp_inner.next=null;\n                #if NAPE_POOL_STATS ZPP_Material.POOL_CNT--;\n                ZPP_Material.POOL_ADD++;\n                #end\n            }\n            zpp_inner.alloc();\n        };\n        zpp_inner.outer=this;\n        this.elasticity=elasticity;\n        this.dynamicFriction=dynamicFriction;\n        this.staticFriction=staticFriction;\n        this.density=density;\n        this.rollingFriction=rollingFriction;\n    }\n    /**\n     * Produce a copy of this Material object.\n     * <br/><br/>\n     * The copied object will be identical in all properties with the the\n     * copied userData being assigned the same fields as 'this' Shape with the\n     * same values copied over by reference for object types.\n     *\n     * @return The copied Material.\n     */\n    #if nape_swc@:keep #end\n    public function copy(){\n        var ret=new Material(elasticity,dynamicFriction,staticFriction,density,rollingFriction);\n        if(zpp_inner.userData!=null)ret.zpp_inner.userData=Reflect.copy(zpp_inner.userData);\n        return ret;\n    }\n    /**\n     * Elasticity of material.\n     * <br/><br/>\n     * This property may take any value. Coeffecients of elasticity are combined\n     * by taking their average, and then clamping to the range [0,1]. In this way\n     * you may give very large values (even infinites) to this property to bias\n     * the result of combining elasticities.\n     * <br/><br/>\n     * A combined, clamped value of 0 results in no bouncing whatsoever.\n     * <br/>\n     * A combine, clamped value of 1 results in complete elasticity where if\n     * possible, the objects will not lose any energy at all.\n     *\n     * @default 0.0\n     */\n    #if nape_swc@:isVar #end\n    public var elasticity(get_elasticity,set_elasticity):Float;\n    inline function get_elasticity():Float{\n        return zpp_inner.elasticity*(\"elasticity\"==\"density\"?1000:1);\n    }\n    inline function set_elasticity(elasticity:Float):Float{\n        {\n            if(elasticity!=this.elasticity){\n                #if(!NAPE_RELEASE_BUILD)\n                if((elasticity!=elasticity))throw \"Error: Material::\"+\"elasticity\"+\" cannot be NaN\";\n                if(\"elasticity\"==\"density\"&&elasticity<0)throw \"Error: Material::density must be positive\";\n                if(\"elasticity\"!=\"elasticity\"&&elasticity<0)throw \"Error: Material::\"+\"elasticity\"+\" cannot be negative\";\n                #end\n                zpp_inner.elasticity=elasticity/(\"elasticity\"==\"density\"?1000:1);\n                zpp_inner.invalidate(ZPP_Material.WAKE|ZPP_Material.ARBITERS);\n            }\n        }\n        return get_elasticity();\n    }\n    /**\n     * Coeffecient of dynamic friction for material.\n     * <br/><br/>\n     * This property may take any zero or positive value. Coeffecients of\n     * dynamicFriction are combined by taking the square root of their product.\n     * <br/><br/>\n     * The higher this value the more quickly objects will slow down from speed\n     * when sliding.\n     *\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var dynamicFriction(get_dynamicFriction,set_dynamicFriction):Float;\n    inline function get_dynamicFriction():Float{\n        return zpp_inner.dynamicFriction*(\"dynamicFriction\"==\"density\"?1000:1);\n    }\n    inline function set_dynamicFriction(dynamicFriction:Float):Float{\n        {\n            if(dynamicFriction!=this.dynamicFriction){\n                #if(!NAPE_RELEASE_BUILD)\n                if((dynamicFriction!=dynamicFriction))throw \"Error: Material::\"+\"dynamicFriction\"+\" cannot be NaN\";\n                if(\"dynamicFriction\"==\"density\"&&dynamicFriction<0)throw \"Error: Material::density must be positive\";\n                if(\"dynamicFriction\"!=\"elasticity\"&&dynamicFriction<0)throw \"Error: Material::\"+\"dynamicFriction\"+\" cannot be negative\";\n                #end\n                zpp_inner.dynamicFriction=dynamicFriction/(\"dynamicFriction\"==\"density\"?1000:1);\n                zpp_inner.invalidate(ZPP_Material.WAKE|ZPP_Material.ANGDRAG|ZPP_Material.ARBITERS);\n            }\n        }\n        return get_dynamicFriction();\n    }\n    /**\n     * Coeffecient of static friction for material.\n     * <br/><br/>\n     * This property may take any zero or positive value. Coeffecients of\n     * staticFriction are combined by taking the square root of their product.\n     * <br/><br/>\n     * The higher this value the more quickly objects will come to rest once moving\n     * very slowly, and the harder it will be to cause the objcet to begin to slide.\n     *\n     * @default 2\n     */\n    #if nape_swc@:isVar #end\n    public var staticFriction(get_staticFriction,set_staticFriction):Float;\n    inline function get_staticFriction():Float{\n        return zpp_inner.staticFriction*(\"staticFriction\"==\"density\"?1000:1);\n    }\n    inline function set_staticFriction(staticFriction:Float):Float{\n        {\n            if(staticFriction!=this.staticFriction){\n                #if(!NAPE_RELEASE_BUILD)\n                if((staticFriction!=staticFriction))throw \"Error: Material::\"+\"staticFriction\"+\" cannot be NaN\";\n                if(\"staticFriction\"==\"density\"&&staticFriction<0)throw \"Error: Material::density must be positive\";\n                if(\"staticFriction\"!=\"elasticity\"&&staticFriction<0)throw \"Error: Material::\"+\"staticFriction\"+\" cannot be negative\";\n                #end\n                zpp_inner.staticFriction=staticFriction/(\"staticFriction\"==\"density\"?1000:1);\n                zpp_inner.invalidate(ZPP_Material.WAKE|ZPP_Material.ARBITERS);\n            }\n        }\n        return get_staticFriction();\n    }\n    /**\n     * Density of Shape's using this Material.\n     * <br/><br/>\n     * This property has units of g/pixel/pixel, not Kg/pixel/pixel for the\n     * simple reason that we get more reasonable values like 1 instead of 0.001\n     * to attain reasonable mass values for Bodys.\n     *\n     * @default 1\n     */\n    #if nape_swc@:isVar #end\n    public var density(get_density,set_density):Float;\n    inline function get_density():Float{\n        return zpp_inner.density*(\"density\"==\"density\"?1000:1);\n    }\n    inline function set_density(density:Float):Float{\n        {\n            if(density!=this.density){\n                #if(!NAPE_RELEASE_BUILD)\n                if((density!=density))throw \"Error: Material::\"+\"density\"+\" cannot be NaN\";\n                if(\"density\"==\"density\"&&density<0)throw \"Error: Material::density must be positive\";\n                if(\"density\"!=\"elasticity\"&&density<0)throw \"Error: Material::\"+\"density\"+\" cannot be negative\";\n                #end\n                zpp_inner.density=density/(\"density\"==\"density\"?1000:1);\n                zpp_inner.invalidate(ZPP_Material.WAKE|ZPP_Material.PROPS);\n            }\n        }\n        return get_density();\n    }\n    /**\n     * Coeffecient of rolling friction for circle interactions.\n     * <br/><br/>\n     * This property may take any zero or positive value. Coeffecients of\n     * staticFriction are combined by taking the square root of their product.\n     * <br/><br/>\n     * The higher this value, the more quickly a rolling circle - which would\n     * otherwise roll forever ignoring drag and numerical issues - will come to\n     * rest.\n     *\n     * @default 0.01\n     */\n    #if nape_swc@:isVar #end\n    public var rollingFriction(get_rollingFriction,set_rollingFriction):Float;\n    inline function get_rollingFriction():Float{\n        return zpp_inner.rollingFriction*(\"rollingFriction\"==\"density\"?1000:1);\n    }\n    inline function set_rollingFriction(rollingFriction:Float):Float{\n        {\n            if(rollingFriction!=this.rollingFriction){\n                #if(!NAPE_RELEASE_BUILD)\n                if((rollingFriction!=rollingFriction))throw \"Error: Material::\"+\"rollingFriction\"+\" cannot be NaN\";\n                if(\"rollingFriction\"==\"density\"&&rollingFriction<0)throw \"Error: Material::density must be positive\";\n                if(\"rollingFriction\"!=\"elasticity\"&&rollingFriction<0)throw \"Error: Material::\"+\"rollingFriction\"+\" cannot be negative\";\n                #end\n                zpp_inner.rollingFriction=rollingFriction/(\"rollingFriction\"==\"density\"?1000:1);\n                zpp_inner.invalidate(ZPP_Material.WAKE|ZPP_Material.ARBITERS);\n            }\n        }\n        return get_rollingFriction();\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        return \"{ elasticity: \"+elasticity+\" dynamicFriction: \"+dynamicFriction+\" staticFriction: \"+staticFriction+\" density: \"+density+\" rollingFriction: \"+rollingFriction+\" }\";\n    }\n    /**\n     * Predefined constructor for a wood style Material.\n     *\n     * @return <code>new Material(0.4,0.2,0.38,0.7,0.005)</code>\n     */\n    #if nape_swc@:keep #end\n    public static function wood(){\n        return new Material(0.4,0.2,0.38,0.7,0.005);\n    }\n    /**\n     * Predefined constructor for a steel style Material.\n     *\n     * @return <code>new Material(0.2,0.57,0.74,7.8,0.001)</code>\n     */\n    #if nape_swc@:keep #end\n    public static function steel(){\n        return new Material(0.2,0.57,0.74,7.8,0.001);\n    }\n    /**\n     * Predefined constructor for a ice style Material.\n     *\n     * @return <code>new Material(0.3,0.03,0.1,0.9,0.0001)</code>\n     */\n    #if nape_swc@:keep #end\n    public static function ice(){\n        return new Material(0.3,0.03,0.1,0.9,0.0001);\n    }\n    /**\n     * Predefined constructor for a rubber style Material.\n     *\n     * @return <code>new Material(0.8,1.0,1.4,1.5,0.01)</code>\n     */\n    #if nape_swc@:keep #end\n    public static function rubber(){\n        return new Material(0.8,1.0,1.4,1.5,0.01);\n    }\n    /**\n     * Predefined constructor for a glass style Material.\n     *\n     * @return <code>new Material(0.4,0.4,0.94,2.6,0.002)</code>\n     */\n    #if nape_swc@:keep #end\n    public static function glass(){\n        return new Material(0.4,0.4,0.94,2.6,0.002);\n    }\n    /**\n     * Predefined constructor for a sand style Material.\n     *\n     * @return <code>new Material(-1.0,0.45,0.6,1.6,16.0)</code>\n     */\n    #if nape_swc@:keep #end\n    public static function sand(){\n        return new Material(-1.0,0.45,0.6,1.6,16.0);\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Base type for Nape Shape's\n */\n#if nape_swc@:keep #end\nclass Shape extends Interactor{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Shape=null;\n    /**\n     * Type of shape.\n     */\n    #if nape_swc@:isVar #end\n    public var type(get_type,never):ShapeType;\n    inline function get_type():ShapeType{\n        return ZPP_Shape.types[zpp_inner.type];\n    }\n    /**\n     * Faster equivalent to <code>type == ShapeType.CIRCLE</code>\n     *\n     * @return True if shape is a Circle type.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isCircle(){\n        return zpp_inner.isCircle();\n    }\n    /**\n     * Faster equivalent to <code>type == ShapeType.POLYGON</code>\n     *\n     * @return True if shape is a Polygon type.\n     */\n    #if nape_swc@:keep #end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isPolygon(){\n        return zpp_inner.isPolygon();\n    }\n    /**\n     * @private\n     */\n    #if(!NAPE_RELEASE_BUILD)\n    public static var zpp_internalAlloc=false;\n    #end\n    function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        Interactor.zpp_internalAlloc=true;\n        super();\n        Interactor.zpp_internalAlloc=false;\n        #end\n        #if NAPE_RELEASE_BUILD \n        super();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(!zpp_internalAlloc)throw \"Error: Shape cannot be instantiated derp!\";\n        #end\n    }\n    /**\n     * Body this Shape is assigned to.\n     * <br/><br/>\n     * This value can be set to add Shape to the given Body, and set to null\n     * to remove it from its present Body.\n     *\n     * @default null\n     */\n    #if nape_swc@:isVar #end\n    public var body(get_body,set_body):Null<Body>;\n    inline function get_body():Null<Body>{\n        return if(zpp_inner.body!=null)zpp_inner.body.outer else null;\n    }\n    inline function set_body(body:Null<Body>):Null<Body>{\n        {\n            zpp_inner.immutable_midstep(\"Shape::body\");\n            if(this.body!=body){\n                if(zpp_inner.body!=null)this.body.shapes.remove(this);\n                if(body!=null)body.shapes.add(this);\n            }\n        }\n        return get_body();\n    }\n    /**\n     * Faster equivalent to casting this to Circle type\n     */\n    #if nape_swc@:isVar #end\n    public var castCircle(get_castCircle,never):Null<Circle>;\n    inline function get_castCircle():Null<Circle>{\n        return if(isCircle())zpp_inner.circle.outer_zn else null;\n    }\n    /**\n     * Faster equivalent to casting this to Polygon type\n     */\n    #if nape_swc@:isVar #end\n    public var castPolygon(get_castPolygon,never):Null<Polygon>;\n    inline function get_castPolygon():Null<Polygon>{\n        return if(isPolygon())zpp_inner.polygon.outer_zn else null;\n    }\n    /**\n     * World space centre of mass of this Shape.\n     * <br/><br/>\n     * This value can be accessed even if Shape is not in a Body, but\n     * attempting to query the values of it will return an error in debug\n     * builds unless the Shape is in a Body.\n     * <br/><br/>\n     * This Vec2 is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var worldCOM(get_worldCOM,never):Vec2;\n    inline function get_worldCOM():Vec2{\n        if(zpp_inner.wrap_worldCOM==null){\n            zpp_inner.wrap_worldCOM=Vec2.get(zpp_inner.worldCOMx,zpp_inner.worldCOMy);\n            zpp_inner.wrap_worldCOM.zpp_inner._inuse=true;\n            zpp_inner.wrap_worldCOM.zpp_inner._immutable=true;\n            zpp_inner.wrap_worldCOM.zpp_inner._validate=zpp_inner.getworldCOM;\n        }\n        return zpp_inner.wrap_worldCOM;\n    }\n    /**\n     * Local space centre of mass of this Shape.\n     * <br/><br/>\n     * This Vec2 can be set and is equivalent to performing the necessary\n     * translation of the Shape in local coordinates, and also equivalent\n     * to <code>this.localCOM.set(value)</code>.\n     * <br/>\n     * Setting this value whilst this shape is part of a static Body that\n     * is part of a Space is not permitted.\n     */\n    #if nape_swc@:isVar #end\n    public var localCOM(get_localCOM,set_localCOM):Vec2;\n    inline function get_localCOM():Vec2{\n        if(zpp_inner.wrap_localCOM==null){\n            if(isCircle())zpp_inner.circle.setupLocalCOM();\n            else zpp_inner.polygon.setupLocalCOM();\n        }\n        return zpp_inner.wrap_localCOM;\n    }\n    inline function set_localCOM(localCOM:Vec2):Vec2{\n        {\n            zpp_inner.immutable_midstep(\"Body::localCOM\");\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(localCOM!=null&&localCOM.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.body!=null&&zpp_inner.body.space!=null&&zpp_inner.body.isStatic())throw \"Error: Cannot modify Shape belonging to a static Object once inside a Space\";\n            if(localCOM==null)throw \"Error: Shape::localCOM cannot be null\";\n            #end\n            this.localCOM.set(localCOM);\n        }\n        return get_localCOM();\n    }\n    /**\n     * Area of the Hhape.\n     */\n    #if nape_swc@:isVar #end\n    public var area(get_area,never):Float;\n    inline function get_area():Float{\n        zpp_inner.validate_area_inertia();\n        return zpp_inner.area;\n    }\n    /**\n     * Non-mass weighted moment of inertia for Shape.\n     */\n    #if nape_swc@:isVar #end\n    public var inertia(get_inertia,never):Float;\n    inline function get_inertia():Float{\n        zpp_inner.validate_area_inertia();\n        return zpp_inner.inertia;\n    }\n    /**\n     * Coeffecient of angular fluid drag for this Shape.\n     */\n    #if nape_swc@:isVar #end\n    public var angDrag(get_angDrag,never):Float;\n    inline function get_angDrag():Float{\n        zpp_inner.validate_angDrag();\n        return zpp_inner.angDrag;\n    }\n    /**\n     * Material used by this shape.\n     *\n     * @default new Material()\n     */\n    #if nape_swc@:isVar #end\n    public var material(get_material,set_material):Material;\n    inline function get_material():Material{\n        return zpp_inner.material.wrapper();\n    }\n    inline function set_material(material:Material):Material{\n        {\n            zpp_inner.immutable_midstep(\"Shape::material\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(material==null)throw \"Error: Cannot assign null as Shape material\";\n            #end\n            zpp_inner.setMaterial(material.zpp_inner);\n        }\n        return get_material();\n    }\n    /**\n     * InteractionFilter used by this shape.\n     *\n     * @default new InteractionFilter()\n     */\n    #if nape_swc@:isVar #end\n    public var filter(get_filter,set_filter):InteractionFilter;\n    inline function get_filter():InteractionFilter{\n        return zpp_inner.filter.wrapper();\n    }\n    inline function set_filter(filter:InteractionFilter):InteractionFilter{\n        {\n            zpp_inner.immutable_midstep(\"Shape::filter\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(filter==null)throw \"Error: Cannot assign null as Shape filter\";\n            #end\n            zpp_inner.setFilter(filter.zpp_inner);\n        }\n        return get_filter();\n    }\n    /**\n     * FluidProperties used by this shape.\n     * <br/><br/>\n     * This object provides information for buoyancy and fluid drag computations\n     * when this shape is interacting as a fluid.\n     *\n     * @default new FluidProperties();\n     */\n    #if nape_swc@:isVar #end\n    public var fluidProperties(get_fluidProperties,set_fluidProperties):FluidProperties;\n    inline function get_fluidProperties():FluidProperties{\n        zpp_inner.immutable_midstep(\"Shape::fluidProperties\");\n        if(zpp_inner.fluidProperties==null)zpp_inner.setFluid(new FluidProperties().zpp_inner);\n        return zpp_inner.fluidProperties.wrapper();\n    }\n    inline function set_fluidProperties(fluidProperties:FluidProperties):FluidProperties{\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(fluidProperties==null)throw \"Error: Cannot assign null as Shape fluidProperties, disable fluids by setting fluidEnabled to false\";\n            #end\n            zpp_inner.setFluid(fluidProperties.zpp_inner);\n        }\n        return get_fluidProperties();\n    }\n    /**\n     * Whether this shape is able to interact as a fluid.\n     * <br/><br/>\n     * Unless this field is true, this Shape can never interact as a fluid.\n     * <br/><br/>\n     * Just because this field is true however, does not mean this shape will always\n     * interact as a fluid, the final result is down to the combination of\n     * InteractionFilters on the pairing of shapes and sensory interaction\n     * takes higher priority.\n     *\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var fluidEnabled(get_fluidEnabled,set_fluidEnabled):Bool;\n    inline function get_fluidEnabled():Bool{\n        return zpp_inner.fluidEnabled;\n    }\n    inline function set_fluidEnabled(fluidEnabled:Bool):Bool{\n        {\n            zpp_inner.immutable_midstep(\"Shape::fluidEnabled\");\n            zpp_inner.fluidEnabled=fluidEnabled;\n            if(fluidEnabled&&zpp_inner.fluidProperties==null)this.fluidProperties=new FluidProperties();\n            zpp_inner.wake();\n        }\n        return get_fluidEnabled();\n    }\n    /**\n     * Whether this shape is able to interact as sensor.\n     * <br/><br/>\n     * Unless this field is true, this Shape can never interact as a sensor.\n     * <br/><br/>\n     * Just because this field is true however, does not mean this shape will always\n     * interact as a sensor, the final result is down to the combination of\n     * InteractionFilters on the pairing of shapes. Sensor interaction has highest priority.\n     *\n     * @default false\n     */\n    #if nape_swc@:isVar #end\n    public var sensorEnabled(get_sensorEnabled,set_sensorEnabled):Bool;\n    inline function get_sensorEnabled():Bool{\n        return zpp_inner.sensorEnabled;\n    }\n    inline function set_sensorEnabled(sensorEnabled:Bool):Bool{\n        {\n            zpp_inner.immutable_midstep(\"Shape::sensorEnabled\");\n            zpp_inner.sensorEnabled=sensorEnabled;\n            zpp_inner.wake();\n        }\n        return get_sensorEnabled();\n    }\n    /**\n     * World space bounding box for this shape.\n     * <br/><br/>\n     * This value can be accessed even if the Shape is not part of a Body,\n     * however attempting to query its values would result in an error in\n     * debug builds.\n     * <br/><br/>\n     * This AABB is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var bounds(get_bounds,never):AABB;\n    inline function get_bounds():AABB{\n        return zpp_inner.aabb.wrapper();\n    }\n    /**\n     * Translate this shape in its local coordinate system.\n     * <br/><br/>\n     * This is equivalent to: <code>shape.localCOM.addeq(displacement)</code>\n     *\n     * @param translation The local translation to apply to Shape.\n     * @return A reference to 'this' Shape.\n     * @throws # If translation is null or has been disposed of.\n     * @throws # If this shape is part of a static body that is inside of a Space.\n     */\n    #if nape_swc@:keep #end\n    public function translate(translation:Vec2){\n        zpp_inner.immutable_midstep(\"Shape::translate()\");\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(translation!=null&&translation.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.body!=null&&zpp_inner.body.space!=null&&zpp_inner.body.isStatic())throw \"Error: Cannot modify Shape belonging to a static Object once inside a Space\";\n        if(translation==null)throw \"Error: Cannot displace Shape by null Vec2\";\n        #end\n        if(translation.lsq()>0){\n            if(isCircle())zpp_inner.circle.__translate(translation.x,translation.y);\n            else zpp_inner.polygon.__translate(translation.x,translation.y);\n        }\n        ({\n            if(({\n                translation.zpp_inner.weak;\n            })){\n                translation.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return this;\n    }\n    /**\n     * Scale this shape in its local coordinate system.\n     * <br/><br/>\n     * For Circle shapes, scalex and scaley must be exactly equal.\n     *\n     * @param scalex The x-coordinate scaling to apply to Shape.\n     * @param scaley The y-coordinate scaling to apply to Shape.\n     * @return A reference to 'this' Shape.\n     * @throws # If this shape is part of a static body that is inside of a Space.\n     * @throws # If scalex or scaley is 0. Negative values 'are' permitted.\n     */\n    #if nape_swc@:keep #end\n    public function scale(scalex:Float,scaley:Float){\n        zpp_inner.immutable_midstep(\"Shape::scale()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.body!=null&&zpp_inner.body.space!=null&&zpp_inner.body.isStatic())throw \"Error: Cannot modify Shape belonging to a static Object once inside a Space\";\n        if((scalex!=scalex)||(scaley!=scaley))throw \"Error: Cannot scale Shape by NaN\";\n        if(scalex==0||scaley==0)throw \"Error: Cannot Scale shape by a factor of 0\";\n        #end\n        if(isCircle()){\n            var d=scalex*scalex-scaley*scaley;\n            if(d*d<(Config.epsilon*Config.epsilon)){\n                zpp_inner.circle.__scale(scalex,scaley);\n            }\n            else{\n                #if(!NAPE_RELEASE_BUILD)\n                throw \"Error: Cannot perform a non equal scaling on a Circle\";\n                #end\n            }\n        }\n        else zpp_inner.polygon.__scale(scalex,scaley);\n        return this;\n    }\n    /**\n     * Rotate this shape in its local coordinate system.\n     *\n     * @param angle The number of radians to rotate this Shape by in a clockwise\n     *              direction.\n     * @return A reference to 'this' Shape.\n     * @throws # If this shape is part of a static body that is inside of a Space.\n     */\n    #if nape_swc@:keep #end\n    public function rotate(angle:Float){\n        zpp_inner.immutable_midstep(\"Shape::rotate()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.body!=null&&zpp_inner.body.space!=null&&zpp_inner.body.isStatic())throw \"Error: Cannot modify Shape belonging to a static Object once inside a Space\";\n        if((angle!=angle))throw \"Error: Cannot rotate Shape by NaN\";\n        #end\n        var dr=angle%(2*Math.PI);\n        if(dr!=0.0){\n            var cos=Math.cos(angle);\n            var sin=Math.sin(angle);\n            if(isCircle())zpp_inner.circle.__rotate(sin,cos);\n            else zpp_inner.polygon.__rotate(sin,cos);\n        }\n        return this;\n    }\n    /**\n     * Apply local transformation matrix to Shape.\n     * <br/><br/>\n     * For Circle shapes, the matrix must be equiorthogonal.\n     *\n     * @param matrix The matrix to transform Shape by.\n     * @return A reference to 'this' Shape.\n     * @throws # If matrix is null or singular.\n     * @throws # If shape is a Circle, and matrix is not equiorthogonal.\n     * @throws # If this shape is part of a static body that is inside of a Space.\n     */\n    #if nape_swc@:keep #end\n    public function transform(matrix:Mat23){\n        zpp_inner.immutable_midstep(\"Shape::transform()\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.body!=null&&zpp_inner.body.space!=null&&zpp_inner.body.isStatic())throw \"Error: Cannot modify Shape belonging to a static Object once inside a Space\";\n        if(matrix==null)throw \"Error: Cannot transform Shape by null matrix\";\n        if(matrix.singular())throw \"Error: Cannot transform Shape by a singular matrix\";\n        #end\n        if(isCircle()){\n            if(matrix.equiorthogonal()){\n                zpp_inner.circle.__transform(matrix);\n            }\n            else{\n                #if(!NAPE_RELEASE_BUILD)\n                throw \"Error: Cannot transform Circle by a non equiorthogonal matrix\";\n                #end\n            }\n        }\n        else zpp_inner.polygon.__transform(matrix);\n        return this;\n    }\n    /**\n     * Test containment of world-space coordinate in Shape.\n     * <br/><br/>\n     * This Shape must be part of a Body so that world coordinates are\n     * defined.\n     *\n     * @param point The point to check for containment.\n     * @return True if point is contained within the Shape.\n     * @throws If point is null or disposed of.\n     * @throws If this shape is not part of a Body.\n     */\n    #if nape_swc@:keep #end\n    public function contains(point:Vec2){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null)throw \"Cannot check null point for containment\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(body==null)throw \"Error: Shape is not well defined without a Body\";\n        #end\n        ZPP_Geom.validateShape(zpp_inner);\n        point.zpp_inner.validate();\n        var ret=ZPP_Collide.shapeContains(zpp_inner,point.zpp_inner);\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Produce an exact copy of this Shape.\n     * <br/><br/>\n     * The copied shape will be identical with the copied Shape's userData\n     * object being assigned the same fields as 'this' Shape with the same\n     * values copied over by reference for object types.\n     *\n     * @return A copy of this shape.\n     */\n    #if nape_swc@:keep #end\n    public function copy(){\n        return zpp_inner.copy();\n    }\n    /**\n     * @private\n     */\n    @:keep public override function toString(){\n        var ret=isCircle()?\"Circle\":\"Polygon\";\n        return ret+\"#\"+id;\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Shape subtype representing a Circle\n */\n@:final#if nape_swc@:keep #end\nclass Circle extends Shape{\n    /**\n     * @private\n     */\n    public var zpp_inner_zn:ZPP_Circle=null;\n    /**\n     * Construct a new Circle\n     *\n     * @param radius The radius of the circle, this value must be positive.\n     * @param localCOM The local offset for the circle. (default &#40;0,0&#41;)\n     * @param material The material for this circle. (default new Material&#40;&#41;)\n     * @param filter The interaction filter for this circle.\n     *               (default new InteractionFilter&#40;&#41;)\n     * @return The constructed Circle\n     * @throws # If radius is not strictly positive\n     * @throws # If localCOM is non-null, but has been disposed of.\n     */\n    #if flib@:keep function flibopts_3(){}\n    #end\n    public function new(radius:Float,localCOM:Vec2=null,material:Material=null,filter:InteractionFilter=null){\n        #if(!NAPE_RELEASE_BUILD)\n        Shape.zpp_internalAlloc=true;\n        super();\n        Shape.zpp_internalAlloc=false;\n        #end\n        #if NAPE_RELEASE_BUILD \n        super();\n        #end\n        zpp_inner_zn=new ZPP_Circle();\n        zpp_inner_zn.outer=this;\n        zpp_inner_zn.outer_zn=this;\n        zpp_inner=zpp_inner_zn;\n        zpp_inner_i=zpp_inner;\n        zpp_inner_i.outer_i=this;\n        this.radius=radius;\n        if(localCOM==null){\n            zpp_inner.localCOMx=0;\n            zpp_inner.localCOMy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((zpp_inner.localCOMx!=zpp_inner.localCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.localCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((zpp_inner.localCOMy!=zpp_inner.localCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.localCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        else{\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(localCOM!=null&&localCOM.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            {\n                zpp_inner.localCOMx=localCOM.x;\n                zpp_inner.localCOMy=localCOM.y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((zpp_inner.localCOMx!=zpp_inner.localCOMx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.localCOM\"+\",in x: \"+\"localCOM.x\"+\",in y: \"+\"localCOM.y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((zpp_inner.localCOMy!=zpp_inner.localCOMy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(zpp_inner.localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"zpp_inner.localCOM\"+\",in x: \"+\"localCOM.x\"+\",in y: \"+\"localCOM.y\"+\")\");\n                    #end\n                };\n            };\n            ({\n                if(({\n                    localCOM.zpp_inner.weak;\n                })){\n                    localCOM.dispose();\n                    true;\n                }\n                else{\n                    false;\n                }\n            });\n        }\n        if(material==null){\n            if(ZPP_Material.zpp_pool==null){\n                zpp_inner.material=new ZPP_Material();\n                #if NAPE_POOL_STATS ZPP_Material.POOL_TOT++;\n                ZPP_Material.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                zpp_inner.material=ZPP_Material.zpp_pool;\n                ZPP_Material.zpp_pool=zpp_inner.material.next;\n                zpp_inner.material.next=null;\n                #if NAPE_POOL_STATS ZPP_Material.POOL_CNT--;\n                ZPP_Material.POOL_ADD++;\n                #end\n            }\n            zpp_inner.material.alloc();\n        };\n        else this.material=material;\n        if(filter==null){\n            if(ZPP_InteractionFilter.zpp_pool==null){\n                zpp_inner.filter=new ZPP_InteractionFilter();\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_TOT++;\n                ZPP_InteractionFilter.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                zpp_inner.filter=ZPP_InteractionFilter.zpp_pool;\n                ZPP_InteractionFilter.zpp_pool=zpp_inner.filter.next;\n                zpp_inner.filter.next=null;\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_CNT--;\n                ZPP_InteractionFilter.POOL_ADD++;\n                #end\n            }\n            zpp_inner.filter.alloc();\n        };\n        else this.filter=filter;\n        zpp_inner_i.insert_cbtype(CbType.ANY_SHAPE.zpp_inner);\n    }\n    /**\n     * Radius of circle\n     * <br/><br/>\n     * This value must be strictly positive, and attempting to set this value\n     * whilst this Circle is part of a static Body inside a Space will result\n     * in a debug time error.\n     */\n    #if nape_swc@:isVar #end\n    public var radius(get_radius,set_radius):Float;\n    inline function get_radius():Float{\n        return zpp_inner_zn.radius;\n    }\n    inline function set_radius(radius:Float):Float{\n        {\n            zpp_inner.immutable_midstep(\"Circle::radius\");\n            #if(!NAPE_RELEASE_BUILD)\n            if(zpp_inner.body!=null&&zpp_inner.body.isStatic()&&zpp_inner.body.space!=null)throw \"Error: Cannot modifiy radius of Circle contained in static object once added to space\";\n            #end\n            if(radius!=this.radius){\n                #if(!NAPE_RELEASE_BUILD)\n                if((radius!=radius))throw \"Error: Circle::radius cannot be NaN\";\n                if(radius<Config.epsilon)throw \"Error: Circle::radius (\"+radius+\") must be > Config.epsilon\";\n                if(radius>ZPP_Const.FMAX)throw \"Error: Circle::radius (\"+radius+\") must be < PR(Const).FMAX\";\n                #end\n                zpp_inner_zn.radius=radius;\n                zpp_inner_zn.invalidate_radius();\n            }\n        }\n        return get_radius();\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Edge class providing internal details of Polygon.\n */\n@:final#if nape_swc@:keep #end\nclass Edge{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Edge=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Edge.internal)throw \"Error: Cannot instantiate an Edge derp!\";\n        #end\n    }\n    /**\n     * Reference to Polygon this Edge belongs to.\n     */\n    #if nape_swc@:isVar #end\n    public var polygon(get_polygon,never):Polygon;\n    inline function get_polygon():Polygon{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        return zpp_inner.polygon.outer_zn;\n    }\n    /**\n     * Normal of edge in local coordinates.\n     * <br/><br/>\n     * This Vec2 is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var localNormal(get_localNormal,never):Vec2;\n    inline function get_localNormal():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        if(zpp_inner.wrap_lnorm==null)zpp_inner.getlnorm();\n        return zpp_inner.wrap_lnorm;\n    }\n    /**\n     * Normal of edge in world coordinates.\n     * <br/><br/>\n     * This Vec2 is immutable, and may be accessed even if the related Polygon\n     * is not part of a Body but queries to its values will result in a debug\n     * build error.\n     */\n    #if nape_swc@:isVar #end\n    public var worldNormal(get_worldNormal,never):Vec2;\n    inline function get_worldNormal():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        if(zpp_inner.wrap_gnorm==null)zpp_inner.getgnorm();\n        return zpp_inner.wrap_gnorm;\n    }\n    /**\n     * Length of edge.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Float;\n    inline function get_length():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        zpp_inner.polygon.validate_laxi();\n        return zpp_inner.length;\n    }\n    /**\n     * Local projection of polygon onto edge axis.\n     */\n    #if nape_swc@:isVar #end\n    public var localProjection(get_localProjection,never):Float;\n    inline function get_localProjection():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        zpp_inner.polygon.validate_laxi();\n        return zpp_inner.lprojection;\n    }\n    /**\n     * World projection of polygon to edge axis.\n     * <br/><br/>\n     * This value can only be accessed if related Polygon is part of a Body.\n     */\n    #if nape_swc@:isVar #end\n    public var worldProjection(get_worldProjection,never):Float;\n    inline function get_worldProjection():Float{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        if(zpp_inner.polygon.body==null)throw \"Error: Edge world projection only makes sense for Polygons contained within a rigid body\";\n        #end\n        zpp_inner.polygon.validate_gaxi();\n        return zpp_inner.gprojection;\n    }\n    /**\n     * Reference to first local vertex for edge.\n     */\n    #if nape_swc@:isVar #end\n    public var localVertex1(get_localVertex1,never):Vec2;\n    inline function get_localVertex1():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        zpp_inner.polygon.validate_laxi();\n        return zpp_inner.lp0.wrapper();\n    }\n    /**\n     * Reference to second local vertex for edge.\n     */\n    #if nape_swc@:isVar #end\n    public var localVertex2(get_localVertex2,never):Vec2;\n    inline function get_localVertex2():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        zpp_inner.polygon.validate_laxi();\n        return zpp_inner.lp1.wrapper();\n    }\n    /**\n     * Reference to first world vertex for edge.\n     */\n    #if nape_swc@:isVar #end\n    public var worldVertex1(get_worldVertex1,never):Vec2;\n    inline function get_worldVertex1():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        zpp_inner.polygon.validate_gaxi();\n        return zpp_inner.gp0.wrapper();\n    }\n    /**\n     * Reference to second world vertex for edge.\n     */\n    #if nape_swc@:isVar #end\n    public var worldVertex2(get_worldVertex2,never):Vec2;\n    inline function get_worldVertex2():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.polygon==null)throw \"Error: Edge not current in use\";\n        #end\n        zpp_inner.polygon.validate_gaxi();\n        return zpp_inner.gp1.wrapper();\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(zpp_inner.polygon==null)return \"Edge(object-pooled)\";\n        else if(zpp_inner.polygon.body==null){\n            zpp_inner.polygon.validate_laxi();\n            return \"{ localNormal : \"+(\"{ x: \"+zpp_inner.lnormx+\" y: \"+zpp_inner.lnormy+\" }\")+\" }\";\n        }\n        else{\n            zpp_inner.polygon.validate_gaxi();\n            return \"{ localNormal : \"+(\"{ x: \"+zpp_inner.lnormx+\" y: \"+zpp_inner.lnormy+\" }\")+\" worldNormal : \"+(\"{ x: \"+zpp_inner.gnormx+\" y: \"+zpp_inner.gnormy+\" }\")+\" }\";\n        }\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass EdgeIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:EdgeList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:EdgeIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:EdgeIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_EdgeList.internal)throw \"Error: Cannot instantiate \"+\"Edge\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:EdgeList){\n        var ret=if(zpp_pool==null){\n            ZPP_EdgeList.internal=true;\n            var ret=new EdgeIterator();\n            ZPP_EdgeList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=EdgeIterator.zpp_pool;\n                EdgeIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Edge type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Edge = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Edge = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Edge = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass EdgeList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_EdgeList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Edge\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Edge>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new EdgeList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Edge)#else Std.is(i,Edge)#end)throw \"Error: Array contains non \"+\"Edge\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Edge>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new EdgeList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Edge):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Edge{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(index==length-1?index:length-2-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().wrapper();\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Edge):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Edge\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Edge):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Edge\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Edge{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Edge\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Edge{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Edge\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:Edge):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Edge):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Edge\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Edge\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return EdgeIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new EdgeList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Edge\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:EdgeList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_EdgeList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:Edge->Void):EdgeList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=EdgeIterator.zpp_pool;\n                    EdgeIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Edge->Bool):EdgeList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Polygon subtype of Shape.\n * <br/><br/>\n * Can be used to simulate any convex polygon.\n */\n@:final#if nape_swc@:keep #end\nclass Polygon extends Shape{\n    /**\n     * @private\n     */\n    public var zpp_inner_zn:ZPP_Polygon=null;\n    /**\n     * Construct a polygon representing a rectangle.\n     * <br/><br/>\n     * For a dynamic object, you may consider use of the box method instead\n     * as dynamic bodies will only respond as expected if their centre of mass\n     * is equal to the origin.\n     * <br/><br/>\n     * The generate polygon will have coordinates equal to:\n     * <pre>\n     * (x, y) -> (x + width, y + height)\n     * </pre>\n     * Negative values of width/height are permitted so that the given x/y values\n     * may not necessarigly be the top-left corner of rectangle.\n     *\n     * @param x The x coordinate of rectangle.\n     * @param y The y coordinate of rectangle.\n     * @param width The width of the ractangle. This value may be negative.\n     * @param height The height of the rectangle This value may be negative.\n     * @param weak If true, the generated list of vertices will be allocated as\n     *             weak Vec2s so that when this list is passed to a Nape function\n     *             these Vec2s will be automatically sent back to object pool.\n     *             (default false)\n     * @return An array of Vec2 representing the given rectangle.\n     */\n    #if nape_swc@:keep #end\n    public static function rect(x:Float,y:Float,width:Float,height:Float,weak:Bool=false):Array<Vec2>{\n        #if(!NAPE_RELEASE_BUILD)\n        if((x!=x)||(y!=y)||(width!=width)||(height!=height))throw \"Error: Polygon.rect cannot accept NaN arguments\";\n        #end\n        return[Vec2.get(x,y,weak),Vec2.get(x+width,y,weak),Vec2.get(x+width,y+height,weak),Vec2.get(x,y+height,weak)];\n    }\n    /**\n     * Construct a polygon representing an origin centred box.\n     * <br/><br/>\n     * This method is equivalent to calling: <code>Polygon.rect(-width/2,-height/2,width,height)</code>\n     *\n     * @param width The width of the box (This value may be negative but will\n     *              make no difference).\n     * @param height The height of the box (This value may be negative but will\n     *              make no difference).\n     * @param weak If true, the generated list of vertices will be allocated as\n     *             weak Vec2s so that when this list is passed to a Nape function\n     *             these Vec2s will be automatically sent back to object pool.\n     *             (default false)\n     * @return An array of Vec2 representing the given box.\n     */\n    #if nape_swc@:keep #end\n    public static function box(width:Float,height:Float,weak:Bool=false):Array<Vec2>{\n        #if(!NAPE_RELEASE_BUILD)\n        if((width!=width)||(height!=height))throw \"Error: Polygon.box cannot accept NaN arguments\";\n        #end\n        return rect(-width/2,-height/2,width,height,weak);\n    }\n    /**\n     * Construct a regular polygon centred at origin.\n     * <br/><br/>\n     * Vertices are created at positions on the edge of an ellipsoid of given\n     * radii, when radii are not equal the vertices will not have an equal\n     * angle between them; it will be as though an actual regular polygon were\n     * created, and then squashed to conform to the input radii.\n     *\n     * @param xRadius The x radius of polygon before angleOffset rotation.\n     * @param yRadius The y radius of polygon before angleOffset rotation.\n     * @param edgeCount The number of edges/vertices in polygon.\n     * @param angleOffset The clockwise angular offset to generate vertices at\n     *                    in radians. (default 0.0)\n     * @param weak If true, the generated list of vertices will be allocated as\n     *             weak Vec2s so that when this list is passed to a Nape function\n     *             these Vec2s will be automatically sent back to object pool.\n     *             (default false)\n     * @return An array of Vec2 representing the polygon.\n     */\n    #if nape_swc@:keep #end\n    public static function regular(xRadius:Float,yRadius:Float,edgeCount:Int,angleOffset=0.0,weak:Bool=false):Array<Vec2>{\n        #if(!NAPE_RELEASE_BUILD)\n        if((xRadius!=xRadius)||(yRadius!=yRadius)||(angleOffset!=angleOffset))throw \"Error: Polygon.regular cannot accept NaN arguments\";\n        #end\n        var ret=[];\n        var dangle=Math.PI*2/edgeCount;\n        for(i in 0...edgeCount){\n            var ang=i*dangle+angleOffset;\n            var x=Vec2.get(Math.cos(ang)*xRadius,Math.sin(ang)*yRadius,weak);\n            ret.push(x);\n        }\n        return ret;\n    }\n    /**\n     * Local coordinates of vertices.\n     * <br/><br/>\n     * This list can be modified, but modifications to a Polygon that is\n     * part of a static Body inside of a Space will given an error in\n     * debug builds.\n     */\n    #if nape_swc@:isVar #end\n    public var localVerts(get_localVerts,never):Vec2List;\n    inline function get_localVerts():Vec2List{\n        if(zpp_inner_zn.wrap_lverts==null)zpp_inner_zn.getlverts();\n        return zpp_inner_zn.wrap_lverts;\n    }\n    /**\n     * World coordinates of vertices.\n     * <br/><br/>\n     * This list can be accessed, but any queries of values will result\n     * in an error in debug builds unless this Polygon is part of a Body.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var worldVerts(get_worldVerts,never):Vec2List;\n    inline function get_worldVerts():Vec2List{\n        if(zpp_inner_zn.wrap_gverts==null)zpp_inner_zn.getgverts();\n        return zpp_inner_zn.wrap_gverts;\n    }\n    /**\n     * Set of edges on polygon.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var edges(get_edges,never):EdgeList;\n    inline function get_edges():EdgeList{\n        if(zpp_inner_zn.wrap_edges==null)zpp_inner_zn.getedges();\n        return zpp_inner_zn.wrap_edges;\n    }\n    /**\n     * Determine validity of polygon for use in a Nape simulation.\n     */\n    #if nape_swc@:keep #end\n    public function validity():ValidationResult{\n        return zpp_inner_zn.valid();\n    }\n    /**\n     * Construct a new Polygon.\n     * <br/><br/>\n     * The localVerts parameter is typed Dynamic and may be one of:\n     * <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>\n     *\n     * @param localVerts The local vertices of polygon.\n     * @param material The material for this polygon. (default new Material&#40;&#41;)\n     * @param filter The interaction filter for this polygon.\n     *               (default new InteractionFilter&#40;&#41;)\n     * @return The constructed Polygon.\n     * @throws # If localVerts is null, or not of the expected Type.\n     * @throws # If localVerts contains any disposed or null Vec2.\n     */\n    #if flib@:keep function flibopts_2(){}\n    #end\n    public function new(localVerts:Dynamic,material:Material=null,filter:InteractionFilter=null){\n        #if(!NAPE_RELEASE_BUILD)\n        Shape.zpp_internalAlloc=true;\n        super();\n        Shape.zpp_internalAlloc=false;\n        #end\n        #if NAPE_RELEASE_BUILD \n        super();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(localVerts==null)throw \"Error: localVerts cannot be null\";\n        #end\n        zpp_inner_zn=new ZPP_Polygon();\n        zpp_inner_zn.outer=this;\n        zpp_inner_zn.outer_zn=this;\n        zpp_inner=zpp_inner_zn;\n        zpp_inner_i=zpp_inner;\n        zpp_inner_i.outer_i=this;\n        {\n            if(#if flash untyped __is__(localVerts,Array)#else Std.is(localVerts,Array)#end){\n                var lv:Array<Dynamic>=localVerts;\n                for(vite in lv){\n                    #if(!NAPE_RELEASE_BUILD)\n                    if(vite==null)throw \"Error: Array<Vec2> contains null objects\";\n                    #end\n                    #if(!NAPE_RELEASE_BUILD)\n                    if(!#if flash untyped __is__(vite,Vec2)#else Std.is(vite,Vec2)#end)throw \"Error: Array<Vec2> contains non Vec2 objects\";\n                    #end\n                    var x:Vec2=vite;\n                    {\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(x!=null&&x.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                        #end\n                    };\n                    this.localVerts.push(x.copy());\n                }\n            }\n            else if(#if flash10 untyped __is__(localVerts,ZPP_Const.vec2vector)#else false #end){\n                #if flash10 var lv:flash.Vector<Vec2>=localVerts;\n                for(vite in lv){\n                    #if(!NAPE_RELEASE_BUILD)\n                    if(vite==null)throw \"Error: flash.Vector<Vec2> contains null objects\";\n                    #end\n                    var x:Vec2=vite;\n                    {\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(x!=null&&x.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                        #end\n                    };\n                    this.localVerts.push(x.copy());\n                }\n                #end\n            }\n            else if(#if flash untyped __is__(localVerts,Vec2List)#else Std.is(localVerts,Vec2List)#end){\n                var lv:Vec2List=localVerts;\n                for(x in lv){\n                    #if(!NAPE_RELEASE_BUILD)\n                    if(x==null)throw \"Error: Vec2List contains null objects\";\n                    #end\n                    {\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(x!=null&&x.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                        #end\n                    };\n                    this.localVerts.push(x.copy());\n                }\n            }\n            else if(#if flash untyped __is__(localVerts,GeomPoly)#else Std.is(localVerts,GeomPoly)#end){\n                var lv:GeomPoly=localVerts;\n                {\n                    #if(!NAPE_RELEASE_BUILD)\n                    if(lv!=null&&lv.zpp_disp)throw \"Error: \"+\"GeomPoly\"+\" has been disposed and cannot be used!\";\n                    #end\n                };\n                var verts:ZPP_GeomVert=lv.zpp_inner.vertices;\n                if(verts!=null){\n                    var vite=verts;\n                    do{\n                        var x=Vec2.get(vite.x,vite.y);\n                        vite=vite.next;\n                        this.localVerts.push(x.copy());\n                        x.dispose();\n                    }\n                    while(vite!=verts);\n                }\n            }\n            else{\n                #if(!NAPE_RELEASE_BUILD)\n                throw \"Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>\";\n                #end\n            }\n        };\n        {\n            if(#if flash untyped __is__(localVerts,Array)#else Std.is(localVerts,Array)#end){\n                var lv:Array<Vec2>=localVerts;\n                var i=0;\n                while(i<lv.length){\n                    var cur=lv[i];\n                    if(({\n                        if(({\n                            cur.zpp_inner.weak;\n                        })){\n                            cur.dispose();\n                            true;\n                        }\n                        else{\n                            false;\n                        }\n                    })){\n                        lv.splice(i,1);\n                        continue;\n                    }\n                    i++;\n                }\n            }\n            else if(#if flash10 untyped __is__(localVerts,ZPP_Const.vec2vector)#else false #end){\n                #if flash10 var lv:flash.Vector<Vec2>=localVerts;\n                if(!lv.fixed){\n                    var i:Int=0;\n                    while(i<cast lv.length){\n                        var cur=lv[i];\n                        if(({\n                            if(({\n                                cur.zpp_inner.weak;\n                            })){\n                                cur.dispose();\n                                true;\n                            }\n                            else{\n                                false;\n                            }\n                        })){\n                            lv.splice(i,1);\n                            continue;\n                        }\n                        i++;\n                    }\n                }\n                #end\n            }\n            else if(#if flash untyped __is__(localVerts,Vec2List)#else Std.is(localVerts,Vec2List)#end){\n                var lv:Vec2List=localVerts;\n                if(lv.zpp_inner._validate!=null)lv.zpp_inner._validate();\n                var ins=lv.zpp_inner.inner;\n                var pre=null;\n                var cur=ins.begin();\n                while(cur!=null){\n                    var x=cur.elem();\n                    if(({\n                        x.outer.zpp_inner.weak;\n                    })){\n                        cur=ins.erase(pre);\n                        ({\n                            if(({\n                                x.outer.zpp_inner.weak;\n                            })){\n                                x.outer.dispose();\n                                true;\n                            }\n                            else{\n                                false;\n                            }\n                        });\n                    }\n                    else{\n                        pre=cur;\n                        cur=cur.next;\n                    }\n                }\n            }\n        };\n        if(material==null){\n            if(ZPP_Material.zpp_pool==null){\n                zpp_inner.material=new ZPP_Material();\n                #if NAPE_POOL_STATS ZPP_Material.POOL_TOT++;\n                ZPP_Material.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                zpp_inner.material=ZPP_Material.zpp_pool;\n                ZPP_Material.zpp_pool=zpp_inner.material.next;\n                zpp_inner.material.next=null;\n                #if NAPE_POOL_STATS ZPP_Material.POOL_CNT--;\n                ZPP_Material.POOL_ADD++;\n                #end\n            }\n            zpp_inner.material.alloc();\n        };\n        else this.material=material;\n        if(filter==null){\n            if(ZPP_InteractionFilter.zpp_pool==null){\n                zpp_inner.filter=new ZPP_InteractionFilter();\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_TOT++;\n                ZPP_InteractionFilter.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                zpp_inner.filter=ZPP_InteractionFilter.zpp_pool;\n                ZPP_InteractionFilter.zpp_pool=zpp_inner.filter.next;\n                zpp_inner.filter.next=null;\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_CNT--;\n                ZPP_InteractionFilter.POOL_ADD++;\n                #end\n            }\n            zpp_inner.filter.alloc();\n        };\n        else this.filter=filter;\n        zpp_inner_i.insert_cbtype(CbType.ANY_SHAPE.zpp_inner);\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Haxe Iterator<T> compatible iterator over Nape list.\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ShapeIterator{\n    /**\n     * @private\n     */\n    public var zpp_inner:ShapeList=null;\n    /**\n     * @private\n     */\n    public var zpp_i:Int=0;\n    /**\n     * @private\n     */\n    public var zpp_critical:Bool=false;\n    /**\n     * @private\n     */\n    public static var zpp_pool:ShapeIterator=null;\n    /**\n     * @private\n     */\n    public var zpp_next:ShapeIterator=null;\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_ShapeList.internal)throw \"Error: Cannot instantiate \"+\"Shape\"+\"Iterator derp!\";\n        #end\n    }\n    /**\n     * Create iterator for Nape list.\n     * <br/><br/>\n     * There is no specific reason to use this over: <code>list.iterator()</code>\n     * especcialy since this requires writing the class name :)\n     * (This function is used internally)\n     *\n     * @param list The Nape list to create iterator for.\n     * @return     An iterator over the Nape list.\n     */\n    public static function get(list:ShapeList){\n        var ret=if(zpp_pool==null){\n            ZPP_ShapeList.internal=true;\n            var ret=new ShapeIterator();\n            ZPP_ShapeList.internal=false;\n            ret;\n        }\n        else{\n            var r=zpp_pool;\n            zpp_pool=r.zpp_next;\n            r;\n        }\n        ret.zpp_i=0;\n        ret.zpp_inner=list;\n        ret.zpp_critical=false;\n        return ret;\n    }\n    /**\n     * Check if there are any elements remaining.\n     *\n     * @return True if there are more elements to iterator over.\n     */\n    #if nape_swc@:keep #end\n    public inline function hasNext(){\n        #if true zpp_inner.zpp_inner.valmod();\n        #else zpp_inner.zpp_vm();\n        #end\n        var length=zpp_inner.length;\n        zpp_critical=true;\n        if(zpp_i<length){\n            return true;\n        }\n        else{\n            {\n                this.zpp_next=ShapeIterator.zpp_pool;\n                ShapeIterator.zpp_pool=this;\n                this.zpp_inner=null;\n            };\n            return false;\n        }\n    }\n    /**\n     * Return next element in list.\n     *\n     * @return The next element in iteration.\n     */\n    #if nape_swc@:keep #end\n    public inline function next(){\n        zpp_critical=false;\n        return zpp_inner.at(zpp_i++);\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Nape list of Shape type objects\n * <br/><br/>\n * Internally this list is at present implemented as a linked list with\n * object pooled nodes and iterators with various fast paths made for\n * standard access patterns (For instance accessing successive elements\n * runs in constant time when using random access functions)\n * <br/><br/>\n * Iteration of this list can be done in various ways, but the preferred\n * way on all targets, is through use of the foreach function:\n * <pre>\n * list.foreach(function (obj) {\n * });\n * </pre>\n * This method is inlined so that in haxe no closure will need to be created.\n * <br/><br/>\n * In AS3, a closure would need to be created in general, so for performance\n * reasons you 'may' choose to use iteration as follows:\n * <pre>\n * for (var i:int = 0; i < list.length; i++) {\n *     var obj:Shape = list.at(i);\n * }\n * </pre>\n * <br/>\n * NOTE: It is 'not' safe to modify a list whilst iterating over it.\n * If you wish to remove elements during an iteration you should use the\n * filter method, for example:\n * <pre>\n * list.filter(function (obj) {\n *     // operate on object.\n *     // ...\n *     return (false if you want object to be removed);\n * });\n * </pre>\n * <br/><br/>\n * In AS3, if you wish to avoid a closure generation, you can perform such\n * an iteration in a safe manner as follows:\n * <pre>\n * var i:int = 0;\n * while (i < list.length) {\n *     var obj:Shape = list.at(i);\n *     // operate on object.\n *     // ...\n *     if (should remove obj) {\n *         list.remove(obj);\n *         continue;\n *     }\n *     else i++;\n * }\n * </pre>\n * Or if you are always clearing the list entirely you could write:\n * <pre>\n * while (!list.empty()) {\n *     var obj:Shape = list.pop();\n *     // operate on object.\n *     // ...\n * }\n * </pre>\n */\n#if!false@:final #end\n#if nape_swc@:keep #end\nclass ShapeList{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_ShapeList=null;\n    /**\n     * Length of list.\n     */\n    #if nape_swc@:isVar #end\n    public var length(get_length,never):Int;\n    #if true inline function get_length(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    #else inline function get_length(){\n        return zpp_gl();\n    }\n    /**\n     * @private\n     */\n    public function zpp_gl(){\n        zpp_inner.valmod();\n        if(zpp_inner.zip_length){\n            zpp_inner.zip_length=false;\n            if(false){\n                zpp_inner.user_length=0;\n                {\n                    var cx_ite=zpp_inner.inner.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        if(true)zpp_inner.user_length++;\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else zpp_inner.user_length=zpp_inner.inner.length;\n        }\n        return zpp_inner.user_length;\n    }\n    /**\n     * @private\n     */\n    public function zpp_vm(){\n        zpp_inner.valmod();\n    }\n    #end\n    /**\n     * Convert standard Array to Nape list.\n     *\n     * @param array The array to be converted\n     * @return An equivalent Nape list.\n     * @throws If array argument is null.\n     * @throws If array contains elements of type other than Shape\n     */\n    #if nape_swc@:keep #end\n    public static function fromArray(array:Array<Shape>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(array==null){\n            throw \"Error: Cannot convert null Array to Nape list\";\n        }\n        #end\n        var ret=new ShapeList();\n        for(i in array){\n            #if flash9#if(!NAPE_RELEASE_BUILD)\n            if(!#if flash untyped __is__(i,Shape)#else Std.is(i,Shape)#end)throw \"Error: Array contains non \"+\"Shape\"+\" types.\";\n            #end\n            #end\n            ret.push(i);\n        }\n        return ret;\n    }\n    #if flash9 /**\n     * Convert flash.Vector to Nape list.\n     *\n     * @param vector The vector to be converted\n     * @return An equivalent Nape list.\n     * @throws # If vector argument is null.\n     */\n    #if nape_swc@:keep #end\n    public static function fromVector(vector:flash.Vector<Shape>){\n        #if(!NAPE_RELEASE_BUILD)\n        if(vector==null){\n            throw \"Error: Cannot convert null Vector to Nape list\";\n        }\n        #end\n        var ret=new ShapeList();\n        for(i in vector)ret.push(i);\n        return ret;\n    }\n    #end\n    /**\n     * Check if element is already in the list\n     *\n     * @param obj The object to test.\n     * @return True if object is in the list.\n     */\n    #if nape_swc@:keep #end\n    public function has(obj:Shape):Bool{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return zpp_inner.inner.has(obj.zpp_inner);\n    }\n    /**\n     * Random access to elements of list by index.\n     * <br/><br/>\n     * Under normal circumstances, accessing succesive elements via this\n     * method will occur in constant time.\n     *\n     * @param index The index of the element in list to access.\n     * @returns The element at the given index.\n     * @throws # If index is out of bounds.\n     */\n    #if nape_swc@:keep #end\n    public function at(index:Int):Shape{\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=(length-1-index);\n        if(!false){\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=index;\n                zpp_inner.at_ite=zpp_inner.inner.iterator_at(index);\n            }\n            else{\n                while(zpp_inner.at_index!=index){\n                    zpp_inner.at_index++;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        else{\n            if(index<zpp_inner.at_index||zpp_inner.at_ite==null){\n                zpp_inner.at_index=0;\n                zpp_inner.at_ite=zpp_inner.inner.begin();\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n            while(zpp_inner.at_index!=index){\n                zpp_inner.at_index++;\n                zpp_inner.at_ite=zpp_inner.at_ite.next;\n                while(true){\n                    var x=zpp_inner.at_ite.elem();\n                    if(true)break;\n                    zpp_inner.at_ite=zpp_inner.at_ite.next;\n                }\n            }\n        }\n        return zpp_inner.at_ite.elem().outer;\n    }\n    /**\n     * Push element to back of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function push(obj:Shape):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Shape\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)zpp_inner.inner.add(obj.zpp_inner);\n            else{\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Push element to front of list.\n     * <br/><br/>\n     * When the order of objects is not important, it is best to use the\n     * add() method instead.\n     *\n     * @param obj The object to insert.\n     * @returns True if object was successively inserted.\n     * @throws # If list is immutable.\n     */\n    #if nape_swc@:keep #end\n    public function unshift(obj:Shape):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Shape\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                if(zpp_inner.push_ite==null)zpp_inner.push_ite=empty()?null:zpp_inner.inner.iterator_at(length-1);\n                zpp_inner.push_ite=zpp_inner.inner.insert(zpp_inner.push_ite,obj.zpp_inner);\n            }\n            else zpp_inner.inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    /**\n     * Pop element from back of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function pop():Shape{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Shape\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        else{\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Pop element from front of list.\n     * <br/><br/>\n     * If you are wanting to clear a list, whilst operating on its elements,\n     * consider use of the filter method instead.\n     *\n     * @returns The element removed from list.\n     * @throws # If list is immutable.\n     * @throws # If the list is empty.\n     */\n    #if nape_swc@:keep #end\n    public function shift():Shape{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Shape\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(zpp_inner.at_ite!=null&&zpp_inner.at_ite.next==null)zpp_inner.at_ite=null;\n            var ite=length==1?null:zpp_inner.inner.iterator_at(length-2);\n            ret=ite==null?zpp_inner.inner.front():ite.next.elem();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.erase(ite);\n        }\n        else{\n            ret=zpp_inner.inner.front();\n            var retx=ret.outer;\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)zpp_inner.inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.outer;\n        return retx;\n    }\n    /**\n     * Insert element into list in most effecient way.\n     * <br/><br/>\n     * This method will defer to either the push or unshift function\n     * depending on which is most effecient in the context.\n     * <br/><br/>\n     * If order of elements is not important then you should always use\n     * this function to insert elements.\n     *\n     * @param obj The object to insert.\n     * @return True if object was successfuly inserted.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public inline function add(obj:Shape):Bool{\n        return if(zpp_inner.reverse_flag)push(obj)else unshift(obj);\n    }\n    /**\n     * Remove element from list.\n     * <br/><br/>\n     * This is a linear time operation.\n     *\n     * @param obj The object to remove\n     * @return True if object was removed from list.\n     * @throws # If list is immutable\n     */\n    #if nape_swc@:keep #end\n    public function remove(obj:Shape):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Shape\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=zpp_inner.inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x==obj.zpp_inner){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)zpp_inner.inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    /**\n     * Clear the list, removing all elements.\n     *\n     * @throws # If list is iummutable\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Shape\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n    /**\n     * Test if list is empty or not.\n     *\n     * @return True if list is empty.\n     */\n    #if nape_swc@:keep #end\n    public inline function empty(){\n        #if true if(false)return length==0;\n        else return zpp_inner.inner.empty();\n        #else return length==0;\n        #end\n    }\n    /**\n     * Return Haxe iterator for list.\n     * <br/><br/>\n     * Use of this iterator, whilst stylistically better in Haxe should not\n     * be used, in preference for use of the foreach function which will\n     * not require allocation of an iterator object.\n     * <br/><br/>\n     * Equally in AS3, the foreach method should be the preferred way to iterate.\n     */\n    #if nape_swc@:keep #end\n    public inline function iterator(){\n        #if true zpp_inner.valmod();\n        #else zpp_vm();\n        #end\n        return ShapeIterator.get(this);\n    }\n    /**\n     * Produce a possibly deep copy of list.\n     *\n     * @param deep If true, then each element will have its own copy\n     *             function called instead of simply having its\n     *             reference copied over.\n     * @return     The copied list.\n     */\n    #if nape_swc@:keep #end\n    public function copy(deep:Bool=false){\n        var ret=new ShapeList();\n        for(i in this)ret.push(deep?{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: \"+\"Shape\"+\" is not a copyable type\";\n            #end\n            null;\n        }\n        :i);\n        return ret;\n    }\n    /**\n     * Merge given list into this one.\n     * <br/><br/>\n     * The result is that this list will have all objects from the argument\n     * that were not already in the list inserted. You should make no\n     * assumption about the order of these insertions.\n     *\n     * @param xs The list to merge.\n     * @throws # If xs argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function merge(xs:ShapeList):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(xs==null)throw \"Error: Cannot merge with null list\";\n        #end\n        for(x in xs){\n            if(!has(x))add(x);\n        }\n    }\n    /**\n     * Construct a new list.\n     */\n    public function new(){\n        zpp_inner=new ZPP_ShapeList();\n        zpp_inner.outer=this;\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        var ret=\"[\";\n        var fst=true;\n        for(i in this){\n            if(!fst)ret+=\",\";\n            ret+=(i==null?\"NULL\":i.toString());\n            fst=false;\n        }\n        return ret+\"]\";\n    }\n    /**\n     * Iterate over list applying function.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method should be preferred to using standard haxe iteration\n     * as there will be no allocation of an iterator object.\n     * <pre>\n     * list.foreach(function (obj) {\n     *     if (ignore_object(obj)) return; //acts as a 'continue' statement\n     *     if (halt_iteration(obj)) throw \"\": //acts as a 'break' statement\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public inline function foreach(lambda:Shape->Void):ShapeList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot execute null on list elements\";\n        #end\n        var it=iterator();\n        while(it.hasNext()){\n            try{\n                lambda(it.next());\n            }\n            catch(e:Dynamic){\n                {\n                    it.zpp_next=ShapeIterator.zpp_pool;\n                    ShapeIterator.zpp_pool=it;\n                    it.zpp_inner=null;\n                };\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n     * Iterate over list filtering elements.\n     * <br/><br/>\n     * The given function will be applied to each element, whenever the\n     * function returns false, the element will be removed from the list.\n     * <br/><br/>\n     * Any exception thrown by the supplied function will be treat as a\n     * signal to halt iteration acting as a 'break' statement.\n     * <br/><br/>\n     * This method is to be greatly preferred for filtering logic as\n     * it is otherwise unsafe to modify the list during an iteration.\n     * <br/><br/>\n     * An example of using this method to clean up a list whilst performing\n     * actions on the elements.\n     * <pre>\n     * list.filter(function (obj) {\n     *    // perform clean up with obj\n     *    return false; // remove from list.\n     * });\n     * </pre>\n     *\n     * @param lambda The function to apply to each argument, deciding if\n     *               element should be removed.\n     * @return A reference to 'this' list.\n     * @throws # If lambda argument is null.\n     */\n    #if nape_swc@:keep #end\n    public function filter(lambda:Shape->Bool):ShapeList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: Cannot select elements of list with null\";\n        #end\n        var i=0;\n        while(i<length){\n            var x=at(i);\n            try{\n                if(lambda(x))i++;\n                else remove(x);\n            }\n            catch(e:Dynamic){\n                break;\n            }\n        }\n        return this;\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of Nape Shape types.\n */\n@:final#if nape_swc@:keep #end\nclass ShapeType{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"ShapeType\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==CIRCLE)return\"CIRCLE\";\n        else if(this==POLYGON)return\"POLYGON\";\n        else return \"\";\n    }\n    /**\n     * Circle shape type\n     */\n    #if nape_swc@:isVar #end\n    public static var CIRCLE(get_CIRCLE,never):ShapeType;\n    inline static function get_CIRCLE(){\n        if(ZPP_Flags.ShapeType_CIRCLE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ShapeType_CIRCLE=new ShapeType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ShapeType_CIRCLE;\n    }\n    /**\n     * Polygon shape type\n     */\n    #if nape_swc@:isVar #end\n    public static var POLYGON(get_POLYGON,never):ShapeType;\n    inline static function get_POLYGON(){\n        if(ZPP_Flags.ShapeType_POLYGON==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ShapeType_POLYGON=new ShapeType();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ShapeType_POLYGON;\n    }\n}\n","package nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of validation results for a Polygon.\n */\n@:final#if nape_swc@:keep #end\nclass ValidationResult{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"ValidationResult\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==VALID)return\"VALID\";\n        else if(this==DEGENERATE)return\"DEGENERATE\";\n        else if(this==CONCAVE)return\"CONCAVE\";\n        else if(this==SELF_INTERSECTING)return\"SELF_INTERSECTING\";\n        else return \"\";\n    }\n    /**\n     * Denotes polygon is valid for simulation in Nape.\n     */\n    #if nape_swc@:isVar #end\n    public static var VALID(get_VALID,never):ValidationResult;\n    inline static function get_VALID(){\n        if(ZPP_Flags.ValidationResult_VALID==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ValidationResult_VALID=new ValidationResult();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ValidationResult_VALID;\n    }\n    /**\n     * Denotes polygon is degenerate (has zero area).\n     */\n    #if nape_swc@:isVar #end\n    public static var DEGENERATE(get_DEGENERATE,never):ValidationResult;\n    inline static function get_DEGENERATE(){\n        if(ZPP_Flags.ValidationResult_DEGENERATE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ValidationResult_DEGENERATE=new ValidationResult();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ValidationResult_DEGENERATE;\n    }\n    /**\n     * Denotes polygon is concave.\n     */\n    #if nape_swc@:isVar #end\n    public static var CONCAVE(get_CONCAVE,never):ValidationResult;\n    inline static function get_CONCAVE(){\n        if(ZPP_Flags.ValidationResult_CONCAVE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ValidationResult_CONCAVE=new ValidationResult();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ValidationResult_CONCAVE;\n    }\n    /**\n     * Denotes polygon is self-intersecting.\n     */\n    #if nape_swc@:isVar #end\n    public static var SELF_INTERSECTING(get_SELF_INTERSECTING,never):ValidationResult;\n    inline static function get_SELF_INTERSECTING(){\n        if(ZPP_Flags.ValidationResult_SELF_INTERSECTING==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.ValidationResult_SELF_INTERSECTING=new ValidationResult();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.ValidationResult_SELF_INTERSECTING;\n    }\n}\n","package nape.space;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * Enumeration of available broadphase collision types that Spaces may use.\n */\n@:final#if nape_swc@:keep #end\nclass Broadphase{\n    /**\n     * @private\n     */\n    public function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!ZPP_Flags.internal)throw \"Error: Cannot instantiate \"+\"Broadphase\"+\" derp!\";\n        #end\n    }\n    /**\n     * @private\n     */\n    @:keep public function toString(){\n        if(false)return \"\";\n        \n        else if(this==DYNAMIC_AABB_TREE)return\"DYNAMIC_AABB_TREE\";\n        else if(this==SWEEP_AND_PRUNE)return\"SWEEP_AND_PRUNE\";\n        else return \"\";\n    }\n    /**\n     * Dynamic AABB Tree broadphase.\n     * <br/><br/>\n     * This broadphase uses a pair of binary trees with objects inserted based\n     * on containment of their AABB.\n     * <br/><br/>\n     * This is a general purpose broadphase which does not suffer for objects\n     * of varying sizes, or objects moving very quickly and is well set for such\n     * acts as ray casting and spatial queries like objectsInAABB of the Space type.\n     * <br/><br/>\n     * This is the default broadphase nape will use.\n     */\n    #if nape_swc@:isVar #end\n    public static var DYNAMIC_AABB_TREE(get_DYNAMIC_AABB_TREE,never):Broadphase;\n    inline static function get_DYNAMIC_AABB_TREE(){\n        if(ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE=new Broadphase();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE;\n    }\n    /**\n     * Sweep and prune broadphase.\n     * <br/><br/>\n     * This is a very simple broadphase using the x-axis to keep objects\n     * sorted by their minimum x coordinate.\n     * <br/><br/>\n     * Performance of this broadphase is generally good and in some circumstances\n     * superior to the DYNAMIC_AABB_TREE broadphase.\n     * <br/><br/>\n     * This broadphase will however be much slower for things such as ray casts and\n     * spatial queries like objectsInAABB on the Space type.\n     * Also in cases where lots of objects are moving very quickly or when there is a\n     * large variety in the size of objects.\n     * <br/><br/>\n     * Due to the simplicity of this broadphase, it serves as a good test should you\n     * ever feel there might be something going wrong with the DYNAMIC_AABB_TREE\n     * broadphase type.\n     */\n    #if nape_swc@:isVar #end\n    public static var SWEEP_AND_PRUNE(get_SWEEP_AND_PRUNE,never):Broadphase;\n    inline static function get_SWEEP_AND_PRUNE(){\n        if(ZPP_Flags.Broadphase_SWEEP_AND_PRUNE==null){\n            ZPP_Flags.internal=true;\n            ZPP_Flags.Broadphase_SWEEP_AND_PRUNE=new Broadphase();\n            ZPP_Flags.internal=false;\n        }\n        return ZPP_Flags.Broadphase_SWEEP_AND_PRUNE;\n    }\n}\n","package nape.space;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n/**\n * The heart of all Nape simulations.\n */\n@:final#if nape_swc@:keep #end\nclass Space{\n    /**\n     * @private\n     */\n    public var zpp_inner:ZPP_Space=null;\n    /**\n     * Dynamic object for user to store additional data.\n     * <br/><br/>\n     * This object cannot be set, only its dynamically created\n     * properties may be set. In AS3 the type of this property is &#42\n     * <br/><br/>\n     * This object will be lazily constructed so that until accessed\n     * for the first time, will be null internally.\n     *\n     * @default {}\n     */\n    #if nape_swc@:isVar #end\n    public var userData(get_userData,never):Dynamic<Dynamic>;\n    inline function get_userData():Dynamic<Dynamic>{\n        if(zpp_inner.userData==null){\n            zpp_inner.userData=cast{};\n        }\n        return zpp_inner.userData;\n    }\n    /**\n     * Space gravity.\n     * <br/><br/>\n     * Units are of pixels/second/second\n     * @default (0,0)\n     */\n    #if nape_swc@:isVar #end\n    public var gravity(get_gravity,set_gravity):Vec2;\n    inline function get_gravity():Vec2{\n        if(zpp_inner.wrap_gravity==null)zpp_inner.getgravity();\n        return zpp_inner.wrap_gravity;\n    }\n    inline function set_gravity(gravity:Vec2):Vec2{\n        {\n            {\n                #if(!NAPE_RELEASE_BUILD)\n                if(gravity!=null&&gravity.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n                #end\n            };\n            #if(!NAPE_RELEASE_BUILD)\n            if(gravity==null)throw \"Error: Space::gravity cannot be null\";\n            #end\n            this.gravity.set(gravity);\n        }\n        return get_gravity();\n    }\n    /**\n     * Broadphase type in use.\n     */\n    #if nape_swc@:isVar #end\n    public var broadphase(get_broadphase,never):Broadphase;\n    inline function get_broadphase():Broadphase{\n        return zpp_inner.bphase.is_sweep?Broadphase.SWEEP_AND_PRUNE:Broadphase.DYNAMIC_AABB_TREE;\n    }\n    /**\n     * Flag controlling sorting of contact points.\n     * <br/><br/>\n     * If true, then collisions will be resolved in an order defined by their\n     * penetration depths. This can be shown to improve stability of the physics\n     * as well as making simulations more consistent regardless of which broadphase\n     * is used.\n     * <br/><br/>\n     * Having sorting enabled obviously incurs a cost, and you may consider\n     * disabling it if you are having issues with performance (Though things\n     * such as number of physics iterations will have much greater bearing on\n     * performance than this, especcialy since enabling this may permit you\n     * to use less iterations).\n     *\n     * @default true\n     */\n    #if nape_swc@:isVar #end\n    public var sortContacts(get_sortContacts,set_sortContacts):Bool;\n    inline function get_sortContacts():Bool{\n        return zpp_inner.sortcontacts;\n    }\n    inline function set_sortContacts(sortContacts:Bool):Bool{\n        {\n            zpp_inner.sortcontacts=sortContacts;\n        }\n        return get_sortContacts();\n    }\n    /**\n     * Angular drag applied to all bodies in Space.\n     * <br/><br/>\n     * This represents the fraction of a body's angular velocity which will be\n     * removed per second. This value has no unit attached.\n     *\n     * @default 0.015\n     */\n    #if nape_swc@:isVar #end\n    public var worldAngularDrag(get_worldAngularDrag,set_worldAngularDrag):Float;\n    inline function get_worldAngularDrag():Float{\n        return zpp_inner.global_ang_drag;\n    }\n    inline function set_worldAngularDrag(worldAngularDrag:Float):Float{\n        {\n            var d=worldAngularDrag;\n            #if(!NAPE_RELEASE_BUILD)\n            if((d!=d))throw \"Error: Space::worldAngularDrag cannot be NaN\";\n            #end\n            zpp_inner.global_ang_drag=d;\n        }\n        return get_worldAngularDrag();\n    }\n    /**\n     * Linear drag applied to all bodies in Space.\n     * <br/><br/>\n     * This represents the fraction of a body's linear velocity which will be\n     * removed per second. This value has no unit attached.\n     *\n     * @default 0.015\n     */\n    #if nape_swc@:isVar #end\n    public var worldLinearDrag(get_worldLinearDrag,set_worldLinearDrag):Float;\n    inline function get_worldLinearDrag():Float{\n        return zpp_inner.global_lin_drag;\n    }\n    inline function set_worldLinearDrag(worldLinearDrag:Float):Float{\n        {\n            var d=worldLinearDrag;\n            #if(!NAPE_RELEASE_BUILD)\n            if((d!=d))throw \"Error: Space::worldLinearDrag cannot be NaN\";\n            #end\n            zpp_inner.global_lin_drag=d;\n        }\n        return get_worldLinearDrag();\n    }\n    /**\n     * List of all Compounds directly placed in space.\n     * <br/><br/>\n     * This list is mutable, and adding an element to this list is one way of\n     * adding a Compound to this Space equivalent to: <code>compound.space = space</code>\n     * <br/><br/>\n     * This list is only those compounds directly placed in the space, any\n     * compound that is a child of another compound will not be in this list.\n     */\n    #if nape_swc@:isVar #end\n    public var compounds(get_compounds,never):CompoundList;\n    inline function get_compounds():CompoundList{\n        return zpp_inner.wrap_compounds;\n    }\n    /**\n     * List of all Bodys directly placed in space.\n     * <br/><br/>\n     * This list is mutable, and adding an element to this list is one way of\n     * adding a Body to this Space equivalent to: <code>body.space = space</code>\n     * <br/><br/>\n     * This list is only those bodies directly placed in the space, any\n     * body that is a child of a Compound will not be in this list.\n     */\n    #if nape_swc@:isVar #end\n    public var bodies(get_bodies,never):BodyList;\n    inline function get_bodies():BodyList{\n        return zpp_inner.wrap_bodies;\n    }\n    /**\n     * List of all active dynamic Bodies in space.\n     * <br/><br/>\n     * This list contains all dynamic bodies that are awake regardless of their containment in a Compound.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var liveBodies(get_liveBodies,never):BodyList;\n    inline function get_liveBodies():BodyList{\n        return zpp_inner.wrap_live;\n    }\n    /**\n     * List of all Constraints directly placed in space.\n     * <br/><br/>\n     * This list is mutable, and adding an element to this list is one way of\n     * adding a Constraint to this Space equivalent to: <code>constraint.space = space</code>\n     * <br/><br/>\n     * This list is only those bodies directly placed in the space, any\n     * constraint that is a child of a Compound will not be in this list.\n     */\n    #if nape_swc@:isVar #end\n    public var constraints(get_constraints,never):ConstraintList;\n    inline function get_constraints():ConstraintList{\n        return zpp_inner.wrap_constraints;\n    }\n    /**\n     * List of all active Constraints in space.\n     * <br/><br/>\n     * This list contains all constraints regardless of their containment in a Compound.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var liveConstraints(get_liveConstraints,never):ConstraintList;\n    inline function get_liveConstraints():ConstraintList{\n        return zpp_inner.wrap_livecon;\n    }\n    /**\n     * Apply given function to all bodies in space.\n     * <br/><br/>\n     * This method is a way to iterate over 'every' Body in the Space\n     * regardless of containment in a Compound.\n     *\n     * @param lambda The function to apply to each Body.\n     * @throws # If lambda is null.\n     */\n    public function visitBodies(lambda:Body->Void){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: lambda cannot be null for Space::visitBodies\";\n        #end\n        for(b in bodies)lambda(b);\n        for(c in compounds)c.visitBodies(lambda);\n    }\n    /**\n     * Apply given function to all constraints in space.\n     * <br/><br/>\n     * This method is a way to iterate over 'every' Constraint in the Space\n     * regardless of containment in a Compound.\n     *\n     * @param lambda The function to apply to each Constraint.\n     * @throws # If lambda is null.\n     */\n    public function visitConstraints(lambda:Constraint->Void){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: lambda cannot be null for Space::visitConstraints\";\n        #end\n        for(c in constraints)lambda(c);\n        for(c in compounds)c.visitConstraints(lambda);\n    }\n    /**\n     * Apply given function to all compounds in space.\n     * <br/><br/>\n     * This method is a way to iterate over 'every' Compound in the Space\n     * regardless of containment in another Compound.\n     *\n     * @param lambda The function to apply to each Compound.\n     * @throws # If lambda is null.\n     */\n    public function visitCompounds(lambda:Compound->Void){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lambda==null)throw \"Error: lambda cannot be null for Space::visitCompounds\";\n        #end\n        for(c in compounds){\n            lambda(c);\n            c.visitCompounds(lambda);\n        }\n    }\n    /**\n     * Static, immutable Body for constraint purposes.\n     * <br/><br/>\n     * This is a completely static, uncollidable, uninteractable Body\n     * with no Shapes, that cannot be modified in any way.\n     * <br/><br/>\n     * Its purpose is to provide a means for attaching Constraints\n     * from one Body to the Space itself, for instance pinning a body\n     * against a static point in space.\n     */\n    #if nape_swc@:isVar #end\n    public var world(get_world,never):Body;\n    inline function get_world():Body{\n        return zpp_inner.__static;\n    }\n    /**\n     * List of all active arbiters in Space.\n     * <br/><br/>\n     * This list is immutable.\n     */\n    #if nape_swc@:isVar #end\n    public var arbiters(get_arbiters,never):ArbiterList;\n    inline function get_arbiters():ArbiterList{\n        if(zpp_inner.wrap_arbiters==null){\n            var ret=new ZPP_SpaceArbiterList();\n            ret.space=zpp_inner;\n            zpp_inner.wrap_arbiters=ret;\n        }\n        return zpp_inner.wrap_arbiters;\n    }\n    /**\n     * List of all Listeners in space.\n     * <br/><br/>\n     * This list is mutable, and adding an element to this list is one way of\n     * adding a Listener to this Space equivalent to: <code>listener.space = space</code>\n     */\n    #if nape_swc@:isVar #end\n    public var listeners(get_listeners,never):ListenerList;\n    inline function get_listeners():ListenerList{\n        return zpp_inner.wrap_listeners;\n    }\n    /**\n     * Clear the Space of all objects.\n     * <br/><br/>\n     * Things such as the elapsed simulation time, and time step will too be\n     * reset to 0.\n     * <br/><br/>\n     * Parameters such as gravity, and worldLinearDrag will be untouched by\n     * this operation.\n     */\n    #if nape_swc@:keep #end\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.midstep)throw \"Error: Space::clear() cannot be called during space step()\";\n        #end\n        zpp_inner.clear();\n    }\n    /**\n     * Step simulation forward in time.\n     *\n     * @param deltaTime The number of seconds to simulate. For 60fps physics\n     *                  you would use a value of 1/60.\n     * @param velocityIterations The number of iterations to use in resolving\n     *                           errors in the velocities of objects. This is\n     *                           together with collision detection the most\n     *                           expensive phase of a simulation update, as well\n     *                           as the most important for stable results.\n     *                           (default 10)\n     * @param positionIterations The number of iterations to use in resolving\n     *                           errors in the positions of objects. This is\n     *                           far more lightweight than velocity iterations,\n     *                           as well as being less important for the\n     *                           stability of results. (default 10)\n     * @throws # If deltaTime is not strictly positive.\n     * @throws # If either of the number of iterations is not strictly positive.\n     */\n    #if nape_swc@:keep #end\n    public function step(deltaTime:Float,velocityIterations:Int=10,positionIterations:Int=10){\n        #if(!NAPE_RELEASE_BUILD)\n        if((deltaTime!=deltaTime))throw \"Error: deltaTime cannot be NaN\";\n        if(deltaTime<=0)throw \"Error: deltaTime must be strictly positive\";\n        if(velocityIterations<=0)throw \"Error: must use atleast one velocity iteration\";\n        if(positionIterations<=0)throw \"Error: must use atleast one position iteration\";\n        #end\n        zpp_inner.step(deltaTime,velocityIterations,positionIterations);\n    }\n    /**\n     * The time stamp of this Space object.\n     * <br/><br/>\n     * This is equal to the number of times that space.step(..) has been invoked.\n     */\n    #if nape_swc@:isVar #end\n    public var timeStamp(get_timeStamp,never):Int;\n    inline function get_timeStamp():Int{\n        return zpp_inner.stamp;\n    }\n    /**\n     * The elapsed simulation time.\n     * <br/><br/>\n     * This is the total amount of 'time' that has elapsed in the Space simulation.\n     */\n    #if nape_swc@:isVar #end\n    public var elapsedTime(get_elapsedTime,never):Float;\n    inline function get_elapsedTime():Float{\n        return zpp_inner.time;\n    }\n    /**\n     * Construct a new Space object.\n     *\n     * @param gravity The gravity of this space. (default &#40;0,0&#41;)\n     * @param broadphase The broadphase type to use. (default DYNAMIC_AABB_TREE)\n     * @return The constructed Space object.\n     * @throws # If gravity is non-null, and has been disposed of.\n     */\n    public function new(gravity:Vec2=null,broadphase:Broadphase=null){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(gravity!=null&&gravity.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        zpp_inner=new ZPP_Space(gravity==null?null:gravity.zpp_inner,broadphase);\n        zpp_inner.outer=this;\n        if(gravity!=null)({\n            if(({\n                gravity.zpp_inner.weak;\n            })){\n                gravity.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n    }\n    /**\n     * Determine the interaction type that would occur between a pair of Shapes.\n     * <br/><br/>\n     * This function takes into account everything possible, and ignoring the\n     * callback system will tell you precisely the type of interaction (if any\n     * at all) which will occur between these Shapes.\n     * <br/><br/>\n     * This function can only work if the Shapes belong to a Body.\n     * <br/><br/>\n     * This function can only make use of any constraints 'ignore' property\n     * to determine if 'null' should be returned if the constraints being used\n     * are inside of a Space.\n     *\n     * @param shape1 The first Shape to test.\n     * @param shape2 The second Shape to test.\n     * @return The interaction type that will occur between these shapes, or null\n     *         if no interaction will occur.\n     * @throws # If either shape is null, or is not contained within a body.\n     */\n    #if nape_swc@:keep #end\n    public function interactionType(shape1:Shape,shape2:Shape):Null<InteractionType>{\n        #if(!NAPE_RELEASE_BUILD)\n        if(shape1==null||shape2==null)throw \"Error: Cannot evaluate interaction type for null shapes\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(shape1.body==null||shape2.body==null)throw \"Error: Cannot evaluate interaction type for shapes not part of a Body\";\n        #end\n        if(shape1.body.isStatic()&&shape2.body.isStatic())return null;\n        if(shape1.body==shape2.body)return null;\n        var s1=shape1.zpp_inner;\n        var s2=shape2.zpp_inner;\n        return switch(zpp_inner.interactionType(s1,s2,s1.body,s2.body)){\n            case 0:InteractionType.FLUID;\n            case 1:InteractionType.COLLISION;\n            case 2:InteractionType.SENSOR;\n            default:null;\n        }\n    }\n    /**\n     * Evaluate all Shapes under a given Point.\n     * <br/><br/>\n     * If the filter argument is non-null, then only shapes who's filter\n     * agrees to 'collide' will be considered.\n     *\n     * @param point The point to evaluate shapes.\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the Shapes containing the given point.\n     * @throws # If point is null or disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function shapesUnderPoint(point:Vec2,filter:InteractionFilter=null,output:ShapeList=null){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null)throw \"Error: Cannot evaluate shapes under a null point :)\";\n        #end\n        var ret=zpp_inner.shapesUnderPoint(point.x,point.y,filter==null?null:filter.zpp_inner,output);\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Evaluate all Bodies under a given Point.\n     * <br/><br/>\n     * If the filter argument is non-null, then only bodies with a shape containing\n     * the given point whose filter agrees to 'collide' will be considered.\n     *\n     * @param point The point to evaluate bodies.\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the Bodies containing the given point.\n     * @throws # If point is null or disposed of.\n     */\n    #if nape_swc@:keep #end\n    public function bodiesUnderPoint(point:Vec2,filter:InteractionFilter=null,output:BodyList=null){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(point!=null&&point.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(point==null)throw \"Error: Cannot evaluate objects under a null point :)\";\n        #end\n        var ret=zpp_inner.bodiesUnderPoint(point.x,point.y,filter==null?null:filter.zpp_inner,output);\n        ({\n            if(({\n                point.zpp_inner.weak;\n            })){\n                point.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Evaluate all Shapes given an AABB.\n     * <br/><br/>\n     * If the filter argument is non-null, then only shapes who's filter\n     * agrees to 'collide' will be considered.\n     *\n     * @param aabb The bounding box to query shapes by,\n     * @param containment If true, then only Shapes entirely contained (Rather\n     *                    than simply intersected) will be considered.\n     *                    (default false)\n     * @param strict If false, then the Shape's bounding box will be used to\n     *               classify the Shape, instead of the Shape itself.\n     *               (default true)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the shapes for given AABB.\n     * @throws # If AABB is null, or is degenerate.\n     */\n    #if nape_swc@:keep #end\n    public function shapesInAABB(aabb:AABB,containment:Bool=false,strict:Bool=true,filter:InteractionFilter=null,output:ShapeList=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(aabb==null)throw \"Error: Cannot evaluate shapes in a null AABB :)\";\n        if(aabb.width==0||aabb.height==0)throw \"Error: Cannot evaluate shapes in degenerate AABB :/\";\n        #end\n        return zpp_inner.shapesInAABB(aabb,strict,containment,filter==null?null:filter.zpp_inner,output);\n    }\n    /**\n     * Evaluate all Bodies given an AABB.\n     * <br/><br/>\n     * If the filter argument is non-null, then only bodies with a shape\n     * classified as being part of the AABB, whose filter agrees to collide\n     * will be considered.\n     *\n     * @param aabb The bounding box to query bodies by,\n     * @param containment If true, then only Bodies entirely contained (Rather\n     *                    than simply intersecting) will be considered.\n     *                    (default false)\n     * @param strict If false, then the body's shape's bounding box will be used to\n     *               classify the shapes of the body, instead of the Shape itself.\n     *               (default true)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the shapes for given AABB.\n     * @throws # If AABB is null, or is degenerate.\n     */\n    #if nape_swc@:keep #end\n    public function bodiesInAABB(aabb:AABB,containment:Bool=false,strict:Bool=true,filter:InteractionFilter=null,output:BodyList=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(aabb==null)throw \"Error: Cannot evaluate objects in a null AABB :)\";\n        if(aabb.width==0||aabb.height==0)throw \"Error: Cannot evaluate objects in degenerate AABB :/\";\n        #end\n        return zpp_inner.bodiesInAABB(aabb,strict,containment,filter==null?null:filter.zpp_inner,output);\n    }\n    /**\n     * Evaluate all Shapes given a circle.\n     * <br/><br/>\n     * If the filter argument is non-null, then only shapes who's filter\n     * agrees to 'collide' will be considered.\n     *\n     * @param position The position of the centre of the circle.\n     * @param radius The radius of the circle.\n     * @param containment If true, then only Shapes entirely contained (Rather\n     *                    than simply intersected) will be considered.\n     *                    (default false)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the shapes for given circle.\n     * @throws # If positions is null or disposed of.\n     * @throws # If radius is not strictly positive.\n     */\n    #if nape_swc@:keep #end\n    public function shapesInCircle(position:Vec2,radius:Float,containment:Bool=false,filter:InteractionFilter=null,output:ShapeList=null){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(position!=null&&position.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(position==null)throw \"Error: Cannot evaluate shapes at null circle :)\";\n        if((radius!=radius))throw \"Error: Circle radius cannot be NaN\";\n        if(radius<=0)throw \"Error: Circle radius must be strictly positive\";\n        #end\n        var ret=zpp_inner.shapesInCircle(position,radius,containment,filter==null?null:filter.zpp_inner,output);\n        ({\n            if(({\n                position.zpp_inner.weak;\n            })){\n                position.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Evaluate all Bodies given a circle.\n     * <br/><br/>\n     * If the filter argument is non-null, then only bodies with a shape\n     * classified as being part of the circle, whose filter agrees to collide\n     * will be considered.\n     *\n     * @param position The position of the centre of the circle.\n     * @param radius The radius of the circle.\n     * @param containment If true, then only Bodies entirely contained (Rather\n     *                    than simply intersecting) will be considered. If a\n     *                    filter is supplied, only shapes that agree to collide\n     *                    will be used in this containment check.\n     *                    (default false)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the shapes for given circle.\n     * @throws # If positions is null or disposed of.\n     * @throws # If radius is not strictly positive.\n     */\n    #if nape_swc@:keep #end\n    public function bodiesInCircle(position:Vec2,radius:Float,containment:Bool=false,filter:InteractionFilter=null,output:BodyList=null){\n        {\n            #if(!NAPE_RELEASE_BUILD)\n            if(position!=null&&position.zpp_disp)throw \"Error: \"+\"Vec2\"+\" has been disposed and cannot be used!\";\n            #end\n        };\n        #if(!NAPE_RELEASE_BUILD)\n        if(position==null)throw \"Error: Cannot evaluate objects at null circle :)\";\n        if((radius!=radius))throw \"Error: Circle radius cannot be NaN\";\n        if(radius<=0)throw \"Error: Circle radius must be strictly positive\";\n        #end\n        var ret=zpp_inner.bodiesInCircle(position,radius,containment,filter==null?null:filter.zpp_inner,output);\n        ({\n            if(({\n                position.zpp_inner.weak;\n            })){\n                position.dispose();\n                true;\n            }\n            else{\n                false;\n            }\n        });\n        return ret;\n    }\n    /**\n     * Evaluate all Shapes given another shape.\n     * <br/><br/>\n     * If the filter argument is non-null, then only shapes who's filter\n     * agrees to 'collide' will be considered. The input shape's own filter\n     * is never used in this method. The input shape is considered a purely\n     * geometric object.\n     * <br/><br/>\n     * The input shape must be part of a Body so as to be well defined.\n     *\n     * @param shape The shape to use in classifying other shapes.\n     * @param containment If true, then only Shapes entirely contained (Rather\n     *                    than simply intersected) will be considered.\n     *                    (default false)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the shapes for given shape.\n     * @throws # If shape is null or not part of a body.\n     * @throws # If shape is a polygon, and that polygon is not 'valid'\n     */\n    #if nape_swc@:keep #end\n    public function shapesInShape(shape:Shape,containment:Bool=false,filter:InteractionFilter=null,output:ShapeList=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(shape==null)throw \"Error: Cannot evaluate shapes in a null shapes :)\";\n        if(shape.body==null)throw \"Error: Query shape needs to be inside a Body to be well defined :)\";\n        if(shape.isPolygon()){\n            var res=shape.zpp_inner.polygon.valid();\n            if(res!=ValidationResult.VALID)throw \"Error: Polygon query shape is invalid : \"+res.toString();\n        }\n        #end\n        return zpp_inner.shapesInShape(shape.zpp_inner,containment,filter==null?null:filter.zpp_inner,output);\n    }\n    /**\n     * Evaluate all Bodies given a shape.\n     * <br/><br/>\n     * If the filter argument is non-null, then only bodies with a shape\n     * classified as being part of the input shape, whose filter agrees to collide\n     * will be considered. The input shape is considered a purely geometric\n     * <br/><br/>\n     * The input shape must be part of a Body so as to be well defined.\n     *\n     * @param shape The shape to use in classifying other shapes.\n     * @param containment If true, then only Bodies entirely contained (Rather\n     *                    than simply intersecting) will be considered.\n     *                    (default false)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the bodies for given shape.\n     * @throws # If shape is null or not part of a body.\n     * @throws # If shape is a polygon, and that polygon is not 'valid'\n     */\n    #if nape_swc@:keep #end\n    public function bodiesInShape(shape:Shape,containment:Bool=false,filter:InteractionFilter=null,output:BodyList=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(shape==null)throw \"Error: Cannot evaluate bodies in a null shapes :)\";\n        if(shape.body==null)throw \"Error: Query shape needs to be inside a Body to be well defined :)\";\n        if(shape.isPolygon()){\n            var res=shape.zpp_inner.polygon.valid();\n            if(res!=ValidationResult.VALID)throw \"Error: Polygon query shape is invalid : \"+res.toString();\n        }\n        #end\n        return zpp_inner.bodiesInShape(shape.zpp_inner,containment,filter==null?null:filter.zpp_inner,output);\n    }\n    /**\n     * Evaluate all Shapes given a Body.\n     * <br/><br/>\n     * If the filter argument is non-null, then only shapes who's filter\n     * agrees to 'collide' will be considered. The input body's shape's own filters\n     * are never used in this method. The input body is considered a purely\n     * geometric object.\n     *\n     * @param body The body to use in classifying other shapes.\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the shapes for given body.\n     * @throws # If body is null.\n     * @throws # If body has a shape that is a polygon, and that polygon is not 'valid'\n     */\n    #if nape_swc@:keep #end\n    public function shapesInBody(body:Body,filter:InteractionFilter=null,output:ShapeList=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(body==null)throw \"Error: Cannot evaluate shapes in null body\";\n        #end\n        var ret=(output==null?new ShapeList():output);\n        for(shape in body.shapes){\n            var cur=shapesInShape(shape,false,filter,ret);\n        }\n        return ret;\n    }\n    /**\n     * Evaluate all Bodies given a Body.\n     * <br/><br/>\n     * If the filter argument is non-null, then only bodies with a shape\n     * classified as being part of the input body, whose filter agrees to collide\n     * will be considered. The input body is considered a purely geometric\n     *\n     * @param body The body to use in classifying other bodies.\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output Optional list to append results to instead of creating a new list (default null).\n     * @return A list of all the bodies for given body.\n     * @throws # If body is null.\n     * @throws # If body has a shape that is a polygon, and that polygon is not 'valid'\n     */\n    #if nape_swc@:keep #end\n    public function bodiesInBody(body:Body,filter:InteractionFilter=null,output:BodyList=null){\n        #if(!NAPE_RELEASE_BUILD)\n        if(body==null)throw \"Error: Cannot evaluate shapes in null body\";\n        #end\n        var ret=(output==null?new BodyList():output);\n        for(shape in body.shapes){\n            var cur=bodiesInShape(shape,false,filter,ret);\n        }\n        return ret;\n    }\n    /**\n     * Perform a convex cast for soonest collision.\n     * <br/><br/>\n     * This method will return only the soonest collision result (if any), to find\n     * more than this, use the convexMultiCast method. The shape will not be\n     * swept further than the time delta provided.\n     * Shapes already intersecting\n     * the sweep shape at t = 0 are ignored.\n     * <br/><br/>\n     * If the filter argument is null, then all shapes will be collidable\n     * otherwise only those for whose filter agrees to 'collide'.\n     *\n     * @param shape The Shape to be cast through space. This shape must belong\n     *              to a body whose velocity is used to define the sweep.\n     * @param deltaTime The amount of time to sweep the shape forward.\n     * @param liveSweep If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @return The soonest result (if any) of convex intersection.\n     * @throws # If shape is null, or not part of a body.\n     * @throws # If deltaTime is negative.\n     */\n    #if nape_swc@:keep #end\n    public function convexCast(shape:Shape,deltaTime:Float,liveSweep:Bool=false,filter:InteractionFilter=null):Null<ConvexResult>{\n        #if(!NAPE_RELEASE_BUILD)\n        if(shape==null)throw \"Error: Cannot cast null shape :)\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(shape.body==null)throw \"Error: Shape must belong to a body to be cast.\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(deltaTime<0||(deltaTime!=deltaTime))throw \"Error: deltaTime must be positive\";\n        #end\n        return zpp_inner.convexCast(shape.zpp_inner,deltaTime,filter,liveSweep);\n    }\n    /**\n     * Perform a convex cast for all collisions in time order.\n     * <br/><br/>\n     * This method will return all collisions, or an empty list if there are none.\n     * The shape will not be\n     * swept further than the time delta provided. Shapes already intersecting\n     * the sweep shape at t = 0 are ignored.\n     * <br/><br/>\n     * If the filter argument is null, then all shapes will be collidable\n     * otherwise only those for whose filter agrees to 'collide'.\n     *\n     * @param shape The Shape to be cast through space. This shape must belong\n     *              to a body whose velocity is used to define the sweep.\n     * @param deltaTime The amount of time to sweep the shape forward.\n     * @param liveSweep If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output A list to append results to instead of allocating a new one (default null)\n     * @return The collision results in time order.\n     * @throws # If shape is null, or not part of a body.\n     * @throws # If deltaTime is negative.\n     */\n    #if nape_swc@:keep #end\n    public function convexMultiCast(shape:Shape,deltaTime:Float,liveSweep:Bool=false,filter:InteractionFilter=null,output:ConvexResultList):ConvexResultList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(shape==null)throw \"Error: Cannot cast null shape :)\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(shape.body==null)throw \"Error: Shape must belong to a body to be cast.\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(deltaTime<0||(deltaTime!=deltaTime))throw \"Error: deltaTime must be positive\";\n        #end\n        return zpp_inner.convexMultiCast(shape.zpp_inner,deltaTime,filter,liveSweep,output);\n    }\n    /**\n     * Perform a ray cast for closest result.\n     * <br/><br/>\n     * This method will return only the closest result (if any), to find more\n     * the first result, use the rayMultiCast method. The ray will not be\n     * cast beyond its maxDistance.\n     * <br/><br/>\n     * If the filter argument is null, then all shapes will be intersectable\n     * otherwise only those for whose filter agrees to 'collide'.\n     *\n     * @param ray The ray to cast through space.\n     * @param inner If true then inner surfaces of shapes will also be intersected.\n     *              otherwise only the outer surfaces. (default false)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @return The closest result (if any) of ray intersection.\n     * @throws # If ray is null.\n     */\n    #if nape_swc@:keep #end\n    public function rayCast(ray:Ray,inner:Bool=false,filter:InteractionFilter=null):Null<RayResult>{\n        #if(!NAPE_RELEASE_BUILD)\n        if(ray==null)throw \"Error: Cannot cast null ray :)\";\n        #end\n        return zpp_inner.rayCast(ray,inner,filter);\n    }\n    /**\n     * Perform a ray cast for all valid results.\n     * <br/><br/>\n     * This method will return all intersections (in distance order) of ray\n     * with shapes in the space up to the ray's maxDistance.\n     * <br/><br/>\n     * If the filter argument is null, then all shapes will be intersectable\n     * otherwise only those for whose filter agrees to 'collide'.\n     *\n     * @param ray The ray to cast through space.\n     * @param inner If true then inner surfaces of shapes will also be intersected.\n     *              otherwise only the outer surfaces. (default false)\n     * @param filter Optional filter to pick and choose shapes, based on whether\n     *               the filters agree to collide. (default null)\n     * @param output A list to append results to instead of allocating a new one (default null)\n     * @return All valid results of ray cast in distance order from closest to furthest.\n     * @throws # If ray is null.\n     */\n    #if nape_swc@:keep #end\n    public function rayMultiCast(ray:Ray,inner:Bool=false,filter:InteractionFilter=null,output:RayResultList=null):RayResultList{\n        #if(!NAPE_RELEASE_BUILD)\n        if(ray==null)throw \"Error: Cannot cast null ray :)\";\n        #end\n        return zpp_inner.rayMultiCast(ray,inner,filter,output);\n    }\n}\n","package pixi.plugins.app;\n\nimport js.html.DivElement;\nimport js.html.Element;\nimport pixi.core.renderers.webgl.WebGLRenderer;\nimport pixi.core.renderers.canvas.CanvasRenderer;\nimport pixi.core.renderers.Detector;\nimport pixi.core.display.Container;\nimport js.html.Event;\nimport js.html.CanvasElement;\nimport js.Browser;\n\n#if fps import jsfps.simplefps.Fps; #end\n#if fpsmeter import jsfps.fpsmeter.FPSMeter; #end\n#if stats import jsfps.stats.Stats; #end\n\n/**\n * Pixi Boilerplate Helper class that can be used by any application\n * @author Adi Reddy Mora\n * http://adireddy.github.io\n * @license MIT\n * @copyright 2015\n */\nclass Application {\n\n\t/**\n     * Sets the pixel ratio of the application.\n     * default - 1\n     */\n\tpublic var pixelRatio:Float;\n\n\t/**\n\t * Default frame rate is 60 FPS and this can be set to true to get 30 FPS.\n\t * default - false\n\t */\n\tpublic var skipFrame(default, set):Bool;\n\n\t/**\n\t * Default frame rate is 60 FPS and this can be set to anything between 1 - 60.\n\t * default - 60\n\t */\n\tpublic var fps(default, set):Int;\n\n\t/**\n\t * Width of the application.\n\t * default - Browser.window.innerWidth\n\t */\n\tpublic var width:Float;\n\n\t/**\n\t * Height of the application.\n\t * default - Browser.window.innerHeight\n\t */\n\tpublic var height:Float;\n\n\t/**\n\t * Renderer transparency property.\n\t * default - false\n\t */\n\tpublic var transparent:Bool;\n\n\t/**\n\t * Graphics antialias property.\n\t * default - false\n\t */\n\tpublic var antialias:Bool;\n\n\t/**\n\t * Force FXAA shader antialias instead of native (faster).\n\t * default - false\n\t */\n\tpublic var forceFXAA:Bool;\n\n\t/**\n\t * Force round pixels.\n\t * default - false\n\t */\n\tpublic var roundPixels:Bool;\n\n\t/**\n\t * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.\n     * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.\n     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.\n\t * default - true\n\t */\n\tpublic var clearBeforeRender:Bool;\n\n\t/**\n\t * enables drawing buffer preservation, enable this if you need to call toDataUrl on the webgl context\n\t * default - false\n\t */\n\tpublic var preserveDrawingBuffer:Bool;\n\n\t/**\n\t * Whether you want to resize the canvas and renderer on browser resize.\n\t * Should be set to false when custom width and height are used for the application.\n\t * default - true\n\t */\n\tpublic var autoResize:Bool;\n\n\t/**\n\t * Sets the background color of the stage.\n\t * default - 0xFFFFFF\n\t */\n\tpublic var backgroundColor:Int;\n\n\t/**\n\t * Update listener \tfunction\n\t */\n\tpublic var onUpdate:Float -> Void;\n\n\t/**\n\t * Window resize listener \tfunction\n\t */\n\tpublic var onResize:Void -> Void;\n\n\t/**\n\t * Canvas Element\n\t * Read-only\n\t */\n\tpublic var canvas(default, null):CanvasElement;\n\n\t/**\n\t * Renderer\n\t * Read-only\n\t */\n\tpublic var renderer(default, null):Dynamic;\n\n\t/**\n\t * Global Container.\n\t * Read-only\n\t */\n\tpublic var stage(default, null):Container;\n\n\tpublic static inline var AUTO:String = \"auto\";\n\tpublic static inline var RECOMMENDED:String = \"recommended\";\n\tpublic static inline var CANVAS:String = \"canvas\";\n\tpublic static inline var WEBGL:String = \"webgl\";\n\n\tvar _lastTime:Date;\n\tvar _currentTime:Date;\n\tvar _elapsedTime:Float;\n\tvar _frameCount:Int;\n\n\t#if fps\n\tvar _fps:Fps;\n\tvar _fpsDiv:DivElement;\n\t#end\n\n\t#if stats var _stats:Stats; #end\n\t#if fpsmeter var _fpsMeter:FPSMeter; #end\n\n\tpublic function new() {\n\t\t_lastTime = Date.now();\n\t\t_setDefaultValues();\n\t}\n\n\tfunction set_fps(val:Int):Int {\n\t\t_frameCount = 0;\n\t\treturn fps = (val >= 1 && val < 60) ? Std.int(val) : 60;\n\t}\n\n\tfunction set_skipFrame(val:Bool):Bool {\n\t\tif (val) {\n\t\t\ttrace(\"pixi.plugins.app.Application > Deprecated: skipFrame - use fps property and set it to 30 instead\");\n\t\t\tfps = 30;\n\t\t}\n\t\treturn skipFrame = val;\n\t}\n\n\tinline function _setDefaultValues() {\n\t\tpixelRatio = 1;\n\t\tskipFrame = false;\n\t\tautoResize = true;\n\t\ttransparent = false;\n\t\tantialias = false;\n\t\tforceFXAA = false;\n\t\troundPixels = false;\n\t\tclearBeforeRender = true;\n\t\tpreserveDrawingBuffer = false;\n\t\tbackgroundColor = 0xFFFFFF;\n\t\twidth = Browser.window.innerWidth;\n\t\theight = Browser.window.innerHeight;\n\t\tfps = 60;\n\t}\n\n\t/**\n\t * Starts pixi application setup using the properties set or default values\n\t * @param [rendererType] - Renderer type to use AUTO (default) | CANVAS | WEBGL\n\t * @param [stats] - Enable/disable stats for the application.\n\t * Note that stats.js is not part of pixi so don't forget to include it you html page\n\t * Can be found in libs folder. \"libs/stats.min.js\" <script type=\"text/javascript\" src=\"libs/stats.min.js\"></script>\n\t * @param [parentDom] - By default canvas will be appended to body or it can be appended to custom element if passed\n\t */\n\n\tpublic function start(?rendererType:String = \"auto\", ?parentDom:Element) {\n\t\tcanvas = Browser.document.createCanvasElement();\n\t\tcanvas.style.width = width + \"px\";\n\t\tcanvas.style.height = height + \"px\";\n\t\tcanvas.style.position = \"absolute\";\n\t\tif (parentDom == null) Browser.document.body.appendChild(canvas);\n\t\telse parentDom.appendChild(canvas);\n\n\t\tstage = new Container();\n\n\t\tvar renderingOptions:RenderingOptions = {};\n\t\trenderingOptions.view = canvas;\n\t\trenderingOptions.backgroundColor = backgroundColor;\n\t\trenderingOptions.resolution = pixelRatio;\n\t\trenderingOptions.antialias = antialias;\n\t\trenderingOptions.forceFXAA = forceFXAA;\n\t\trenderingOptions.autoResize = autoResize;\n\t\trenderingOptions.transparent = transparent;\n\t\trenderingOptions.clearBeforeRender = clearBeforeRender;\n\t\trenderingOptions.preserveDrawingBuffer = preserveDrawingBuffer;\n\n\t\tif (rendererType == AUTO) renderer = Detector.autoDetectRenderer(width, height, renderingOptions);\n\t\telse if (rendererType == CANVAS) renderer = new CanvasRenderer(width, height, renderingOptions);\n\t\telse renderer = new WebGLRenderer(width, height, renderingOptions);\n\n\t\tif (roundPixels) renderer.roundPixels = true;\n\n\t\tBrowser.document.body.appendChild(renderer.view);\n\t\tif (autoResize) Browser.window.onresize = _onWindowResize;\n\t\tBrowser.window.requestAnimationFrame(cast _onRequestAnimationFrame);\n\t\t_lastTime = Date.now();\n\n\t\t_addStats();\n\t}\n\n\tpublic function pauseRendering() {\n\t\tBrowser.window.onresize = null;\n\t\tBrowser.window.requestAnimationFrame(cast function(){});\n\t}\n\n\tpublic function resumeRendering() {\n\t\tif (autoResize) Browser.window.onresize = _onWindowResize;\n\t\tBrowser.window.requestAnimationFrame(cast _onRequestAnimationFrame);\n\t}\n\n\t@:noCompletion function _onWindowResize(event:Event) {\n\t\twidth = Browser.window.innerWidth;\n\t\theight = Browser.window.innerHeight;\n\t\trenderer.resize(width, height);\n\t\tcanvas.style.width = width + \"px\";\n\t\tcanvas.style.height = height + \"px\";\n\n\t\tif (onResize != null) onResize();\n\t}\n\n\t@:noCompletion function _onRequestAnimationFrame() {\n\t\t_frameCount++;\n\t\tif (_frameCount == Std.int(60 / fps)) {\n\t\t\t_frameCount = 0;\n\t\t\t_calculateElapsedTime();\n\t\t\tif (onUpdate != null) onUpdate(_elapsedTime);\n\t\t\trenderer.render(stage);\n\t\t}\n\t\tBrowser.window.requestAnimationFrame(cast _onRequestAnimationFrame);\n\n\t\t#if fps _fps.tick(); #end\n\t\t#if stats if (_stats != null) _stats.update(); #end\n\t\t#if fpsmeter if (_fpsMeter != null) _fpsMeter.tick(); #end\n\t}\n\n\t@:noCompletion function _calculateElapsedTime() {\n\t\t_currentTime = Date.now();\n\t\t_elapsedTime = _currentTime.getTime() - _lastTime.getTime();\n\t\t_lastTime = _currentTime;\n\t}\n\n\t@:noCompletion function _addStats() {\n\t\t#if fps\n\t\t_fps = new Fps(_updateFps);\n\t\t_fpsDiv = Browser.document.createDivElement();\n\t\t_fpsDiv.id = \"fps\";\n\t\t_fpsDiv.className = \"fps\";\n\t\t_fpsDiv.style.position = \"absolute\";\n\t\t_fpsDiv.style.right = \"0px\";\n\t\t_fpsDiv.style.top = \"14px\";\n\t\t_fpsDiv.style.width = \"76px\";\n\t\t_fpsDiv.style.background = \"#CCCCC\";\n\t\t_fpsDiv.style.backgroundColor = \"#00FF00\";\n\t\t_fpsDiv.style.fontFamily = \"Helvetica,Arial\";\n\t\t_fpsDiv.style.padding = \"2px\";\n\t\t_fpsDiv.style.color = \"#000000\";\n\t\t_fpsDiv.style.fontSize = \"9px\";\n\t\t_fpsDiv.style.fontWeight = \"bold\";\n\t\t_fpsDiv.style.textAlign = \"center\";\n\t\t_fpsDiv.innerHTML = \"FPS: 60\";\n\t\tBrowser.document.body.appendChild(_fpsDiv);\n\t\t_addRenderStats();\n\t\t#end\n\n\t\t#if stats\n\t\tif (untyped __js__(\"window\").Stats != null) {\n\t\t\tvar container = Browser.document.createDivElement();\n\t\t\tBrowser.document.body.appendChild(container);\n\t\t\t_stats = new Stats();\n\t\t\t_stats.domElement.style.position = \"absolute\";\n\t\t\t_stats.domElement.style.top = \"14px\";\n\t\t\t_stats.domElement.style.right = \"0px\";\n\t\t\tcontainer.appendChild(_stats.domElement);\n\t\t\t_stats.begin();\n\t\t\t_addRenderStats();\n\t\t}\n\t\telse trace(\"Unable to find stats.js\");\n\t\t#end\n\n\t\t#if fpsmeter\n\t\tif (untyped __js__(\"window\").FPSMeter != null) {\n\t\t\t_fpsMeter = new FPSMeter( {theme: \"colorful\", top: \"14px\", right: \"0px\", left: \"auto\"});\n\t\t\t_addRenderStats();\n\t\t}\n\t\telse trace(\"Unable to find fpsmeter.js\");\n\t\t#end\n\t}\n\n\tinline function _addRenderStats(?top:Int = 0) {\n\t\tvar ren:DivElement = Browser.document.createDivElement();\n\t\tren.style.position = \"absolute\";\n\t\tren.style.width = \"76px\";\n\t\tren.style.top = top + \"px\";\n\t\tren.style.right = \"0px\";\n\t\tren.style.background = \"#CCCCC\";\n\t\tren.style.backgroundColor = \"#105CB6\";\n\t\tren.style.fontFamily = \"Helvetica,Arial\";\n\t\tren.style.padding = \"2px\";\n\t\tren.style.color = \"#0FF\";\n\t\tren.style.fontSize = \"9px\";\n\t\tren.style.fontWeight = \"bold\";\n\t\tren.style.textAlign = \"center\";\n\t\tBrowser.document.body.appendChild(ren);\n\t\tren.innerHTML = [\"UNKNOWN\", \"WEBGL\", \"CANVAS\"][renderer.type] + \" - \" + pixelRatio;\n\t}\n\n\t#if fps\n\tfunction _updateFps(val:Float) {\n\t\t_fpsDiv.innerHTML = \"FPS: \" + val;\n\t}\n\t#end\n}","package samples.nape;\n\nimport pixi.core.textures.Texture;\nimport pixi.core.sprites.Sprite;\nimport pixi.plugins.app.Application;\nimport haxe.Timer;\n\nimport nape.geom.Vec2;\nimport nape.phys.Body;\nimport nape.phys.BodyType;\nimport nape.shape.Circle;\nimport nape.shape.Polygon;\nimport nape.space.Space;\nimport nape.phys.Material;\n\nclass Main extends Application {\n\n\tvar _floor:Body;\n\tvar _space:Space;\n\tvar _balls:Array<Sprite>;\n\tvar _pballs:Array<Body>;\n\n\tpublic function new() {\n\t\tsuper();\n\t\t_init();\n\n\t\t_balls = [];\n\t\t_pballs = [];\n\t\t_setUpPhysics();\n\t\tonUpdate = _onUpdate;\n\t\tvar timer:Timer = new Timer(1000);\n\t\ttimer.run = _addBall;\n\t\t_addBall();\n\t}\n\n\tfunction _init() {\n\t\tbackgroundColor = 0x6699FF;\n\t\tautoResize = false;\n\t\twidth = 800;\n\t\theight = 600;\n\t\tsuper.start();\n\t}\n\n\tfunction _onUpdate(elapsedTime:Float) {\n\t\t_space.step(1 / 60);\n\n\t\tfor(i in 0 ... _pballs.length) {\n\t\t\t_balls[i].position.x = _pballs[i].position.x;\n\t\t\t_balls[i].position.y = _pballs[i].position.y;\n\t\t\t_balls[i].rotation = _pballs[i].rotation;\n\t\t}\n\t}\n\n\tfunction _setUpPhysics() {\n\t\tvar gravity = Vec2.weak(0, 600);\n\t\t_space = new Space(gravity);\n\n\t\t_floor = new Body(BodyType.STATIC);\n\t\t_floor.setShapeMaterials(Material.wood());\n\t\t_floor.shapes.add(new Polygon(Polygon.rect(0, 595, 800, 1)));\n\t\t_floor.space = _space;\n\t}\n\n\tfunction _addBall() {\n\t\tvar ball:Sprite = new Sprite(Texture.fromImage(\"assets/nape/ball.png\"));\n\t\tball.anchor.set(0.5, 0.5);\n\t\t_balls.push(ball);\n\t\tstage.addChild(ball);\n\n\t\tvar pball:Body = new Body(BodyType.DYNAMIC);\n\t\tpball.shapes.add(new Circle(10));\n\t\tpball.position.setxy(Std.random(800), 0);\n\t\tpball.angularVel = 0;\n\t\tpball.allowRotation = true;\n\n\t\tpball.setShapeMaterials(Material.rubber());\n\t\tpball.space = _space;\n\t\t_pballs.push(pball);\n\t}\n\n\tstatic function main() {\n\t\tnew Main();\n\t}\n}","package zpp_nape;\nimport zpp_nape.Const;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_ID{\n    \n    public static var _Constraint:Int=0;\n    public static function Constraint(){\n        return _Constraint++;\n    }\n    public static var _Interactor:Int=0;\n    public static function Interactor(){\n        return _Interactor++;\n    }\n    public static var _CbType:Int=0;\n    public static function CbType(){\n        return _CbType++;\n    }\n    public static var _CbSet:Int=0;\n    public static function CbSet(){\n        return _CbSet++;\n    }\n    public static var _Listener:Int=0;\n    public static function Listener(){\n        return _Listener++;\n    }\n    public static var _ZPP_SimpleVert:Int=0;\n    public static function ZPP_SimpleVert(){\n        return _ZPP_SimpleVert++;\n    }\n    public static var _ZPP_SimpleSeg:Int=0;\n    public static function ZPP_SimpleSeg(){\n        return _ZPP_SimpleSeg++;\n    }\n    public static var _Space:Int=0;\n    public static function Space(){\n        return _Space++;\n    }\n    public static var _InteractionGroup:Int=0;\n    public static function InteractionGroup(){\n        return _InteractionGroup++;\n    }\n}\n","package zpp_nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Callback{\n    public var outer_body:Null<BodyCallback>=null;\n    public var outer_con:Null<ConstraintCallback>=null;\n    public var outer_int:Null<InteractionCallback>=null;\n    #if(!NAPE_RELEASE_BUILD)\n    public static var internal=false;\n    #end\n    public function wrapper_body(){\n        if(outer_body==null){\n            #if(!NAPE_RELEASE_BUILD)\n            internal=true;\n            #end\n            outer_body=new BodyCallback();\n            #if(!NAPE_RELEASE_BUILD)\n            internal=false;\n            #end\n            outer_body.zpp_inner=this;\n        }\n        return outer_body;\n    }\n    public function wrapper_con(){\n        if(outer_con==null){\n            #if(!NAPE_RELEASE_BUILD)\n            internal=true;\n            #end\n            outer_con=new ConstraintCallback();\n            #if(!NAPE_RELEASE_BUILD)\n            internal=false;\n            #end\n            outer_con.zpp_inner=this;\n        }\n        return outer_con;\n    }\n    public function wrapper_int(){\n        if(outer_int==null){\n            #if(!NAPE_RELEASE_BUILD)\n            internal=true;\n            #end\n            outer_int=new InteractionCallback();\n            #if(!NAPE_RELEASE_BUILD)\n            internal=false;\n            #end\n            outer_int.zpp_inner=this;\n        }\n        genarbs();\n        return outer_int;\n    }\n    public var event:Int=0;\n    public var listener:ZPP_Listener=null;\n    public var space:ZPP_Space=null;\n    public var index:Int=0;\n    public var next:ZPP_Callback=null;\n    public var prev:ZPP_Callback=null;\n    public var length:Int=0;\n    public function push(obj:ZPP_Callback){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"push null?\");\n            #end\n        };\n        if(prev!=null)prev.next=obj;\n        else next=obj;\n        obj.prev=prev;\n        obj.next=null;\n        prev=obj;\n        length++;\n    }\n    public function push_rev(obj:ZPP_Callback){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"push_rev null?\");\n            #end\n        };\n        if(next!=null)next.prev=obj;\n        else prev=obj;\n        obj.next=next;\n        obj.prev=null;\n        next=obj;\n        length++;\n    }\n    public function pop():ZPP_Callback{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                next!=null;\n            };\n            if(!res)throw \"assert(\"+\"next!=null\"+\") :: \"+(\"empty queue\");\n            #end\n        };\n        var ret=next;\n        next=ret.next;\n        if(next==null)prev=null;\n        else next.prev=null;\n        length--;\n        return ret;\n    }\n    public function pop_rev():ZPP_Callback{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                prev!=null;\n            };\n            if(!res)throw \"assert(\"+\"prev!=null\"+\") :: \"+(\"empty queue\");\n            #end\n        };\n        var ret=prev;\n        prev=ret.prev;\n        if(prev==null)next=null;\n        else prev.next=null;\n        length--;\n        return ret;\n    }\n    public function empty(){\n        return next==null;\n    }\n    public function clear(){\n        while(!empty())pop();\n    }\n    public function splice(o:ZPP_Callback){\n        var ret=o.next;\n        if(o.prev==null){\n            next=o.next;\n            if(next!=null)next.prev=null;\n            else prev=null;\n        }\n        else{\n            o.prev.next=o.next;\n            if(o.next!=null)o.next.prev=o.prev;\n            else prev=o.prev;\n        }\n        length--;\n        return ret;\n    }\n    public function rotateL(){\n        push(pop());\n    }\n    public function rotateR(){\n        push_rev(pop_rev());\n    }\n    public function cycleNext(o:ZPP_Callback){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null;\n            };\n            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"cyclNext null?\");\n            #end\n        };\n        if(o.next==null)return next;\n        else return o.next;\n    }\n    public function cyclePrev(o:ZPP_Callback){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null;\n            };\n            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"cyclPrev null?\");\n            #end\n        };\n        if(o.prev==null)return prev;\n        else return o.prev;\n    }\n    public function at(i:Int){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                i>=0&&i<length;\n            };\n            if(!res)throw \"assert(\"+\"i>=0&&i<length\"+\") :: \"+(\"at index bounds\");\n            #end\n        };\n        var ret=next;\n        while(i--!=0)ret=ret.next;\n        return ret;\n    }\n    public function rev_at(i:Int){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                i>=0&&i<length;\n            };\n            if(!res)throw \"assert(\"+\"i>=0&&i<length\"+\") :: \"+(\"rev_at index bounds\");\n            #end\n        };\n        var ret=prev;\n        while(i--!=0)ret=ret.prev;\n        return ret;\n    }\n    static public var zpp_pool:ZPP_Callback=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        int1=int2=null;\n        body=null;\n        constraint=null;\n        listener=null;\n        if(wrap_arbiters!=null){\n            wrap_arbiters.zpp_inner.inner=null;\n        }\n        set=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    public var int1:ZPP_Interactor=null;\n    public var int2:ZPP_Interactor=null;\n    public var set:ZPP_CallbackSet=null;\n    public var wrap_arbiters:ArbiterList=null;\n    public var pre_arbiter:ZPP_Arbiter=null;\n    public var pre_swapped:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function genarbs(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                set!=null;\n            };\n            if(!res)throw \"assert(\"+\"set!=null\"+\") :: \"+(\"after ongoing event was added, this should never be the case\");\n            #end\n        };\n        if(wrap_arbiters==null){\n            wrap_arbiters=ZPP_ArbiterList.get(set.arbiters,true);\n        }\n        else{\n            wrap_arbiters.zpp_inner.inner=set.arbiters;\n        }\n        wrap_arbiters.zpp_inner.zip_length=true;\n        wrap_arbiters.zpp_inner.at_ite=null;\n    }\n    public var body:ZPP_Body=null;\n    public var constraint:ZPP_Constraint=null;\n    public function new(){\n        length=0;\n    }\n}\n","package zpp_nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_CbSet{\n    public var cbTypes:ZNPList_ZPP_CbType=null;\n    public var count:Int=0;\n    public var next:ZPP_CbSet=null;\n    static public var zpp_pool:ZPP_CbSet=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var id:Int=0;\n    public var manager:ZPP_CbSetManager=null;\n    public var cbpairs:ZNPList_ZPP_CbSetPair=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function increment():Void{\n        count++;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function decrement():Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                count>0;\n            };\n            if(!res)throw \"assert(\"+\"count>0\"+\") :: \"+(\"decrementing ref.count into negatives??\");\n            #end\n        };\n        return(--count)==0;\n    }\n    public function invalidate_pairs():Void{\n        {\n            var cx_ite=cbpairs.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                cb.invalidate();\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public var listeners:ZNPList_ZPP_InteractionListener=null;\n    public var zip_listeners:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_listeners():Void{\n        zip_listeners=true;\n        #if true invalidate_pairs();\n        #end\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_listeners():Void{\n        if(zip_listeners){\n            zip_listeners=false;\n            realvalidate_listeners();\n        }\n    }\n    public function realvalidate_listeners(){\n        listeners.clear();\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                {\n                    var npre=null;\n                    var nite=listeners.begin();\n                    var cite=cb.listeners.begin();\n                    while(cite!=null){\n                        var cx=cite.elem();\n                        if(nite!=null&&nite.elem()==cx){\n                            cite=cite.next;\n                            npre=nite;\n                            nite=nite.next;\n                        }\n                        else if(nite==null||ZPP_Listener.setlt(cx,nite.elem())){\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !listeners.has(cx);\n                                };\n                                if(!res)throw \"assert(\"+\"!listeners.has(cx)\"+\") :: \"+(\"merged list already contains listener\");\n                                #end\n                            };\n                            if(#if true true#else!cx.options.excluded(cbTypes)#end\n                            &&manager.valid_listener(cx)){\n                                npre=listeners.inlined_insert(npre,cx);\n                            }\n                            cite=cite.next;\n                        }\n                        else{\n                            npre=nite;\n                            nite=nite.next;\n                        }\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public var bodylisteners:ZNPList_ZPP_BodyListener=null;\n    public var zip_bodylisteners:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_bodylisteners():Void{\n        zip_bodylisteners=true;\n        #if false invalidate_pairs();\n        #end\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_bodylisteners():Void{\n        if(zip_bodylisteners){\n            zip_bodylisteners=false;\n            realvalidate_bodylisteners();\n        }\n    }\n    public function realvalidate_bodylisteners(){\n        bodylisteners.clear();\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                {\n                    var npre=null;\n                    var nite=bodylisteners.begin();\n                    var cite=cb.bodylisteners.begin();\n                    while(cite!=null){\n                        var cx=cite.elem();\n                        if(nite!=null&&nite.elem()==cx){\n                            cite=cite.next;\n                            npre=nite;\n                            nite=nite.next;\n                        }\n                        else if(nite==null||ZPP_Listener.setlt(cx,nite.elem())){\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !bodylisteners.has(cx);\n                                };\n                                if(!res)throw \"assert(\"+\"!bodylisteners.has(cx)\"+\") :: \"+(\"merged list already contains listener\");\n                                #end\n                            };\n                            if(#if false true#else!cx.options.excluded(cbTypes)#end\n                            &&manager.valid_listener(cx)){\n                                npre=bodylisteners.inlined_insert(npre,cx);\n                            }\n                            cite=cite.next;\n                        }\n                        else{\n                            npre=nite;\n                            nite=nite.next;\n                        }\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public var conlisteners:ZNPList_ZPP_ConstraintListener=null;\n    public var zip_conlisteners:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_conlisteners():Void{\n        zip_conlisteners=true;\n        #if false invalidate_pairs();\n        #end\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_conlisteners():Void{\n        if(zip_conlisteners){\n            zip_conlisteners=false;\n            realvalidate_conlisteners();\n        }\n    }\n    public function realvalidate_conlisteners(){\n        conlisteners.clear();\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                {\n                    var npre=null;\n                    var nite=conlisteners.begin();\n                    var cite=cb.conlisteners.begin();\n                    while(cite!=null){\n                        var cx=cite.elem();\n                        if(nite!=null&&nite.elem()==cx){\n                            cite=cite.next;\n                            npre=nite;\n                            nite=nite.next;\n                        }\n                        else if(nite==null||ZPP_Listener.setlt(cx,nite.elem())){\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !conlisteners.has(cx);\n                                };\n                                if(!res)throw \"assert(\"+\"!conlisteners.has(cx)\"+\") :: \"+(\"merged list already contains listener\");\n                                #end\n                            };\n                            if(#if false true#else!cx.options.excluded(cbTypes)#end\n                            &&manager.valid_listener(cx)){\n                                npre=conlisteners.inlined_insert(npre,cx);\n                            }\n                            cite=cite.next;\n                        }\n                        else{\n                            npre=nite;\n                            nite=nite.next;\n                        }\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function validate(){\n        \n        validate_listeners();\n        validate_bodylisteners();\n        validate_conlisteners();\n    }\n    public var interactors:ZNPList_ZPP_Interactor=null;\n    public var wrap_interactors:InteractorList=null;\n    public var constraints:ZNPList_ZPP_Constraint=null;\n    public var wrap_constraints:ConstraintList=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addConstraint(con:ZPP_Constraint){\n        constraints.add(con);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addInteractor(intx:ZPP_Interactor){\n        interactors.add(intx);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remConstraint(con:ZPP_Constraint){\n        constraints.remove(con);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remInteractor(intx:ZPP_Interactor){\n        interactors.remove(intx);\n    }\n    public static function setlt(a:ZPP_CbSet,b:ZPP_CbSet):Bool{\n        var i=a.cbTypes.begin();\n        var j=b.cbTypes.begin();\n        while(i!=null&&j!=null){\n            var ca=i.elem();\n            var cb=j.elem();\n            if(ZPP_CbType.setlt(ca,cb))return true;\n            if(ZPP_CbType.setlt(cb,ca))return false;\n            else{\n                i=i.next;\n                j=j.next;\n            }\n        }\n        return j!=null&&i==null;\n    }\n    public function new(){\n        cbTypes=new ZNPList_ZPP_CbType();\n        \n        listeners=new ZNPList_ZPP_InteractionListener();\n        zip_listeners=true;\n        bodylisteners=new ZNPList_ZPP_BodyListener();\n        zip_bodylisteners=true;\n        conlisteners=new ZNPList_ZPP_ConstraintListener();\n        zip_conlisteners=true;\n        constraints=new ZNPList_ZPP_Constraint();\n        interactors=new ZNPList_ZPP_Interactor();\n        id=ZPP_ID.CbSet();\n        cbpairs=new ZNPList_ZPP_CbSetPair();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                constraints.empty();\n            };\n            if(!res)throw \"assert(\"+\"constraints.empty()\"+\") :: \"+(\"non-empty constraints\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                interactors.empty();\n            };\n            if(!res)throw \"assert(\"+\"interactors.empty()\"+\") :: \"+(\"non-empty interactors\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                count==0;\n            };\n            if(!res)throw \"assert(\"+\"count==0\"+\") :: \"+(\"deallocating with count!=0?\");\n            #end\n        };\n        \n        listeners.clear();\n        zip_listeners=true;\n        bodylisteners.clear();\n        zip_bodylisteners=true;\n        conlisteners.clear();\n        zip_conlisteners=true;\n        {\n            while(!cbTypes.empty()){\n                var cb=cbTypes.pop_unsafe();\n                cb.cbsets.remove(this);\n            }\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cbpairs.empty();\n            };\n            if(!res)throw \"assert(\"+\"cbpairs.empty()\"+\") :: \"+(\"non-empty cbpairs\");\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_ASSERT public static function assert_cbTypes(cbTypes:ZNPList_ZPP_CbType):Void{\n        var pre=null;\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cur=cx_ite.elem();\n                {\n                    if(pre!=null){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                ZPP_CbType.setlt(pre,cur);\n                            };\n                            if(!res)throw \"assert(\"+\"ZPP_CbType.setlt(pre,cur)\"+\") :: \"+(\"cbTypes of CbSet not well-ordered!\");\n                            #end\n                        };\n                    }\n                    pre=cur;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    #end\n    public static function get(cbTypes:ZNPList_ZPP_CbType){\n        var ret;\n        {\n            if(ZPP_CbSet.zpp_pool==null){\n                ret=new ZPP_CbSet();\n                #if NAPE_POOL_STATS ZPP_CbSet.POOL_TOT++;\n                ZPP_CbSet.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_CbSet.zpp_pool;\n                ZPP_CbSet.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_CbSet.POOL_CNT--;\n                ZPP_CbSet.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        var ite=null;\n        #if NAPE_ASSERT assert_cbTypes(cbTypes);\n        #end\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                {\n                    ite=ret.cbTypes.insert(ite,cb);\n                    cb.cbsets.add(ret);\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    static function compatible(i:ZPP_InteractionListener,a:ZPP_CbSet,b:ZPP_CbSet):Bool{\n        return(i.options1.compatible(a.cbTypes)&&i.options2.compatible(b.cbTypes))||(i.options2.compatible(a.cbTypes)&&i.options1.compatible(b.cbTypes));\n    }\n    public static#if NAPE_NO_INLINE#else inline #end\n    function empty_intersection(a:ZPP_CbSet,b:ZPP_CbSet):Bool{\n        return a.manager.pair(a,b).empty_intersection();\n    }\n    public static function single_intersection(a:ZPP_CbSet,b:ZPP_CbSet,i:ZPP_InteractionListener):Bool{\n        return a.manager.pair(a,b).single_intersection(i);\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    public static function find_all(a:ZPP_CbSet,b:ZPP_CbSet,event:Int,cb:ZPP_InteractionListener->Void):Void{\n        a.manager.pair(a,b).forall(event,cb);\n    }\n}\n","package zpp_nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_CbSetPair{\n    public var a:ZPP_CbSet=null;\n    public var b:ZPP_CbSet=null;\n    public var next:ZPP_CbSetPair=null;\n    static public var zpp_pool:ZPP_CbSetPair=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        a=b=null;\n        listeners.clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{\n        zip_listeners=true;\n    }\n    public function new(){\n        listeners=new ZNPList_ZPP_InteractionListener();\n    }\n    public static#if NAPE_NO_INLINE#else inline #end\n    function get(a:ZPP_CbSet,b:ZPP_CbSet):ZPP_CbSetPair{\n        var ret;\n        {\n            if(ZPP_CbSetPair.zpp_pool==null){\n                ret=new ZPP_CbSetPair();\n                #if NAPE_POOL_STATS ZPP_CbSetPair.POOL_TOT++;\n                ZPP_CbSetPair.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_CbSetPair.zpp_pool;\n                ZPP_CbSetPair.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_CbSetPair.POOL_CNT--;\n                ZPP_CbSetPair.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        if(ZPP_CbSet.setlt(a,b)){\n            ret.a=a;\n            ret.b=b;\n        }\n        else{\n            ret.a=b;\n            ret.b=a;\n        }\n        return ret;\n    }\n    public static#if NAPE_NO_INLINE#else inline #end\n    function setlt(x:ZPP_CbSetPair,y:ZPP_CbSetPair):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                (x.a==y.a)==(!ZPP_CbSet.setlt(x.a,y.a)&&!ZPP_CbSet.setlt(y.a,x.a));\n            };\n            if(!res)throw \"assert(\"+\"(x.a==y.a)==(!ZPP_CbSet.setlt(x.a,y.a)&&!ZPP_CbSet.setlt(y.a,x.a))\"+\") :: \"+(\"Assumption that CbSet's are unique!! Aka we can compare for 'equal' CbSet with == is wrong?? :(\");\n            #end\n        };\n        return ZPP_CbSet.setlt(x.a,y.a)||(x.a==y.a&&ZPP_CbSet.setlt(x.b,y.b));\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    #if NAPE_NO_INLINE#else inline #end\n    function compatible(i:ZPP_InteractionListener):Bool{\n        return(i.options1.compatible(a.cbTypes)&&i.options2.compatible(b.cbTypes))||(i.options2.compatible(a.cbTypes)&&i.options1.compatible(b.cbTypes));\n    }\n    public var zip_listeners:Bool=false;\n    public var listeners:ZNPList_ZPP_InteractionListener=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate():Void{\n        zip_listeners=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate():Void{\n        if(zip_listeners){\n            zip_listeners=false;\n            __validate();\n        }\n    }\n    public function __validate():Void{\n        listeners.clear();\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !a.zip_listeners;\n            };\n            if(!res)throw \"assert(\"+\"!a.zip_listeners\"+\") :: \"+(\"a.listeners not validated??\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !b.zip_listeners;\n            };\n            if(!res)throw \"assert(\"+\"!b.zip_listeners\"+\") :: \"+(\"b.listeners not validated??\");\n            #end\n        };\n        var aite=a.listeners.begin();\n        var bite=b.listeners.begin();\n        while(aite!=null&&bite!=null){\n            var ax=aite.elem();\n            var bx=bite.elem();\n            if(ax==bx){\n                if(compatible(ax)){\n                    listeners.add(ax);\n                }\n                aite=aite.next;\n                bite=bite.next;\n            }\n            else if(ZPP_Listener.setlt(ax,bx))aite=aite.next;\n            else bite=bite.next;\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty_intersection():Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !zip_listeners;\n            };\n            if(!res)throw \"assert(\"+\"!zip_listeners\"+\") :: \"+(\"not validated before empty_intersection\");\n            #end\n        };\n        return listeners.empty();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function single_intersection(i:ZPP_InteractionListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !zip_listeners;\n            };\n            if(!res)throw \"assert(\"+\"!zip_listeners\"+\") :: \"+(\"not validated before single_intersection\");\n            #end\n        };\n        var ite=listeners.begin();\n        return ite!=null&&ite.elem()==i&&ite.next==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function forall(event:Int,cb:ZPP_InteractionListener->Void):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !zip_listeners;\n            };\n            if(!res)throw \"assert(\"+\"!zip_listeners\"+\") :: \"+(\"not validated before forall\");\n            #end\n        };\n        {\n            var cx_ite=listeners.begin();\n            while(cx_ite!=null){\n                var x=cx_ite.elem();\n                {\n                    if(x.event==event)cb(x);\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n}\n","package zpp_nape.util;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_CbType{\n    public var head:ZNPNode_ZPP_CbType=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_CbType{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_CbType):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_CbType):ZPP_CbType{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_CbType):ZPP_CbType{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CbType.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CbType();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbType.POOL_TOT++;\n                    ZNPNode_ZPP_CbType.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CbType.zpp_pool;\n                    ZNPNode_ZPP_CbType.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbType.POOL_CNT--;\n                    ZNPNode_ZPP_CbType.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_CbType):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_CbType,o:ZPP_CbType):ZNPNode_ZPP_CbType{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_CbType,o:ZPP_CbType):ZNPNode_ZPP_CbType{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CbType.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CbType();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbType.POOL_TOT++;\n                    ZNPNode_ZPP_CbType.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CbType.zpp_pool;\n                    ZNPNode_ZPP_CbType.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbType.POOL_CNT--;\n                    ZNPNode_ZPP_CbType.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CbType\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CbType.zpp_pool;\n            ZNPNode_ZPP_CbType.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CbType.POOL_CNT++;\n            ZNPNode_ZPP_CbType.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_CbType{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_CbType{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_CbType):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_CbType):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_CbType):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_CbType):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_CbType):ZNPNode_ZPP_CbType{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_CbType):ZNPNode_ZPP_CbType{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_CbType;\n        var ret:ZNPNode_ZPP_CbType;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CbType\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CbType.zpp_pool;\n            ZNPNode_ZPP_CbType.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CbType.POOL_CNT++;\n            ZNPNode_ZPP_CbType.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_CbType,n:Int):ZNPNode_ZPP_CbType{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_CbType):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_CbType):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_CbType{\n        return begin().elem();\n    }\n    public function back():ZPP_CbType{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_CbType{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_CbType{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbType\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_CallbackSet{\n    public var head:ZNPNode_ZPP_CallbackSet=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_CallbackSet{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_CallbackSet):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_CallbackSet):ZPP_CallbackSet{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_CallbackSet):ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CallbackSet.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CallbackSet();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CallbackSet.POOL_TOT++;\n                    ZNPNode_ZPP_CallbackSet.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CallbackSet.zpp_pool;\n                    ZNPNode_ZPP_CallbackSet.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CallbackSet.POOL_CNT--;\n                    ZNPNode_ZPP_CallbackSet.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_CallbackSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_CallbackSet,o:ZPP_CallbackSet):ZNPNode_ZPP_CallbackSet{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_CallbackSet,o:ZPP_CallbackSet):ZNPNode_ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CallbackSet.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CallbackSet();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CallbackSet.POOL_TOT++;\n                    ZNPNode_ZPP_CallbackSet.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CallbackSet.zpp_pool;\n                    ZNPNode_ZPP_CallbackSet.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CallbackSet.POOL_CNT--;\n                    ZNPNode_ZPP_CallbackSet.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CallbackSet\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CallbackSet.zpp_pool;\n            ZNPNode_ZPP_CallbackSet.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CallbackSet.POOL_CNT++;\n            ZNPNode_ZPP_CallbackSet.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_CallbackSet{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_CallbackSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_CallbackSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_CallbackSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_CallbackSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_CallbackSet):ZNPNode_ZPP_CallbackSet{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_CallbackSet):ZNPNode_ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_CallbackSet;\n        var ret:ZNPNode_ZPP_CallbackSet;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CallbackSet\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CallbackSet.zpp_pool;\n            ZNPNode_ZPP_CallbackSet.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CallbackSet.POOL_CNT++;\n            ZNPNode_ZPP_CallbackSet.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_CallbackSet,n:Int):ZNPNode_ZPP_CallbackSet{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_CallbackSet):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_CallbackSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_CallbackSet{\n        return begin().elem();\n    }\n    public function back():ZPP_CallbackSet{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Shape{\n    public var head:ZNPNode_ZPP_Shape=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Shape{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Shape):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Shape):ZPP_Shape{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Shape):ZPP_Shape{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Shape.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Shape();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Shape.POOL_TOT++;\n                    ZNPNode_ZPP_Shape.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Shape.zpp_pool;\n                    ZNPNode_ZPP_Shape.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Shape.POOL_CNT--;\n                    ZNPNode_ZPP_Shape.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Shape):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Shape,o:ZPP_Shape):ZNPNode_ZPP_Shape{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Shape,o:ZPP_Shape):ZNPNode_ZPP_Shape{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Shape.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Shape();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Shape.POOL_TOT++;\n                    ZNPNode_ZPP_Shape.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Shape.zpp_pool;\n                    ZNPNode_ZPP_Shape.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Shape.POOL_CNT--;\n                    ZNPNode_ZPP_Shape.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Shape\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Shape.zpp_pool;\n            ZNPNode_ZPP_Shape.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Shape.POOL_CNT++;\n            ZNPNode_ZPP_Shape.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Shape{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Shape{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Shape):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Shape):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Shape):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Shape):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Shape):ZNPNode_ZPP_Shape{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Shape):ZNPNode_ZPP_Shape{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Shape;\n        var ret:ZNPNode_ZPP_Shape;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Shape\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Shape.zpp_pool;\n            ZNPNode_ZPP_Shape.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Shape.POOL_CNT++;\n            ZNPNode_ZPP_Shape.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Shape,n:Int):ZNPNode_ZPP_Shape{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Shape):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Shape):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Shape{\n        return begin().elem();\n    }\n    public function back():ZPP_Shape{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Shape{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Shape{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Shape\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Body{\n    public var head:ZNPNode_ZPP_Body=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Body{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Body):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Body):ZPP_Body{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Body):ZPP_Body{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Body.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Body();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Body.POOL_TOT++;\n                    ZNPNode_ZPP_Body.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Body.zpp_pool;\n                    ZNPNode_ZPP_Body.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Body.POOL_CNT--;\n                    ZNPNode_ZPP_Body.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Body):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Body,o:ZPP_Body):ZNPNode_ZPP_Body{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Body,o:ZPP_Body):ZNPNode_ZPP_Body{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Body.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Body();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Body.POOL_TOT++;\n                    ZNPNode_ZPP_Body.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Body.zpp_pool;\n                    ZNPNode_ZPP_Body.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Body.POOL_CNT--;\n                    ZNPNode_ZPP_Body.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Body\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Body.zpp_pool;\n            ZNPNode_ZPP_Body.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Body.POOL_CNT++;\n            ZNPNode_ZPP_Body.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Body{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Body{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Body):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Body):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Body):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Body):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Body):ZNPNode_ZPP_Body{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Body):ZNPNode_ZPP_Body{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Body;\n        var ret:ZNPNode_ZPP_Body;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Body\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Body.zpp_pool;\n            ZNPNode_ZPP_Body.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Body.POOL_CNT++;\n            ZNPNode_ZPP_Body.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Body,n:Int):ZNPNode_ZPP_Body{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Body):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Body):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Body{\n        return begin().elem();\n    }\n    public function back():ZPP_Body{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Body{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Body{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Body\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Constraint{\n    public var head:ZNPNode_ZPP_Constraint=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Constraint{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Constraint):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Constraint):ZPP_Constraint{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Constraint):ZPP_Constraint{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Constraint.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Constraint();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Constraint.POOL_TOT++;\n                    ZNPNode_ZPP_Constraint.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Constraint.zpp_pool;\n                    ZNPNode_ZPP_Constraint.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Constraint.POOL_CNT--;\n                    ZNPNode_ZPP_Constraint.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Constraint):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Constraint,o:ZPP_Constraint):ZNPNode_ZPP_Constraint{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Constraint,o:ZPP_Constraint):ZNPNode_ZPP_Constraint{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Constraint.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Constraint();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Constraint.POOL_TOT++;\n                    ZNPNode_ZPP_Constraint.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Constraint.zpp_pool;\n                    ZNPNode_ZPP_Constraint.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Constraint.POOL_CNT--;\n                    ZNPNode_ZPP_Constraint.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Constraint\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Constraint.zpp_pool;\n            ZNPNode_ZPP_Constraint.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Constraint.POOL_CNT++;\n            ZNPNode_ZPP_Constraint.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Constraint{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Constraint{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Constraint):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Constraint):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Constraint):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Constraint):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Constraint):ZNPNode_ZPP_Constraint{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Constraint):ZNPNode_ZPP_Constraint{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Constraint;\n        var ret:ZNPNode_ZPP_Constraint;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Constraint\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Constraint.zpp_pool;\n            ZNPNode_ZPP_Constraint.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Constraint.POOL_CNT++;\n            ZNPNode_ZPP_Constraint.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Constraint,n:Int):ZNPNode_ZPP_Constraint{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Constraint):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Constraint):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Constraint{\n        return begin().elem();\n    }\n    public function back():ZPP_Constraint{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Constraint{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Constraint{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Constraint\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Compound{\n    public var head:ZNPNode_ZPP_Compound=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Compound{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Compound):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Compound):ZPP_Compound{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Compound):ZPP_Compound{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Compound.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Compound();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Compound.POOL_TOT++;\n                    ZNPNode_ZPP_Compound.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Compound.zpp_pool;\n                    ZNPNode_ZPP_Compound.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Compound.POOL_CNT--;\n                    ZNPNode_ZPP_Compound.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Compound):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Compound,o:ZPP_Compound):ZNPNode_ZPP_Compound{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Compound,o:ZPP_Compound):ZNPNode_ZPP_Compound{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Compound.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Compound();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Compound.POOL_TOT++;\n                    ZNPNode_ZPP_Compound.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Compound.zpp_pool;\n                    ZNPNode_ZPP_Compound.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Compound.POOL_CNT--;\n                    ZNPNode_ZPP_Compound.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Compound\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Compound.zpp_pool;\n            ZNPNode_ZPP_Compound.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Compound.POOL_CNT++;\n            ZNPNode_ZPP_Compound.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Compound{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Compound{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Compound):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Compound):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Compound):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Compound):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Compound):ZNPNode_ZPP_Compound{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Compound):ZNPNode_ZPP_Compound{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Compound;\n        var ret:ZNPNode_ZPP_Compound;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Compound\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Compound.zpp_pool;\n            ZNPNode_ZPP_Compound.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Compound.POOL_CNT++;\n            ZNPNode_ZPP_Compound.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Compound,n:Int):ZNPNode_ZPP_Compound{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Compound):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Compound):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Compound{\n        return begin().elem();\n    }\n    public function back():ZPP_Compound{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Compound{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Compound{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Compound\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_InteractionListener{\n    public var head:ZNPNode_ZPP_InteractionListener=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_InteractionListener{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_InteractionListener):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_InteractionListener):ZPP_InteractionListener{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_InteractionListener):ZPP_InteractionListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_InteractionListener.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_InteractionListener();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionListener.POOL_TOT++;\n                    ZNPNode_ZPP_InteractionListener.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_InteractionListener.zpp_pool;\n                    ZNPNode_ZPP_InteractionListener.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionListener.POOL_CNT--;\n                    ZNPNode_ZPP_InteractionListener.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_InteractionListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_InteractionListener,o:ZPP_InteractionListener):ZNPNode_ZPP_InteractionListener{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_InteractionListener,o:ZPP_InteractionListener):ZNPNode_ZPP_InteractionListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_InteractionListener.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_InteractionListener();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionListener.POOL_TOT++;\n                    ZNPNode_ZPP_InteractionListener.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_InteractionListener.zpp_pool;\n                    ZNPNode_ZPP_InteractionListener.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionListener.POOL_CNT--;\n                    ZNPNode_ZPP_InteractionListener.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_InteractionListener\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_InteractionListener.zpp_pool;\n            ZNPNode_ZPP_InteractionListener.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionListener.POOL_CNT++;\n            ZNPNode_ZPP_InteractionListener.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_InteractionListener{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_InteractionListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_InteractionListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_InteractionListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_InteractionListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_InteractionListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_InteractionListener):ZNPNode_ZPP_InteractionListener{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_InteractionListener):ZNPNode_ZPP_InteractionListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_InteractionListener;\n        var ret:ZNPNode_ZPP_InteractionListener;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_InteractionListener\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_InteractionListener.zpp_pool;\n            ZNPNode_ZPP_InteractionListener.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionListener.POOL_CNT++;\n            ZNPNode_ZPP_InteractionListener.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_InteractionListener,n:Int):ZNPNode_ZPP_InteractionListener{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_InteractionListener):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_InteractionListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_InteractionListener{\n        return begin().elem();\n    }\n    public function back():ZPP_InteractionListener{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_InteractionListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_InteractionListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionListener\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_CbSet{\n    public var head:ZNPNode_ZPP_CbSet=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_CbSet{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_CbSet):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_CbSet):ZPP_CbSet{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_CbSet):ZPP_CbSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CbSet.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CbSet();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbSet.POOL_TOT++;\n                    ZNPNode_ZPP_CbSet.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CbSet.zpp_pool;\n                    ZNPNode_ZPP_CbSet.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbSet.POOL_CNT--;\n                    ZNPNode_ZPP_CbSet.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_CbSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_CbSet,o:ZPP_CbSet):ZNPNode_ZPP_CbSet{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_CbSet,o:ZPP_CbSet):ZNPNode_ZPP_CbSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CbSet.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CbSet();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbSet.POOL_TOT++;\n                    ZNPNode_ZPP_CbSet.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CbSet.zpp_pool;\n                    ZNPNode_ZPP_CbSet.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbSet.POOL_CNT--;\n                    ZNPNode_ZPP_CbSet.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CbSet\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CbSet.zpp_pool;\n            ZNPNode_ZPP_CbSet.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CbSet.POOL_CNT++;\n            ZNPNode_ZPP_CbSet.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_CbSet{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_CbSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_CbSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_CbSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_CbSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_CbSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_CbSet):ZNPNode_ZPP_CbSet{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_CbSet):ZNPNode_ZPP_CbSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_CbSet;\n        var ret:ZNPNode_ZPP_CbSet;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CbSet\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CbSet.zpp_pool;\n            ZNPNode_ZPP_CbSet.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CbSet.POOL_CNT++;\n            ZNPNode_ZPP_CbSet.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_CbSet,n:Int):ZNPNode_ZPP_CbSet{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_CbSet):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_CbSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_CbSet{\n        return begin().elem();\n    }\n    public function back():ZPP_CbSet{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_CbSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_CbSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSet\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Interactor{\n    public var head:ZNPNode_ZPP_Interactor=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Interactor{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Interactor):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Interactor):ZPP_Interactor{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Interactor):ZPP_Interactor{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Interactor.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Interactor();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Interactor.POOL_TOT++;\n                    ZNPNode_ZPP_Interactor.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Interactor.zpp_pool;\n                    ZNPNode_ZPP_Interactor.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Interactor.POOL_CNT--;\n                    ZNPNode_ZPP_Interactor.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Interactor):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Interactor,o:ZPP_Interactor):ZNPNode_ZPP_Interactor{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Interactor,o:ZPP_Interactor):ZNPNode_ZPP_Interactor{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Interactor.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Interactor();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Interactor.POOL_TOT++;\n                    ZNPNode_ZPP_Interactor.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Interactor.zpp_pool;\n                    ZNPNode_ZPP_Interactor.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Interactor.POOL_CNT--;\n                    ZNPNode_ZPP_Interactor.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Interactor\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Interactor.zpp_pool;\n            ZNPNode_ZPP_Interactor.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Interactor.POOL_CNT++;\n            ZNPNode_ZPP_Interactor.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Interactor{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Interactor{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Interactor):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Interactor):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Interactor):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Interactor):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Interactor):ZNPNode_ZPP_Interactor{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Interactor):ZNPNode_ZPP_Interactor{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Interactor;\n        var ret:ZNPNode_ZPP_Interactor;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Interactor\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Interactor.zpp_pool;\n            ZNPNode_ZPP_Interactor.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Interactor.POOL_CNT++;\n            ZNPNode_ZPP_Interactor.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Interactor,n:Int):ZNPNode_ZPP_Interactor{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Interactor):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Interactor):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Interactor{\n        return begin().elem();\n    }\n    public function back():ZPP_Interactor{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Interactor{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Interactor{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Interactor\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_BodyListener{\n    public var head:ZNPNode_ZPP_BodyListener=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_BodyListener{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_BodyListener):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_BodyListener):ZPP_BodyListener{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_BodyListener):ZPP_BodyListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_BodyListener.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_BodyListener();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_BodyListener.POOL_TOT++;\n                    ZNPNode_ZPP_BodyListener.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_BodyListener.zpp_pool;\n                    ZNPNode_ZPP_BodyListener.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_BodyListener.POOL_CNT--;\n                    ZNPNode_ZPP_BodyListener.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_BodyListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_BodyListener,o:ZPP_BodyListener):ZNPNode_ZPP_BodyListener{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_BodyListener,o:ZPP_BodyListener):ZNPNode_ZPP_BodyListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_BodyListener.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_BodyListener();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_BodyListener.POOL_TOT++;\n                    ZNPNode_ZPP_BodyListener.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_BodyListener.zpp_pool;\n                    ZNPNode_ZPP_BodyListener.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_BodyListener.POOL_CNT--;\n                    ZNPNode_ZPP_BodyListener.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_BodyListener\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_BodyListener.zpp_pool;\n            ZNPNode_ZPP_BodyListener.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_BodyListener.POOL_CNT++;\n            ZNPNode_ZPP_BodyListener.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_BodyListener{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_BodyListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_BodyListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_BodyListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_BodyListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_BodyListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_BodyListener):ZNPNode_ZPP_BodyListener{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_BodyListener):ZNPNode_ZPP_BodyListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_BodyListener;\n        var ret:ZNPNode_ZPP_BodyListener;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_BodyListener\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_BodyListener.zpp_pool;\n            ZNPNode_ZPP_BodyListener.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_BodyListener.POOL_CNT++;\n            ZNPNode_ZPP_BodyListener.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_BodyListener,n:Int):ZNPNode_ZPP_BodyListener{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_BodyListener):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_BodyListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_BodyListener{\n        return begin().elem();\n    }\n    public function back():ZPP_BodyListener{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_BodyListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_BodyListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_BodyListener\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Arbiter{\n    public var head:ZNPNode_ZPP_Arbiter=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Arbiter{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Arbiter):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Arbiter):ZPP_Arbiter{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Arbiter):ZPP_Arbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Arbiter.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Arbiter();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Arbiter.POOL_TOT++;\n                    ZNPNode_ZPP_Arbiter.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Arbiter.zpp_pool;\n                    ZNPNode_ZPP_Arbiter.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Arbiter.POOL_CNT--;\n                    ZNPNode_ZPP_Arbiter.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Arbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Arbiter,o:ZPP_Arbiter):ZNPNode_ZPP_Arbiter{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Arbiter,o:ZPP_Arbiter):ZNPNode_ZPP_Arbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Arbiter.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Arbiter();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Arbiter.POOL_TOT++;\n                    ZNPNode_ZPP_Arbiter.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Arbiter.zpp_pool;\n                    ZNPNode_ZPP_Arbiter.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Arbiter.POOL_CNT--;\n                    ZNPNode_ZPP_Arbiter.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Arbiter\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Arbiter.zpp_pool;\n            ZNPNode_ZPP_Arbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Arbiter.POOL_CNT++;\n            ZNPNode_ZPP_Arbiter.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Arbiter{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Arbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Arbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Arbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Arbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Arbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Arbiter):ZNPNode_ZPP_Arbiter{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Arbiter):ZNPNode_ZPP_Arbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Arbiter;\n        var ret:ZNPNode_ZPP_Arbiter;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Arbiter\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Arbiter.zpp_pool;\n            ZNPNode_ZPP_Arbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Arbiter.POOL_CNT++;\n            ZNPNode_ZPP_Arbiter.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Arbiter,n:Int):ZNPNode_ZPP_Arbiter{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Arbiter):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Arbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Arbiter{\n        return begin().elem();\n    }\n    public function back():ZPP_Arbiter{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Arbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Arbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Arbiter\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_ConstraintListener{\n    public var head:ZNPNode_ZPP_ConstraintListener=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_ConstraintListener{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_ConstraintListener):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_ConstraintListener):ZPP_ConstraintListener{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_ConstraintListener):ZPP_ConstraintListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_ConstraintListener.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_ConstraintListener();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ConstraintListener.POOL_TOT++;\n                    ZNPNode_ZPP_ConstraintListener.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_ConstraintListener.zpp_pool;\n                    ZNPNode_ZPP_ConstraintListener.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ConstraintListener.POOL_CNT--;\n                    ZNPNode_ZPP_ConstraintListener.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_ConstraintListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_ConstraintListener,o:ZPP_ConstraintListener):ZNPNode_ZPP_ConstraintListener{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_ConstraintListener,o:ZPP_ConstraintListener):ZNPNode_ZPP_ConstraintListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_ConstraintListener.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_ConstraintListener();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ConstraintListener.POOL_TOT++;\n                    ZNPNode_ZPP_ConstraintListener.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_ConstraintListener.zpp_pool;\n                    ZNPNode_ZPP_ConstraintListener.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ConstraintListener.POOL_CNT--;\n                    ZNPNode_ZPP_ConstraintListener.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_ConstraintListener\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_ConstraintListener.zpp_pool;\n            ZNPNode_ZPP_ConstraintListener.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_ConstraintListener.POOL_CNT++;\n            ZNPNode_ZPP_ConstraintListener.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_ConstraintListener{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_ConstraintListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_ConstraintListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_ConstraintListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_ConstraintListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_ConstraintListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_ConstraintListener):ZNPNode_ZPP_ConstraintListener{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_ConstraintListener):ZNPNode_ZPP_ConstraintListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_ConstraintListener;\n        var ret:ZNPNode_ZPP_ConstraintListener;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_ConstraintListener\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_ConstraintListener.zpp_pool;\n            ZNPNode_ZPP_ConstraintListener.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_ConstraintListener.POOL_CNT++;\n            ZNPNode_ZPP_ConstraintListener.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_ConstraintListener,n:Int):ZNPNode_ZPP_ConstraintListener{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_ConstraintListener):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_ConstraintListener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_ConstraintListener{\n        return begin().elem();\n    }\n    public function back():ZPP_ConstraintListener{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_ConstraintListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_ConstraintListener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ConstraintListener\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_CbSetPair{\n    public var head:ZNPNode_ZPP_CbSetPair=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_CbSetPair{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_CbSetPair):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_CbSetPair):ZPP_CbSetPair{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_CbSetPair):ZPP_CbSetPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CbSetPair.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CbSetPair();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbSetPair.POOL_TOT++;\n                    ZNPNode_ZPP_CbSetPair.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CbSetPair.zpp_pool;\n                    ZNPNode_ZPP_CbSetPair.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbSetPair.POOL_CNT--;\n                    ZNPNode_ZPP_CbSetPair.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_CbSetPair):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_CbSetPair,o:ZPP_CbSetPair):ZNPNode_ZPP_CbSetPair{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_CbSetPair,o:ZPP_CbSetPair):ZNPNode_ZPP_CbSetPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CbSetPair.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CbSetPair();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbSetPair.POOL_TOT++;\n                    ZNPNode_ZPP_CbSetPair.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CbSetPair.zpp_pool;\n                    ZNPNode_ZPP_CbSetPair.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CbSetPair.POOL_CNT--;\n                    ZNPNode_ZPP_CbSetPair.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CbSetPair\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CbSetPair.zpp_pool;\n            ZNPNode_ZPP_CbSetPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CbSetPair.POOL_CNT++;\n            ZNPNode_ZPP_CbSetPair.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_CbSetPair{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_CbSetPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_CbSetPair):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_CbSetPair):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_CbSetPair):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_CbSetPair):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_CbSetPair):ZNPNode_ZPP_CbSetPair{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_CbSetPair):ZNPNode_ZPP_CbSetPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_CbSetPair;\n        var ret:ZNPNode_ZPP_CbSetPair;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CbSetPair\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CbSetPair.zpp_pool;\n            ZNPNode_ZPP_CbSetPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CbSetPair.POOL_CNT++;\n            ZNPNode_ZPP_CbSetPair.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_CbSetPair,n:Int):ZNPNode_ZPP_CbSetPair{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_CbSetPair):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_CbSetPair):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_CbSetPair{\n        return begin().elem();\n    }\n    public function back():ZPP_CbSetPair{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_CbSetPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_CbSetPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CbSetPair\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_CutInt{\n    public var head:ZNPNode_ZPP_CutInt=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_CutInt{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_CutInt):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_CutInt):ZPP_CutInt{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_CutInt):ZPP_CutInt{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CutInt.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CutInt();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CutInt.POOL_TOT++;\n                    ZNPNode_ZPP_CutInt.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CutInt.zpp_pool;\n                    ZNPNode_ZPP_CutInt.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CutInt.POOL_CNT--;\n                    ZNPNode_ZPP_CutInt.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_CutInt):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_CutInt,o:ZPP_CutInt):ZNPNode_ZPP_CutInt{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_CutInt,o:ZPP_CutInt):ZNPNode_ZPP_CutInt{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CutInt.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CutInt();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CutInt.POOL_TOT++;\n                    ZNPNode_ZPP_CutInt.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CutInt.zpp_pool;\n                    ZNPNode_ZPP_CutInt.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CutInt.POOL_CNT--;\n                    ZNPNode_ZPP_CutInt.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CutInt\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CutInt.zpp_pool;\n            ZNPNode_ZPP_CutInt.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CutInt.POOL_CNT++;\n            ZNPNode_ZPP_CutInt.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_CutInt{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_CutInt{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_CutInt):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_CutInt):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_CutInt):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_CutInt):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_CutInt):ZNPNode_ZPP_CutInt{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_CutInt):ZNPNode_ZPP_CutInt{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_CutInt;\n        var ret:ZNPNode_ZPP_CutInt;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CutInt\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CutInt.zpp_pool;\n            ZNPNode_ZPP_CutInt.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CutInt.POOL_CNT++;\n            ZNPNode_ZPP_CutInt.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_CutInt,n:Int):ZNPNode_ZPP_CutInt{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_CutInt):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_CutInt):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_CutInt{\n        return begin().elem();\n    }\n    public function back():ZPP_CutInt{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_CutInt{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_CutInt{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutInt\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_CutVert{\n    public var head:ZNPNode_ZPP_CutVert=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_CutVert{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_CutVert):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_CutVert):ZPP_CutVert{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_CutVert):ZPP_CutVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CutVert.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CutVert();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CutVert.POOL_TOT++;\n                    ZNPNode_ZPP_CutVert.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CutVert.zpp_pool;\n                    ZNPNode_ZPP_CutVert.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CutVert.POOL_CNT--;\n                    ZNPNode_ZPP_CutVert.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_CutVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_CutVert,o:ZPP_CutVert):ZNPNode_ZPP_CutVert{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_CutVert,o:ZPP_CutVert):ZNPNode_ZPP_CutVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_CutVert.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_CutVert();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CutVert.POOL_TOT++;\n                    ZNPNode_ZPP_CutVert.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_CutVert.zpp_pool;\n                    ZNPNode_ZPP_CutVert.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_CutVert.POOL_CNT--;\n                    ZNPNode_ZPP_CutVert.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CutVert\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CutVert.zpp_pool;\n            ZNPNode_ZPP_CutVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CutVert.POOL_CNT++;\n            ZNPNode_ZPP_CutVert.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_CutVert{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_CutVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_CutVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_CutVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_CutVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_CutVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_CutVert):ZNPNode_ZPP_CutVert{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_CutVert):ZNPNode_ZPP_CutVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_CutVert;\n        var ret:ZNPNode_ZPP_CutVert;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_CutVert\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_CutVert.zpp_pool;\n            ZNPNode_ZPP_CutVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_CutVert.POOL_CNT++;\n            ZNPNode_ZPP_CutVert.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_CutVert,n:Int):ZNPNode_ZPP_CutVert{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_CutVert):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_CutVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_CutVert{\n        return begin().elem();\n    }\n    public function back():ZPP_CutVert{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_CutVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_CutVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CutVert\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_PartitionVertex{\n    public var head:ZNPNode_ZPP_PartitionVertex=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_PartitionVertex{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_PartitionVertex):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_PartitionVertex):ZPP_PartitionVertex{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_PartitionVertex):ZPP_PartitionVertex{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_PartitionVertex.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_PartitionVertex();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionVertex.POOL_TOT++;\n                    ZNPNode_ZPP_PartitionVertex.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_PartitionVertex.zpp_pool;\n                    ZNPNode_ZPP_PartitionVertex.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionVertex.POOL_CNT--;\n                    ZNPNode_ZPP_PartitionVertex.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_PartitionVertex):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_PartitionVertex,o:ZPP_PartitionVertex):ZNPNode_ZPP_PartitionVertex{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_PartitionVertex,o:ZPP_PartitionVertex):ZNPNode_ZPP_PartitionVertex{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_PartitionVertex.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_PartitionVertex();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionVertex.POOL_TOT++;\n                    ZNPNode_ZPP_PartitionVertex.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_PartitionVertex.zpp_pool;\n                    ZNPNode_ZPP_PartitionVertex.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionVertex.POOL_CNT--;\n                    ZNPNode_ZPP_PartitionVertex.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_PartitionVertex\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_PartitionVertex.zpp_pool;\n            ZNPNode_ZPP_PartitionVertex.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionVertex.POOL_CNT++;\n            ZNPNode_ZPP_PartitionVertex.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_PartitionVertex{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_PartitionVertex{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_PartitionVertex):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_PartitionVertex):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_PartitionVertex):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_PartitionVertex):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_PartitionVertex):ZNPNode_ZPP_PartitionVertex{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_PartitionVertex):ZNPNode_ZPP_PartitionVertex{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_PartitionVertex;\n        var ret:ZNPNode_ZPP_PartitionVertex;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_PartitionVertex\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_PartitionVertex.zpp_pool;\n            ZNPNode_ZPP_PartitionVertex.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionVertex.POOL_CNT++;\n            ZNPNode_ZPP_PartitionVertex.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_PartitionVertex,n:Int):ZNPNode_ZPP_PartitionVertex{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_PartitionVertex):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_PartitionVertex):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_PartitionVertex{\n        return begin().elem();\n    }\n    public function back():ZPP_PartitionVertex{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_PartitionVertex{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_PartitionVertex{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionVertex\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_PartitionedPoly{\n    public var head:ZNPNode_ZPP_PartitionedPoly=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_PartitionedPoly{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_PartitionedPoly):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_PartitionedPoly):ZPP_PartitionedPoly{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_PartitionedPoly):ZPP_PartitionedPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_PartitionedPoly.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_PartitionedPoly();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionedPoly.POOL_TOT++;\n                    ZNPNode_ZPP_PartitionedPoly.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_PartitionedPoly.zpp_pool;\n                    ZNPNode_ZPP_PartitionedPoly.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionedPoly.POOL_CNT--;\n                    ZNPNode_ZPP_PartitionedPoly.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_PartitionedPoly):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_PartitionedPoly,o:ZPP_PartitionedPoly):ZNPNode_ZPP_PartitionedPoly{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_PartitionedPoly,o:ZPP_PartitionedPoly):ZNPNode_ZPP_PartitionedPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_PartitionedPoly.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_PartitionedPoly();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionedPoly.POOL_TOT++;\n                    ZNPNode_ZPP_PartitionedPoly.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_PartitionedPoly.zpp_pool;\n                    ZNPNode_ZPP_PartitionedPoly.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionedPoly.POOL_CNT--;\n                    ZNPNode_ZPP_PartitionedPoly.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_PartitionedPoly\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_PartitionedPoly.zpp_pool;\n            ZNPNode_ZPP_PartitionedPoly.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionedPoly.POOL_CNT++;\n            ZNPNode_ZPP_PartitionedPoly.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_PartitionedPoly{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_PartitionedPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_PartitionedPoly):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_PartitionedPoly):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_PartitionedPoly):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_PartitionedPoly):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_PartitionedPoly):ZNPNode_ZPP_PartitionedPoly{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_PartitionedPoly):ZNPNode_ZPP_PartitionedPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_PartitionedPoly;\n        var ret:ZNPNode_ZPP_PartitionedPoly;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_PartitionedPoly\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_PartitionedPoly.zpp_pool;\n            ZNPNode_ZPP_PartitionedPoly.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_PartitionedPoly.POOL_CNT++;\n            ZNPNode_ZPP_PartitionedPoly.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_PartitionedPoly,n:Int):ZNPNode_ZPP_PartitionedPoly{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_PartitionedPoly):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_PartitionedPoly):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_PartitionedPoly{\n        return begin().elem();\n    }\n    public function back():ZPP_PartitionedPoly{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_PartitionedPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_PartitionedPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_PartitionedPoly\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_GeomVert{\n    public var head:ZNPNode_ZPP_GeomVert=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_GeomVert{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_GeomVert):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_GeomVert):ZPP_GeomVert{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_GeomVert):ZPP_GeomVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_GeomVert.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_GeomVert();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_GeomVert.POOL_TOT++;\n                    ZNPNode_ZPP_GeomVert.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_GeomVert.zpp_pool;\n                    ZNPNode_ZPP_GeomVert.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_GeomVert.POOL_CNT--;\n                    ZNPNode_ZPP_GeomVert.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_GeomVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_GeomVert,o:ZPP_GeomVert):ZNPNode_ZPP_GeomVert{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_GeomVert,o:ZPP_GeomVert):ZNPNode_ZPP_GeomVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_GeomVert.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_GeomVert();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_GeomVert.POOL_TOT++;\n                    ZNPNode_ZPP_GeomVert.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_GeomVert.zpp_pool;\n                    ZNPNode_ZPP_GeomVert.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_GeomVert.POOL_CNT--;\n                    ZNPNode_ZPP_GeomVert.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_GeomVert\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_GeomVert.zpp_pool;\n            ZNPNode_ZPP_GeomVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_GeomVert.POOL_CNT++;\n            ZNPNode_ZPP_GeomVert.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_GeomVert{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_GeomVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_GeomVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_GeomVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_GeomVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_GeomVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_GeomVert):ZNPNode_ZPP_GeomVert{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_GeomVert):ZNPNode_ZPP_GeomVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_GeomVert;\n        var ret:ZNPNode_ZPP_GeomVert;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_GeomVert\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_GeomVert.zpp_pool;\n            ZNPNode_ZPP_GeomVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_GeomVert.POOL_CNT++;\n            ZNPNode_ZPP_GeomVert.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_GeomVert,n:Int):ZNPNode_ZPP_GeomVert{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_GeomVert):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_GeomVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_GeomVert{\n        return begin().elem();\n    }\n    public function back():ZPP_GeomVert{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_GeomVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_GeomVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomVert\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_SimplifyP{\n    public var head:ZNPNode_ZPP_SimplifyP=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_SimplifyP{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_SimplifyP):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_SimplifyP):ZPP_SimplifyP{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_SimplifyP):ZPP_SimplifyP{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_SimplifyP.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_SimplifyP();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimplifyP.POOL_TOT++;\n                    ZNPNode_ZPP_SimplifyP.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_SimplifyP.zpp_pool;\n                    ZNPNode_ZPP_SimplifyP.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimplifyP.POOL_CNT--;\n                    ZNPNode_ZPP_SimplifyP.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_SimplifyP):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_SimplifyP,o:ZPP_SimplifyP):ZNPNode_ZPP_SimplifyP{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_SimplifyP,o:ZPP_SimplifyP):ZNPNode_ZPP_SimplifyP{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_SimplifyP.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_SimplifyP();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimplifyP.POOL_TOT++;\n                    ZNPNode_ZPP_SimplifyP.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_SimplifyP.zpp_pool;\n                    ZNPNode_ZPP_SimplifyP.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimplifyP.POOL_CNT--;\n                    ZNPNode_ZPP_SimplifyP.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_SimplifyP\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_SimplifyP.zpp_pool;\n            ZNPNode_ZPP_SimplifyP.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_SimplifyP.POOL_CNT++;\n            ZNPNode_ZPP_SimplifyP.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_SimplifyP{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_SimplifyP{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_SimplifyP):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_SimplifyP):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_SimplifyP):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_SimplifyP):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_SimplifyP):ZNPNode_ZPP_SimplifyP{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_SimplifyP):ZNPNode_ZPP_SimplifyP{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_SimplifyP;\n        var ret:ZNPNode_ZPP_SimplifyP;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_SimplifyP\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_SimplifyP.zpp_pool;\n            ZNPNode_ZPP_SimplifyP.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_SimplifyP.POOL_CNT++;\n            ZNPNode_ZPP_SimplifyP.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_SimplifyP,n:Int):ZNPNode_ZPP_SimplifyP{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_SimplifyP):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_SimplifyP):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_SimplifyP{\n        return begin().elem();\n    }\n    public function back():ZPP_SimplifyP{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_SimplifyP{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_SimplifyP{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimplifyP\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_SimpleVert{\n    public var head:ZNPNode_ZPP_SimpleVert=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_SimpleVert{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_SimpleVert):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_SimpleVert):ZPP_SimpleVert{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_SimpleVert):ZPP_SimpleVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_SimpleVert.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_SimpleVert();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleVert.POOL_TOT++;\n                    ZNPNode_ZPP_SimpleVert.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_SimpleVert.zpp_pool;\n                    ZNPNode_ZPP_SimpleVert.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleVert.POOL_CNT--;\n                    ZNPNode_ZPP_SimpleVert.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_SimpleVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_SimpleVert,o:ZPP_SimpleVert):ZNPNode_ZPP_SimpleVert{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_SimpleVert,o:ZPP_SimpleVert):ZNPNode_ZPP_SimpleVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_SimpleVert.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_SimpleVert();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleVert.POOL_TOT++;\n                    ZNPNode_ZPP_SimpleVert.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_SimpleVert.zpp_pool;\n                    ZNPNode_ZPP_SimpleVert.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleVert.POOL_CNT--;\n                    ZNPNode_ZPP_SimpleVert.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_SimpleVert\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_SimpleVert.zpp_pool;\n            ZNPNode_ZPP_SimpleVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleVert.POOL_CNT++;\n            ZNPNode_ZPP_SimpleVert.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_SimpleVert{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_SimpleVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_SimpleVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_SimpleVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_SimpleVert):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_SimpleVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_SimpleVert):ZNPNode_ZPP_SimpleVert{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_SimpleVert):ZNPNode_ZPP_SimpleVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_SimpleVert;\n        var ret:ZNPNode_ZPP_SimpleVert;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_SimpleVert\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_SimpleVert.zpp_pool;\n            ZNPNode_ZPP_SimpleVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleVert.POOL_CNT++;\n            ZNPNode_ZPP_SimpleVert.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_SimpleVert,n:Int):ZNPNode_ZPP_SimpleVert{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_SimpleVert):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_SimpleVert):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_SimpleVert{\n        return begin().elem();\n    }\n    public function back():ZPP_SimpleVert{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_SimpleVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_SimpleVert{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleVert\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_SimpleEvent{\n    public var head:ZNPNode_ZPP_SimpleEvent=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_SimpleEvent{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_SimpleEvent):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_SimpleEvent):ZPP_SimpleEvent{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_SimpleEvent):ZPP_SimpleEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_SimpleEvent.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_SimpleEvent();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleEvent.POOL_TOT++;\n                    ZNPNode_ZPP_SimpleEvent.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_SimpleEvent.zpp_pool;\n                    ZNPNode_ZPP_SimpleEvent.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleEvent.POOL_CNT--;\n                    ZNPNode_ZPP_SimpleEvent.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_SimpleEvent):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_SimpleEvent,o:ZPP_SimpleEvent):ZNPNode_ZPP_SimpleEvent{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_SimpleEvent,o:ZPP_SimpleEvent):ZNPNode_ZPP_SimpleEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_SimpleEvent.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_SimpleEvent();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleEvent.POOL_TOT++;\n                    ZNPNode_ZPP_SimpleEvent.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_SimpleEvent.zpp_pool;\n                    ZNPNode_ZPP_SimpleEvent.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleEvent.POOL_CNT--;\n                    ZNPNode_ZPP_SimpleEvent.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_SimpleEvent\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_SimpleEvent.zpp_pool;\n            ZNPNode_ZPP_SimpleEvent.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleEvent.POOL_CNT++;\n            ZNPNode_ZPP_SimpleEvent.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_SimpleEvent{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_SimpleEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_SimpleEvent):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_SimpleEvent):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_SimpleEvent):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_SimpleEvent):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_SimpleEvent):ZNPNode_ZPP_SimpleEvent{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_SimpleEvent):ZNPNode_ZPP_SimpleEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_SimpleEvent;\n        var ret:ZNPNode_ZPP_SimpleEvent;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_SimpleEvent\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_SimpleEvent.zpp_pool;\n            ZNPNode_ZPP_SimpleEvent.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_SimpleEvent.POOL_CNT++;\n            ZNPNode_ZPP_SimpleEvent.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_SimpleEvent,n:Int):ZNPNode_ZPP_SimpleEvent{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_SimpleEvent):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_SimpleEvent):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_SimpleEvent{\n        return begin().elem();\n    }\n    public function back():ZPP_SimpleEvent{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_SimpleEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_SimpleEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SimpleEvent\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_AABBPair{\n    public var head:ZNPNode_ZPP_AABBPair=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_AABBPair{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_AABBPair):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_AABBPair):ZPP_AABBPair{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_AABBPair):ZPP_AABBPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_AABBPair.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_AABBPair();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_AABBPair.POOL_TOT++;\n                    ZNPNode_ZPP_AABBPair.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_AABBPair.zpp_pool;\n                    ZNPNode_ZPP_AABBPair.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_AABBPair.POOL_CNT--;\n                    ZNPNode_ZPP_AABBPair.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_AABBPair):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_AABBPair,o:ZPP_AABBPair):ZNPNode_ZPP_AABBPair{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_AABBPair,o:ZPP_AABBPair):ZNPNode_ZPP_AABBPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_AABBPair.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_AABBPair();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_AABBPair.POOL_TOT++;\n                    ZNPNode_ZPP_AABBPair.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_AABBPair.zpp_pool;\n                    ZNPNode_ZPP_AABBPair.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_AABBPair.POOL_CNT--;\n                    ZNPNode_ZPP_AABBPair.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_AABBPair\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_AABBPair.zpp_pool;\n            ZNPNode_ZPP_AABBPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_AABBPair.POOL_CNT++;\n            ZNPNode_ZPP_AABBPair.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_AABBPair{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_AABBPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_AABBPair):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_AABBPair):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_AABBPair):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_AABBPair):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_AABBPair):ZNPNode_ZPP_AABBPair{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_AABBPair):ZNPNode_ZPP_AABBPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_AABBPair;\n        var ret:ZNPNode_ZPP_AABBPair;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_AABBPair\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_AABBPair.zpp_pool;\n            ZNPNode_ZPP_AABBPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_AABBPair.POOL_CNT++;\n            ZNPNode_ZPP_AABBPair.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_AABBPair,n:Int):ZNPNode_ZPP_AABBPair{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_AABBPair):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_AABBPair):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_AABBPair{\n        return begin().elem();\n    }\n    public function back():ZPP_AABBPair{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_AABBPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_AABBPair{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBPair\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Edge{\n    public var head:ZNPNode_ZPP_Edge=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Edge{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Edge):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Edge):ZPP_Edge{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Edge):ZPP_Edge{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Edge.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Edge();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Edge.POOL_TOT++;\n                    ZNPNode_ZPP_Edge.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Edge.zpp_pool;\n                    ZNPNode_ZPP_Edge.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Edge.POOL_CNT--;\n                    ZNPNode_ZPP_Edge.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Edge):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Edge,o:ZPP_Edge):ZNPNode_ZPP_Edge{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Edge,o:ZPP_Edge):ZNPNode_ZPP_Edge{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Edge.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Edge();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Edge.POOL_TOT++;\n                    ZNPNode_ZPP_Edge.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Edge.zpp_pool;\n                    ZNPNode_ZPP_Edge.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Edge.POOL_CNT--;\n                    ZNPNode_ZPP_Edge.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Edge\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Edge.zpp_pool;\n            ZNPNode_ZPP_Edge.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Edge.POOL_CNT++;\n            ZNPNode_ZPP_Edge.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Edge{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Edge{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Edge):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Edge):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Edge):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Edge):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Edge):ZNPNode_ZPP_Edge{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Edge):ZNPNode_ZPP_Edge{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Edge;\n        var ret:ZNPNode_ZPP_Edge;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Edge\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Edge.zpp_pool;\n            ZNPNode_ZPP_Edge.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Edge.POOL_CNT++;\n            ZNPNode_ZPP_Edge.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Edge,n:Int):ZNPNode_ZPP_Edge{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Edge):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Edge):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Edge{\n        return begin().elem();\n    }\n    public function back():ZPP_Edge{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Edge{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Edge{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Edge\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Vec2{\n    public var head:ZNPNode_ZPP_Vec2=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Vec2{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Vec2):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Vec2):ZPP_Vec2{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Vec2):ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Vec2.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Vec2();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Vec2.POOL_TOT++;\n                    ZNPNode_ZPP_Vec2.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Vec2.zpp_pool;\n                    ZNPNode_ZPP_Vec2.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Vec2.POOL_CNT--;\n                    ZNPNode_ZPP_Vec2.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Vec2):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Vec2,o:ZPP_Vec2):ZNPNode_ZPP_Vec2{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Vec2,o:ZPP_Vec2):ZNPNode_ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Vec2.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Vec2();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Vec2.POOL_TOT++;\n                    ZNPNode_ZPP_Vec2.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Vec2.zpp_pool;\n                    ZNPNode_ZPP_Vec2.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Vec2.POOL_CNT--;\n                    ZNPNode_ZPP_Vec2.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Vec2\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Vec2.zpp_pool;\n            ZNPNode_ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Vec2.POOL_CNT++;\n            ZNPNode_ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Vec2{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Vec2):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Vec2):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Vec2):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Vec2):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Vec2):ZNPNode_ZPP_Vec2{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Vec2):ZNPNode_ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Vec2;\n        var ret:ZNPNode_ZPP_Vec2;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Vec2\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Vec2.zpp_pool;\n            ZNPNode_ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Vec2.POOL_CNT++;\n            ZNPNode_ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Vec2,n:Int):ZNPNode_ZPP_Vec2{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Vec2):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Vec2):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Vec2{\n        return begin().elem();\n    }\n    public function back():ZPP_Vec2{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Component{\n    public var head:ZNPNode_ZPP_Component=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Component{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Component):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Component):ZPP_Component{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Component):ZPP_Component{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Component.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Component();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Component.POOL_TOT++;\n                    ZNPNode_ZPP_Component.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Component.zpp_pool;\n                    ZNPNode_ZPP_Component.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Component.POOL_CNT--;\n                    ZNPNode_ZPP_Component.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Component):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Component,o:ZPP_Component):ZNPNode_ZPP_Component{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Component,o:ZPP_Component):ZNPNode_ZPP_Component{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Component.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Component();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Component.POOL_TOT++;\n                    ZNPNode_ZPP_Component.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Component.zpp_pool;\n                    ZNPNode_ZPP_Component.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Component.POOL_CNT--;\n                    ZNPNode_ZPP_Component.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Component\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Component.zpp_pool;\n            ZNPNode_ZPP_Component.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Component.POOL_CNT++;\n            ZNPNode_ZPP_Component.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Component{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Component{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Component):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Component):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Component):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Component):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Component):ZNPNode_ZPP_Component{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Component):ZNPNode_ZPP_Component{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Component;\n        var ret:ZNPNode_ZPP_Component;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Component\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Component.zpp_pool;\n            ZNPNode_ZPP_Component.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Component.POOL_CNT++;\n            ZNPNode_ZPP_Component.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Component,n:Int):ZNPNode_ZPP_Component{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Component):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Component):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Component{\n        return begin().elem();\n    }\n    public function back():ZPP_Component{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Component{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Component{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Component\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_AABBNode{\n    public var head:ZNPNode_ZPP_AABBNode=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_AABBNode{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_AABBNode):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_AABBNode):ZPP_AABBNode{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_AABBNode):ZPP_AABBNode{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_AABBNode.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_AABBNode();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_AABBNode.POOL_TOT++;\n                    ZNPNode_ZPP_AABBNode.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_AABBNode.zpp_pool;\n                    ZNPNode_ZPP_AABBNode.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_AABBNode.POOL_CNT--;\n                    ZNPNode_ZPP_AABBNode.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_AABBNode):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_AABBNode,o:ZPP_AABBNode):ZNPNode_ZPP_AABBNode{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_AABBNode,o:ZPP_AABBNode):ZNPNode_ZPP_AABBNode{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_AABBNode.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_AABBNode();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_AABBNode.POOL_TOT++;\n                    ZNPNode_ZPP_AABBNode.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_AABBNode.zpp_pool;\n                    ZNPNode_ZPP_AABBNode.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_AABBNode.POOL_CNT--;\n                    ZNPNode_ZPP_AABBNode.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_AABBNode\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_AABBNode.zpp_pool;\n            ZNPNode_ZPP_AABBNode.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_AABBNode.POOL_CNT++;\n            ZNPNode_ZPP_AABBNode.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_AABBNode{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_AABBNode{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_AABBNode):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_AABBNode):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_AABBNode):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_AABBNode):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_AABBNode):ZNPNode_ZPP_AABBNode{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_AABBNode):ZNPNode_ZPP_AABBNode{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_AABBNode;\n        var ret:ZNPNode_ZPP_AABBNode;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_AABBNode\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_AABBNode.zpp_pool;\n            ZNPNode_ZPP_AABBNode.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_AABBNode.POOL_CNT++;\n            ZNPNode_ZPP_AABBNode.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_AABBNode,n:Int):ZNPNode_ZPP_AABBNode{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_AABBNode):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_AABBNode):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_AABBNode{\n        return begin().elem();\n    }\n    public function back():ZPP_AABBNode{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_AABBNode{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_AABBNode{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_AABBNode\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_InteractionGroup{\n    public var head:ZNPNode_ZPP_InteractionGroup=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_InteractionGroup{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_InteractionGroup):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_InteractionGroup):ZPP_InteractionGroup{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_InteractionGroup):ZPP_InteractionGroup{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_InteractionGroup.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_InteractionGroup();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionGroup.POOL_TOT++;\n                    ZNPNode_ZPP_InteractionGroup.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_InteractionGroup.zpp_pool;\n                    ZNPNode_ZPP_InteractionGroup.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionGroup.POOL_CNT--;\n                    ZNPNode_ZPP_InteractionGroup.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_InteractionGroup):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_InteractionGroup,o:ZPP_InteractionGroup):ZNPNode_ZPP_InteractionGroup{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_InteractionGroup,o:ZPP_InteractionGroup):ZNPNode_ZPP_InteractionGroup{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_InteractionGroup.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_InteractionGroup();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionGroup.POOL_TOT++;\n                    ZNPNode_ZPP_InteractionGroup.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_InteractionGroup.zpp_pool;\n                    ZNPNode_ZPP_InteractionGroup.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionGroup.POOL_CNT--;\n                    ZNPNode_ZPP_InteractionGroup.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_InteractionGroup\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_InteractionGroup.zpp_pool;\n            ZNPNode_ZPP_InteractionGroup.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionGroup.POOL_CNT++;\n            ZNPNode_ZPP_InteractionGroup.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_InteractionGroup{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_InteractionGroup{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_InteractionGroup):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_InteractionGroup):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_InteractionGroup):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_InteractionGroup):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_InteractionGroup):ZNPNode_ZPP_InteractionGroup{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_InteractionGroup):ZNPNode_ZPP_InteractionGroup{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_InteractionGroup;\n        var ret:ZNPNode_ZPP_InteractionGroup;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_InteractionGroup\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_InteractionGroup.zpp_pool;\n            ZNPNode_ZPP_InteractionGroup.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_InteractionGroup.POOL_CNT++;\n            ZNPNode_ZPP_InteractionGroup.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_InteractionGroup,n:Int):ZNPNode_ZPP_InteractionGroup{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_InteractionGroup):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_InteractionGroup):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_InteractionGroup{\n        return begin().elem();\n    }\n    public function back():ZPP_InteractionGroup{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_InteractionGroup{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_InteractionGroup{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_InteractionGroup\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_FluidArbiter{\n    public var head:ZNPNode_ZPP_FluidArbiter=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_FluidArbiter{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_FluidArbiter):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_FluidArbiter):ZPP_FluidArbiter{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_FluidArbiter):ZPP_FluidArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_FluidArbiter.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_FluidArbiter();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_FluidArbiter.POOL_TOT++;\n                    ZNPNode_ZPP_FluidArbiter.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_FluidArbiter.zpp_pool;\n                    ZNPNode_ZPP_FluidArbiter.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_FluidArbiter.POOL_CNT--;\n                    ZNPNode_ZPP_FluidArbiter.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_FluidArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_FluidArbiter,o:ZPP_FluidArbiter):ZNPNode_ZPP_FluidArbiter{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_FluidArbiter,o:ZPP_FluidArbiter):ZNPNode_ZPP_FluidArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_FluidArbiter.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_FluidArbiter();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_FluidArbiter.POOL_TOT++;\n                    ZNPNode_ZPP_FluidArbiter.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_FluidArbiter.zpp_pool;\n                    ZNPNode_ZPP_FluidArbiter.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_FluidArbiter.POOL_CNT--;\n                    ZNPNode_ZPP_FluidArbiter.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_FluidArbiter\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_FluidArbiter.zpp_pool;\n            ZNPNode_ZPP_FluidArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_FluidArbiter.POOL_CNT++;\n            ZNPNode_ZPP_FluidArbiter.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_FluidArbiter{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_FluidArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_FluidArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_FluidArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_FluidArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_FluidArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_FluidArbiter):ZNPNode_ZPP_FluidArbiter{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_FluidArbiter):ZNPNode_ZPP_FluidArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_FluidArbiter;\n        var ret:ZNPNode_ZPP_FluidArbiter;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_FluidArbiter\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_FluidArbiter.zpp_pool;\n            ZNPNode_ZPP_FluidArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_FluidArbiter.POOL_CNT++;\n            ZNPNode_ZPP_FluidArbiter.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_FluidArbiter,n:Int):ZNPNode_ZPP_FluidArbiter{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_FluidArbiter):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_FluidArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_FluidArbiter{\n        return begin().elem();\n    }\n    public function back():ZPP_FluidArbiter{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_FluidArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_FluidArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_FluidArbiter\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_SensorArbiter{\n    public var head:ZNPNode_ZPP_SensorArbiter=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_SensorArbiter{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_SensorArbiter):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_SensorArbiter):ZPP_SensorArbiter{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_SensorArbiter):ZPP_SensorArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_SensorArbiter.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_SensorArbiter();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SensorArbiter.POOL_TOT++;\n                    ZNPNode_ZPP_SensorArbiter.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_SensorArbiter.zpp_pool;\n                    ZNPNode_ZPP_SensorArbiter.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SensorArbiter.POOL_CNT--;\n                    ZNPNode_ZPP_SensorArbiter.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_SensorArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_SensorArbiter,o:ZPP_SensorArbiter):ZNPNode_ZPP_SensorArbiter{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_SensorArbiter,o:ZPP_SensorArbiter):ZNPNode_ZPP_SensorArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_SensorArbiter.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_SensorArbiter();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SensorArbiter.POOL_TOT++;\n                    ZNPNode_ZPP_SensorArbiter.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_SensorArbiter.zpp_pool;\n                    ZNPNode_ZPP_SensorArbiter.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_SensorArbiter.POOL_CNT--;\n                    ZNPNode_ZPP_SensorArbiter.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_SensorArbiter\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_SensorArbiter.zpp_pool;\n            ZNPNode_ZPP_SensorArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_SensorArbiter.POOL_CNT++;\n            ZNPNode_ZPP_SensorArbiter.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_SensorArbiter{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_SensorArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_SensorArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_SensorArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_SensorArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_SensorArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_SensorArbiter):ZNPNode_ZPP_SensorArbiter{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_SensorArbiter):ZNPNode_ZPP_SensorArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_SensorArbiter;\n        var ret:ZNPNode_ZPP_SensorArbiter;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_SensorArbiter\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_SensorArbiter.zpp_pool;\n            ZNPNode_ZPP_SensorArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_SensorArbiter.POOL_CNT++;\n            ZNPNode_ZPP_SensorArbiter.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_SensorArbiter,n:Int):ZNPNode_ZPP_SensorArbiter{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_SensorArbiter):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_SensorArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_SensorArbiter{\n        return begin().elem();\n    }\n    public function back():ZPP_SensorArbiter{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_SensorArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_SensorArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_SensorArbiter\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_ColArbiter{\n    public var head:ZNPNode_ZPP_ColArbiter=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_ColArbiter{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_ColArbiter):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_ColArbiter):ZPP_ColArbiter{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_ColArbiter):ZPP_ColArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_ColArbiter.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_ColArbiter();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ColArbiter.POOL_TOT++;\n                    ZNPNode_ZPP_ColArbiter.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_ColArbiter.zpp_pool;\n                    ZNPNode_ZPP_ColArbiter.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ColArbiter.POOL_CNT--;\n                    ZNPNode_ZPP_ColArbiter.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_ColArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_ColArbiter,o:ZPP_ColArbiter):ZNPNode_ZPP_ColArbiter{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_ColArbiter,o:ZPP_ColArbiter):ZNPNode_ZPP_ColArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_ColArbiter.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_ColArbiter();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ColArbiter.POOL_TOT++;\n                    ZNPNode_ZPP_ColArbiter.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_ColArbiter.zpp_pool;\n                    ZNPNode_ZPP_ColArbiter.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ColArbiter.POOL_CNT--;\n                    ZNPNode_ZPP_ColArbiter.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_ColArbiter\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_ColArbiter.zpp_pool;\n            ZNPNode_ZPP_ColArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_ColArbiter.POOL_CNT++;\n            ZNPNode_ZPP_ColArbiter.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_ColArbiter{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_ColArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_ColArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_ColArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_ColArbiter):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_ColArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_ColArbiter):ZNPNode_ZPP_ColArbiter{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_ColArbiter):ZNPNode_ZPP_ColArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_ColArbiter;\n        var ret:ZNPNode_ZPP_ColArbiter;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_ColArbiter\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_ColArbiter.zpp_pool;\n            ZNPNode_ZPP_ColArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_ColArbiter.POOL_CNT++;\n            ZNPNode_ZPP_ColArbiter.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_ColArbiter,n:Int):ZNPNode_ZPP_ColArbiter{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_ColArbiter):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_ColArbiter):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_ColArbiter{\n        return begin().elem();\n    }\n    public function back():ZPP_ColArbiter{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_ColArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_ColArbiter{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ColArbiter\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_Listener{\n    public var head:ZNPNode_ZPP_Listener=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_Listener{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_Listener):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Listener):ZPP_Listener{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Listener):ZPP_Listener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Listener.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Listener();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Listener.POOL_TOT++;\n                    ZNPNode_ZPP_Listener.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Listener.zpp_pool;\n                    ZNPNode_ZPP_Listener.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Listener.POOL_CNT--;\n                    ZNPNode_ZPP_Listener.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_Listener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_Listener,o:ZPP_Listener):ZNPNode_ZPP_Listener{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_Listener,o:ZPP_Listener):ZNPNode_ZPP_Listener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_Listener.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_Listener();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Listener.POOL_TOT++;\n                    ZNPNode_ZPP_Listener.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_Listener.zpp_pool;\n                    ZNPNode_ZPP_Listener.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_Listener.POOL_CNT--;\n                    ZNPNode_ZPP_Listener.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Listener\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Listener.zpp_pool;\n            ZNPNode_ZPP_Listener.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Listener.POOL_CNT++;\n            ZNPNode_ZPP_Listener.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Listener{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Listener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Listener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Listener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Listener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Listener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_Listener):ZNPNode_ZPP_Listener{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_Listener):ZNPNode_ZPP_Listener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_Listener;\n        var ret:ZNPNode_ZPP_Listener;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_Listener\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_Listener.zpp_pool;\n            ZNPNode_ZPP_Listener.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_Listener.POOL_CNT++;\n            ZNPNode_ZPP_Listener.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_Listener,n:Int):ZNPNode_ZPP_Listener{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Listener):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Listener):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Listener{\n        return begin().elem();\n    }\n    public function back():ZPP_Listener{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_Listener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Listener{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Listener\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_ToiEvent{\n    public var head:ZNPNode_ZPP_ToiEvent=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_ToiEvent{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_ToiEvent):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_ToiEvent):ZPP_ToiEvent{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_ToiEvent):ZPP_ToiEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_ToiEvent.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_ToiEvent();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ToiEvent.POOL_TOT++;\n                    ZNPNode_ZPP_ToiEvent.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_ToiEvent.zpp_pool;\n                    ZNPNode_ZPP_ToiEvent.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ToiEvent.POOL_CNT--;\n                    ZNPNode_ZPP_ToiEvent.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_ToiEvent):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_ToiEvent,o:ZPP_ToiEvent):ZNPNode_ZPP_ToiEvent{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_ToiEvent,o:ZPP_ToiEvent):ZNPNode_ZPP_ToiEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_ToiEvent.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_ToiEvent();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ToiEvent.POOL_TOT++;\n                    ZNPNode_ZPP_ToiEvent.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_ToiEvent.zpp_pool;\n                    ZNPNode_ZPP_ToiEvent.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_ToiEvent.POOL_CNT--;\n                    ZNPNode_ZPP_ToiEvent.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_ToiEvent\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_ToiEvent.zpp_pool;\n            ZNPNode_ZPP_ToiEvent.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_ToiEvent.POOL_CNT++;\n            ZNPNode_ZPP_ToiEvent.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_ToiEvent{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_ToiEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_ToiEvent):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_ToiEvent):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_ToiEvent):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_ToiEvent):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_ToiEvent):ZNPNode_ZPP_ToiEvent{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_ToiEvent):ZNPNode_ZPP_ToiEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_ToiEvent;\n        var ret:ZNPNode_ZPP_ToiEvent;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_ToiEvent\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_ToiEvent.zpp_pool;\n            ZNPNode_ZPP_ToiEvent.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_ToiEvent.POOL_CNT++;\n            ZNPNode_ZPP_ToiEvent.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_ToiEvent,n:Int):ZNPNode_ZPP_ToiEvent{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_ToiEvent):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_ToiEvent):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_ToiEvent{\n        return begin().elem();\n    }\n    public function back():ZPP_ToiEvent{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_ToiEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_ToiEvent{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_ToiEvent\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ConvexResult{\n    public var head:ZNPNode_ConvexResult=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ConvexResult{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ConvexResult):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ConvexResult):ConvexResult{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ConvexResult):ConvexResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ConvexResult.zpp_pool==null){\n                    ret=new ZNPNode_ConvexResult();\n                    #if NAPE_POOL_STATS ZNPNode_ConvexResult.POOL_TOT++;\n                    ZNPNode_ConvexResult.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ConvexResult.zpp_pool;\n                    ZNPNode_ConvexResult.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ConvexResult.POOL_CNT--;\n                    ZNPNode_ConvexResult.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ConvexResult):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ConvexResult,o:ConvexResult):ZNPNode_ConvexResult{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ConvexResult,o:ConvexResult):ZNPNode_ConvexResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ConvexResult.zpp_pool==null){\n                    ret=new ZNPNode_ConvexResult();\n                    #if NAPE_POOL_STATS ZNPNode_ConvexResult.POOL_TOT++;\n                    ZNPNode_ConvexResult.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ConvexResult.zpp_pool;\n                    ZNPNode_ConvexResult.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ConvexResult.POOL_CNT--;\n                    ZNPNode_ConvexResult.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ConvexResult\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ConvexResult.zpp_pool;\n            ZNPNode_ConvexResult.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ConvexResult.POOL_CNT++;\n            ZNPNode_ConvexResult.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ConvexResult{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ConvexResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ConvexResult):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ConvexResult):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ConvexResult):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ConvexResult):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ConvexResult):ZNPNode_ConvexResult{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ConvexResult):ZNPNode_ConvexResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ConvexResult;\n        var ret:ZNPNode_ConvexResult;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ConvexResult\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ConvexResult.zpp_pool;\n            ZNPNode_ConvexResult.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ConvexResult.POOL_CNT++;\n            ZNPNode_ConvexResult.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ConvexResult,n:Int):ZNPNode_ConvexResult{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ConvexResult):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ConvexResult):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ConvexResult{\n        return begin().elem();\n    }\n    public function back():ConvexResult{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ConvexResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ConvexResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ConvexResult\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_ZPP_GeomPoly{\n    public var head:ZNPNode_ZPP_GeomPoly=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_ZPP_GeomPoly{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_ZPP_GeomPoly):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_GeomPoly):ZPP_GeomPoly{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_GeomPoly):ZPP_GeomPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_GeomPoly.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_GeomPoly();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_GeomPoly.POOL_TOT++;\n                    ZNPNode_ZPP_GeomPoly.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_GeomPoly.zpp_pool;\n                    ZNPNode_ZPP_GeomPoly.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_GeomPoly.POOL_CNT--;\n                    ZNPNode_ZPP_GeomPoly.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_ZPP_GeomPoly):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_ZPP_GeomPoly,o:ZPP_GeomPoly):ZNPNode_ZPP_GeomPoly{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_ZPP_GeomPoly,o:ZPP_GeomPoly):ZNPNode_ZPP_GeomPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_ZPP_GeomPoly.zpp_pool==null){\n                    ret=new ZNPNode_ZPP_GeomPoly();\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_GeomPoly.POOL_TOT++;\n                    ZNPNode_ZPP_GeomPoly.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_ZPP_GeomPoly.zpp_pool;\n                    ZNPNode_ZPP_GeomPoly.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_ZPP_GeomPoly.POOL_CNT--;\n                    ZNPNode_ZPP_GeomPoly.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_GeomPoly\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_GeomPoly.zpp_pool;\n            ZNPNode_ZPP_GeomPoly.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_GeomPoly.POOL_CNT++;\n            ZNPNode_ZPP_GeomPoly.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_GeomPoly{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_GeomPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_GeomPoly):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_GeomPoly):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_GeomPoly):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_GeomPoly):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_ZPP_GeomPoly):ZNPNode_ZPP_GeomPoly{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_ZPP_GeomPoly):ZNPNode_ZPP_GeomPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_ZPP_GeomPoly;\n        var ret:ZNPNode_ZPP_GeomPoly;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_ZPP_GeomPoly\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_ZPP_GeomPoly.zpp_pool;\n            ZNPNode_ZPP_GeomPoly.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_ZPP_GeomPoly.POOL_CNT++;\n            ZNPNode_ZPP_GeomPoly.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_ZPP_GeomPoly,n:Int):ZNPNode_ZPP_GeomPoly{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_GeomPoly):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_GeomPoly):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_GeomPoly{\n        return begin().elem();\n    }\n    public function back():ZPP_GeomPoly{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_ZPP_GeomPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_GeomPoly{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_GeomPoly\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPList_RayResult{\n    public var head:ZNPNode_RayResult=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZNPNode_RayResult{\n        return head;\n    }\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZNPNode_RayResult):Void{\n        head=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:RayResult):RayResult{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:RayResult):RayResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_RayResult.zpp_pool==null){\n                    ret=new ZNPNode_RayResult();\n                    #if NAPE_POOL_STATS ZNPNode_RayResult.POOL_TOT++;\n                    ZNPNode_RayResult.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_RayResult.zpp_pool;\n                    ZNPNode_RayResult.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_RayResult.POOL_CNT--;\n                    ZNPNode_RayResult.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        temp.next=begin();\n        head=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZNPList_RayResult):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZNPNode_RayResult,o:RayResult):ZNPNode_RayResult{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZNPNode_RayResult,o:RayResult):ZNPNode_RayResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            var ret;\n            {\n                if(ZNPNode_RayResult.zpp_pool==null){\n                    ret=new ZNPNode_RayResult();\n                    #if NAPE_POOL_STATS ZNPNode_RayResult.POOL_TOT++;\n                    ZNPNode_RayResult.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    ret=ZNPNode_RayResult.zpp_pool;\n                    ZNPNode_RayResult.zpp_pool=ret.next;\n                    ret.next=null;\n                    #if NAPE_POOL_STATS ZNPNode_RayResult.POOL_CNT--;\n                    ZNPNode_RayResult.POOL_ADD++;\n                    #end\n                }\n                ret.alloc();\n            };\n            ret.elt=o;\n            ret;\n        };\n        if(cur==null){\n            temp.next=begin();\n            head=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        head=ret.next;\n        {};\n        {\n            var o=ret;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_RayResult\"+\", in obj: \"+\"ret\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_RayResult.zpp_pool;\n            ZNPNode_RayResult.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_RayResult.POOL_CNT++;\n            ZNPNode_RayResult.POOL_SUB++;\n            #end\n        };\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():RayResult{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():RayResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:RayResult):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:RayResult):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:RayResult):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:RayResult):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZNPNode_RayResult):ZNPNode_RayResult{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZNPNode_RayResult):ZNPNode_RayResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZNPNode_RayResult;\n        var ret:ZNPNode_RayResult;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            head=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {};\n        {\n            var o=old;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZNPNode_RayResult\"+\", in obj: \"+\"old\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZNPNode_RayResult.zpp_pool;\n            ZNPNode_RayResult.zpp_pool=o;\n            #if NAPE_POOL_STATS ZNPNode_RayResult.POOL_CNT++;\n            ZNPNode_RayResult.POOL_SUB++;\n            #end\n        };\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZNPNode_RayResult,n:Int):ZNPNode_RayResult{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(true){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            head=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:RayResult):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:RayResult):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():RayResult{\n        return begin().elem();\n    }\n    public function back():RayResult{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZNPNode_RayResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):RayResult{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"RayResult\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_CbType{\n    static public var zpp_pool:ZNPNode_ZPP_CbType=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_CbType=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_CbType=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_CbType{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_CallbackSet{\n    static public var zpp_pool:ZNPNode_ZPP_CallbackSet=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_CallbackSet=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_CallbackSet=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_CallbackSet{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Shape{\n    static public var zpp_pool:ZNPNode_ZPP_Shape=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Shape=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Shape=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Shape{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Body{\n    static public var zpp_pool:ZNPNode_ZPP_Body=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Body=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Body=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Body{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Constraint{\n    static public var zpp_pool:ZNPNode_ZPP_Constraint=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Constraint=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Constraint=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Constraint{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Compound{\n    static public var zpp_pool:ZNPNode_ZPP_Compound=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Compound=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Compound=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Compound{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_InteractionListener{\n    static public var zpp_pool:ZNPNode_ZPP_InteractionListener=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_InteractionListener=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_InteractionListener=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_InteractionListener{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_CbSet{\n    static public var zpp_pool:ZNPNode_ZPP_CbSet=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_CbSet=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_CbSet=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_CbSet{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Interactor{\n    static public var zpp_pool:ZNPNode_ZPP_Interactor=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Interactor=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Interactor=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Interactor{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_BodyListener{\n    static public var zpp_pool:ZNPNode_ZPP_BodyListener=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_BodyListener=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_BodyListener=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_BodyListener{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Arbiter{\n    static public var zpp_pool:ZNPNode_ZPP_Arbiter=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Arbiter=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Arbiter=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Arbiter{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_ConstraintListener{\n    static public var zpp_pool:ZNPNode_ZPP_ConstraintListener=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_ConstraintListener=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_ConstraintListener=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_ConstraintListener{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_CbSetPair{\n    static public var zpp_pool:ZNPNode_ZPP_CbSetPair=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_CbSetPair=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_CbSetPair=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_CbSetPair{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_CutInt{\n    static public var zpp_pool:ZNPNode_ZPP_CutInt=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_CutInt=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_CutInt=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_CutInt{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_CutVert{\n    static public var zpp_pool:ZNPNode_ZPP_CutVert=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_CutVert=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_CutVert=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_CutVert{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_PartitionVertex{\n    static public var zpp_pool:ZNPNode_ZPP_PartitionVertex=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_PartitionVertex=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_PartitionVertex=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_PartitionVertex{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_PartitionedPoly{\n    static public var zpp_pool:ZNPNode_ZPP_PartitionedPoly=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_PartitionedPoly=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_PartitionedPoly=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_PartitionedPoly{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_GeomVert{\n    static public var zpp_pool:ZNPNode_ZPP_GeomVert=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_GeomVert=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_GeomVert=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_GeomVert{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_SimplifyP{\n    static public var zpp_pool:ZNPNode_ZPP_SimplifyP=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_SimplifyP=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_SimplifyP=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_SimplifyP{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_SimpleVert{\n    static public var zpp_pool:ZNPNode_ZPP_SimpleVert=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_SimpleVert=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_SimpleVert=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_SimpleVert{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_SimpleEvent{\n    static public var zpp_pool:ZNPNode_ZPP_SimpleEvent=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_SimpleEvent=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_SimpleEvent=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_SimpleEvent{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_AABBPair{\n    static public var zpp_pool:ZNPNode_ZPP_AABBPair=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_AABBPair=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_AABBPair=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_AABBPair{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Edge{\n    static public var zpp_pool:ZNPNode_ZPP_Edge=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Edge=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Edge=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Edge{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Vec2{\n    static public var zpp_pool:ZNPNode_ZPP_Vec2=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Vec2=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Vec2=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Vec2{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Component{\n    static public var zpp_pool:ZNPNode_ZPP_Component=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Component=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Component=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Component{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_AABBNode{\n    static public var zpp_pool:ZNPNode_ZPP_AABBNode=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_AABBNode=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_AABBNode=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_AABBNode{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_InteractionGroup{\n    static public var zpp_pool:ZNPNode_ZPP_InteractionGroup=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_InteractionGroup=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_InteractionGroup=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_InteractionGroup{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_FluidArbiter{\n    static public var zpp_pool:ZNPNode_ZPP_FluidArbiter=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_FluidArbiter=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_FluidArbiter=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_FluidArbiter{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_SensorArbiter{\n    static public var zpp_pool:ZNPNode_ZPP_SensorArbiter=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_SensorArbiter=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_SensorArbiter=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_SensorArbiter{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_ColArbiter{\n    static public var zpp_pool:ZNPNode_ZPP_ColArbiter=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_ColArbiter=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_ColArbiter=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_ColArbiter{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_Listener{\n    static public var zpp_pool:ZNPNode_ZPP_Listener=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_Listener=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_Listener=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Listener{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_ToiEvent{\n    static public var zpp_pool:ZNPNode_ZPP_ToiEvent=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_ToiEvent=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_ToiEvent=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_ToiEvent{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ConvexResult{\n    static public var zpp_pool:ZNPNode_ConvexResult=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ConvexResult=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ConvexResult=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ConvexResult{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_ZPP_GeomPoly{\n    static public var zpp_pool:ZNPNode_ZPP_GeomPoly=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_ZPP_GeomPoly=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:ZPP_GeomPoly=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_GeomPoly{\n        return elt;\n    }\n}\n#if nape_swc@:keep #end\nclass ZNPNode_RayResult{\n    static public var zpp_pool:ZNPNode_RayResult=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZNPNode_RayResult=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        elt=null;\n    }\n    public var elt:RayResult=null;\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():RayResult{\n        return elt;\n    }\n}\n\n#if nape_swc@:keep #end\nclass ZPP_MixVec2List extends Vec2List{\n    public var inner:ZPP_Vec2=null;\n    public var _length:Int=0;\n    public var zip_length:Bool=false;\n    public var at_ite:ZPP_Vec2=null;\n    public var at_index:Int=0;\n    public static function get(list:ZPP_Vec2,immutable=false):ZPP_MixVec2List{\n        var ret=new ZPP_MixVec2List();\n        ret.inner=list;\n        ret.zpp_inner.immutable=immutable;\n        return ret;\n    }\n    public function new(){\n        super();\n        at_ite=null;\n        at_index=0;\n        zip_length=true;\n        _length=0;\n    }\n    public override function zpp_gl():Int{\n        zpp_vm();\n        if(zip_length){\n            _length=0;\n            {\n                var cx_ite=inner.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    if(true)_length++;\n                    cx_ite=cx_ite.next;\n                }\n            };\n            zip_length=false;\n        }\n        return _length;\n    }\n    public override function zpp_vm():Void{\n        zpp_inner.validate();\n        if(inner.modified){\n            zip_length=true;\n            _length=0;\n            at_ite=null;\n        }\n    }\n    #if nape_swc@:keep #end\n    public override function at(index:Int):Vec2{\n        zpp_vm();\n        #if(!NAPE_RELEASE_BUILD)\n        if(index<0||index>=length)throw \"Error: Index out of bounds\";\n        #end\n        if(zpp_inner.reverse_flag)index=length-1-index;\n        if(index<at_index||at_ite==null){\n            at_index=0;\n            at_ite=inner.begin();\n            while(true){\n                var x=at_ite.elem();\n                if(true)break;\n                at_ite=at_ite.next;\n            }\n        }\n        while(at_index!=index){\n            at_index++;\n            at_ite=at_ite.next;\n            while(true){\n                var x=at_ite.elem();\n                if(true)break;\n                at_ite=at_ite.next;\n            }\n        }\n        return at_ite.elem().wrapper();\n    }\n    #if nape_swc@:keep #end\n    public override function push(obj:Vec2):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        zpp_vm();\n        #if(!NAPE_RELEASE_BUILD)\n        if(obj.zpp_inner._inuse)throw \"Error: \"+\"Vec2\"+\" is already in use\";\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag)inner.add(obj.zpp_inner);\n            else{\n                var ite=inner.iterator_at(length-1);\n                inner.insert(ite,obj.zpp_inner);\n            }\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    #if nape_swc@:keep #end\n    public override function unshift(obj:Vec2):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        zpp_vm();\n        #if(!NAPE_RELEASE_BUILD)\n        if(obj.zpp_inner._inuse)throw \"Error: \"+\"Vec2\"+\" is already in use\";\n        #end\n        var cont=if(zpp_inner.adder!=null)zpp_inner.adder(obj)else true;\n        if(cont){\n            if(zpp_inner.reverse_flag){\n                var ite=inner.iterator_at(length-1);\n                inner.insert(ite,obj.zpp_inner);\n            }\n            else inner.add(obj.zpp_inner);\n            zpp_inner.invalidate();\n            if(zpp_inner.post_adder!=null)zpp_inner.post_adder(obj);\n        }\n        return cont;\n    }\n    #if nape_swc@:keep #end\n    public override function pop():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        zpp_vm();\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            ret=inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)inner.pop();\n        }\n        else{\n            if(at_ite!=null&&at_ite.next==null)at_ite=null;\n            var ite=length==1?null:inner.iterator_at(length-2);\n            ret=ite==null?inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)inner.erase(ite);\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    #if nape_swc@:keep #end\n    public override function shift():Vec2{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        #if(!NAPE_RELEASE_BUILD)\n        if(empty())throw \"Error: Cannot remove from empty list\";\n        #end\n        zpp_vm();\n        var ret=null;\n        if(zpp_inner.reverse_flag){\n            if(at_ite!=null&&at_ite.next==null)at_ite=null;\n            var ite=length==1?null:inner.iterator_at(length-2);\n            ret=ite==null?inner.front():ite.next.elem();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)inner.erase(ite);\n        }\n        else{\n            ret=inner.front();\n            var retx=ret.wrapper();\n            if(zpp_inner.subber!=null)zpp_inner.subber(retx);\n            if(!zpp_inner.dontremove)inner.pop();\n        }\n        zpp_inner.invalidate();\n        var retx=ret.wrapper();\n        return retx;\n    }\n    #if nape_swc@:keep #end\n    public override function remove(obj:Vec2):Bool{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        zpp_inner.modify_test();\n        zpp_vm();\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=inner.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(obj.zpp_inner==x){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(ret){\n            if(zpp_inner.subber!=null)zpp_inner.subber(obj);\n            if(!zpp_inner.dontremove)inner.remove(obj.zpp_inner);\n            zpp_inner.invalidate();\n        }\n        return ret;\n    }\n    #if nape_swc@:keep #end\n    public override function clear():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(zpp_inner.immutable)throw \"Error: \"+\"Vec2\"+\"List is immutable\";\n        #end\n        if(zpp_inner.reverse_flag){\n            while(!empty())pop();\n        }\n        else{\n            while(!empty())shift();\n        }\n    }\n}\n\n#if nape_swc@:keep #end\nclass ZPP_ConstraintList{\n    public var outer:ConstraintList=null;\n    public var inner:ZNPList_ZPP_Constraint=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_ConstraintList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Constraint->Bool=null;\n    public var post_adder:Constraint->Void=null;\n    public var subber:Constraint->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Constraint,imm:Bool=false):ConstraintList{\n        var ret=new ConstraintList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Constraint=null;\n    public var push_ite:ZNPNode_ZPP_Constraint=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Constraint();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_BodyList{\n    public var outer:BodyList=null;\n    public var inner:ZNPList_ZPP_Body=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_BodyList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Body->Bool=null;\n    public var post_adder:Body->Void=null;\n    public var subber:Body->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Body,imm:Bool=false):BodyList{\n        var ret=new BodyList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Body=null;\n    public var push_ite:ZNPNode_ZPP_Body=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Body();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_InteractorList{\n    public var outer:InteractorList=null;\n    public var inner:ZNPList_ZPP_Interactor=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_InteractorList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Interactor->Bool=null;\n    public var post_adder:Interactor->Void=null;\n    public var subber:Interactor->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Interactor,imm:Bool=false):InteractorList{\n        var ret=new InteractorList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Interactor=null;\n    public var push_ite:ZNPNode_ZPP_Interactor=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Interactor();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_CompoundList{\n    public var outer:CompoundList=null;\n    public var inner:ZNPList_ZPP_Compound=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_CompoundList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Compound->Bool=null;\n    public var post_adder:Compound->Void=null;\n    public var subber:Compound->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Compound,imm:Bool=false):CompoundList{\n        var ret=new CompoundList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Compound=null;\n    public var push_ite:ZNPNode_ZPP_Compound=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Compound();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_ListenerList{\n    public var outer:ListenerList=null;\n    public var inner:ZNPList_ZPP_Listener=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_ListenerList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Listener->Bool=null;\n    public var post_adder:Listener->Void=null;\n    public var subber:Listener->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Listener,imm:Bool=false):ListenerList{\n        var ret=new ListenerList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Listener=null;\n    public var push_ite:ZNPNode_ZPP_Listener=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Listener();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_CbTypeList{\n    public var outer:CbTypeList=null;\n    public var inner:ZNPList_ZPP_CbType=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_CbTypeList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:CbType->Bool=null;\n    public var post_adder:CbType->Void=null;\n    public var subber:CbType->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_CbType,imm:Bool=false):CbTypeList{\n        var ret=new CbTypeList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_CbType=null;\n    public var push_ite:ZNPNode_ZPP_CbType=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_CbType();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Vec2List{\n    public var outer:Vec2List=null;\n    public var inner:ZNPList_ZPP_Vec2=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_Vec2List->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Vec2->Bool=null;\n    public var post_adder:Vec2->Void=null;\n    public var subber:Vec2->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Vec2,imm:Bool=false):Vec2List{\n        var ret=new Vec2List();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Vec2=null;\n    public var push_ite:ZNPNode_ZPP_Vec2=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Vec2();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_GeomPolyList{\n    public var outer:GeomPolyList=null;\n    public var inner:ZNPList_ZPP_GeomPoly=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_GeomPolyList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:GeomPoly->Bool=null;\n    public var post_adder:GeomPoly->Void=null;\n    public var subber:GeomPoly->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_GeomPoly,imm:Bool=false):GeomPolyList{\n        var ret=new GeomPolyList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_GeomPoly=null;\n    public var push_ite:ZNPNode_ZPP_GeomPoly=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_GeomPoly();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_RayResultList{\n    public var outer:RayResultList=null;\n    public var inner:ZNPList_RayResult=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_RayResultList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:RayResult->Bool=null;\n    public var post_adder:RayResult->Void=null;\n    public var subber:RayResult->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_RayResult,imm:Bool=false):RayResultList{\n        var ret=new RayResultList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_RayResult=null;\n    public var push_ite:ZNPNode_RayResult=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_RayResult();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_ConvexResultList{\n    public var outer:ConvexResultList=null;\n    public var inner:ZNPList_ConvexResult=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_ConvexResultList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:ConvexResult->Bool=null;\n    public var post_adder:ConvexResult->Void=null;\n    public var subber:ConvexResult->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ConvexResult,imm:Bool=false):ConvexResultList{\n        var ret=new ConvexResultList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ConvexResult=null;\n    public var push_ite:ZNPNode_ConvexResult=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ConvexResult();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_EdgeList{\n    public var outer:EdgeList=null;\n    public var inner:ZNPList_ZPP_Edge=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_EdgeList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Edge->Bool=null;\n    public var post_adder:Edge->Void=null;\n    public var subber:Edge->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Edge,imm:Bool=false):EdgeList{\n        var ret=new EdgeList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Edge=null;\n    public var push_ite:ZNPNode_ZPP_Edge=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Edge();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_ShapeList{\n    public var outer:ShapeList=null;\n    public var inner:ZNPList_ZPP_Shape=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_ShapeList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Shape->Bool=null;\n    public var post_adder:Shape->Void=null;\n    public var subber:Shape->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Shape,imm:Bool=false):ShapeList{\n        var ret=new ShapeList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Shape=null;\n    public var push_ite:ZNPNode_ZPP_Shape=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Shape();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_InteractionGroupList{\n    public var outer:InteractionGroupList=null;\n    public var inner:ZNPList_ZPP_InteractionGroup=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_InteractionGroupList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:InteractionGroup->Bool=null;\n    public var post_adder:InteractionGroup->Void=null;\n    public var subber:InteractionGroup->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_InteractionGroup,imm:Bool=false):InteractionGroupList{\n        var ret=new InteractionGroupList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_InteractionGroup=null;\n    public var push_ite:ZNPNode_ZPP_InteractionGroup=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_InteractionGroup();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_ArbiterList{\n    public var outer:ArbiterList=null;\n    public var inner:ZNPList_ZPP_Arbiter=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_ArbiterList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Arbiter->Bool=null;\n    public var post_adder:Arbiter->Void=null;\n    public var subber:Arbiter->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZNPList_ZPP_Arbiter,imm:Bool=false):ArbiterList{\n        var ret=new ArbiterList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZNPNode_ZPP_Arbiter=null;\n    public var push_ite:ZNPNode_ZPP_Arbiter=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZNPList_ZPP_Arbiter();\n        _invalidated=true;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_ContactList{\n    public var outer:ContactList=null;\n    public var inner:ZPP_Contact=null;\n    public var immutable:Bool=false;\n    public var _invalidated:Bool=false;\n    public var _invalidate:ZPP_ContactList->Void=null;\n    public var _validate:Void->Void=null;\n    public var _modifiable:Void->Void=null;\n    public static var internal:Bool=false;\n    public var adder:Contact->Bool=null;\n    public var post_adder:Contact->Void=null;\n    public var subber:Contact->Void=null;\n    public var dontremove:Bool=false;\n    public var reverse_flag:Bool=false;\n     public static function get(list:ZPP_Contact,imm:Bool=false):ContactList{\n        var ret=new ContactList();\n        ret.zpp_inner.inner=list;\n        if(imm)ret.zpp_inner.immutable=true;\n        ret.zpp_inner.zip_length=true;\n        return ret;\n    }\n    public function valmod():Void{\n        validate();\n        if(inner.modified){\n            if(inner.pushmod)push_ite=null;\n            at_ite=null;\n            inner.modified=false;\n            inner.pushmod=false;\n            zip_length=true;\n        }\n    }\n    public function modified():Void{\n        zip_length=true;\n        at_ite=null;\n        push_ite=null;\n    }\n    public function modify_test():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_modifiable!=null)_modifiable();\n        #end\n    }\n    public function validate():Void{\n        if(_invalidated){\n            _invalidated=false;\n            if(_validate!=null)_validate();\n        }\n    }\n    public function invalidate():Void{\n        _invalidated=true;\n        if(_invalidate!=null)_invalidate(this);\n    }\n    public var at_index:Int=0;\n    public var at_ite:ZPP_Contact=null;\n    public var push_ite:ZPP_Contact=null;\n    public var zip_length:Bool=false;\n    public var user_length:Int=0;\n    public function new(){\n        inner=new ZPP_Contact();\n        _invalidated=true;\n    }\n}\n","package zpp_nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_CbType{\n    public var outer:CbType=null;\n    public var userData:Dynamic<Dynamic>=null;\n    public var id:Int=0;\n    public var cbsets:ZNPList_ZPP_CbSet=null;\n    public#if NAPE_NO_INLINE#else inline #end\n    static function setlt(a:ZPP_CbType,b:ZPP_CbType):Bool{\n        return a.id<b.id;\n    }\n    public var interactors:ZNPList_ZPP_Interactor;\n    public var wrap_interactors:InteractorList;\n    public var constraints:ZNPList_ZPP_Constraint;\n    public var wrap_constraints:ConstraintList;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addConstraint(con:ZPP_Constraint){\n        constraints.add(con);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addInteractor(intx:ZPP_Interactor){\n        interactors.add(intx);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remConstraint(con:ZPP_Constraint){\n        constraints.remove(con);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remInteractor(intx:ZPP_Interactor){\n        interactors.remove(intx);\n    }\n    public var listeners:ZNPList_ZPP_InteractionListener=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addint(x:ZPP_InteractionListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !listeners.has(x);\n            };\n            if(!res)throw \"assert(\"+\"!listeners.has(x)\"+\") :: \"+(\"listener already in list\");\n            #end\n        };\n        {\n            var pre=null;\n            {\n                var cx_ite=listeners.begin();\n                while(cx_ite!=null){\n                    var j=cx_ite.elem();\n                    {\n                        if(ZPP_Listener.setlt(x,j))break;\n                        pre=cx_ite;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            listeners.inlined_insert(pre,x);\n        };\n        invalidateint();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function removeint(x:ZPP_InteractionListener):Void{\n        listeners.remove(x);\n        invalidateint();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidateint():Void{\n        {\n            var cx_ite=cbsets.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                cb.invalidate_listeners();\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public var bodylisteners:ZNPList_ZPP_BodyListener=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addbody(x:ZPP_BodyListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !bodylisteners.has(x);\n            };\n            if(!res)throw \"assert(\"+\"!bodylisteners.has(x)\"+\") :: \"+(\"listener already in list\");\n            #end\n        };\n        {\n            var pre=null;\n            {\n                var cx_ite=bodylisteners.begin();\n                while(cx_ite!=null){\n                    var j=cx_ite.elem();\n                    {\n                        if(ZPP_Listener.setlt(x,j))break;\n                        pre=cx_ite;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            bodylisteners.inlined_insert(pre,x);\n        };\n        invalidatebody();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function removebody(x:ZPP_BodyListener):Void{\n        bodylisteners.remove(x);\n        invalidatebody();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidatebody():Void{\n        {\n            var cx_ite=cbsets.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                cb.invalidate_bodylisteners();\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public var conlisteners:ZNPList_ZPP_ConstraintListener=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addconstraint(x:ZPP_ConstraintListener):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !conlisteners.has(x);\n            };\n            if(!res)throw \"assert(\"+\"!conlisteners.has(x)\"+\") :: \"+(\"listener already in list\");\n            #end\n        };\n        {\n            var pre=null;\n            {\n                var cx_ite=conlisteners.begin();\n                while(cx_ite!=null){\n                    var j=cx_ite.elem();\n                    {\n                        if(ZPP_Listener.setlt(x,j))break;\n                        pre=cx_ite;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            conlisteners.inlined_insert(pre,x);\n        };\n        invalidateconstraint();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function removeconstraint(x:ZPP_ConstraintListener):Void{\n        conlisteners.remove(x);\n        invalidateconstraint();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidateconstraint():Void{\n        {\n            var cx_ite=cbsets.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                cb.invalidate_conlisteners();\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public static var ANY_SHAPE=new CbType();\n    public static var ANY_BODY=new CbType();\n    public static var ANY_COMPOUND=new CbType();\n    public static var ANY_CONSTRAINT=new CbType();\n    public function new(){\n        id=ZPP_ID.CbType();\n        \n        listeners=new ZNPList_ZPP_InteractionListener();\n        bodylisteners=new ZNPList_ZPP_BodyListener();\n        conlisteners=new ZNPList_ZPP_ConstraintListener();\n        constraints=new ZNPList_ZPP_Constraint();\n        interactors=new ZNPList_ZPP_Interactor();\n        cbsets=new ZNPList_ZPP_CbSet();\n    }\n}\n","package zpp_nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Listener{\n    public var outer:Listener=null;\n    #if(!NAPE_RELEASE_BUILD)\n    public static var internal:Bool=false;\n    #end\n    public var id:Int=0;\n    public var type:Int=0;\n    public var event:Int=0;\n    public static var types:Array<ListenerType>=[ListenerType.BODY,ListenerType.CONSTRAINT,ListenerType.INTERACTION,ListenerType.PRE];\n    public static var events:Array<CbEvent>=[CbEvent.BEGIN,CbEvent.END,CbEvent.WAKE,CbEvent.SLEEP,CbEvent.BREAK,CbEvent.PRE,CbEvent.ONGOING];\n    public var precedence:Int=0;\n    public var body:Null<ZPP_BodyListener>=null;\n    public var constraint:Null<ZPP_ConstraintListener>=null;\n    public var interaction:Null<ZPP_InteractionListener>=null;\n    public var space:Null<ZPP_Space>=null;\n    function new(){\n        id=ZPP_ID.Listener();\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    static function setlt(a:ZPP_Listener,b:ZPP_Listener):Bool{\n        return(a.precedence>b.precedence)||(a.precedence==b.precedence&&a.id>b.id);\n    }\n    public function swapEvent(event:Int):Void{}\n    public function invalidate_precedence():Void{}\n    public function addedToSpace():Void{}\n    public function removedFromSpace():Void{}\n}\n#if nape_swc@:keep #end\nclass ZPP_BodyListener extends ZPP_Listener{\n    public var outer_zn:BodyListener=null;\n    public var options:ZPP_OptionType=null;\n    public var handler:BodyCallback->Void=null;\n    #if(!NAPE_RELEASE_BUILD)\n    function immutable_options(){\n        if(space!=null&&space.midstep){\n            throw \"Error: Cannot change listener type options during space.step()\";\n        }\n    }\n    #end\n    public function new(options:OptionType,event:Int,handler:BodyCallback->Void){\n        super();\n        this.event=event;\n        this.handler=handler;\n        body=this;\n        type=ZPP_Flags.id_ListenerType_BODY;\n        this.options=options.zpp_inner;\n    }\n    public override function addedToSpace():Void{\n        options.handler=cbtype_change;\n        {\n            var cx_ite=options.includes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                {\n                    cb.addbody(this);\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public override function removedFromSpace():Void{\n        {\n            var cx_ite=options.includes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                {\n                    cb.removebody(this);\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        options.handler=null;\n    }\n    function cbtype_change(cb:ZPP_CbType,included:Bool,added:Bool):Void{\n        removedFromSpace();\n        options.effect_change(cb,included,added);\n        addedToSpace();\n    }\n    public override function invalidate_precedence():Void{\n        if(space!=null){\n            removedFromSpace();\n            addedToSpace();\n        }\n    }\n    public override function swapEvent(newev:Int):Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(newev!=ZPP_Flags.id_CbEvent_WAKE&&newev!=ZPP_Flags.id_CbEvent_SLEEP){\n            throw \"Error: BodyListener event must be either WAKE or SLEEP only\";\n        }\n        #end\n        removedFromSpace();\n        event=newev;\n        addedToSpace();\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_ConstraintListener extends ZPP_Listener{\n    public var outer_zn:ConstraintListener=null;\n    public var options:ZPP_OptionType=null;\n    public var handler:ConstraintCallback->Void=null;\n    #if(!NAPE_RELEASE_BUILD)\n    function immutable_options(){\n        if(space!=null&&space.midstep){\n            throw \"Error: Cannot change listener type options during space.step()\";\n        }\n    }\n    #end\n    public function new(options:OptionType,event:Int,handler:ConstraintCallback->Void){\n        super();\n        this.event=event;\n        this.handler=handler;\n        constraint=this;\n        type=ZPP_Flags.id_ListenerType_CONSTRAINT;\n        this.options=options.zpp_inner;\n    }\n    public override function addedToSpace():Void{\n        options.handler=cbtype_change;\n        {\n            var cx_ite=options.includes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                {\n                    cb.addconstraint(this);\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public override function removedFromSpace():Void{\n        {\n            var cx_ite=options.includes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                {\n                    cb.removeconstraint(this);\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        options.handler=null;\n    }\n    function cbtype_change(cb:ZPP_CbType,included:Bool,added:Bool):Void{\n        removedFromSpace();\n        options.effect_change(cb,included,added);\n        addedToSpace();\n    }\n    public override function invalidate_precedence():Void{\n        if(space!=null){\n            removedFromSpace();\n            addedToSpace();\n        }\n    }\n    public override function swapEvent(newev:Int){\n        #if(!NAPE_RELEASE_BUILD)\n        if(newev!=ZPP_Flags.id_CbEvent_WAKE&&newev!=ZPP_Flags.id_CbEvent_SLEEP&&newev!=ZPP_Flags.id_CbEvent_BREAK){\n            throw \"Error: ConstraintListener event must be either WAKE or SLEEP only\";\n        }\n        #end\n        removedFromSpace();\n        event=newev;\n        addedToSpace();\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_InteractionListener extends ZPP_Listener{\n    public var outer_zni:Null<InteractionListener>=null;\n    public var outer_znp:Null<PreListener>=null;\n    public var itype:Int=0;\n    public var options1:ZPP_OptionType=null;\n    public var options2:ZPP_OptionType=null;\n    public var handleri:Null<InteractionCallback->Void>=null;\n    public var allowSleepingCallbacks:Bool=false;\n    public var pure:Bool=false;\n    public var handlerp:Null<PreCallback->Null<PreFlag>>=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setInteractionType(itype:Int){\n        this.itype=itype;\n    }\n    public function new(options1:OptionType,options2:OptionType,event:Int,type:Int){\n        super();\n        this.type=type;\n        interaction=this;\n        this.event=event;\n        this.options1=options1.zpp_inner;\n        this.options2=options2.zpp_inner;\n        allowSleepingCallbacks=false;\n    }\n    public function wake(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                type==ZPP_Flags.id_ListenerType_PRE;\n            };\n            if(!res)throw \"assert(\"+\"type==ZPP_Flags.id_ListenerType_PRE\"+\") :: \"+(\"waking non-pre?\");\n            #end\n        };\n        with_union(function(cb:ZPP_CbType):Void{\n            {\n                var cx_ite=cb.interactors.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    {\n                        i.wake();\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        });\n    }\n    \n    static var UCbSet=new ZNPList_ZPP_CbSet();\n    static var VCbSet=new ZNPList_ZPP_CbSet();\n    static var WCbSet=new ZNPList_ZPP_CbSet();\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    #if NAPE_NO_INLINE#else inline #end\n    function CbSetset(A:ZNPList_ZPP_CbSet,B:ZNPList_ZPP_CbSet,lambda:ZPP_CbSet->ZPP_CbSet->Void):Void{\n        var U=UCbSet;\n        var V=VCbSet;\n        var W=WCbSet;\n        var aite=A.begin();\n        var bite=B.begin();\n        while(aite!=null&&bite!=null){\n            var a=aite.elem();\n            var b=bite.elem();\n            if(a==b){\n                W.inlined_add(a);\n                aite=aite.next;\n                bite=bite.next;\n            }\n            else if(ZPP_CbSet.setlt(a,b)){\n                U.inlined_add(a);\n                aite=aite.next;\n            }\n            else{\n                V.inlined_add(b);\n                bite=bite.next;\n            }\n        }\n        while(aite!=null){\n            U.inlined_add(aite.elem());\n            aite=aite.next;\n        }\n        while(bite!=null){\n            V.inlined_add(bite.elem());\n            bite=bite.next;\n        }\n        {\n            while(!U.empty()){\n                var x=U.pop_unsafe();\n                {\n                    var cx_ite=B.begin();\n                    while(cx_ite!=null){\n                        var y=cx_ite.elem();\n                        lambda(x,y);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        };\n        {\n            while(!V.empty()){\n                var x=V.pop_unsafe();\n                {\n                    var cx_ite=W.begin();\n                    while(cx_ite!=null){\n                        var y=cx_ite.elem();\n                        lambda(x,y);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        };\n        {\n            while(!W.empty()){\n                var x=W.pop_unsafe();\n                {\n                    lambda(x,x);\n                    {\n                        var cx_ite=W.begin();\n                        while(cx_ite!=null){\n                            var y=cx_ite.elem();\n                            lambda(x,y);\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                };\n            }\n        };\n    }\n    static var UCbType=new ZNPList_ZPP_CbType();\n    static var VCbType=new ZNPList_ZPP_CbType();\n    static var WCbType=new ZNPList_ZPP_CbType();\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    #if NAPE_NO_INLINE#else inline #end\n    function CbTypeset(A:ZNPList_ZPP_CbType,B:ZNPList_ZPP_CbType,lambda:ZPP_CbType->ZPP_CbType->Void):Void{\n        var U=UCbType;\n        var V=VCbType;\n        var W=WCbType;\n        var aite=A.begin();\n        var bite=B.begin();\n        while(aite!=null&&bite!=null){\n            var a=aite.elem();\n            var b=bite.elem();\n            if(a==b){\n                W.inlined_add(a);\n                aite=aite.next;\n                bite=bite.next;\n            }\n            else if(ZPP_CbType.setlt(a,b)){\n                U.inlined_add(a);\n                aite=aite.next;\n            }\n            else{\n                V.inlined_add(b);\n                bite=bite.next;\n            }\n        }\n        while(aite!=null){\n            U.inlined_add(aite.elem());\n            aite=aite.next;\n        }\n        while(bite!=null){\n            V.inlined_add(bite.elem());\n            bite=bite.next;\n        }\n        {\n            while(!U.empty()){\n                var x=U.pop_unsafe();\n                {\n                    var cx_ite=B.begin();\n                    while(cx_ite!=null){\n                        var y=cx_ite.elem();\n                        lambda(x,y);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        };\n        {\n            while(!V.empty()){\n                var x=V.pop_unsafe();\n                {\n                    var cx_ite=W.begin();\n                    while(cx_ite!=null){\n                        var y=cx_ite.elem();\n                        lambda(x,y);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        };\n        {\n            while(!W.empty()){\n                var x=W.pop_unsafe();\n                {\n                    lambda(x,x);\n                    {\n                        var cx_ite=W.begin();\n                        while(cx_ite!=null){\n                            var y=cx_ite.elem();\n                            lambda(x,y);\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                };\n            }\n        };\n    }\n    function with_uniquesets(fresh:Bool){\n        var set;\n        {\n            if(ZPP_Set_ZPP_CbSetPair.zpp_pool==null){\n                set=new ZPP_Set_ZPP_CbSetPair();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_TOT++;\n                ZPP_Set_ZPP_CbSetPair.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                set=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n                ZPP_Set_ZPP_CbSetPair.zpp_pool=set.next;\n                set.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT--;\n                ZPP_Set_ZPP_CbSetPair.POOL_ADD++;\n                #end\n            }\n            set.alloc();\n        };\n        set.lt=ZPP_CbSetPair.setlt;\n        CbTypeset(options1.includes,options2.includes,function(a:ZPP_CbType,b:ZPP_CbType):Void{\n            CbSetset(a.cbsets,b.cbsets,function(a:ZPP_CbSet,b:ZPP_CbSet):Void{\n                a.validate();\n                b.validate();\n                if(ZPP_CbSet.single_intersection(a,b,this)){\n                    set.try_insert(ZPP_CbSetPair.get(a,b));\n                }\n            });\n        });\n        set.clear_with(function(pair:ZPP_CbSetPair):Void{\n            if(fresh)space.freshListenerType(pair.a,pair.b);\n            else space.nullListenerType(pair.a,pair.b);\n            {\n                var o=pair;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_CbSetPair\"+\", in obj: \"+\"pair\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_CbSetPair.zpp_pool;\n                ZPP_CbSetPair.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_CbSetPair.POOL_CNT++;\n                ZPP_CbSetPair.POOL_SUB++;\n                #end\n            };\n        });\n        {\n            var o=set;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_CbSetPair\"+\", in obj: \"+\"set\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n            ZPP_Set_ZPP_CbSetPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT++;\n            ZPP_Set_ZPP_CbSetPair.POOL_SUB++;\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    #if NAPE_NO_INLINE#else inline #end\n    function with_union(lambda:ZPP_CbType->Void):Void{\n        var ite1=options1.includes.begin();\n        var ite2=options2.includes.begin();\n        while(ite1!=null&&ite2!=null){\n            var cb1=ite1.elem();\n            var cb2=ite2.elem();\n            if(cb1==cb2){\n                lambda(cb1);\n                ite1=ite1.next;\n                ite2=ite2.next;\n            }\n            else if(ZPP_CbType.setlt(cb1,cb2)){\n                lambda(cb1);\n                ite1=ite1.next;\n            }\n            else{\n                lambda(cb2);\n                ite2=ite2.next;\n            }\n        }\n        while(ite1!=null){\n            lambda(ite1.elem());\n            ite1=ite1.next;\n        }\n        while(ite2!=null){\n            lambda(ite2.elem());\n            ite2=ite2.next;\n        }\n    }\n    public override function addedToSpace():Void{\n        var pre=type==ZPP_Flags.id_ListenerType_PRE;\n        with_union(function(cb:ZPP_CbType):Void{\n            cb.addint(this);\n            if(pre){\n                {\n                    var cx_ite=cb.interactors.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        i.wake();\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        });\n        options1.handler=cbtype_change1;\n        options2.handler=cbtype_change2;\n        with_uniquesets(true);\n    }\n    public override function removedFromSpace():Void{\n        with_uniquesets(false);\n        var pre=type==ZPP_Flags.id_ListenerType_PRE;\n        with_union(function(cb:ZPP_CbType):Void{\n            cb.removeint(this);\n            if(pre){\n                {\n                    var cx_ite=cb.interactors.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        i.wake();\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        });\n        options1.handler=null;\n        options2.handler=null;\n    }\n    public override function invalidate_precedence(){\n        if(space!=null){\n            var pre=type==ZPP_Flags.id_ListenerType_PRE;\n            with_union(function(cb:ZPP_CbType):Void{\n                cb.removeint(this);\n                cb.addint(this);\n                if(pre){\n                    {\n                        var cx_ite=cb.interactors.begin();\n                        while(cx_ite!=null){\n                            var i=cx_ite.elem();\n                            i.wake();\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                }\n            });\n        }\n    }\n    function cbtype_change1(cb:ZPP_CbType,included:Bool,added:Bool):Void{\n        cbtype_change(options1,cb,included,added);\n    }\n    function cbtype_change2(cb:ZPP_CbType,included:Bool,added:Bool):Void{\n        cbtype_change(options2,cb,included,added);\n    }\n    function cbtype_change(options:ZPP_OptionType,cb:ZPP_CbType,included:Bool,added:Bool):Void{\n        space.revoke_listener(this);\n        removedFromSpace();\n        options.effect_change(cb,included,added);\n        addedToSpace();\n        space.unrevoke_listener(this);\n    }\n    public override function swapEvent(newev:Int){\n        #if(!NAPE_RELEASE_BUILD)\n        if(type==ZPP_Flags.id_ListenerType_PRE){\n            throw \"Error: PreListener event can only be PRE\";\n        }\n        else if(newev!=ZPP_Flags.id_CbEvent_BEGIN&&newev!=ZPP_Flags.id_CbEvent_END&&newev!=ZPP_Flags.id_CbEvent_ONGOING){\n            throw \"Error: InteractionListener event must be either BEGIN, END, ONGOING\";\n        }\n        #end\n        removedFromSpace();\n        event=newev;\n        addedToSpace();\n    }\n}\n","package zpp_nape.callbacks;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_OptionType{\n    public var outer:OptionType=null;\n    public var handler:Null<ZPP_CbType->Bool->Bool->Void>=null;\n    public var includes:ZNPList_ZPP_CbType=null;\n    public var excludes:ZNPList_ZPP_CbType=null;\n    public function new(){\n        includes=new ZNPList_ZPP_CbType();\n        excludes=new ZNPList_ZPP_CbType();\n    }\n    public var wrap_includes:CbTypeList=null;\n    public var wrap_excludes:CbTypeList=null;\n    public function setup_includes():Void{\n        wrap_includes=ZPP_CbTypeList.get(includes,true);\n    }\n    public function setup_excludes():Void{\n        wrap_excludes=ZPP_CbTypeList.get(excludes,true);\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function excluded(xs:ZNPList_ZPP_CbType):Bool{\n        return nonemptyintersection(xs,excludes);\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function included(xs:ZNPList_ZPP_CbType):Bool{\n        return nonemptyintersection(xs,includes);\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function compatible(xs:ZNPList_ZPP_CbType):Bool{\n        return included(xs)&&!excluded(xs);\n    }\n    public function nonemptyintersection(xs:ZNPList_ZPP_CbType,ys:ZNPList_ZPP_CbType):Bool{\n        var ret=false;\n        var xite=xs.begin();\n        var eite=ys.begin();\n        while(eite!=null&&xite!=null){\n            var ex=eite.elem();\n            var xi=xite.elem();\n            if(ex==xi){\n                ret=true;\n                break;\n            }\n            else if(ZPP_CbType.setlt(ex,xi)){\n                eite=eite.next;\n            }\n            else{\n                xite=xite.next;\n            }\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function effect_change(val:ZPP_CbType,included:Bool,added:Bool):Void{\n        if(included){\n            if(added){\n                var pre=null;\n                {\n                    var cx_ite=includes.begin();\n                    while(cx_ite!=null){\n                        var j=cx_ite.elem();\n                        {\n                            if(ZPP_CbType.setlt(val,j))break;\n                            pre=cx_ite;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                includes.inlined_insert(pre,val);\n            };\n            else includes.remove(val);\n        }\n        else{\n            if(added){\n                var pre=null;\n                {\n                    var cx_ite=excludes.begin();\n                    while(cx_ite!=null){\n                        var j=cx_ite.elem();\n                        {\n                            if(ZPP_CbType.setlt(val,j))break;\n                            pre=cx_ite;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                excludes.inlined_insert(pre,val);\n            };\n            else excludes.remove(val);\n        }\n    }\n    function append_type(list:ZNPList_ZPP_CbType,val:ZPP_CbType){\n        if(list==includes){\n            if(!includes.has(val)){\n                if(!excludes.has(val)){\n                    if(handler!=null)handler(val,true,true);\n                    else effect_change(val,true,true);\n                }\n                else{\n                    if(handler!=null)handler(val,false,false);\n                    else effect_change(val,false,false);\n                }\n            }\n        }\n        else{\n            if(!excludes.has(val)){\n                if(!includes.has(val)){\n                    if(handler!=null)handler(val,false,true);\n                    else effect_change(val,false,true);\n                }\n                else{\n                    if(handler!=null)handler(val,true,false);\n                    else effect_change(val,true,false);\n                }\n            }\n        }\n    }\n    public function set(options:ZPP_OptionType){\n        if(options!=this){\n            while(!includes.empty())append_type(excludes,includes.front());\n            while(!excludes.empty())append_type(includes,excludes.front());\n            {\n                var cx_ite=options.excludes.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    append_type(excludes,i);\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var cx_ite=options.includes.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    append_type(includes,i);\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n        return this;\n    }\n    public function append(list:ZNPList_ZPP_CbType,val:Dynamic){\n        #if(!NAPE_RELEASE_BUILD)\n        if(val==null){\n            throw \"Error: Cannot append null, only CbType and CbType list values\";\n        }\n        #end\n        if(#if flash untyped __is__(val,CbType)#else Std.is(val,CbType)#end){\n            var cb:CbType=val;\n            append_type(list,cb.zpp_inner);\n        }\n        else if(#if flash untyped __is__(val,CbTypeList)#else Std.is(val,CbTypeList)#end){\n            var cbs:CbTypeList=val;\n            for(cb in cbs)append_type(list,cb.zpp_inner);\n        }\n        else if(#if flash10#if flash untyped __is__(val,ZPP_Const.cbtypevector)#else Std.is(val,ZPP_Const.cbtypevector)#end\n        #else false #end){\n            #if flash10 var cbs:flash.Vector<CbType>=val;\n            for(cb in cbs)append_type(list,cb.zpp_inner);\n            #end\n        }\n        else if(#if flash untyped __is__(val,Array)#else Std.is(val,Array)#end){\n            var cbs:Array<Dynamic>=val;\n            for(cb in cbs){\n                #if(!NAPE_RELEASE_BUILD)\n                if(!#if flash untyped __is__(cb,CbType)#else Std.is(cb,CbType)#end){\n                    throw \"Error: Cannot append non-CbType or CbType list value\";\n                }\n                #end\n                var cbx:CbType=cb;\n                append_type(list,cbx.zpp_inner);\n            }\n        }\n        else{\n            #if(!NAPE_RELEASE_BUILD)\n            throw \"Error: Cannot append non-CbType or CbType list value\";\n            #end\n        }\n    }\n    public static function argument(val:Dynamic):OptionType{\n        return if(val==null)new OptionType();\n        else if(#if flash untyped __is__(val,OptionType)#else Std.is(val,OptionType)#end)val;\n        else new OptionType().including(val);\n    }\n}\n","package zpp_nape.constraint;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Constraint{\n    public var outer:Constraint=null;\n    public function clear(){}\n    public var id:Int=0;\n    public var userData:Dynamic<Dynamic>=null;\n    public var compound:ZPP_Compound=null;\n    public var space:ZPP_Space=null;\n    public var active:Bool=false;\n    public var stiff:Bool=false;\n    public var frequency:Float=0.0;\n    public var damping:Float=0.0;\n    public var maxForce:Float=0.0;\n    public var maxError:Float=0.0;\n    public var breakUnderForce:Bool=false;\n    public var breakUnderError:Bool=false;\n    public var removeOnBreak:Bool=false;\n    public var component:ZPP_Component=null;\n    public var ignore:Bool=false;\n    public var __velocity:Bool=false;\n    public function new(){\n        __velocity=false;\n        id=ZPP_ID.Constraint();\n        stiff=true;\n        active=true;\n        ignore=false;\n        frequency=10;\n        damping=1;\n        maxForce=ZPP_Const.POSINF();\n        maxError=ZPP_Const.POSINF();\n        breakUnderForce=false;\n        removeOnBreak=true;\n        pre_dt=-1.0;\n        cbTypes=new ZNPList_ZPP_CbType();\n    }\n    public function immutable_midstep(name:String){\n        #if(!NAPE_RELEASE_BUILD)\n        if(space!=null&&space.midstep)throw \"Error: Constraint::\"+name+\" cannot be set during space step()\";\n        #end\n    }\n    public var cbTypes:ZNPList_ZPP_CbType=null;\n    public var cbSet:ZPP_CbSet=null;\n    public var wrap_cbTypes:CbTypeList=null;\n    public function setupcbTypes(){\n        wrap_cbTypes=ZPP_CbTypeList.get(cbTypes);\n        wrap_cbTypes.zpp_inner.adder=wrap_cbTypes_adder;\n        wrap_cbTypes.zpp_inner.subber=wrap_cbTypes_subber;\n        wrap_cbTypes.zpp_inner.dontremove=true;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_cbTypes.zpp_inner._modifiable=immutable_cbTypes;\n        #end\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    function immutable_cbTypes(){\n        immutable_midstep(\"Constraint::cbTypes\");\n    }\n    #end\n    function wrap_cbTypes_subber(pcb:CbType):Void{\n        var cb=pcb.zpp_inner;\n        if(cbTypes.has(cb)){\n            if(space!=null){\n                dealloc_cbSet();\n                cb.remConstraint(this);\n            }\n            cbTypes.remove(cb);\n            if(space!=null){\n                alloc_cbSet();\n                wake();\n            }\n        }\n    }\n    function wrap_cbTypes_adder(cb:CbType):Bool{\n        insert_cbtype(cb.zpp_inner);\n        return false;\n    }\n    public function insert_cbtype(cb:ZPP_CbType){\n        if(!cbTypes.has(cb)){\n            if(space!=null){\n                dealloc_cbSet();\n                cb.addConstraint(this);\n            }\n            {\n                var pre=null;\n                {\n                    var cx_ite=cbTypes.begin();\n                    while(cx_ite!=null){\n                        var j=cx_ite.elem();\n                        {\n                            if(ZPP_CbType.setlt(cb,j))break;\n                            pre=cx_ite;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                cbTypes.inlined_insert(pre,cb);\n            };\n            if(space!=null){\n                alloc_cbSet();\n                wake();\n            }\n        }\n    }\n    public function alloc_cbSet(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                space!=null;\n            };\n            if(!res)throw \"assert(\"+\"space!=null\"+\") :: \"+(\"space null in alloc_cbSet\");\n            #end\n        };\n        if((cbSet=space.cbsets.get(cbTypes))!=null){\n            cbSet.increment();\n            cbSet.addConstraint(this);\n        }\n    }\n    public function dealloc_cbSet(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                space!=null;\n            };\n            if(!res)throw \"assert(\"+\"space!=null\"+\") :: \"+(\"space null in dealloc_cbSet\");\n            #end\n        };\n        if(cbSet!=null){\n            cbSet.remConstraint(this);\n            if(cbSet.decrement()){\n                space.cbsets.remove(cbSet);\n                {\n                    var o=cbSet;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_CbSet\"+\", in obj: \"+\"cbSet\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_CbSet.zpp_pool;\n                    ZPP_CbSet.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_CbSet.POOL_CNT++;\n                    ZPP_CbSet.POOL_SUB++;\n                    #end\n                };\n            }\n            cbSet=null;\n        }\n    }\n    public function activate(){\n        if(space!=null)activeInSpace();\n    }\n    public function deactivate(){\n        if(space!=null)inactiveOrOutSpace();\n    }\n    public function addedToSpace(){\n        if(active)activeInSpace();\n        activeBodies();\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                cb.addConstraint(this);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function removedFromSpace(){\n        if(active)inactiveOrOutSpace();\n        inactiveBodies();\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                cb.remConstraint(this);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function activeInSpace(){\n        alloc_cbSet();\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                component==null;\n            };\n            if(!res)throw \"assert(\"+\"component==null\"+\") :: \"+(\"already has a component?\");\n            #end\n        };\n        {\n            if(ZPP_Component.zpp_pool==null){\n                component=new ZPP_Component();\n                #if NAPE_POOL_STATS ZPP_Component.POOL_TOT++;\n                ZPP_Component.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                component=ZPP_Component.zpp_pool;\n                ZPP_Component.zpp_pool=component.next;\n                component.next=null;\n                #if NAPE_POOL_STATS ZPP_Component.POOL_CNT--;\n                ZPP_Component.POOL_ADD++;\n                #end\n            }\n            component.alloc();\n        };\n        component.isBody=false;\n        component.constraint=this;\n    }\n    public function inactiveOrOutSpace(){\n        dealloc_cbSet();\n        {\n            var o=component;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Component\"+\", in obj: \"+\"component\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Component.zpp_pool;\n            ZPP_Component.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Component.POOL_CNT++;\n            ZPP_Component.POOL_SUB++;\n            #end\n        };\n        component=null;\n    }\n    #if nape_swc@:keep #end\n    public function activeBodies(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"activeBodies not overriden\");\n            #end\n        };\n    }\n    #if nape_swc@:keep #end\n    public function inactiveBodies(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"inactiveBodies not overriden\");\n            #end\n        };\n    }\n    #if nape_swc@:keep #end\n    public function clearcache(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"clearcache not overriden\");\n            #end\n        };\n    }\n    #if nape_swc@:keep #end\n    public function validate(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"validate not overriden\");\n            #end\n        };\n    }\n    #if nape_swc@:keep #end\n    public function wake_connected(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"wake_connected not overriden\");\n            #end\n        };\n    }\n    #if nape_swc@:keep #end\n    public function forest(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"forest not overriden\");\n            #end\n        };\n    }\n    #if nape_swc@:keep #end\n    public function pair_exists(id:Int,di:Int){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"pair_exists not overriden\");\n            #end\n        };\n        return false;\n    }\n    #if nape_swc@:keep #end\n    public function broken(){}\n    #if nape_swc@:keep #end\n    public function warmStart(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"warmStart not overriden\");\n            #end\n        };\n    }\n    public var pre_dt:Float=0.0;\n    #if nape_swc@:keep #end\n    public function preStep(dt:Float):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"preStep not overriden\");\n            #end\n        };\n        return false;\n    }\n    #if nape_swc@:keep #end\n    public function applyImpulseVel(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"applyImpulseVel not overriden\");\n            #end\n        };\n        return false;\n    }\n    #if nape_swc@:keep #end\n    public function applyImpulsePos(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"applyImpulsePos not overriden\");\n            #end\n        };\n        return false;\n    }\n    public function wake(){\n        if(space!=null)space.wake_constraint(this);\n    }\n    public function draw(g:Debug){}\n    public function copy(dict:Array<ZPP_CopyHelper>=null,todo:Array<ZPP_CopyHelper>=null):Constraint{\n        return null;\n    }\n    public function copyto(ret:Constraint){\n        var me=outer;\n        for(cb in me.cbTypes)ret.cbTypes.add(cb);\n        ret.removeOnBreak=me.removeOnBreak;\n        ret.breakUnderError=me.breakUnderError;\n        ret.breakUnderForce=me.breakUnderForce;\n        ret.maxError=me.maxError;\n        ret.maxForce=me.maxForce;\n        ret.damping=me.damping;\n        ret.frequency=me.frequency;\n        ret.stiff=me.stiff;\n        ret.ignore=me.ignore;\n        ret.active=me.active;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_CopyHelper{\n    public var id:Int=0;\n    public var bc:Body=null;\n    public var cb:Body->Void=null;\n    function new(){}\n    public static function dict(id:Int,bc:Body){\n        var ret=new ZPP_CopyHelper();\n        ret.id=id;\n        ret.bc=bc;\n        return ret;\n    }\n    public static function todo(id:Int,cb:Body->Void){\n        var ret=new ZPP_CopyHelper();\n        ret.id=id;\n        ret.cb=cb;\n        return ret;\n    }\n}\n","package zpp_nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Arbiter{\n    public var outer:Arbiter=null;\n    #if NAPE_POOL_STATS public var arbid:Int=0;\n    static var nextarbid:Int=0;\n    #end\n    public static var internal=false;\n    public function wrapper(){\n        if(outer==null){\n            internal=true;\n            if(type==COL){\n                colarb.outer_zn=new CollisionArbiter();\n                outer=colarb.outer_zn;\n            }\n            else if(type==FLUID){\n                fluidarb.outer_zn=new FluidArbiter();\n                outer=fluidarb.outer_zn;\n            }\n            else outer=new Arbiter();\n            outer.zpp_inner=this;\n            internal=false;\n        }\n        return outer;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inactiveme(){\n        return!active;\n    }\n    public var hnext:ZPP_Arbiter=null;\n    public function new(){\n        #if NAPE_POOL_STATS arbid=nextarbid++;\n        #end\n    }\n    public var id:Int=0;\n    public var di:Int=0;\n    public var stamp:Int=0;\n    public var up_stamp:Int=0;\n    public var sleep_stamp:Int=0;\n    public var endGenerated:Int=0;\n    public var active:Bool=false;\n    public var cleared:Bool=false;\n    public var sleeping:Bool=false;\n    public var present:Int=0;\n    public var intchange:Bool=false;\n    public var presentable:Bool=false;\n    public var continuous:Bool=false;\n    public var fresh:Bool=false;\n    public var immState:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function acting(){\n        return active&&((immState&ZPP_Flags.id_ImmState_ACCEPT)!=0);\n    }\n    public var invalidated:Bool=false;\n    public var b1:ZPP_Body=null;\n    public var b2:ZPP_Body=null;\n    public var ws1:ZPP_Shape=null;\n    public var ws2:ZPP_Shape=null;\n    public var pair:ZPP_AABBPair=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function swap_features(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                type==COL;\n            };\n            if(!res)throw \"assert(\"+\"type==COL\"+\") :: \"+(\"Arbiter::swap_features\");\n            #end\n        };\n        {\n            var t=b1;\n            b1=b2;\n            b2=t;\n        };\n        {\n            var t=ws1;\n            ws1=ws2;\n            ws2=t;\n        };\n        {\n            var t=colarb.s1;\n            colarb.s1=colarb.s2;\n            colarb.s2=t;\n        };\n    }\n    public var type:Int=0;\n     public static var COL=1;\n     public static var FLUID=4;\n     public static var SENSOR=2;\n    static public var types:Array<ArbiterType>=[null,ArbiterType.COLLISION,ArbiterType.SENSOR,null,ArbiterType.FLUID];\n    public var colarb:ZPP_ColArbiter=null;\n    public var fluidarb:ZPP_FluidArbiter=null;\n    public var sensorarb:ZPP_SensorArbiter=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function lazyRetire(s:ZPP_Space,b:ZPP_Body=null){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !cleared;\n            };\n            if(!res)throw \"assert(\"+\"!cleared\"+\") :: \"+(\"Arbiter::lazyRetire\");\n            #end\n        };\n        cleared=true;\n        if(b==null||(b2==b))b1.arbiters.inlined_remove(this);\n        if(b==null||(b1==b))b2.arbiters.inlined_remove(this);\n        if(pair!=null){\n            pair.arb=null;\n            pair=null;\n        }\n        active=false;\n        s.f_arbiters.modified=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function sup_assign(s1:ZPP_Shape,s2:ZPP_Shape,id:Int,di:Int){\n        b1=s1.body;\n        ws1=s1;\n        b2=s2.body;\n        ws2=s2;\n        this.id=id;\n        this.di=di;\n        b1.arbiters.inlined_add(this);\n        b2.arbiters.inlined_add(this);\n        active=true;\n        present=0;\n        cleared=false;\n        sleeping=false;\n        fresh=false;\n        presentable=false;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function sup_retire(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                b1!=null;\n            };\n            if(!res)throw \"assert(\"+\"b1!=null\"+\") :: \"+(\"Arbiter::sup_retire\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                b2!=null;\n            };\n            if(!res)throw \"assert(\"+\"b2!=null\"+\") :: \"+(\"Arbiter::sup_retire\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                present==0;\n            };\n            if(!res)throw \"assert(\"+\"present==0\"+\") :: \"+(\"Arbiter::sup_retire cbsets present\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !intchange;\n            };\n            if(!res)throw \"assert(\"+\"!intchange\"+\") :: \"+(\"Arbiter::sup_retire intchange\");\n            #end\n        };\n        if(!cleared){\n            b1.arbiters.inlined_remove(this);\n            b2.arbiters.inlined_remove(this);\n            if(pair!=null){\n                pair.arb=null;\n                pair=null;\n            }\n        }\n        b1=b2=null;\n        active=false;\n        intchange=false;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_SensorArbiter extends ZPP_Arbiter{\n    public var next:ZPP_SensorArbiter=null;\n    static public var zpp_pool:ZPP_SensorArbiter=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                pair==null;\n            };\n            if(!res)throw \"assert(\"+\"pair==null\"+\") :: \"+(\"AABBNode pair exists on arb going out of pool? (sensor)\");\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                pair==null;\n            };\n            if(!res)throw \"assert(\"+\"pair==null\"+\") :: \"+(\"AABBNode pair exists on arb going into pool? (sensor)\");\n            #end\n        };\n    }\n    public function new(){\n        super();\n        type=ZPP_Arbiter.SENSOR;\n        sensorarb=this;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function assign(s1:ZPP_Shape,s2:ZPP_Shape,id:Int,di:Int){\n        sup_assign(s1,s2,id,di);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function retire(){\n        sup_retire();\n        {\n            var o=this;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_SensorArbiter\"+\", in obj: \"+\"this\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_SensorArbiter.zpp_pool;\n            ZPP_SensorArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_SensorArbiter.POOL_CNT++;\n            ZPP_SensorArbiter.POOL_SUB++;\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function makemutable(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function makeimmutable(){}\n}\n#if nape_swc@:keep #end\nclass ZPP_FluidArbiter extends ZPP_Arbiter{\n    public var outer_zn:FluidArbiter=null;\n    public var next:ZPP_FluidArbiter=null;\n    static public var zpp_pool:ZPP_FluidArbiter=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                pair==null;\n            };\n            if(!res)throw \"assert(\"+\"pair==null\"+\") :: \"+(\"AABBNode pair exists on arb going out of pool? (fluid)\");\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                pair==null;\n            };\n            if(!res)throw \"assert(\"+\"pair==null\"+\") :: \"+(\"AABBNode pair exists on arb going into pool? (fluid)\");\n            #end\n        };\n    }\n    public var centroidx:Float=0.0;\n    public var centroidy:Float=0.0;\n    public var overlap:Float=0.0;\n    public var r1x:Float=0.0;\n    public var r1y:Float=0.0;\n    public var r2x:Float=0.0;\n    public var r2y:Float=0.0;\n    public var nodrag:Bool=false;\n    public var wMass:Float=0.0;\n    public var adamp:Float=0.0;\n    public var agamma:Float=0.0;\n    public var vMassa:Float=0.0;\n    public var vMassb:Float=0.0;\n    public var vMassc:Float=0.0;\n    public var dampx:Float=0.0;\n    public var dampy:Float=0.0;\n    public var lgamma:Float=0.0;\n    public var nx:Float=0.0;\n    public var ny:Float=0.0;\n    public var buoyx:Float=0.0;\n    public var buoyy:Float=0.0;\n    private function position_validate(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(inactiveme())throw \"Error: Arbiter not currently in use\";\n        #end\n        {\n            wrap_position.zpp_inner.x=centroidx;\n            wrap_position.zpp_inner.y=centroidy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_position.zpp_inner.x!=wrap_position.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_position.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_position.zpp_inner.\"+\",in x: \"+\"centroidx\"+\",in y: \"+\"centroidy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_position.zpp_inner.y!=wrap_position.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_position.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_position.zpp_inner.\"+\",in x: \"+\"centroidx\"+\",in y: \"+\"centroidy\"+\")\");\n                #end\n            };\n        };\n    }\n    private function position_invalidate(x:ZPP_Vec2){\n        {\n            centroidx=x.x;\n            centroidy=x.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((centroidx!=centroidx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(centroidx)\"+\") :: \"+(\"vec_set(in n: \"+\"centroid\"+\",in x: \"+\"x.x\"+\",in y: \"+\"x.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((centroidy!=centroidy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(centroidy)\"+\") :: \"+(\"vec_set(in n: \"+\"centroid\"+\",in x: \"+\"x.x\"+\",in y: \"+\"x.y\"+\")\");\n                #end\n            };\n        };\n    }\n    public var wrap_position:Vec2=null;\n    public function getposition(){\n        wrap_position=Vec2.get();\n        wrap_position.zpp_inner._inuse=true;\n        wrap_position.zpp_inner._immutable=!mutable;\n        wrap_position.zpp_inner._validate=position_validate;\n        wrap_position.zpp_inner._invalidate=position_invalidate;\n    }\n    public function new(){\n        super();\n        type=ZPP_Arbiter.FLUID;\n        fluidarb=this;\n        {\n            buoyx=0;\n            buoyy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((buoyx!=buoyx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(buoyx)\"+\") :: \"+(\"vec_set(in n: \"+\"buoy\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((buoyy!=buoyy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(buoyy)\"+\") :: \"+(\"vec_set(in n: \"+\"buoy\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        pre_dt=-1.0;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function assign(s1:ZPP_Shape,s2:ZPP_Shape,id:Int,di:Int){\n        sup_assign(s1,s2,id,di);\n        {\n            nx=0;\n            ny=1;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((nx!=nx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(nx)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"0\"+\",in y: \"+\"1\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ny!=ny));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ny)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"0\"+\",in y: \"+\"1\"+\")\");\n                #end\n            };\n        };\n        {\n            dampx=0;\n            dampy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((dampx!=dampx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(dampx)\"+\") :: \"+(\"vec_set(in n: \"+\"damp\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((dampy!=dampy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(dampy)\"+\") :: \"+(\"vec_set(in n: \"+\"damp\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        adamp=0.0;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function retire(){\n        sup_retire();\n        {\n            var o=this;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_FluidArbiter\"+\", in obj: \"+\"this\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_FluidArbiter.zpp_pool;\n            ZPP_FluidArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_FluidArbiter.POOL_CNT++;\n            ZPP_FluidArbiter.POOL_SUB++;\n            #end\n        };\n        pre_dt=-1.0;\n    }\n    public var mutable:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function makemutable(){\n        mutable=true;\n        if(wrap_position!=null)wrap_position.zpp_inner._immutable=false;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function makeimmutable(){\n        mutable=false;\n        if(wrap_position!=null)wrap_position.zpp_inner._immutable=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inject(area:Float,cx:Float,cy:Float){\n        overlap=area;\n        {\n            centroidx=cx;\n            centroidy=cy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((centroidx!=centroidx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(centroidx)\"+\") :: \"+(\"vec_set(in n: \"+\"centroid\"+\",in x: \"+\"cx\"+\",in y: \"+\"cy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((centroidy!=centroidy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(centroidy)\"+\") :: \"+(\"vec_set(in n: \"+\"centroid\"+\",in x: \"+\"cx\"+\",in y: \"+\"cy\"+\")\");\n                #end\n            };\n        };\n    }\n    public var pre_dt:Float=0.0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function preStep(s:ZPP_Space,dt:Float){\n        if(pre_dt==-1.0)pre_dt=dt;\n        var dtratio=dt/pre_dt;\n        pre_dt=dt;\n        {\n            r1x=centroidx-b1.posx;\n            r1y=centroidy-b1.posy;\n        };\n        {\n            r2x=centroidx-b2.posx;\n            r2y=centroidy-b2.posy;\n        };\n        var g1x:Float=0.0;\n        var g1y:Float=0.0;\n        if(ws1.fluidEnabled&&ws1.fluidProperties.wrap_gravity!=null){\n            g1x=ws1.fluidProperties.gravityx;\n            g1y=ws1.fluidProperties.gravityy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((g1x!=g1x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(g1x)\"+\") :: \"+(\"vec_set(in n: \"+\"g1\"+\",in x: \"+\"ws1.fluidProperties.gravityx\"+\",in y: \"+\"ws1.fluidProperties.gravityy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((g1y!=g1y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(g1y)\"+\") :: \"+(\"vec_set(in n: \"+\"g1\"+\",in x: \"+\"ws1.fluidProperties.gravityx\"+\",in y: \"+\"ws1.fluidProperties.gravityy\"+\")\");\n                #end\n            };\n        }\n        else{\n            g1x=s.gravityx;\n            g1y=s.gravityy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((g1x!=g1x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(g1x)\"+\") :: \"+(\"vec_set(in n: \"+\"g1\"+\",in x: \"+\"s.gravityx\"+\",in y: \"+\"s.gravityy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((g1y!=g1y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(g1y)\"+\") :: \"+(\"vec_set(in n: \"+\"g1\"+\",in x: \"+\"s.gravityx\"+\",in y: \"+\"s.gravityy\"+\")\");\n                #end\n            };\n        };\n        var g2x:Float=0.0;\n        var g2y:Float=0.0;\n        if(ws2.fluidEnabled&&ws2.fluidProperties.wrap_gravity!=null){\n            g2x=ws2.fluidProperties.gravityx;\n            g2y=ws2.fluidProperties.gravityy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((g2x!=g2x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(g2x)\"+\") :: \"+(\"vec_set(in n: \"+\"g2\"+\",in x: \"+\"ws2.fluidProperties.gravityx\"+\",in y: \"+\"ws2.fluidProperties.gravityy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((g2y!=g2y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(g2y)\"+\") :: \"+(\"vec_set(in n: \"+\"g2\"+\",in x: \"+\"ws2.fluidProperties.gravityx\"+\",in y: \"+\"ws2.fluidProperties.gravityy\"+\")\");\n                #end\n            };\n        }\n        else{\n            g2x=s.gravityx;\n            g2y=s.gravityy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((g2x!=g2x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(g2x)\"+\") :: \"+(\"vec_set(in n: \"+\"g2\"+\",in x: \"+\"s.gravityx\"+\",in y: \"+\"s.gravityy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((g2y!=g2y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(g2y)\"+\") :: \"+(\"vec_set(in n: \"+\"g2\"+\",in x: \"+\"s.gravityx\"+\",in y: \"+\"s.gravityy\"+\")\");\n                #end\n            };\n        };\n        var buoyx:Float=0;\n        var buoyy:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((buoyx!=buoyx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(buoyx)\"+\") :: \"+(\"vec_new(in n: \"+\"buoy\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((buoyy!=buoyy));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(buoyy)\"+\") :: \"+(\"vec_new(in n: \"+\"buoy\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        if(ws1.fluidEnabled&&ws2.fluidEnabled){\n            var mass1=overlap*ws1.fluidProperties.density;\n            var mass2=overlap*ws2.fluidProperties.density;\n            if(mass1>mass2){\n                var t=(mass1+mass2);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"buoy\"+\",in b: \"+\"g1\"+\",in s: \"+\"mass1+mass2\"+\")\");\n                    #end\n                };\n                buoyx-=g1x*t;\n                buoyy-=g1y*t;\n            };\n            else if(mass1<mass2){\n                var t=(mass1+mass2);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"buoy\"+\",in b: \"+\"g2\"+\",in s: \"+\"mass1+mass2\"+\")\");\n                    #end\n                };\n                buoyx+=g2x*t;\n                buoyy+=g2y*t;\n            };\n            else{\n                var gx:Float=0.0;\n                var gy:Float=0.0;\n                {\n                    gx=g1x+g2x;\n                    gy=g1y+g2y;\n                };\n                {\n                    var t=(0.5);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"g\"+\",in s: \"+\"0.5\"+\")\");\n                        #end\n                    };\n                    gx*=t;\n                    gy*=t;\n                };\n                if((ws1.worldCOMx*gx+ws1.worldCOMy*gy)>(ws2.worldCOMx*gx+ws2.worldCOMy*gy)){\n                    var t=(mass1+mass2);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"buoy\"+\",in b: \"+\"g\"+\",in s: \"+\"mass1+mass2\"+\")\");\n                        #end\n                    };\n                    buoyx-=gx*t;\n                    buoyy-=gy*t;\n                };\n                else{\n                    var t=(mass1+mass2);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"buoy\"+\",in b: \"+\"g\"+\",in s: \"+\"mass1+mass2\"+\")\");\n                        #end\n                    };\n                    buoyx+=gx*t;\n                    buoyy+=gy*t;\n                };\n            }\n        }\n        else if(ws1.fluidEnabled){\n            var mass=overlap*ws1.fluidProperties.density;\n            {\n                var t=(mass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"buoy\"+\",in b: \"+\"g1\"+\",in s: \"+\"mass\"+\")\");\n                    #end\n                };\n                buoyx-=g1x*t;\n                buoyy-=g1y*t;\n            };\n        }\n        else if(ws2.fluidEnabled){\n            var mass=overlap*ws2.fluidProperties.density;\n            {\n                var t=(mass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"buoy\"+\",in b: \"+\"g2\"+\",in s: \"+\"mass\"+\")\");\n                    #end\n                };\n                buoyx+=g2x*t;\n                buoyy+=g2y*t;\n            };\n        }\n        {\n            var t=(dt);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((t!=t));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"buoy\"+\",in s: \"+\"dt\"+\")\");\n                #end\n            };\n            buoyx*=t;\n            buoyy*=t;\n        };\n        {\n            this.buoyx=buoyx;\n            this.buoyy=buoyy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.buoyx!=this.buoyx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.buoyx)\"+\") :: \"+(\"vec_set(in n: \"+\"this.buoy\"+\",in x: \"+\"buoyx\"+\",in y: \"+\"buoyy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.buoyy!=this.buoyy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.buoyy)\"+\") :: \"+(\"vec_set(in n: \"+\"this.buoy\"+\",in x: \"+\"buoyx\"+\",in y: \"+\"buoyy\"+\")\");\n                #end\n            };\n        };\n        if(b1.isDynamic()){\n            {\n                var t=(b1.imass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.vel\"+\",in b: \"+\"buoy\"+\",in s: \"+\"b1.imass\"+\")\");\n                    #end\n                };\n                b1.velx-=buoyx*t;\n                b1.vely-=buoyy*t;\n            };\n            b1.angvel-=(buoyy*r1x-buoyx*r1y)*b1.iinertia;\n        }\n        if(b2.isDynamic()){\n            {\n                var t=(b2.imass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.vel\"+\",in b: \"+\"buoy\"+\",in s: \"+\"b2.imass\"+\")\");\n                    #end\n                };\n                b2.velx+=buoyx*t;\n                b2.vely+=buoyy*t;\n            };\n            b2.angvel+=(buoyy*r2x-buoyx*r2y)*b2.iinertia;\n        }\n        if((!ws1.fluidEnabled||ws1.fluidProperties.viscosity==0)&&(!ws2.fluidEnabled||ws2.fluidProperties.viscosity==0)){\n            nodrag=true;\n            {\n                dampx=0;\n                dampy=0;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((dampx!=dampx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(dampx)\"+\") :: \"+(\"vec_set(in n: \"+\"damp\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((dampy!=dampy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(dampy)\"+\") :: \"+(\"vec_set(in n: \"+\"damp\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                    #end\n                };\n            };\n            adamp=0;\n        }\n        else{\n            nodrag=false;\n            var tViscosity=0.0;\n            if(ws1.fluidEnabled){\n                ws2.validate_angDrag();\n                tViscosity+=ws1.fluidProperties.viscosity*ws2.angDrag*overlap/ws2.area;\n            }\n            if(ws2.fluidEnabled){\n                ws1.validate_angDrag();\n                tViscosity+=ws2.fluidProperties.viscosity*ws1.angDrag*overlap/ws1.area;\n            }\n            if(tViscosity!=0){\n                var iSum=b1.sinertia+b2.sinertia;\n                if(iSum!=0)wMass=1/iSum;\n                else wMass=0.0;\n                var biasCoef;\n                tViscosity*=0.0004;\n                wMass*={\n                    var omega=2*Math.PI*tViscosity;\n                    agamma=1/(dt*omega*(2*1+omega*dt));\n                    var ig=1/(1+agamma);\n                    biasCoef=dt*omega*omega*agamma;\n                    agamma*=ig;\n                    ig;\n                };\n            }\n            else{\n                wMass=0.0;\n                agamma=0.0;\n            }\n            var vrnx:Float=(b2.velx+b2.kinvelx-r2y*(b2.angvel+b2.kinangvel))-(b1.velx+b1.kinvelx-r1y*(b2.angvel+b2.kinangvel));\n            var vrny:Float=(b2.vely+b2.kinvely+r2x*(b2.angvel+b2.kinangvel))-(b1.vely+b1.kinvely+r1x*(b1.angvel+b1.kinangvel));\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((vrnx!=vrnx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(vrnx)\"+\") :: \"+(\"vec_new(in n: \"+\"vrn\"+\",in x: \"+\"(b2.velx+b2.kinvelx-r2y*(b2.angvel+b2.kinangvel))-(b1.velx+b1.kinvelx-r1y*(b2.angvel+b2.kinangvel))\"+\",in y: \"+\"(b2.vely+b2.kinvely+r2x*(b2.angvel+b2.kinangvel))-(b1.vely+b1.kinvely+r1x*(b1.angvel+b1.kinangvel))\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((vrny!=vrny));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(vrny)\"+\") :: \"+(\"vec_new(in n: \"+\"vrn\"+\",in x: \"+\"(b2.velx+b2.kinvelx-r2y*(b2.angvel+b2.kinangvel))-(b1.velx+b1.kinvelx-r1y*(b2.angvel+b2.kinangvel))\"+\",in y: \"+\"(b2.vely+b2.kinvely+r2x*(b2.angvel+b2.kinangvel))-(b1.vely+b1.kinvely+r1x*(b1.angvel+b1.kinangvel))\"+\")\");\n                #end\n            };\n            if((vrnx*vrnx+vrny*vrny)<(Config.epsilon*Config.epsilon)){}\n            else{\n                {\n                    var d=(vrnx*vrnx+vrny*vrny);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            d!=0.0;\n                        };\n                        if(!res)throw \"assert(\"+\"d!=0.0\"+\") :: \"+(\"vec_normalise(in n: \"+\"vrn\"+\")\");\n                        #end\n                    };\n                    var imag=ZPP_Math.invsqrt(d);\n                    {\n                        var t=(imag);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"vrn\"+\",in s: \"+\"imag\"+\")\");\n                            #end\n                        };\n                        vrnx*=t;\n                        vrny*=t;\n                    };\n                };\n                {\n                    nx=vrnx;\n                    ny=vrny;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((nx!=nx));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(nx)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"vrnx\"+\",in y: \"+\"vrny\"+\")\");\n                        #end\n                    };\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((ny!=ny));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(ny)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"vrnx\"+\",in y: \"+\"vrny\"+\")\");\n                        #end\n                    };\n                };\n            }\n            var tViscosity=0.0;\n            if(ws1.fluidEnabled){\n                var f=-ws1.fluidProperties.viscosity*overlap/ws2.area;\n                if(ws2.type==ZPP_Flags.id_ShapeType_CIRCLE)tViscosity-=f*ws2.circle.radius*Config.fluidLinearDrag/(2*ws2.circle.radius*Math.PI);\n                else{\n                    var poly=ws2.polygon;\n                    var bord=0.0;\n                    var acc=0.0;\n                    {\n                        var cx_ite=poly.edges.begin();\n                        while(cx_ite!=null){\n                            var ex=cx_ite.elem();\n                            {\n                                bord+=ex.length;\n                                var fact=f*ex.length*(ex.gnormx*nx+ex.gnormy*ny);\n                                if(fact>0)fact=fact*=-Config.fluidVacuumDrag;\n                                acc-=fact*0.5*Config.fluidLinearDrag;\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    tViscosity+=acc/bord;\n                }\n            }\n            if(ws2.fluidEnabled){\n                var f=-ws2.fluidProperties.viscosity*overlap/ws1.area;\n                if(ws1.type==ZPP_Flags.id_ShapeType_CIRCLE)tViscosity-=f*ws1.circle.radius*Config.fluidLinearDrag/(2*ws1.circle.radius*Math.PI);\n                else{\n                    var poly=ws1.polygon;\n                    var bord=0.0;\n                    var acc=0.0;\n                    {\n                        var cx_ite=poly.edges.begin();\n                        while(cx_ite!=null){\n                            var ex=cx_ite.elem();\n                            {\n                                bord+=ex.length;\n                                var fact=f*ex.length*(ex.gnormx*nx+ex.gnormy*ny);\n                                if(fact>0)fact=fact*=-Config.fluidVacuumDrag;\n                                acc-=fact*0.5*Config.fluidLinearDrag;\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    tViscosity+=acc/bord;\n                }\n            }\n            if(tViscosity!=0){\n                var m=b1.smass+b2.smass;\n                var Ka:Float=0.0;\n                var Kb:Float=0.0;\n                var Kc:Float=0.0;\n                {\n                    Ka=m;\n                    Kb=0;\n                    Kc=m;\n                };\n                if(b1.sinertia!=0){\n                    var X=r1x*b1.sinertia;\n                    var Y=r1y*b1.sinertia;\n                    {\n                        Ka+=Y*r1y;\n                        Kb+=-Y*r1x;\n                        Kc+=X*r1x;\n                    };\n                };\n                if(b2.sinertia!=0){\n                    var X=r2x*b2.sinertia;\n                    var Y=r2y*b2.sinertia;\n                    {\n                        Ka+=Y*r2y;\n                        Kb+=-Y*r2x;\n                        Kc+=X*r2x;\n                    };\n                };\n                {\n                    var det=(Ka*Kc-Kb*Kb);\n                    if((det!=det)){\n                        Ka=Kb=Kc=0;\n                        3;\n                    }\n                    else if(det==0){\n                        var flag=0;\n                        if(Ka!=0)Ka=1/Ka;\n                        else{\n                            Ka=0;\n                            flag|=1;\n                        }\n                        if(Kc!=0)Kc=1/Kc;\n                        else{\n                            Kc=0;\n                            flag|=2;\n                        }\n                        Kb=0;\n                        flag;\n                    }\n                    else{\n                        det=1/det;\n                        var t=Kc*det;\n                        Kc=Ka*det;\n                        Ka=t;\n                        Kb*=-det;\n                        0;\n                    }\n                };\n                {\n                    vMassa=Ka;\n                    vMassb=Kb;\n                    vMassc=Kc;\n                };\n                var biasCoef;\n                {\n                    var X=({\n                        var omega=2*Math.PI*tViscosity;\n                        lgamma=1/(dt*omega*(2*1+omega*dt));\n                        var ig=1/(1+lgamma);\n                        biasCoef=dt*omega*omega*lgamma;\n                        lgamma*=ig;\n                        ig;\n                    });\n                    vMassa*=X;\n                    vMassb*=X;\n                    vMassc*=X;\n                };\n            }\n            else{\n                {\n                    vMassa=0;\n                    vMassb=0;\n                    vMassc=0;\n                };\n                lgamma=0.0;\n            }\n        }\n        {\n            var t=(dtratio);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((t!=t));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"damp\"+\",in s: \"+\"dtratio\"+\")\");\n                #end\n            };\n            dampx*=t;\n            dampy*=t;\n        };\n        adamp*=dtratio;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function warmStart(){\n        {\n            var t=(b1.imass);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((t!=t));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.vel\"+\",in b: \"+\"damp\"+\",in s: \"+\"b1.imass\"+\")\");\n                #end\n            };\n            b1.velx-=dampx*t;\n            b1.vely-=dampy*t;\n        };\n        {\n            var t=(b2.imass);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((t!=t));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.vel\"+\",in b: \"+\"damp\"+\",in s: \"+\"b2.imass\"+\")\");\n                #end\n            };\n            b2.velx+=dampx*t;\n            b2.vely+=dampy*t;\n        };\n        b1.angvel-=b1.iinertia*(dampy*r1x-dampx*r1y);\n        b2.angvel+=b2.iinertia*(dampy*r2x-dampx*r2y);\n        b1.angvel-=adamp*b1.iinertia;\n        b2.angvel+=adamp*b2.iinertia;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function applyImpulseVel(){\n        if(!nodrag){\n            var w1=b1.angvel+b1.kinangvel;\n            var w2=b2.angvel+b2.kinangvel;\n            var jx:Float=(b1.velx+b1.kinvelx-r1y*w1)-(b2.velx+b2.kinvelx-r2y*w2);\n            var jy:Float=(b1.vely+b1.kinvely+r1x*w1)-(b2.vely+b2.kinvely+r2x*w2);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((jx!=jx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(jx)\"+\") :: \"+(\"vec_new(in n: \"+\"j\"+\",in x: \"+\"(b1.velx+b1.kinvelx-r1y*w1)-(b2.velx+b2.kinvelx-r2y*w2)\"+\",in y: \"+\"(b1.vely+b1.kinvely+r1x*w1)-(b2.vely+b2.kinvely+r2x*w2)\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((jy!=jy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(jy)\"+\") :: \"+(\"vec_new(in n: \"+\"j\"+\",in x: \"+\"(b1.velx+b1.kinvelx-r1y*w1)-(b2.velx+b2.kinvelx-r2y*w2)\"+\",in y: \"+\"(b1.vely+b1.kinvely+r1x*w1)-(b2.vely+b2.kinvely+r2x*w2)\"+\")\");\n                #end\n            };\n            {\n                var t=vMassa*jx+vMassb*jy;\n                jy=vMassb*jx+vMassc*jy;\n                jx=t;\n            };\n            {\n                var t=(lgamma);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"j\"+\",in b: \"+\"damp\"+\",in s: \"+\"lgamma\"+\")\");\n                    #end\n                };\n                jx-=dampx*t;\n                jy-=dampy*t;\n            };\n            {\n                var t=(1.0);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"damp\"+\",in b: \"+\"j\"+\",in s: \"+\"1.0\"+\")\");\n                    #end\n                };\n                dampx+=jx*t;\n                dampy+=jy*t;\n            };\n            {\n                var t=(b1.imass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.vel\"+\",in b: \"+\"j\"+\",in s: \"+\"b1.imass\"+\")\");\n                    #end\n                };\n                b1.velx-=jx*t;\n                b1.vely-=jy*t;\n            };\n            {\n                var t=(b2.imass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.vel\"+\",in b: \"+\"j\"+\",in s: \"+\"b2.imass\"+\")\");\n                    #end\n                };\n                b2.velx+=jx*t;\n                b2.vely+=jy*t;\n            };\n            b1.angvel-=b1.iinertia*(jy*r1x-jx*r1y);\n            b2.angvel+=b2.iinertia*(jy*r2x-jx*r2y);\n            var j_damp=(w1-w2)*wMass-adamp*agamma;\n            adamp+=j_damp;\n            b1.angvel-=j_damp*b1.iinertia;\n            b2.angvel+=j_damp*b2.iinertia;\n        }\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_ColArbiter extends ZPP_Arbiter{\n    public var outer_zn:CollisionArbiter=null;\n    public var dyn_fric:Float=0.0;\n    public var stat_fric:Float=0.0;\n    public var restitution:Float=0.0;\n    public var rfric:Float=0.0;\n    public var userdef_dyn_fric:Bool=false;\n    public var userdef_stat_fric:Bool=false;\n    public var userdef_restitution:Bool=false;\n    public var userdef_rfric:Bool=false;\n    public var s1:ZPP_Shape=null;\n    public var s2:ZPP_Shape=null;\n    public var contacts:ZPP_Contact=null;\n    public var wrap_contacts:ContactList=null;\n    public var innards:ZPP_IContact=null;\n    public var nx:Float=0.0;\n    public var ny:Float=0.0;\n    private function normal_validate(){\n        if(cleared)throw \"Error: Arbiter not currently in use\";\n        {\n            wrap_normal.zpp_inner.x=nx;\n            wrap_normal.zpp_inner.y=ny;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_normal.zpp_inner.x!=wrap_normal.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_normal.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_normal.zpp_inner.\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_normal.zpp_inner.y!=wrap_normal.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_normal.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_normal.zpp_inner.\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                #end\n            };\n        };\n        if(ws1.id>ws2.id){\n            {\n                wrap_normal.zpp_inner.x=-wrap_normal.zpp_inner.x;\n                wrap_normal.zpp_inner.y=-wrap_normal.zpp_inner.y;\n            };\n        }\n    }\n    public var wrap_normal:Vec2=null;\n    public function getnormal(){\n        wrap_normal=Vec2.get(0,0);\n        wrap_normal.zpp_inner._immutable=true;\n        wrap_normal.zpp_inner._inuse=true;\n        wrap_normal.zpp_inner._validate=normal_validate;\n    }\n    var kMassa:Float=0.0;\n    var kMassb:Float=0.0;\n    var kMassc:Float=0.0;\n    var Ka:Float=0.0;\n    var Kb:Float=0.0;\n    var Kc:Float=0.0;\n    public var rMass:Float=0.0;\n    public var jrAcc:Float=0.0;\n    var rn1a:Float=0.0;\n    var rt1a:Float=0.0;\n    var rn1b:Float=0.0;\n    var rt1b:Float=0.0;\n    var rn2a:Float=0.0;\n    var rt2a:Float=0.0;\n    var rn2b:Float=0.0;\n    var rt2b:Float=0.0;\n    var k1x:Float=0.0;\n    var k1y:Float=0.0;\n    var k2x:Float=0.0;\n    var k2y:Float=0.0;\n    public var surfacex:Float=0.0;\n    public var surfacey:Float=0.0;\n    public static inline var FACE1=0;\n    public static inline var FACE2=1;\n    public static inline var CIRCLE=2;\n    public var ptype:Int;\n    public var lnormx:Float=0.0;\n    public var lnormy:Float=0.0;\n    public var lproj:Float=0.0;\n    public var radius:Float=0.0;\n    public var rev:Bool=false;\n    var biasCoef:Float=0.0;\n    public var __ref_edge1:ZPP_Edge=null;\n    public var __ref_edge2:ZPP_Edge=null;\n    public var __ref_vertex:Int=0;\n    public var c1:ZPP_IContact=null;\n    public var oc1:ZPP_Contact=null;\n    public var c2:ZPP_IContact=null;\n    public var oc2:ZPP_Contact=null;\n    public var hc2:Bool=false;\n    public var hpc2:Bool=false;\n    public var next:ZPP_ColArbiter=null;\n    static public var zpp_pool:ZPP_ColArbiter=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public function new(){\n        super();\n        pre_dt=-1.0;\n        contacts=new ZPP_Contact();\n        innards=new ZPP_IContact();\n        type=ZPP_Arbiter.COL;\n        colarb=this;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                pair==null;\n            };\n            if(!res)throw \"assert(\"+\"pair==null\"+\") :: \"+(\"AABBNode exists on col arbiter going out of pool?\");\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                contacts.empty();\n            };\n            if(!res)throw \"assert(\"+\"contacts.empty()\"+\") :: \"+(\"still has contacts on free?\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                pair==null;\n            };\n            if(!res)throw \"assert(\"+\"pair==null\"+\") :: \"+(\"AABBNode exists on col arbiter going into pool?\");\n            #end\n        };\n        userdef_dyn_fric=false;\n        userdef_stat_fric=false;\n        userdef_restitution=false;\n        userdef_rfric=false;\n        __ref_edge1=__ref_edge2=null;\n    }\n    public var stat:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function injectContact(px:Float,py:Float,nx:Float,ny:Float,dist:Float,hash:Int,posOnly=false){\n        var c:ZPP_Contact=null;\n        {\n            var cx_ite=contacts.begin();\n            while(cx_ite!=null){\n                var cur=cx_ite.elem();\n                if(hash==cur.hash){\n                    c=cur;\n                    break;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(c==null){\n            {\n                if(ZPP_Contact.zpp_pool==null){\n                    c=new ZPP_Contact();\n                    #if NAPE_POOL_STATS ZPP_Contact.POOL_TOT++;\n                    ZPP_Contact.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    c=ZPP_Contact.zpp_pool;\n                    ZPP_Contact.zpp_pool=c.next;\n                    c.next=null;\n                    #if NAPE_POOL_STATS ZPP_Contact.POOL_CNT--;\n                    ZPP_Contact.POOL_ADD++;\n                    #end\n                }\n                c.alloc();\n            };\n            var ci=c.inner;\n            ci.jnAcc=ci.jtAcc=0;\n            c.hash=hash;\n            c.fresh=true;\n            c.arbiter=this;\n            jrAcc=0;\n            contacts.inlined_add(c);\n            innards.add(ci);\n        }\n        else c.fresh=false;\n        {\n            c.px=px;\n            c.py=py;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((c.px!=c.px));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(c.px)\"+\") :: \"+(\"vec_set(in n: \"+\"c.p\"+\",in x: \"+\"px\"+\",in y: \"+\"py\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((c.py!=c.py));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(c.py)\"+\") :: \"+(\"vec_set(in n: \"+\"c.p\"+\",in x: \"+\"px\"+\",in y: \"+\"py\"+\")\");\n                #end\n            };\n        };\n        {\n            this.nx=nx;\n            this.ny=ny;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.nx!=this.nx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.nx)\"+\") :: \"+(\"vec_set(in n: \"+\"this.n\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.ny!=this.ny));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.ny)\"+\") :: \"+(\"vec_set(in n: \"+\"this.n\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                #end\n            };\n        };\n        c.dist=dist;\n        c.stamp=stamp;\n        c.posOnly=posOnly;\n        return c;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function assign(s1:ZPP_Shape,s2:ZPP_Shape,id:Int,di:Int){\n        sup_assign(s1,s2,id,di);\n        this.s1=s1;\n        this.s2=s2;\n        calcProperties();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function calcProperties(){\n        if(!userdef_restitution){\n            if(s1.material.elasticity<=ZPP_Const.NEGINF()||s2.material.elasticity<=ZPP_Const.NEGINF())restitution=0;\n            else if(s1.material.elasticity>=ZPP_Const.POSINF()||s2.material.elasticity>=ZPP_Const.POSINF())restitution=1;\n            else restitution=(s1.material.elasticity+s2.material.elasticity)/2;\n            if(restitution<0)restitution=0;\n            if(restitution>1)restitution=1;\n        }\n        if(!userdef_dyn_fric){\n            dyn_fric=ZPP_Math.sqrt(s1.material.dynamicFriction*s2.material.dynamicFriction);\n        }\n        if(!userdef_stat_fric){\n            stat_fric=ZPP_Math.sqrt(s1.material.staticFriction*s2.material.staticFriction);\n        }\n        if(!userdef_rfric){\n            rfric=ZPP_Math.sqrt(s1.material.rollingFriction*s2.material.rollingFriction);\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_props(){\n        if(invalidated){\n            invalidated=false;\n            calcProperties();\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function retire(){\n        sup_retire();\n        while(!contacts.empty()){\n            {\n                var o=contacts.inlined_pop_unsafe();\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Contact\"+\", in obj: \"+\"contacts.inlined_pop_unsafe()\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_Contact.zpp_pool;\n                ZPP_Contact.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_Contact.POOL_CNT++;\n                ZPP_Contact.POOL_SUB++;\n                #end\n            };\n            innards.inlined_pop();\n        }\n        {\n            var o=this;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ColArbiter\"+\", in obj: \"+\"this\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_ColArbiter.zpp_pool;\n            ZPP_ColArbiter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_ColArbiter.POOL_CNT++;\n            ZPP_ColArbiter.POOL_SUB++;\n            #end\n        };\n        pre_dt=-1.0;\n    }\n    public var mutable:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function makemutable(){\n        mutable=true;\n        if(wrap_normal!=null)wrap_normal.zpp_inner._immutable=false;\n        if(wrap_contacts!=null)wrap_contacts.zpp_inner.immutable=false;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function makeimmutable(){\n        mutable=false;\n        if(wrap_normal!=null)wrap_normal.zpp_inner._immutable=true;\n        if(wrap_contacts!=null)wrap_contacts.zpp_inner.immutable=true;\n    }\n    private function contacts_adder(x:Contact){\n        #if(!NAPE_RELEASE_BUILD)\n        throw \"Error: Cannot add new contacts, information required is far too specific and detailed :)\";\n        #end\n        return false;\n    }\n    private function contacts_subber(x:Contact){\n        var pre=null;\n        var prei=null;\n        var cx_itei=innards.begin();\n        {\n            var cx_ite=contacts.begin();\n            while(cx_ite!=null){\n                var c=cx_ite.elem();\n                {\n                    if(c==x.zpp_inner){\n                        contacts.erase(pre);\n                        innards.erase(prei);\n                        {\n                            var o=c;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    o!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Contact\"+\", in obj: \"+\"c\"+\")\");\n                                #end\n                            };\n                            o.free();\n                            o.next=ZPP_Contact.zpp_pool;\n                            ZPP_Contact.zpp_pool=o;\n                            #if NAPE_POOL_STATS ZPP_Contact.POOL_CNT++;\n                            ZPP_Contact.POOL_SUB++;\n                            #end\n                        };\n                        break;\n                    }\n                    pre=cx_ite;\n                    prei=cx_itei;\n                    cx_itei=cx_itei.next;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function setupcontacts(){\n        wrap_contacts=ZPP_ContactList.get(contacts,true);\n        wrap_contacts.zpp_inner.immutable=!mutable;\n        wrap_contacts.zpp_inner.adder=contacts_adder;\n        wrap_contacts.zpp_inner.dontremove=true;\n        wrap_contacts.zpp_inner.subber=contacts_subber;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function cleanupContacts(){\n        var fst=true;\n        var pre=null;\n        var prei=null;\n        var cx_itei=innards.begin();\n        hc2=false;\n        {\n            var cx_ite=contacts.begin();\n            while(cx_ite!=null){\n                var c=cx_ite.elem();\n                {\n                    if(c.stamp+Config.arbiterExpirationDelay<stamp){\n                        cx_ite=contacts.inlined_erase(pre);\n                        cx_itei=innards.inlined_erase(prei);\n                        {\n                            var o=c;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    o!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Contact\"+\", in obj: \"+\"c\"+\")\");\n                                #end\n                            };\n                            o.free();\n                            o.next=ZPP_Contact.zpp_pool;\n                            ZPP_Contact.zpp_pool=o;\n                            #if NAPE_POOL_STATS ZPP_Contact.POOL_CNT++;\n                            ZPP_Contact.POOL_SUB++;\n                            #end\n                        };\n                        continue;\n                    }\n                    var ci=c.inner;\n                    var pact=c.active;\n                    c.active=c.stamp==stamp;\n                    if(c.active){\n                        if(fst){\n                            fst=false;\n                            c1=ci;\n                            oc1=c;\n                        }\n                        else{\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !hc2;\n                                };\n                                if(!res)throw \"assert(\"+\"!hc2\"+\") :: \"+(\"arbiter has +2 contacts??\");\n                                #end\n                            };\n                            hc2=true;\n                            c2=ci;\n                            oc2=c;\n                        }\n                    }\n                    if(pact!=c.active)contacts.modified=true;\n                    pre=cx_ite;\n                    prei=cx_itei;\n                    cx_itei=cx_itei.next;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(hc2){\n            hpc2=true;\n            if(oc1.posOnly){\n                var tmp=c1;\n                c1=c2;\n                c2=tmp;\n                var tmp2=oc1;\n                oc1=oc2;\n                oc2=tmp2;\n                hc2=false;\n            }\n            else if(oc2.posOnly){\n                hc2=false;\n            }\n            if(oc1.posOnly){\n                fst=true;\n            }\n        }\n        else{\n            hpc2=false;\n        }\n        return fst;\n    }\n    public var pre_dt:Float=0.0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function preStep(dt:Float){\n        validate_props();\n        #if NAPE_TIMES Debug.AACNT++;\n        #end\n        if(pre_dt==-1.0)pre_dt=dt;\n        var dtratio=dt/pre_dt;\n        pre_dt=dt;\n        var mass_sum=b1.smass+b2.smass;\n        hc2=false;\n        var fst=true;\n        var statType=(!b1.isDynamic()||!b2.isDynamic());\n        var bias=(statType?(continuous?Config.contactContinuousStaticBiasCoef:Config.contactStaticBiasCoef):(continuous?Config.contactContinuousBiasCoef:Config.contactBiasCoef));\n        biasCoef=bias;\n        continuous=false;\n        var pre=null;\n        var prei=null;\n        var cx_itei=innards.begin();\n        {\n            var cx_ite=contacts.begin();\n            while(cx_ite!=null){\n                var c=cx_ite.elem();\n                {\n                    if(c.stamp+Config.arbiterExpirationDelay<stamp){\n                        cx_ite=contacts.inlined_erase(pre);\n                        cx_itei=innards.inlined_erase(prei);\n                        {\n                            var o=c;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    o!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Contact\"+\", in obj: \"+\"c\"+\")\");\n                                #end\n                            };\n                            o.free();\n                            o.next=ZPP_Contact.zpp_pool;\n                            ZPP_Contact.zpp_pool=o;\n                            #if NAPE_POOL_STATS ZPP_Contact.POOL_CNT++;\n                            ZPP_Contact.POOL_SUB++;\n                            #end\n                        };\n                        continue;\n                    }\n                    #if NAPE_TIMES Debug.CCNT++;\n                    #end\n                    var ci=c.inner;\n                    var pact=c.active;\n                    c.active=c.stamp==stamp;\n                    if(c.active){\n                        #if NAPE_TIMES Debug.ACCNT++;\n                        #end\n                        if(fst){\n                            fst=false;\n                            c1=ci;\n                            oc1=c;\n                        }\n                        else{\n                            hc2=true;\n                            c2=ci;\n                            oc2=c;\n                        }\n                        {\n                            ci.r2x=c.px-b2.posx;\n                            ci.r2y=c.py-b2.posy;\n                        };\n                        {\n                            ci.r1x=c.px-b1.posx;\n                            ci.r1y=c.py-b1.posy;\n                        };\n                        var kt=mass_sum+b2.sinertia*ZPP_Math.sqr((ci.r2x*nx+ci.r2y*ny));\n                        kt+=b1.sinertia*ZPP_Math.sqr((ci.r1x*nx+ci.r1y*ny));\n                        ci.tMass=if(kt<Config.epsilon*Config.epsilon)0 else 1.0/kt;\n                        var nt=mass_sum+b2.sinertia*ZPP_Math.sqr((ny*ci.r2x-nx*ci.r2y));\n                        nt+=b1.sinertia*ZPP_Math.sqr((ny*ci.r1x-nx*ci.r1y));\n                        ci.nMass=if(nt<Config.epsilon*Config.epsilon)0 else 1.0/nt;\n                        var vrx:Float=0.0;\n                        var vry:Float=0.0;\n                        {\n                            var ang=b2.angvel+b2.kinangvel;\n                            vrx=(b2.velx+b2.kinvelx-ci.r2y*ang);\n                            vry=(b2.vely+b2.kinvely+ci.r2x*ang);\n                            ang=b1.angvel+b1.kinangvel;\n                            vrx-=(b1.velx+b1.kinvelx-ci.r1y*ang);\n                            vry-=(b1.vely+b1.kinvely+ci.r1x*ang);\n                        };\n                        var vdot=(nx*vrx+ny*vry);\n                        c.elasticity=restitution;\n                        ci.bounce=vdot*c.elasticity;\n                        if(ci.bounce>-Config.elasticThreshold){\n                            ci.bounce=0;\n                        }\n                        vdot=(vry*nx-vrx*ny);\n                        var thr=Config.staticFrictionThreshold;\n                        if(vdot*vdot>thr*thr){\n                            ci.friction=dyn_fric;\n                        }\n                        else{\n                            ci.friction=stat_fric;\n                        }\n                        ci.jnAcc*=dtratio;\n                        ci.jtAcc*=dtratio;\n                    }\n                    if(pact!=c.active)contacts.modified=true;\n                    pre=cx_ite;\n                    prei=cx_itei;\n                    cx_itei=cx_itei.next;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(hc2){\n            hpc2=true;\n            if(oc1.posOnly){\n                var tmp=c1;\n                c1=c2;\n                c2=tmp;\n                var tmp2=oc1;\n                oc1=oc2;\n                oc2=tmp2;\n                hc2=false;\n            }\n            else if(oc2.posOnly){\n                hc2=false;\n            }\n            if(oc1.posOnly){\n                fst=true;\n            }\n        }\n        else{\n            hpc2=false;\n        }\n        jrAcc*=dtratio;\n        if(!fst){\n            rn1a=(ny*c1.r1x-nx*c1.r1y);\n            rt1a=(c1.r1x*nx+c1.r1y*ny);\n            rn1b=(ny*c1.r2x-nx*c1.r2y);\n            rt1b=(c1.r2x*nx+c1.r2y*ny);\n            k1x=b2.kinvelx-c1.r2y*b2.kinangvel-(b1.kinvelx-c1.r1y*b1.kinangvel);\n            k1y=b2.kinvely+c1.r2x*b2.kinangvel-(b1.kinvely+c1.r1x*b1.kinangvel);\n        }\n        if(hc2){\n            rn2a=(ny*c2.r1x-nx*c2.r1y);\n            rt2a=(c2.r1x*nx+c2.r1y*ny);\n            rn2b=(ny*c2.r2x-nx*c2.r2y);\n            rt2b=(c2.r2x*nx+c2.r2y*ny);\n            k2x=b2.kinvelx-c2.r2y*b2.kinangvel-(b1.kinvelx-c2.r1y*b1.kinangvel);\n            k2y=b2.kinvely+c2.r2x*b2.kinangvel-(b1.kinvely+c2.r1x*b1.kinangvel);\n            {\n                kMassa=mass_sum+b1.sinertia*rn1a*rn1a+b2.sinertia*rn1b*rn1b;\n                kMassb=mass_sum+b1.sinertia*rn1a*rn2a+b2.sinertia*rn1b*rn2b;\n                kMassc=mass_sum+b1.sinertia*rn2a*rn2a+b2.sinertia*rn2b*rn2b;\n            };\n            var norm=(kMassa*kMassa+2*kMassb*kMassb+kMassc*kMassc);\n            if(norm<Config.illConditionedThreshold*(kMassa*kMassc-kMassb*kMassb)){\n                {\n                    Ka=kMassa;\n                    Kb=kMassb;\n                    Kc=kMassc;\n                };\n                {\n                    var det=(kMassa*kMassc-kMassb*kMassb);\n                    if((det!=det)){\n                        kMassa=kMassb=kMassc=0;\n                        3;\n                    }\n                    else if(det==0){\n                        var flag=0;\n                        if(kMassa!=0)kMassa=1/kMassa;\n                        else{\n                            kMassa=0;\n                            flag|=1;\n                        }\n                        if(kMassc!=0)kMassc=1/kMassc;\n                        else{\n                            kMassc=0;\n                            flag|=2;\n                        }\n                        kMassb=0;\n                        flag;\n                    }\n                    else{\n                        det=1/det;\n                        var t=kMassc*det;\n                        kMassc=kMassa*det;\n                        kMassa=t;\n                        kMassb*=-det;\n                        0;\n                    }\n                };\n            }\n            else{\n                hc2=false;\n                if(oc2.dist<oc1.dist){\n                    var t=c1;\n                    c1=c2;\n                    c2=t;\n                };\n                oc2.active=false;\n                contacts.modified=true;\n            }\n        }\n        {\n            surfacex=b2.svelx;\n            surfacey=b2.svely;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((surfacex!=surfacex));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(surfacex)\"+\") :: \"+(\"vec_set(in n: \"+\"surface\"+\",in x: \"+\"b2.svelx\"+\",in y: \"+\"b2.svely\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((surfacey!=surfacey));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(surfacey)\"+\") :: \"+(\"vec_set(in n: \"+\"surface\"+\",in x: \"+\"b2.svelx\"+\",in y: \"+\"b2.svely\"+\")\");\n                #end\n            };\n        };\n        {\n            var t=(1.0);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((t!=t));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"surface\"+\",in b: \"+\"b1.svel\"+\",in s: \"+\"1.0\"+\")\");\n                #end\n            };\n            surfacex+=b1.svelx*t;\n            surfacey+=b1.svely*t;\n        };\n        {\n            surfacex=-surfacex;\n            surfacey=-surfacey;\n        };\n        rMass=b1.sinertia+b2.sinertia;\n        if(rMass!=0)rMass=1/rMass;\n        return fst;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function warmStart(){\n        {\n            var jx=nx*c1.jnAcc-ny*c1.jtAcc;\n            var jy=ny*c1.jnAcc+nx*c1.jtAcc;\n            {\n                var t=(b1.imass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.vel\"+\",in b: \"+\"j\"+\",in s: \"+\"b1.imass\"+\")\");\n                    #end\n                };\n                b1.velx-=jx*t;\n                b1.vely-=jy*t;\n            };\n            b1.angvel-=b1.iinertia*(jy*c1.r1x-jx*c1.r1y);\n            {\n                var t=(b2.imass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.vel\"+\",in b: \"+\"j\"+\",in s: \"+\"b2.imass\"+\")\");\n                    #end\n                };\n                b2.velx+=jx*t;\n                b2.vely+=jy*t;\n            };\n            b2.angvel+=b2.iinertia*(jy*c1.r2x-jx*c1.r2y);\n        };\n        if(hc2){\n            var jx=nx*c2.jnAcc-ny*c2.jtAcc;\n            var jy=ny*c2.jnAcc+nx*c2.jtAcc;\n            {\n                var t=(b1.imass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.vel\"+\",in b: \"+\"j\"+\",in s: \"+\"b1.imass\"+\")\");\n                    #end\n                };\n                b1.velx-=jx*t;\n                b1.vely-=jy*t;\n            };\n            b1.angvel-=b1.iinertia*(jy*c2.r1x-jx*c2.r1y);\n            {\n                var t=(b2.imass);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.vel\"+\",in b: \"+\"j\"+\",in s: \"+\"b2.imass\"+\")\");\n                    #end\n                };\n                b2.velx+=jx*t;\n                b2.vely+=jy*t;\n            };\n            b2.angvel+=b2.iinertia*(jy*c2.r2x-jx*c2.r2y);\n        };\n        b2.angvel+=jrAcc*b2.iinertia;\n        b1.angvel-=jrAcc*b1.iinertia;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function applyImpulseVel(){\n        var jx:Float;\n        var jy:Float;\n        var j:Float;\n        var jMax:Float;\n        var jOld:Float;\n        var cjAcc:Float;\n        var v1x=k1x+b2.velx-c1.r2y*b2.angvel-(b1.velx-c1.r1y*b1.angvel);\n        var v1y=k1y+b2.vely+c1.r2x*b2.angvel-(b1.vely+c1.r1x*b1.angvel);\n        j=((v1y*nx-v1x*ny)+surfacex)*c1.tMass;\n        jMax=c1.friction*c1.jnAcc;\n        jOld=c1.jtAcc;\n        cjAcc=jOld-j;\n        if(cjAcc>jMax)cjAcc=jMax else if(cjAcc<-jMax)cjAcc=-jMax;\n        j=cjAcc-jOld;\n        c1.jtAcc=cjAcc;\n        jx=-ny*j;\n        jy=nx*j;\n        b2.velx+=jx*b2.imass;\n        b2.vely+=jy*b2.imass;\n        b1.velx-=jx*b1.imass;\n        b1.vely-=jy*b1.imass;\n        b2.angvel+=rt1b*j*b2.iinertia;\n        b1.angvel-=rt1a*j*b1.iinertia;\n        if(hc2){\n            var v2x=k2x+b2.velx-c2.r2y*b2.angvel-(b1.velx-c2.r1y*b1.angvel);\n            var v2y=k2y+b2.vely+c2.r2x*b2.angvel-(b1.vely+c2.r1x*b1.angvel);\n            j=((v2y*nx-v2x*ny)+surfacex)*c2.tMass;\n            jMax=c2.friction*c2.jnAcc;\n            jOld=c2.jtAcc;\n            cjAcc=jOld-j;\n            if(cjAcc>jMax)cjAcc=jMax else if(cjAcc<-jMax)cjAcc=-jMax;\n            j=cjAcc-jOld;\n            c2.jtAcc=cjAcc;\n            jx=-ny*j;\n            jy=nx*j;\n            b2.velx+=jx*b2.imass;\n            b2.vely+=jy*b2.imass;\n            b1.velx-=jx*b1.imass;\n            b1.vely-=jy*b1.imass;\n            b2.angvel+=rt2b*j*b2.iinertia;\n            b1.angvel-=rt2a*j*b1.iinertia;\n            v1x=k1x+b2.velx-c1.r2y*b2.angvel-(b1.velx-c1.r1y*b1.angvel);\n            v1y=k1y+b2.vely+c1.r2x*b2.angvel-(b1.vely+c1.r1x*b1.angvel);\n            v2x=k2x+b2.velx-c2.r2y*b2.angvel-(b1.velx-c2.r1y*b1.angvel);\n            v2y=k2y+b2.vely+c2.r2x*b2.angvel-(b1.vely+c2.r1x*b1.angvel);\n            var ax:Float=c1.jnAcc;\n            var ay:Float=c2.jnAcc;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ax!=ax));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ax)\"+\") :: \"+(\"vec_new(in n: \"+\"a\"+\",in x: \"+\"c1.jnAcc\"+\",in y: \"+\"c2.jnAcc\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ay!=ay));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ay)\"+\") :: \"+(\"vec_new(in n: \"+\"a\"+\",in x: \"+\"c1.jnAcc\"+\",in y: \"+\"c2.jnAcc\"+\")\");\n                #end\n            };\n            var jnx=(v1x*nx+v1y*ny)+surfacey+(c1.bounce)-(Ka*ax+Kb*ay);\n            var jny=(v2x*nx+v2y*ny)+surfacey+(c2.bounce)-(Kb*ax+Kc*ay);\n            var xx=-(kMassa*jnx+kMassb*jny);\n            var xy=-(kMassb*jnx+kMassc*jny);\n            if(xx>=0&&xy>=0){\n                {\n                    jnx=xx-ax;\n                    jny=xy-ay;\n                };\n                c1.jnAcc=xx;\n                c2.jnAcc=xy;\n            }\n            else{\n                xx=-c1.nMass*jnx;\n                if(xx>=0&&(Kb*xx+jny)>=0){\n                    jnx=xx-ax;\n                    jny=-ay;\n                    c1.jnAcc=xx;\n                    c2.jnAcc=0;\n                }\n                else{\n                    xy=-c2.nMass*jny;\n                    if(xy>=0&&(Kb*xy+jnx)>=0){\n                        jnx=-ax;\n                        jny=xy-ay;\n                        c1.jnAcc=0;\n                        c2.jnAcc=xy;\n                    }\n                    else if(jnx>=0&&jny>=0){\n                        jnx=-ax;\n                        jny=-ay;\n                        c1.jnAcc=c2.jnAcc=0;\n                    }\n                    else{\n                        jnx=0;\n                        jny=0;\n                    }\n                }\n            }\n            j=jnx+jny;\n            jx=nx*j;\n            jy=ny*j;\n            b2.velx+=jx*b2.imass;\n            b2.vely+=jy*b2.imass;\n            b1.velx-=jx*b1.imass;\n            b1.vely-=jy*b1.imass;\n            b2.angvel+=(rn1b*jnx+rn2b*jny)*b2.iinertia;\n            b1.angvel-=(rn1a*jnx+rn2a*jny)*b1.iinertia;\n        }\n        else{\n            if(radius!=0.0){\n                var dw=b2.angvel-b1.angvel;\n                j=dw*rMass;\n                jMax=rfric*c1.jnAcc;\n                jOld=jrAcc;\n                jrAcc-=j;\n                if(jrAcc>jMax)jrAcc=jMax else if(jrAcc<-jMax)jrAcc=-jMax;\n                j=jrAcc-jOld;\n                b2.angvel+=j*b2.iinertia;\n                b1.angvel-=j*b1.iinertia;\n            }\n            v1x=k1x+b2.velx-c1.r2y*b2.angvel-(b1.velx-c1.r1y*b1.angvel);\n            v1y=k1y+b2.vely+c1.r2x*b2.angvel-(b1.vely+c1.r1x*b1.angvel);\n            j=(c1.bounce+(nx*v1x+ny*v1y)+surfacey)*c1.nMass;\n            jOld=c1.jnAcc;\n            cjAcc=jOld-j;\n            if(cjAcc<0.0)cjAcc=0.0;\n            j=cjAcc-jOld;\n            c1.jnAcc=cjAcc;\n            jx=nx*j;\n            jy=ny*j;\n            b2.velx+=jx*b2.imass;\n            b2.vely+=jy*b2.imass;\n            b1.velx-=jx*b1.imass;\n            b1.vely-=jy*b1.imass;\n            b2.angvel+=rn1b*j*b2.iinertia;\n            b1.angvel-=rn1a*j*b1.iinertia;\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function applyImpulsePos(){\n        if(ptype==ZPP_ColArbiter.CIRCLE){\n            var c=c1;\n            var dx:Float=0.0;\n            var dy:Float=0.0;\n            var r2x:Float=0.0;\n            var r2y:Float=0.0;\n            {\n                r2x=(b2.axisy*c.lr2x-b2.axisx*c.lr2y);\n                r2y=(c.lr2x*b2.axisx+c.lr2y*b2.axisy);\n            };\n            {\n                var t=(1.0);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"r2\"+\",in b: \"+\"b2.pos\"+\",in s: \"+\"1.0\"+\")\");\n                    #end\n                };\n                r2x+=b2.posx*t;\n                r2y+=b2.posy*t;\n            };\n            var r1x:Float=0.0;\n            var r1y:Float=0.0;\n            {\n                r1x=(b1.axisy*c.lr1x-b1.axisx*c.lr1y);\n                r1y=(c.lr1x*b1.axisx+c.lr1y*b1.axisy);\n            };\n            {\n                var t=(1.0);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"r1\"+\",in b: \"+\"b1.pos\"+\",in s: \"+\"1.0\"+\")\");\n                    #end\n                };\n                r1x+=b1.posx*t;\n                r1y+=b1.posy*t;\n            };\n            var dx:Float=0.0;\n            var dy:Float=0.0;\n            {\n                dx=r2x-r1x;\n                dy=r2y-r1y;\n            };\n            var dl=ZPP_Math.sqrt((dx*dx+dy*dy));\n            var r=radius-Config.collisionSlop;\n            var err=(dl-r);\n            if((dx*nx+dy*ny)<0){\n                {\n                    dx=-dx;\n                    dy=-dy;\n                };\n                err-=radius;\n            }\n            if(err<0){\n                if(dl<Config.epsilon){\n                    if(b1.smass!=0.0)b1.posx+=Config.epsilon*10;\n                    else b2.posx+=Config.epsilon*10;\n                }\n                else{\n                    {\n                        var t=(1.0/(dl));\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"d\"+\",in s: \"+\"1.0/(dl)\"+\")\");\n                            #end\n                        };\n                        dx*=t;\n                        dy*=t;\n                    };\n                    var px:Float=0.5*(r1x+r2x);\n                    var py:Float=0.5*(r1y+r2y);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((px!=px));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(px)\"+\") :: \"+(\"vec_new(in n: \"+\"p\"+\",in x: \"+\"0.5*(r1x+r2x)\"+\",in y: \"+\"0.5*(r1y+r2y)\"+\")\");\n                        #end\n                    };\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((py!=py));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(py)\"+\") :: \"+(\"vec_new(in n: \"+\"p\"+\",in x: \"+\"0.5*(r1x+r2x)\"+\",in y: \"+\"0.5*(r1y+r2y)\"+\")\");\n                        #end\n                    };\n                    var pen=dl-r;\n                    {\n                        r1x=px-b1.posx;\n                        r1y=py-b1.posy;\n                    };\n                    {\n                        r2x=px-b2.posx;\n                        r2y=py-b2.posy;\n                    };\n                    var rn1=(dy*r1x-dx*r1y);\n                    var rn2=(dy*r2x-dx*r2y);\n                    var K=b2.smass+rn2*rn2*b2.sinertia+b1.smass+rn1*rn1*b1.sinertia;\n                    if(K!=0){\n                        var jn=-biasCoef*pen/K;\n                        var Jx:Float=0.0;\n                        var Jy:Float=0.0;\n                        {\n                            var t=(jn);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_mul(in a: \"+\"d\"+\",in s: \"+\"jn\"+\",out r: \"+\"J\"+\")\");\n                                #end\n                            };\n                            Jx=dx*t;\n                            Jy=dy*t;\n                        };\n                        {\n                            var t=(b1.imass);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.pos\"+\",in b: \"+\"J\"+\",in s: \"+\"b1.imass\"+\")\");\n                                #end\n                            };\n                            b1.posx-=Jx*t;\n                            b1.posy-=Jy*t;\n                        };\n                        b1.delta_rot(-rn1*b1.iinertia*jn);\n                        {\n                            var t=(b2.imass);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.pos\"+\",in b: \"+\"J\"+\",in s: \"+\"b2.imass\"+\")\");\n                                #end\n                            };\n                            b2.posx+=Jx*t;\n                            b2.posy+=Jy*t;\n                        };\n                        b2.delta_rot(rn2*b2.iinertia*jn);\n                    }\n                }\n            }\n        }\n        else{\n            var gnormx:Float=0.0;\n            var gnormy:Float=0.0;\n            var gproj;\n            var clip1x:Float=0.0;\n            var clip1y:Float=0.0;\n            var clip2x:Float=0;\n            var clip2y:Float=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((clip2x!=clip2x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(clip2x)\"+\") :: \"+(\"vec_new(in n: \"+\"clip2\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((clip2y!=clip2y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(clip2y)\"+\") :: \"+(\"vec_new(in n: \"+\"clip2\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            if(ptype==ZPP_ColArbiter.FACE1){\n                {\n                    gnormx=(b1.axisy*lnormx-b1.axisx*lnormy);\n                    gnormy=(lnormx*b1.axisx+lnormy*b1.axisy);\n                };\n                gproj=lproj+(gnormx*b1.posx+gnormy*b1.posy);\n                {\n                    clip1x=(b2.axisy*c1.lr1x-b2.axisx*c1.lr1y);\n                    clip1y=(c1.lr1x*b2.axisx+c1.lr1y*b2.axisy);\n                };\n                {\n                    var t=(1.0);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"clip1\"+\",in b: \"+\"b2.pos\"+\",in s: \"+\"1.0\"+\")\");\n                        #end\n                    };\n                    clip1x+=b2.posx*t;\n                    clip1y+=b2.posy*t;\n                };\n                if(hpc2){\n                    {\n                        clip2x=(b2.axisy*c2.lr1x-b2.axisx*c2.lr1y);\n                        clip2y=(c2.lr1x*b2.axisx+c2.lr1y*b2.axisy);\n                    };\n                    {\n                        var t=(1.0);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"clip2\"+\",in b: \"+\"b2.pos\"+\",in s: \"+\"1.0\"+\")\");\n                            #end\n                        };\n                        clip2x+=b2.posx*t;\n                        clip2y+=b2.posy*t;\n                    };\n                }\n            }\n            else{\n                {\n                    gnormx=(b2.axisy*lnormx-b2.axisx*lnormy);\n                    gnormy=(lnormx*b2.axisx+lnormy*b2.axisy);\n                };\n                gproj=lproj+(gnormx*b2.posx+gnormy*b2.posy);\n                {\n                    clip1x=(b1.axisy*c1.lr1x-b1.axisx*c1.lr1y);\n                    clip1y=(c1.lr1x*b1.axisx+c1.lr1y*b1.axisy);\n                };\n                {\n                    var t=(1.0);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"clip1\"+\",in b: \"+\"b1.pos\"+\",in s: \"+\"1.0\"+\")\");\n                        #end\n                    };\n                    clip1x+=b1.posx*t;\n                    clip1y+=b1.posy*t;\n                };\n                if(hpc2){\n                    {\n                        clip2x=(b1.axisy*c2.lr1x-b1.axisx*c2.lr1y);\n                        clip2y=(c2.lr1x*b1.axisx+c2.lr1y*b1.axisy);\n                    };\n                    {\n                        var t=(1.0);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"clip2\"+\",in b: \"+\"b1.pos\"+\",in s: \"+\"1.0\"+\")\");\n                            #end\n                        };\n                        clip2x+=b1.posx*t;\n                        clip2y+=b1.posy*t;\n                    };\n                }\n            }\n            var err1=(clip1x*gnormx+clip1y*gnormy)-gproj-radius;\n            err1+=Config.collisionSlop;\n            var err2=0.0;\n            if(hpc2){\n                err2=(clip2x*gnormx+clip2y*gnormy)-gproj-radius;\n                err2+=Config.collisionSlop;\n            }\n            if(err1<0||err2<0){\n                if(rev){\n                    gnormx=-gnormx;\n                    gnormy=-gnormy;\n                };\n                var c1r1x:Float=0.0;\n                var c1r1y:Float=0.0;\n                {\n                    c1r1x=clip1x-b1.posx;\n                    c1r1y=clip1y-b1.posy;\n                };\n                var c1r2x:Float=0.0;\n                var c1r2y:Float=0.0;\n                {\n                    c1r2x=clip1x-b2.posx;\n                    c1r2y=clip1y-b2.posy;\n                };\n                var c2r1x:Float=0;\n                var c2r1y:Float=0;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((c2r1x!=c2r1x));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(c2r1x)\"+\") :: \"+(\"vec_new(in n: \"+\"c2r1\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((c2r1y!=c2r1y));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(c2r1y)\"+\") :: \"+(\"vec_new(in n: \"+\"c2r1\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                    #end\n                };\n                var c2r2x:Float=0;\n                var c2r2y:Float=0;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((c2r2x!=c2r2x));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(c2r2x)\"+\") :: \"+(\"vec_new(in n: \"+\"c2r2\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((c2r2y!=c2r2y));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(c2r2y)\"+\") :: \"+(\"vec_new(in n: \"+\"c2r2\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                    #end\n                };\n                if(hpc2){\n                    {\n                        c2r1x=clip2x-b1.posx;\n                        c2r1y=clip2y-b1.posy;\n                    };\n                    {\n                        c2r2x=clip2x-b2.posx;\n                        c2r2y=clip2y-b2.posy;\n                    };\n                    var rn1a=(gnormy*c1r1x-gnormx*c1r1y);\n                    var rn1b=(gnormy*c1r2x-gnormx*c1r2y);\n                    var rn2a=(gnormy*c2r1x-gnormx*c2r1y);\n                    var rn2b=(gnormy*c2r2x-gnormx*c2r2y);\n                    var mass_sum=b1.smass+b2.smass;\n                    {\n                        kMassa=mass_sum+(b1.sinertia*rn1a*rn1a)+b2.sinertia*rn1b*rn1b;\n                        kMassb=mass_sum+(b1.sinertia*rn1a*rn2a)+b2.sinertia*rn1b*rn2b;\n                        kMassc=mass_sum+(b1.sinertia*rn2a*rn2a)+b2.sinertia*rn2b*rn2b;\n                    };\n                    var Ka:Float=0.0;\n                    var Kb:Float=0.0;\n                    var Kc:Float=0.0;\n                    {\n                        Ka=kMassa;\n                        Kb=kMassb;\n                        Kc=kMassc;\n                    };\n                    var bx:Float=err1*biasCoef;\n                    var by:Float=err2*biasCoef;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((bx!=bx));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(bx)\"+\") :: \"+(\"vec_new(in n: \"+\"b\"+\",in x: \"+\"err1*biasCoef\"+\",in y: \"+\"err2*biasCoef\"+\")\");\n                        #end\n                    };\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((by!=by));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(by)\"+\") :: \"+(\"vec_new(in n: \"+\"b\"+\",in x: \"+\"err1*biasCoef\"+\",in y: \"+\"err2*biasCoef\"+\")\");\n                        #end\n                    };\n                    do{\n                        var xx:Float=0.0;\n                        var xy:Float=0.0;\n                        {\n                            xx=bx;\n                            xy=by;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((xx!=xx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(xx)\"+\") :: \"+(\"vec_set(in n: \"+\"x\"+\",in x: \"+\"bx\"+\",in y: \"+\"by\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((xy!=xy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(xy)\"+\") :: \"+(\"vec_set(in n: \"+\"x\"+\",in x: \"+\"bx\"+\",in y: \"+\"by\"+\")\");\n                                #end\n                            };\n                        };\n                        {\n                            xx=-xx;\n                            xy=-xy;\n                        };\n                        {\n                            var det=(kMassa*kMassc-kMassb*kMassb);\n                            if((det!=det))xx=xy=0;\n                            else if(det==0){\n                                if(kMassa!=0)xx/=kMassa;\n                                else xx=0;\n                                if(kMassc!=0)xy/=kMassc;\n                                else xy=0;\n                            }\n                            else{\n                                det=1/det;\n                                var t=det*(kMassc*xx-kMassb*xy);\n                                xy=det*(kMassa*xy-kMassb*xx);\n                                xx=t;\n                            }\n                        };\n                        if(xx>=0&&xy>=0){\n                            {\n                                var t=((xx+xy)*b1.imass);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.pos\"+\",in b: \"+\"gnorm\"+\",in s: \"+\"(xx+xy)*b1.imass\"+\")\");\n                                    #end\n                                };\n                                b1.posx-=gnormx*t;\n                                b1.posy-=gnormy*t;\n                            };\n                            b1.delta_rot(-b1.iinertia*(rn1a*xx+rn2a*xy));\n                            {\n                                var t=((xx+xy)*b2.imass);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.pos\"+\",in b: \"+\"gnorm\"+\",in s: \"+\"(xx+xy)*b2.imass\"+\")\");\n                                    #end\n                                };\n                                b2.posx+=gnormx*t;\n                                b2.posy+=gnormy*t;\n                            };\n                            b2.delta_rot(b2.iinertia*(rn1b*xx+rn2b*xy));\n                            break;\n                        };\n                        {\n                            xx=-bx/Ka;\n                            xy=0;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((xx!=xx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(xx)\"+\") :: \"+(\"vec_set(in n: \"+\"x\"+\",in x: \"+\"-bx/Ka\"+\",in y: \"+\"0\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((xy!=xy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(xy)\"+\") :: \"+(\"vec_set(in n: \"+\"x\"+\",in x: \"+\"-bx/Ka\"+\",in y: \"+\"0\"+\")\");\n                                #end\n                            };\n                        };\n                        var vn2=Kb*xx+by;\n                        if(xx>=0&&vn2>=0){\n                            {\n                                var t=((xx+xy)*b1.imass);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.pos\"+\",in b: \"+\"gnorm\"+\",in s: \"+\"(xx+xy)*b1.imass\"+\")\");\n                                    #end\n                                };\n                                b1.posx-=gnormx*t;\n                                b1.posy-=gnormy*t;\n                            };\n                            b1.delta_rot(-b1.iinertia*(rn1a*xx+rn2a*xy));\n                            {\n                                var t=((xx+xy)*b2.imass);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.pos\"+\",in b: \"+\"gnorm\"+\",in s: \"+\"(xx+xy)*b2.imass\"+\")\");\n                                    #end\n                                };\n                                b2.posx+=gnormx*t;\n                                b2.posy+=gnormy*t;\n                            };\n                            b2.delta_rot(b2.iinertia*(rn1b*xx+rn2b*xy));\n                            break;\n                        };\n                        {\n                            xx=0;\n                            xy=-by/Kc;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((xx!=xx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(xx)\"+\") :: \"+(\"vec_set(in n: \"+\"x\"+\",in x: \"+\"0\"+\",in y: \"+\"-by/Kc\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((xy!=xy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(xy)\"+\") :: \"+(\"vec_set(in n: \"+\"x\"+\",in x: \"+\"0\"+\",in y: \"+\"-by/Kc\"+\")\");\n                                #end\n                            };\n                        };\n                        var vn1=Kb*xy+bx;\n                        if(xy>=0&&vn1>=0){\n                            {\n                                var t=((xx+xy)*b1.imass);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.pos\"+\",in b: \"+\"gnorm\"+\",in s: \"+\"(xx+xy)*b1.imass\"+\")\");\n                                    #end\n                                };\n                                b1.posx-=gnormx*t;\n                                b1.posy-=gnormy*t;\n                            };\n                            b1.delta_rot(-b1.iinertia*(rn1a*xx+rn2a*xy));\n                            {\n                                var t=((xx+xy)*b2.imass);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.pos\"+\",in b: \"+\"gnorm\"+\",in s: \"+\"(xx+xy)*b2.imass\"+\")\");\n                                    #end\n                                };\n                                b2.posx+=gnormx*t;\n                                b2.posy+=gnormy*t;\n                            };\n                            b2.delta_rot(b2.iinertia*(rn1b*xx+rn2b*xy));\n                            break;\n                        };\n                    }\n                    while(false);\n                }\n                else{\n                    var rn1=(gnormy*c1r1x-gnormx*c1r1y);\n                    var rn2=(gnormy*c1r2x-gnormx*c1r2y);\n                    var K=b2.smass+rn2*rn2*b2.sinertia+b1.smass+rn1*rn1*b1.sinertia;\n                    if(K!=0){\n                        var jn=-biasCoef*err1/K;\n                        var Jx:Float=0.0;\n                        var Jy:Float=0.0;\n                        {\n                            var t=(jn);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_mul(in a: \"+\"gnorm\"+\",in s: \"+\"jn\"+\",out r: \"+\"J\"+\")\");\n                                #end\n                            };\n                            Jx=gnormx*t;\n                            Jy=gnormy*t;\n                        };\n                        {\n                            var t=(b1.imass);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"b1.pos\"+\",in b: \"+\"J\"+\",in s: \"+\"b1.imass\"+\")\");\n                                #end\n                            };\n                            b1.posx-=Jx*t;\n                            b1.posy-=Jy*t;\n                        };\n                        b1.delta_rot(-rn1*b1.iinertia*jn);\n                        {\n                            var t=(b2.imass);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"b2.pos\"+\",in b: \"+\"J\"+\",in s: \"+\"b2.imass\"+\")\");\n                                #end\n                            };\n                            b2.posx+=Jx*t;\n                            b2.posy+=Jy*t;\n                        };\n                        b2.delta_rot(rn2*b2.iinertia*jn);\n                    }\n                }\n            }\n        }\n    }\n}\n","package zpp_nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Contact{\n    public var outer:Contact=null;\n    public static var internal:Bool=false;\n    public function wrapper(){\n        if(outer==null){\n            internal=true;\n            outer=new Contact();\n            internal=false;\n            outer.zpp_inner=this;\n        }\n        return outer;\n    }\n    public var px:Float=0.0;\n    public var py:Float=0.0;\n    private function position_validate(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(inactiveme())throw \"Error: Contact not currently in use\";\n        #end\n        {\n            wrap_position.zpp_inner.x=px;\n            wrap_position.zpp_inner.y=py;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_position.zpp_inner.x!=wrap_position.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_position.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_position.zpp_inner.\"+\",in x: \"+\"px\"+\",in y: \"+\"py\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_position.zpp_inner.y!=wrap_position.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_position.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_position.zpp_inner.\"+\",in x: \"+\"px\"+\",in y: \"+\"py\"+\")\");\n                #end\n            };\n        };\n    }\n    public var wrap_position:Vec2=null;\n    public function getposition(){\n        var me=this;\n        wrap_position=Vec2.get();\n        wrap_position.zpp_inner._inuse=true;\n        wrap_position.zpp_inner._immutable=true;\n        wrap_position.zpp_inner._validate=position_validate;\n    }\n    public function inactiveme(){\n        return!(active&&arbiter!=null&&!arbiter.inactiveme());\n    }\n    public var arbiter:ZPP_Arbiter=null;\n    public var inner:ZPP_IContact=null;\n    public var active:Bool=false;\n    public var posOnly:Bool=false;\n    public var stamp:Int=0;\n    public var hash:Int=0;\n    public var fresh:Bool=false;\n    public var dist:Float=0.0;\n    public var elasticity:Float=0.0;\n    public function new(){\n        inner=new ZPP_IContact();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        arbiter=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    static public var zpp_pool:ZPP_Contact=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var next:ZPP_Contact=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Contact{\n        return this;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZPP_Contact{\n        return next;\n    }\n    public var _inuse:Bool=false;\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZPP_Contact):Void{\n        next=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Contact):ZPP_Contact{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Contact):ZPP_Contact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        temp.next=begin();\n        next=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZPP_Contact):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZPP_Contact,o:ZPP_Contact):ZPP_Contact{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZPP_Contact,o:ZPP_Contact):ZPP_Contact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        if(cur==null){\n            temp.next=begin();\n            next=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        next=ret.next;\n        {\n            ret.elem()._inuse=false;\n        };\n        {};\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Contact{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Contact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Contact):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Contact):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Contact):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Contact):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZPP_Contact):ZPP_Contact{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZPP_Contact):ZPP_Contact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZPP_Contact;\n        var ret:ZPP_Contact;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            next=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {\n            old.elem()._inuse=false;\n        };\n        {};\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZPP_Contact,n:Int):ZPP_Contact{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(false){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            next=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Contact):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Contact):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Contact{\n        return begin().elem();\n    }\n    public function back():ZPP_Contact{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZPP_Contact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Contact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Contact\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_IContact{\n    public var r1x:Float=0.0;\n    public var r1y:Float=0.0;\n    public var r2x:Float=0.0;\n    public var r2y:Float=0.0;\n    public var nMass:Float=0.0;\n    public var tMass:Float=0.0;\n    public var bounce:Float=0.0;\n    public var friction:Float=0.0;\n    public var jnAcc:Float=0.0;\n    public var jtAcc:Float=0.0;\n    public var lr1x:Float=0.0;\n    public var lr1y:Float=0.0;\n    public var lr2x:Float=0.0;\n    public var lr2y:Float=0.0;\n    public function new(){}\n    public var next:ZPP_IContact=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_IContact{\n        return this;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZPP_IContact{\n        return next;\n    }\n    public var _inuse:Bool=false;\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZPP_IContact):Void{\n        next=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_IContact):ZPP_IContact{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_IContact):ZPP_IContact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        temp.next=begin();\n        next=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZPP_IContact):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZPP_IContact,o:ZPP_IContact):ZPP_IContact{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZPP_IContact,o:ZPP_IContact):ZPP_IContact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        if(cur==null){\n            temp.next=begin();\n            next=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        next=ret.next;\n        {\n            ret.elem()._inuse=false;\n        };\n        {};\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_IContact{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_IContact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_IContact):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_IContact):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_IContact):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_IContact):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZPP_IContact):ZPP_IContact{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZPP_IContact):ZPP_IContact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZPP_IContact;\n        var ret:ZPP_IContact;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            next=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {\n            old.elem()._inuse=false;\n        };\n        {};\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZPP_IContact,n:Int):ZPP_IContact{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(false){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            next=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_IContact):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_IContact):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_IContact{\n        return begin().elem();\n    }\n    public function back():ZPP_IContact{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZPP_IContact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_IContact{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_IContact\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n}\n","package zpp_nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_InteractionFilter{\n    public var next:ZPP_InteractionFilter=null;\n    static public var zpp_pool:ZPP_InteractionFilter=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var userData:Dynamic<Dynamic>=null;\n    public var outer:InteractionFilter=null;\n    public function wrapper(){\n        if(outer==null){\n            outer=new InteractionFilter();\n            {\n                var o=outer.zpp_inner;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_InteractionFilter\"+\", in obj: \"+\"outer.zpp_inner\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_InteractionFilter.zpp_pool;\n                ZPP_InteractionFilter.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_CNT++;\n                ZPP_InteractionFilter.POOL_SUB++;\n                #end\n            };\n            outer.zpp_inner=this;\n        }\n        return outer;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        outer=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var shapes:ZNPList_ZPP_Shape=null;\n    public var wrap_shapes:ShapeList=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function feature_cons(){\n        shapes=new ZNPList_ZPP_Shape();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addShape(shape:ZPP_Shape){\n        shapes.add(shape);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remShape(shape:ZPP_Shape){\n        shapes.remove(shape);\n    }\n    public function new(){\n        feature_cons();\n        collisionGroup=sensorGroup=fluidGroup=1;\n        collisionMask=sensorMask=fluidMask=-1;\n    }\n    public function copy(){\n        var ret;\n        {\n            if(ZPP_InteractionFilter.zpp_pool==null){\n                ret=new ZPP_InteractionFilter();\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_TOT++;\n                ZPP_InteractionFilter.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_InteractionFilter.zpp_pool;\n                ZPP_InteractionFilter.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_CNT--;\n                ZPP_InteractionFilter.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        ret.collisionGroup=collisionGroup;\n        ret.collisionMask=collisionMask;\n        ret.sensorGroup=sensorGroup;\n        ret.sensorMask=sensorMask;\n        ret.fluidGroup=fluidGroup;\n        ret.fluidMask=fluidMask;\n        return ret;\n    }\n    public var collisionGroup:Int=0;\n    public var collisionMask:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function shouldCollide(x:ZPP_InteractionFilter){\n        return(collisionMask&x.collisionGroup)!=0&&(x.collisionMask&collisionGroup)!=0;\n    }\n    public var sensorGroup:Int=0;\n    public var sensorMask:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function shouldSense(x:ZPP_InteractionFilter){\n        return(sensorMask&x.sensorGroup)!=0&&(x.sensorMask&sensorGroup)!=0;\n    }\n    public var fluidGroup:Int=0;\n    public var fluidMask:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function shouldFlow(x:ZPP_InteractionFilter){\n        return(fluidMask&x.fluidGroup)!=0&&(x.fluidMask&fluidGroup)!=0;\n    }\n    public function invalidate(){\n        {\n            var cx_ite=shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.invalidate_filter();\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n}\n","package zpp_nape.dynamics;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_InteractionGroup{\n    public var outer:InteractionGroup=null;\n    public var ignore:Bool=false;\n    public var group:ZPP_InteractionGroup=null;\n    public function setGroup(group:ZPP_InteractionGroup){\n        if(this.group!=group){\n            if(this.group!=null){\n                this.group.remGroup(this);\n                this.group.invalidate(true);\n            }\n            this.group=group;\n            if(group!=null){\n                group.addGroup(this);\n                group.invalidate(true);\n            }\n            else this.invalidate(true);\n        }\n    }\n    public var groups:ZNPList_ZPP_InteractionGroup=null;\n    public var wrap_groups:InteractionGroupList=null;\n    public var interactors:ZNPList_ZPP_Interactor=null;\n    public var wrap_interactors:InteractorList=null;\n    public var depth:Int=0;\n    public function invalidate(force=false){\n        if(!(force||ignore))return;\n        {\n            var cx_ite=interactors.begin();\n            while(cx_ite!=null){\n                var b=cx_ite.elem();\n                {\n                    if(b.isBody())b.ibody.wake();\n                    else if(b.isShape())b.ishape.body.wake();\n                    else b.icompound.wake();\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=groups.begin();\n            while(cx_ite!=null){\n                var g=cx_ite.elem();\n                g.invalidate(force);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public static var SHAPE=1;\n    public static var BODY=2;\n    public function new(){\n        depth=0;\n        groups=new ZNPList_ZPP_InteractionGroup();\n        interactors=new ZNPList_ZPP_Interactor();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addGroup(group:ZPP_InteractionGroup){\n        groups.add(group);\n        group.depth=depth+1;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remGroup(group:ZPP_InteractionGroup){\n        groups.remove(group);\n        group.depth=0;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addInteractor(intx:ZPP_Interactor){\n        interactors.add(intx);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remInteractor(intx:ZPP_Interactor,flag:Int=-1){\n        interactors.remove(intx);\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_AABB{\n    public var _invalidate:Null<ZPP_AABB->Void>=null;\n    public var _validate:Null<Void->Void>=null;\n    public var _immutable:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate():Void{\n        if(_validate!=null){\n            _validate();\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate():Void{\n        if(_invalidate!=null){\n            _invalidate(this);\n        }\n    }\n    public var outer:Null<AABB>=null;\n    public function wrapper():AABB{\n        if(outer==null){\n            outer=new AABB();\n            {\n                var o=outer.zpp_inner;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABB\"+\", in obj: \"+\"outer.zpp_inner\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_AABB.zpp_pool;\n                ZPP_AABB.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT++;\n                ZPP_AABB.POOL_SUB++;\n                #end\n            };\n            outer.zpp_inner=this;\n        }\n        return outer;\n    }\n    public var next:ZPP_AABB=null;\n    static public var zpp_pool:ZPP_AABB=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        if(outer!=null){\n            outer.zpp_inner=null;\n            outer=null;\n        }\n        wrap_min=wrap_max=null;\n        _invalidate=null;\n        _validate=null;\n    }\n    public function new(){}\n    public static#if NAPE_NO_INLINE#else inline #end\n    function get(minx:Float,miny:Float,maxx:Float,maxy:Float):ZPP_AABB{\n        var ret;\n        {\n            if(ZPP_AABB.zpp_pool==null){\n                ret=new ZPP_AABB();\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_TOT++;\n                ZPP_AABB.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_AABB.zpp_pool;\n                ZPP_AABB.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT--;\n                ZPP_AABB.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        {\n            ret.minx=minx;\n            ret.miny=miny;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.minx!=ret.minx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.minx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.min\"+\",in x: \"+\"minx\"+\",in y: \"+\"miny\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.miny!=ret.miny));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.miny)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.min\"+\",in x: \"+\"minx\"+\",in y: \"+\"miny\"+\")\");\n                #end\n            };\n        };\n        {\n            ret.maxx=maxx;\n            ret.maxy=maxy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.maxx!=ret.maxx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.maxx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.max\"+\",in x: \"+\"maxx\"+\",in y: \"+\"maxy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.maxy!=ret.maxy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.maxy)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.max\"+\",in x: \"+\"maxx\"+\",in y: \"+\"maxy\"+\")\");\n                #end\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function copy():ZPP_AABB{\n        return ZPP_AABB.get(minx,miny,maxx,maxy);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function width():Float{\n        return maxx-minx;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function height():Float{\n        return maxy-miny;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function perimeter():Float{\n        return(width()+height())*2;\n    }\n    public var minx:Float=0.0;\n    public var miny:Float=0.0;\n    public var wrap_min:Null<Vec2>=null;\n    public function getmin():Vec2{\n        if(wrap_min==null){\n            wrap_min=Vec2.get(minx,miny);\n            wrap_min.zpp_inner._inuse=true;\n            if(_immutable){\n                wrap_min.zpp_inner._immutable=true;\n            }\n            else{\n                wrap_min.zpp_inner._invalidate=mod_min;\n            }\n            wrap_min.zpp_inner._validate=dom_min;\n        }\n        return wrap_min;\n    }\n    public function dom_min():Void{\n        validate();\n        {\n            wrap_min.zpp_inner.x=minx;\n            wrap_min.zpp_inner.y=miny;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_min.zpp_inner.x!=wrap_min.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_min.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_min.zpp_inner.\"+\",in x: \"+\"minx\"+\",in y: \"+\"miny\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_min.zpp_inner.y!=wrap_min.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_min.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_min.zpp_inner.\"+\",in x: \"+\"minx\"+\",in y: \"+\"miny\"+\")\");\n                #end\n            };\n        };\n    }\n    public function mod_min(min:ZPP_Vec2):Void{\n        if(min.x!=minx||min.y!=miny){\n            {\n                minx=min.x;\n                miny=min.y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((minx!=minx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(minx)\"+\") :: \"+(\"vec_set(in n: \"+\"min\"+\",in x: \"+\"min.x\"+\",in y: \"+\"min.y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((miny!=miny));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(miny)\"+\") :: \"+(\"vec_set(in n: \"+\"min\"+\",in x: \"+\"min.x\"+\",in y: \"+\"min.y\"+\")\");\n                    #end\n                };\n            };\n            invalidate();\n        }\n    }\n    public var maxx:Float=0.0;\n    public var maxy:Float=0.0;\n    public var wrap_max:Null<Vec2>=null;\n    public function getmax():Vec2{\n        if(wrap_max==null){\n            wrap_max=Vec2.get(maxx,maxy);\n            wrap_max.zpp_inner._inuse=true;\n            if(_immutable){\n                wrap_max.zpp_inner._immutable=true;\n            }\n            else{\n                wrap_max.zpp_inner._invalidate=mod_max;\n            }\n            wrap_max.zpp_inner._validate=dom_max;\n        }\n        return wrap_max;\n    }\n    public function dom_max():Void{\n        validate();\n        {\n            wrap_max.zpp_inner.x=maxx;\n            wrap_max.zpp_inner.y=maxy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_max.zpp_inner.x!=wrap_max.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_max.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_max.zpp_inner.\"+\",in x: \"+\"maxx\"+\",in y: \"+\"maxy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_max.zpp_inner.y!=wrap_max.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_max.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_max.zpp_inner.\"+\",in x: \"+\"maxx\"+\",in y: \"+\"maxy\"+\")\");\n                #end\n            };\n        };\n    }\n    public function mod_max(max:ZPP_Vec2):Void{\n        if(max.x!=maxx||max.y!=maxy){\n            {\n                maxx=max.x;\n                maxy=max.y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((maxx!=maxx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(maxx)\"+\") :: \"+(\"vec_set(in n: \"+\"max\"+\",in x: \"+\"max.x\"+\",in y: \"+\"max.y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((maxy!=maxy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(maxy)\"+\") :: \"+(\"vec_set(in n: \"+\"max\"+\",in x: \"+\"max.x\"+\",in y: \"+\"max.y\"+\")\");\n                    #end\n                };\n            };\n            invalidate();\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function intersectX(x:ZPP_AABB):Bool{\n        return!(x.minx>maxx||minx>x.maxx);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function intersectY(x:ZPP_AABB):Bool{\n        return!(x.miny>maxy||miny>x.maxy);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function intersect(x:ZPP_AABB):Bool{\n        return x.miny<=maxy&&miny<=x.maxy&&x.minx<=maxx&&minx<=x.maxx;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function combine(x:ZPP_AABB):Void{\n        if(x.minx<minx)minx=x.minx;\n        if(x.maxx>maxx)maxx=x.maxx;\n        if(x.miny<miny)miny=x.miny;\n        if(x.maxy>maxy)maxy=x.maxy;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function contains(x:ZPP_AABB):Bool{\n        return x.minx>=minx&&x.miny>=miny&&x.maxx<=maxx&&x.maxy<=maxy;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function containsPoint(v:ZPP_Vec2):Bool{\n        return v.x>=minx&&v.x<=maxx&&v.y>=miny&&v.y<=maxy;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setCombine(a:ZPP_AABB,b:ZPP_AABB):Void{\n        minx=if(a.minx<b.minx)a.minx else b.minx;\n        miny=if(a.miny<b.miny)a.miny else b.miny;\n        maxx=if(a.maxx>b.maxx)a.maxx else b.maxx;\n        maxy=if(a.maxy>b.maxy)a.maxy else b.maxy;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setExpand(a:ZPP_AABB,fatten:Float):Void{\n        minx=a.minx-fatten;\n        miny=a.miny-fatten;\n        maxx=a.maxx+fatten;\n        maxy=a.maxy+fatten;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setExpandPoint(x:Float,y:Float):Void{\n        if(x<minx)minx=x;\n        if(x>maxx)maxx=x;\n        if(y<miny)miny=y;\n        if(y>maxy)maxy=y;\n    }\n    public function toString(){\n        return \"{ x: \"+minx+\" y: \"+miny+\" w: \"+width()+\" h: \"+height()+\" }\";\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Collide{\n     public static function circleContains(c:ZPP_Circle,p:ZPP_Vec2){\n        var dx:Float=0.0;\n        var dy:Float=0.0;\n        {\n            dx=p.x-c.worldCOMx;\n            dy=p.y-c.worldCOMy;\n        };\n        return(dx*dx+dy*dy)<c.radius*c.radius;\n    }\n     public static function polyContains(s:ZPP_Polygon,p:ZPP_Vec2){\n        var retvar;\n        {\n            retvar=true;\n            {\n                var cx_ite=s.edges.begin();\n                while(cx_ite!=null){\n                    var a=cx_ite.elem();\n                    {\n                        if((a.gnormx*p.x+a.gnormy*p.y)<=a.gprojection){\n                            {\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                        }\n                        else{\n                            retvar=false;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return retvar;\n    }\n     public static function shapeContains(s:ZPP_Shape,p:ZPP_Vec2){\n        return if(s.isCircle())circleContains(s.circle,p);\n        else polyContains(s.polygon,p);\n    }\n     public static function bodyContains(b:ZPP_Body,p:ZPP_Vec2){\n        var retvar;\n        {\n            retvar=false;\n            {\n                var cx_ite=b.shapes.begin();\n                while(cx_ite!=null){\n                    var s=cx_ite.elem();\n                    {\n                        if(shapeContains(s,p)){\n                            retvar=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return retvar;\n    }\n     public static function containTest(s1:ZPP_Shape,s2:ZPP_Shape){\n        if(s1.aabb.contains(s2.aabb)){\n            return if(s1.isCircle()){\n                if(s2.isCircle()){\n                    var minDist=s1.circle.radius+(-s2.circle.radius);\n                    var px:Float=0.0;\n                    var py:Float=0.0;\n                    {\n                        px=s2.circle.worldCOMx-s1.circle.worldCOMx;\n                        py=s2.circle.worldCOMy-s1.circle.worldCOMy;\n                    };\n                    var distSqr=(px*px+py*py);\n                    distSqr<=minDist*minDist;\n                };\n                else({\n                    var retvar;\n                    {\n                        retvar=true;\n                        {\n                            var cx_ite=s2.polygon.gverts.begin();\n                            while(cx_ite!=null){\n                                var p=cx_ite.elem();\n                                {\n                                    if({\n                                        var minDist=s1.circle.radius+0;\n                                        var px:Float=0.0;\n                                        var py:Float=0.0;\n                                        {\n                                            px=p.x-s1.circle.worldCOMx;\n                                            py=p.y-s1.circle.worldCOMy;\n                                        };\n                                        var distSqr=(px*px+py*py);\n                                        distSqr<=minDist*minDist;\n                                    }){\n                                        {\n                                            cx_ite=cx_ite.next;\n                                            continue;\n                                        };\n                                    }\n                                    else{\n                                        retvar=false;\n                                        break;\n                                    }\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                    };\n                    retvar;\n                });\n            }\n            else{\n                if(s2.isCircle())({\n                    var retvar;\n                    {\n                        retvar=true;\n                        {\n                            var cx_ite=s1.polygon.edges.begin();\n                            while(cx_ite!=null){\n                                var a=cx_ite.elem();\n                                {\n                                    if((a.gnormx*s2.circle.worldCOMx+a.gnormy*s2.circle.worldCOMy)+s2.circle.radius<=a.gprojection){\n                                        {\n                                            cx_ite=cx_ite.next;\n                                            continue;\n                                        };\n                                    }\n                                    else{\n                                        retvar=false;\n                                        break;\n                                    }\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                    };\n                    retvar;\n                });\n                else({\n                    var retvar;\n                    {\n                        retvar=true;\n                        {\n                            var cx_ite=s1.polygon.edges.begin();\n                            while(cx_ite!=null){\n                                var a=cx_ite.elem();\n                                {\n                                    if({\n                                        var max=-ZPP_Const.FMAX;\n                                        {\n                                            var cx_ite=s2.polygon.gverts.begin();\n                                            while(cx_ite!=null){\n                                                var v=cx_ite.elem();\n                                                {\n                                                    var k=(a.gnormx*v.x+a.gnormy*v.y);\n                                                    if(k>max)max=k;\n                                                };\n                                                cx_ite=cx_ite.next;\n                                            }\n                                        };\n                                        max<=a.gprojection;\n                                    }){\n                                        {\n                                            cx_ite=cx_ite.next;\n                                            continue;\n                                        };\n                                    }\n                                    else{\n                                        retvar=false;\n                                        break;\n                                    }\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                    };\n                    retvar;\n                });\n            };\n        }\n        else return false;\n    }\n    public static function contactCollide(s1:ZPP_Shape,s2:ZPP_Shape,arb:ZPP_ColArbiter,rev:Bool){\n        if(s2.isPolygon()){\n            if(s1.isPolygon()){\n                var cont=true;\n                var max=-ZPP_Const.FMAX;\n                var maxmin=-ZPP_Const.FMAX;\n                var maxi=-1;\n                var axis1:ZPP_Edge=null;\n                var axis2:ZPP_Edge=null;\n                {\n                    var cx_ite=s1.polygon.edges.begin();\n                    while(cx_ite!=null){\n                        var ax=cx_ite.elem();\n                        {\n                            var min=ZPP_Const.FMAX;\n                            {\n                                var cx_ite=s2.polygon.gverts.begin();\n                                while(cx_ite!=null){\n                                    var v=cx_ite.elem();\n                                    {\n                                        var k=(ax.gnormx*v.x+ax.gnormy*v.y);\n                                        if(k<min)min=k;\n                                        if(min-ax.gprojection<=max)break;\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                            min-=ax.gprojection;\n                            if(min>=0){\n                                cont=false;\n                                break;\n                            }\n                            if(min>max){\n                                max=min;\n                                axis1=ax;\n                                maxi=1;\n                            }\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                if(cont){\n                    {\n                        var cx_ite=s2.polygon.edges.begin();\n                        while(cx_ite!=null){\n                            var ax=cx_ite.elem();\n                            {\n                                var min=ZPP_Const.FMAX;\n                                {\n                                    var cx_ite=s1.polygon.gverts.begin();\n                                    while(cx_ite!=null){\n                                        var v=cx_ite.elem();\n                                        {\n                                            var k=(ax.gnormx*v.x+ax.gnormy*v.y);\n                                            if(k<min)min=k;\n                                            if(min-ax.gprojection<=max)break;\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                min-=ax.gprojection;\n                                if(min>=0){\n                                    cont=false;\n                                    break;\n                                }\n                                if(min>max){\n                                    max=min;\n                                    axis2=ax;\n                                    maxi=2;\n                                }\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    if(!cont)return false;\n                    else{\n                        var q1,q2,ax,scale;\n                        if(maxi==1){\n                            q1=s1.polygon;\n                            q2=s2.polygon;\n                            ax=axis1;\n                            scale=1.0;\n                        }\n                        else{\n                            q1=s2.polygon;\n                            q2=s1.polygon;\n                            ax=axis2;\n                            scale=-1.0;\n                        }\n                        var ay:ZPP_Edge=null;\n                        var min=ZPP_Const.FMAX;\n                        {\n                            var cx_ite=q2.edges.begin();\n                            while(cx_ite!=null){\n                                var axis=cx_ite.elem();\n                                {\n                                    var k=(ax.gnormx*axis.gnormx+ax.gnormy*axis.gnormy);\n                                    if(k<min){\n                                        min=k;\n                                        ay=axis;\n                                    }\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                        var c0x:Float=0.0;\n                        var c0y:Float=0.0;\n                        {\n                            c0x=ay.gp0.x;\n                            c0y=ay.gp0.y;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((c0x!=c0x));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(c0x)\"+\") :: \"+(\"vec_set(in n: \"+\"c0\"+\",in x: \"+\"ay.gp0.x\"+\",in y: \"+\"ay.gp0.y\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((c0y!=c0y));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(c0y)\"+\") :: \"+(\"vec_set(in n: \"+\"c0\"+\",in x: \"+\"ay.gp0.x\"+\",in y: \"+\"ay.gp0.y\"+\")\");\n                                #end\n                            };\n                        };\n                        var c1x:Float=0.0;\n                        var c1y:Float=0.0;\n                        {\n                            c1x=ay.gp1.x;\n                            c1y=ay.gp1.y;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((c1x!=c1x));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(c1x)\"+\") :: \"+(\"vec_set(in n: \"+\"c1\"+\",in x: \"+\"ay.gp1.x\"+\",in y: \"+\"ay.gp1.y\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((c1y!=c1y));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(c1y)\"+\") :: \"+(\"vec_set(in n: \"+\"c1\"+\",in x: \"+\"ay.gp1.x\"+\",in y: \"+\"ay.gp1.y\"+\")\");\n                                #end\n                            };\n                        };\n                        var dvx:Float=0.0;\n                        var dvy:Float=0.0;\n                        {\n                            dvx=c1x-c0x;\n                            dvy=c1y-c0y;\n                        };\n                        var d0=(ax.gnormy*c0x-ax.gnormx*c0y);\n                        var d1=(ax.gnormy*c1x-ax.gnormx*c1y);\n                        var den=1/(d1-d0);\n                        var t=(-ax.tp1-d0)*den;\n                        if(t>Config.epsilon){\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c0\"+\",in b: \"+\"dv\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            c0x+=dvx*t;\n                            c0y+=dvy*t;\n                        };\n                        var t=(-ax.tp0-d1)*den;\n                        if(t<-Config.epsilon){\n                            var t=(t);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c1\"+\",in b: \"+\"dv\"+\",in s: \"+\"t\"+\")\");\n                                #end\n                            };\n                            c1x+=dvx*t;\n                            c1y+=dvy*t;\n                        };\n                        var nx:Float=0.0;\n                        var ny:Float=0.0;\n                        {\n                            var t=(scale);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_mul(in a: \"+\"ax.gnorm\"+\",in s: \"+\"scale\"+\",out r: \"+\"n\"+\")\");\n                                #end\n                            };\n                            nx=ax.gnormx*t;\n                            ny=ax.gnormy*t;\n                        };\n                        {\n                            arb.lnormx=ax.lnormx;\n                            arb.lnormy=ax.lnormy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((arb.lnormx!=arb.lnormx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(arb.lnormx)\"+\") :: \"+(\"vec_set(in n: \"+\"arb.lnorm\"+\",in x: \"+\"ax.lnormx\"+\",in y: \"+\"ax.lnormy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((arb.lnormy!=arb.lnormy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(arb.lnormy)\"+\") :: \"+(\"vec_set(in n: \"+\"arb.lnorm\"+\",in x: \"+\"ax.lnormx\"+\",in y: \"+\"ax.lnormy\"+\")\");\n                                #end\n                            };\n                        };\n                        arb.lproj=ax.lprojection;\n                        arb.radius=0;\n                        arb.rev=rev!=(scale==-1);\n                        arb.ptype=arb.rev?ZPP_ColArbiter.FACE2:ZPP_ColArbiter.FACE1;\n                        var c0d=(c0x*ax.gnormx+c0y*ax.gnormy)-ax.gprojection;\n                        var c1d=(c1x*ax.gnormx+c1y*ax.gnormy)-ax.gprojection;\n                        if(c0d>0&&c1d>0){\n                            return false;\n                        }\n                        else{\n                            if(rev){\n                                nx=-nx;\n                                ny=-ny;\n                            }\n                            var con=arb.injectContact(c0x-(ax.gnormx*c0d*0.5),c0y-(ax.gnormy*c0d*0.5),nx,ny,c0d,arb.rev?1:0,c0d>0);\n                            {\n                                var t=(1.0);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"c0\"+\",in b: \"+\"q2.body.pos\"+\",in s: \"+\"1.0\"+\")\");\n                                    #end\n                                };\n                                c0x-=q2.body.posx*t;\n                                c0y-=q2.body.posy*t;\n                            };\n                            {\n                                con.inner.lr1x=c0x*q2.body.axisy+c0y*q2.body.axisx;\n                                con.inner.lr1y=c0y*q2.body.axisy-c0x*q2.body.axisx;\n                            };\n                            con=arb.injectContact(c1x-(ax.gnormx*c1d*0.5),c1y-(ax.gnormy*c1d*0.5),nx,ny,c1d,arb.rev?0:1,c1d>0);\n                            {\n                                var t=(1.0);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"c1\"+\",in b: \"+\"q2.body.pos\"+\",in s: \"+\"1.0\"+\")\");\n                                    #end\n                                };\n                                c1x-=q2.body.posx*t;\n                                c1y-=q2.body.posy*t;\n                            };\n                            {\n                                con.inner.lr1x=c1x*q2.body.axisy+c1y*q2.body.axisx;\n                                con.inner.lr1y=c1y*q2.body.axisy-c1x*q2.body.axisx;\n                            };\n                            if(maxi==1){\n                                arb.__ref_edge1=ax;\n                                arb.__ref_edge2=ay;\n                            }\n                            else{\n                                arb.__ref_edge2=ax;\n                                arb.__ref_edge1=ay;\n                            }\n                            return true;\n                        }\n                    }\n                }\n                else return false;\n            };\n            else{\n                var max=-ZPP_Const.FMAX;\n                var minmax=-ZPP_Const.FMAX;\n                var cont=true;\n                var a0=null,vi=null;\n                var vite=s2.polygon.gverts.begin();\n                {\n                    var cx_ite=s2.polygon.edges.begin();\n                    while(cx_ite!=null){\n                        var a=cx_ite.elem();\n                        {\n                            var dist=(a.gnormx*s1.circle.worldCOMx+a.gnormy*s1.circle.worldCOMy)-a.gprojection-s1.circle.radius;\n                            if(dist>0){\n                                cont=false;\n                                break;\n                            }\n                            if(dist>max){\n                                max=dist;\n                                a0=a;\n                                vi=vite;\n                            }\n                            vite=vite.next;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                if(cont){\n                    var v0=vi.elem();\n                    var v1=if(vi.next==null)s2.polygon.gverts.front()else vi.next.elem();\n                    var dt=(s1.circle.worldCOMy*a0.gnormx-s1.circle.worldCOMx*a0.gnormy);\n                    if(dt<=(v0.y*a0.gnormx-v0.x*a0.gnormy)){\n                        var co={\n                            var minDist=s1.circle.radius+0;\n                            var px:Float=0.0;\n                            var py:Float=0.0;\n                            {\n                                px=v0.x-s1.circle.worldCOMx;\n                                py=v0.y-s1.circle.worldCOMy;\n                            };\n                            var distSqr=(px*px+py*py);\n                            if(distSqr>minDist*minDist)null;\n                            else if(distSqr<Config.epsilon*Config.epsilon)arb.injectContact(s1.circle.worldCOMx,s1.circle.worldCOMy,1,0,-minDist,0);\n                            else{\n                                var invDist=ZPP_Math.invsqrt(distSqr);\n                                var dist=if(invDist<Config.epsilon)ZPP_Const.FMAX else 1.0/invDist;\n                                var df=0.5+(s1.circle.radius-0.5*minDist)*invDist;\n                                if(rev)arb.injectContact(s1.circle.worldCOMx+px*df,s1.circle.worldCOMy+py*df,-px*invDist,-py*invDist,dist-minDist,0);\n                                else arb.injectContact(s1.circle.worldCOMx+px*df,s1.circle.worldCOMy+py*df,px*invDist,py*invDist,dist-minDist,0);\n                            }\n                        };\n                        if(co!=null){\n                            var con=co.inner;\n                            arb.ptype=ZPP_ColArbiter.CIRCLE;\n                            var vx:Float=0.0;\n                            var vy:Float=0.0;\n                            {\n                                vx=v0.x-s2.polygon.body.posx;\n                                vy=v0.y-s2.polygon.body.posy;\n                            };\n                            arb.__ref_edge1=a0;\n                            arb.__ref_vertex=-1;\n                            if(rev){\n                                {\n                                    con.lr1x=vx*s2.polygon.body.axisy+vy*s2.polygon.body.axisx;\n                                    con.lr1y=vy*s2.polygon.body.axisy-vx*s2.polygon.body.axisx;\n                                };\n                                {\n                                    con.lr2x=s1.circle.localCOMx;\n                                    con.lr2y=s1.circle.localCOMy;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((con.lr2x!=con.lr2x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr2x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr2\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((con.lr2y!=con.lr2y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr2y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr2\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                        #end\n                                    };\n                                };\n                            }\n                            else{\n                                {\n                                    con.lr2x=vx*s2.polygon.body.axisy+vy*s2.polygon.body.axisx;\n                                    con.lr2y=vy*s2.polygon.body.axisy-vx*s2.polygon.body.axisx;\n                                };\n                                {\n                                    con.lr1x=s1.circle.localCOMx;\n                                    con.lr1y=s1.circle.localCOMy;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((con.lr1x!=con.lr1x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr1x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr1\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((con.lr1y!=con.lr1y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr1y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr1\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                        #end\n                                    };\n                                };\n                            }\n                            arb.radius=s1.circle.radius;\n                        }\n                        return co!=null;\n                    }\n                    else if(dt>=(v1.y*a0.gnormx-v1.x*a0.gnormy)){\n                        var co={\n                            var minDist=s1.circle.radius+0;\n                            var px:Float=0.0;\n                            var py:Float=0.0;\n                            {\n                                px=v1.x-s1.circle.worldCOMx;\n                                py=v1.y-s1.circle.worldCOMy;\n                            };\n                            var distSqr=(px*px+py*py);\n                            if(distSqr>minDist*minDist)null;\n                            else if(distSqr<Config.epsilon*Config.epsilon)arb.injectContact(s1.circle.worldCOMx,s1.circle.worldCOMy,1,0,-minDist,0);\n                            else{\n                                var invDist=ZPP_Math.invsqrt(distSqr);\n                                var dist=if(invDist<Config.epsilon)ZPP_Const.FMAX else 1.0/invDist;\n                                var df=0.5+(s1.circle.radius-0.5*minDist)*invDist;\n                                if(rev)arb.injectContact(s1.circle.worldCOMx+px*df,s1.circle.worldCOMy+py*df,-px*invDist,-py*invDist,dist-minDist,0);\n                                else arb.injectContact(s1.circle.worldCOMx+px*df,s1.circle.worldCOMy+py*df,px*invDist,py*invDist,dist-minDist,0);\n                            }\n                        };\n                        if(co!=null){\n                            var con=co.inner;\n                            arb.ptype=ZPP_ColArbiter.CIRCLE;\n                            var vx:Float=0.0;\n                            var vy:Float=0.0;\n                            {\n                                vx=v1.x-s2.polygon.body.posx;\n                                vy=v1.y-s2.polygon.body.posy;\n                            };\n                            arb.__ref_edge1=a0;\n                            arb.__ref_vertex=1;\n                            if(rev){\n                                {\n                                    con.lr1x=vx*s2.polygon.body.axisy+vy*s2.polygon.body.axisx;\n                                    con.lr1y=vy*s2.polygon.body.axisy-vx*s2.polygon.body.axisx;\n                                };\n                                {\n                                    con.lr2x=s1.circle.localCOMx;\n                                    con.lr2y=s1.circle.localCOMy;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((con.lr2x!=con.lr2x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr2x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr2\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((con.lr2y!=con.lr2y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr2y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr2\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                        #end\n                                    };\n                                };\n                            }\n                            else{\n                                {\n                                    con.lr2x=vx*s2.polygon.body.axisy+vy*s2.polygon.body.axisx;\n                                    con.lr2y=vy*s2.polygon.body.axisy-vx*s2.polygon.body.axisx;\n                                };\n                                {\n                                    con.lr1x=s1.circle.localCOMx;\n                                    con.lr1y=s1.circle.localCOMy;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((con.lr1x!=con.lr1x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr1x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr1\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((con.lr1y!=con.lr1y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr1y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr1\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                        #end\n                                    };\n                                };\n                            }\n                            arb.radius=s1.circle.radius;\n                        }\n                        return co!=null;\n                    }\n                    else{\n                        var nx:Float=0.0;\n                        var ny:Float=0.0;\n                        {\n                            var t=(s1.circle.radius+max*0.5);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_mul(in a: \"+\"a0.gnorm\"+\",in s: \"+\"s1.circle.radius+max*0.5\"+\",out r: \"+\"n\"+\")\");\n                                #end\n                            };\n                            nx=a0.gnormx*t;\n                            ny=a0.gnormy*t;\n                        };\n                        var px:Float=0.0;\n                        var py:Float=0.0;\n                        {\n                            px=s1.circle.worldCOMx-nx;\n                            py=s1.circle.worldCOMy-ny;\n                        };\n                        var con=if(rev)arb.injectContact(px,py,a0.gnormx,a0.gnormy,max,0);\n                        else arb.injectContact(px,py,-a0.gnormx,-a0.gnormy,max,0);\n                        arb.ptype=if(rev)ZPP_ColArbiter.FACE1 else ZPP_ColArbiter.FACE2;\n                        {\n                            arb.lnormx=a0.lnormx;\n                            arb.lnormy=a0.lnormy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((arb.lnormx!=arb.lnormx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(arb.lnormx)\"+\") :: \"+(\"vec_set(in n: \"+\"arb.lnorm\"+\",in x: \"+\"a0.lnormx\"+\",in y: \"+\"a0.lnormy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((arb.lnormy!=arb.lnormy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(arb.lnormy)\"+\") :: \"+(\"vec_set(in n: \"+\"arb.lnorm\"+\",in x: \"+\"a0.lnormx\"+\",in y: \"+\"a0.lnormy\"+\")\");\n                                #end\n                            };\n                        };\n                        arb.rev=!rev;\n                        arb.lproj=a0.lprojection;\n                        arb.radius=s1.circle.radius;\n                        {\n                            con.inner.lr1x=s1.circle.localCOMx;\n                            con.inner.lr1y=s1.circle.localCOMy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((con.inner.lr1x!=con.inner.lr1x));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(con.inner.lr1x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.inner.lr1\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((con.inner.lr1y!=con.inner.lr1y));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(con.inner.lr1y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.inner.lr1\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                                #end\n                            };\n                        };\n                        arb.__ref_edge1=a0;\n                        arb.__ref_vertex=0;\n                        return true;\n                    }\n                }\n                else return false;\n            };\n        }\n        else{\n            var co={\n                var minDist=s1.circle.radius+s2.circle.radius;\n                var px:Float=0.0;\n                var py:Float=0.0;\n                {\n                    px=s2.circle.worldCOMx-s1.circle.worldCOMx;\n                    py=s2.circle.worldCOMy-s1.circle.worldCOMy;\n                };\n                var distSqr=(px*px+py*py);\n                if(distSqr>minDist*minDist)null;\n                else if(distSqr<Config.epsilon*Config.epsilon)arb.injectContact(s1.circle.worldCOMx,s1.circle.worldCOMy,1,0,-minDist,0);\n                else{\n                    var invDist=ZPP_Math.invsqrt(distSqr);\n                    var dist=if(invDist<Config.epsilon)ZPP_Const.FMAX else 1.0/invDist;\n                    var df=0.5+(s1.circle.radius-0.5*minDist)*invDist;\n                    if(rev)arb.injectContact(s1.circle.worldCOMx+px*df,s1.circle.worldCOMy+py*df,-px*invDist,-py*invDist,dist-minDist,0);\n                    else arb.injectContact(s1.circle.worldCOMx+px*df,s1.circle.worldCOMy+py*df,px*invDist,py*invDist,dist-minDist,0);\n                }\n            };\n            if(co!=null){\n                var con=co.inner;\n                if(rev){\n                    {\n                        con.lr1x=s2.circle.localCOMx;\n                        con.lr1y=s2.circle.localCOMy;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((con.lr1x!=con.lr1x));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr1x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr1\"+\",in x: \"+\"s2.circle.localCOMx\"+\",in y: \"+\"s2.circle.localCOMy\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((con.lr1y!=con.lr1y));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr1y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr1\"+\",in x: \"+\"s2.circle.localCOMx\"+\",in y: \"+\"s2.circle.localCOMy\"+\")\");\n                            #end\n                        };\n                    };\n                    {\n                        con.lr2x=s1.circle.localCOMx;\n                        con.lr2y=s1.circle.localCOMy;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((con.lr2x!=con.lr2x));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr2x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr2\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((con.lr2y!=con.lr2y));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr2y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr2\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                            #end\n                        };\n                    };\n                }\n                else{\n                    {\n                        con.lr1x=s1.circle.localCOMx;\n                        con.lr1y=s1.circle.localCOMy;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((con.lr1x!=con.lr1x));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr1x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr1\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((con.lr1y!=con.lr1y));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr1y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr1\"+\",in x: \"+\"s1.circle.localCOMx\"+\",in y: \"+\"s1.circle.localCOMy\"+\")\");\n                            #end\n                        };\n                    };\n                    {\n                        con.lr2x=s2.circle.localCOMx;\n                        con.lr2y=s2.circle.localCOMy;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((con.lr2x!=con.lr2x));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr2x)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr2\"+\",in x: \"+\"s2.circle.localCOMx\"+\",in y: \"+\"s2.circle.localCOMy\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((con.lr2y!=con.lr2y));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(con.lr2y)\"+\") :: \"+(\"vec_set(in n: \"+\"con.lr2\"+\",in x: \"+\"s2.circle.localCOMx\"+\",in y: \"+\"s2.circle.localCOMy\"+\")\");\n                            #end\n                        };\n                    };\n                }\n                arb.radius=s1.circle.radius+s2.circle.radius;\n                arb.ptype=ZPP_ColArbiter.CIRCLE;\n                return true;\n            }\n            else return false;\n        };\n    }\n     public static function testCollide_safe(s1:ZPP_Shape,s2:ZPP_Shape){\n        if(s2.isCircle()){\n            var t=s1;\n            s1=s2;\n            s2=t;\n        };\n        return testCollide(s1,s2);\n    }\n     public static function testCollide(s1:ZPP_Shape,s2:ZPP_Shape){\n        if(s2.isPolygon()){\n            return if(s1.isPolygon()){\n                var cont=true;\n                {\n                    var cx_ite=s1.polygon.edges.begin();\n                    while(cx_ite!=null){\n                        var ax=cx_ite.elem();\n                        {\n                            var min=ZPP_Const.FMAX;\n                            {\n                                var cx_ite=s2.polygon.gverts.begin();\n                                while(cx_ite!=null){\n                                    var v=cx_ite.elem();\n                                    {\n                                        var k=(ax.gnormx*v.x+ax.gnormy*v.y);\n                                        if(k<min)min=k;\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                            min-=ax.gprojection;\n                            if(min>0){\n                                cont=false;\n                                break;\n                            }\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                if(cont){\n                    {\n                        var cx_ite=s2.polygon.edges.begin();\n                        while(cx_ite!=null){\n                            var ax=cx_ite.elem();\n                            {\n                                var min=ZPP_Const.FMAX;\n                                {\n                                    var cx_ite=s1.polygon.gverts.begin();\n                                    while(cx_ite!=null){\n                                        var v=cx_ite.elem();\n                                        {\n                                            var k=(ax.gnormx*v.x+ax.gnormy*v.y);\n                                            if(k<min)min=k;\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                min-=ax.gprojection;\n                                if(min>0){\n                                    cont=false;\n                                    break;\n                                }\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    cont;\n                }\n                else false;\n            };\n            else{\n                var a0=null,vi=null;\n                var cont=true;\n                var max=-ZPP_Const.FMAX;\n                var vite=s2.polygon.gverts.begin();\n                {\n                    var cx_ite=s2.polygon.edges.begin();\n                    while(cx_ite!=null){\n                        var a=cx_ite.elem();\n                        {\n                            var dist=(a.gnormx*s1.circle.worldCOMx+a.gnormy*s1.circle.worldCOMy)-a.gprojection-s1.circle.radius;\n                            if(dist>0){\n                                cont=false;\n                                break;\n                            }\n                            if(dist>max){\n                                max=dist;\n                                a0=a;\n                                vi=vite;\n                            }\n                            vite=vite.next;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                if(cont){\n                    var v0=vi.elem();\n                    var v1=if(vi.next==null)s2.polygon.gverts.front()else vi.next.elem();\n                    var dt=(s1.circle.worldCOMy*a0.gnormx-s1.circle.worldCOMx*a0.gnormy);\n                    if(dt<=(v0.y*a0.gnormx-v0.x*a0.gnormy)){\n                        var minDist=s1.circle.radius+0;\n                        var px:Float=0.0;\n                        var py:Float=0.0;\n                        {\n                            px=v0.x-s1.circle.worldCOMx;\n                            py=v0.y-s1.circle.worldCOMy;\n                        };\n                        var distSqr=(px*px+py*py);\n                        distSqr<=minDist*minDist;\n                    };\n                    else if(dt>=(v1.y*a0.gnormx-v1.x*a0.gnormy)){\n                        var minDist=s1.circle.radius+0;\n                        var px:Float=0.0;\n                        var py:Float=0.0;\n                        {\n                            px=v1.x-s1.circle.worldCOMx;\n                            py=v1.y-s1.circle.worldCOMy;\n                        };\n                        var distSqr=(px*px+py*py);\n                        distSqr<=minDist*minDist;\n                    };\n                    else true;\n                }\n                else false;\n            };\n        }\n        else return{\n            var minDist=s1.circle.radius+s2.circle.radius;\n            var px:Float=0.0;\n            var py:Float=0.0;\n            {\n                px=s2.circle.worldCOMx-s1.circle.worldCOMx;\n                py=s2.circle.worldCOMy-s1.circle.worldCOMy;\n            };\n            var distSqr=(px*px+py*py);\n            distSqr<=minDist*minDist;\n        };\n    }\n     public static function flowCollide(s1:ZPP_Shape,s2:ZPP_Shape,arb:ZPP_FluidArbiter){\n        if(s2.isPolygon()){\n            return if(s1.isPolygon()){\n                var out1=new Array<Bool>();\n                var out2=new Array<Bool>();\n                var cont=true;\n                var total=true;\n                {\n                    var cx_ite=s1.polygon.edges.begin();\n                    while(cx_ite!=null){\n                        var ax=cx_ite.elem();\n                        {\n                            var min=ZPP_Const.FMAX;\n                            var ind=0;\n                            {\n                                var cx_ite=s2.polygon.gverts.begin();\n                                while(cx_ite!=null){\n                                    var v=cx_ite.elem();\n                                    {\n                                        var k=(ax.gnormx*v.x+ax.gnormy*v.y);\n                                        if(k<min)min=k;\n                                        if(k>=ax.gprojection+Config.epsilon){\n                                            out2[ind]=true;\n                                            total=false;\n                                        }\n                                        ind++;\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                            min-=ax.gprojection;\n                            if(min>0){\n                                cont=false;\n                                break;\n                            }\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                if(total){\n                    s2.polygon.validate_worldCOM();\n                    arb.inject(s2.polygon.area,s2.polygon.worldCOMx,s2.polygon.worldCOMy);\n                    true;\n                }\n                else if(cont){\n                    total=true;\n                    {\n                        var cx_ite=s2.polygon.edges.begin();\n                        while(cx_ite!=null){\n                            var ax=cx_ite.elem();\n                            {\n                                var min=ZPP_Const.FMAX;\n                                var ind=0;\n                                {\n                                    var cx_ite=s1.polygon.gverts.begin();\n                                    while(cx_ite!=null){\n                                        var v=cx_ite.elem();\n                                        {\n                                            var k=(ax.gnormx*v.x+ax.gnormy*v.y);\n                                            if(k<min)min=k;\n                                            if(k>=ax.gprojection+Config.epsilon){\n                                                out1[ind]=true;\n                                                total=false;\n                                            }\n                                            ind++;\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                min-=ax.gprojection;\n                                if(min>0){\n                                    cont=false;\n                                    break;\n                                }\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    if(total){\n                        s1.polygon.validate_worldCOM();\n                        arb.inject(s1.polygon.area,s1.polygon.worldCOMx,s1.polygon.worldCOMy);\n                        true;\n                    }\n                    else if(cont){\n                        while(!flowpoly.empty()){\n                            var p=flowpoly.pop_unsafe();\n                            if(!p._inuse){\n                                var o=p;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        o!=null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"p\"+\")\");\n                                    #end\n                                };\n                                o.free();\n                                o.next=ZPP_Vec2.zpp_pool;\n                                ZPP_Vec2.zpp_pool=o;\n                                #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n                                ZPP_Vec2.POOL_SUB++;\n                                #end\n                            };\n                        }\n                        var fst_vert=null;\n                        var poly1=false;\n                        var ite1=s1.polygon.gverts.begin();\n                        var ind1=0;\n                        var ite2=s2.polygon.gverts.begin();\n                        var ind2=0;\n                        for(i in 0...s2.polygon.edgeCnt)if(!out2[i]){\n                            ind2=i;\n                            break;\n                        }\n                        else ite2=ite2.next;\n                        if(ite2==null){\n                            ite2=s2.polygon.gverts.begin();\n                            poly1=true;\n                            for(i in 0...s1.polygon.edgeCnt)if(!out1[i]){\n                                ind1=i;\n                                break;\n                            }\n                            else ite1=ite1.next;\n                            if(ite1==null)ite1=s1.polygon.gverts.begin();\n                            else{\n                                flowpoly.add(ite1.elem());\n                                fst_vert=flowpoly.front();\n                            }\n                        }\n                        else{\n                            flowpoly.add(ite2.elem());\n                            fst_vert=flowpoly.front();\n                        }\n                        var cnt=1;\n                        if(flowpoly.empty()){\n                            {\n                                var cx_cont=true;\n                                var cx_itei=s1.polygon.gverts.begin();\n                                var u=cx_itei.elem();\n                                var cx_itej=cx_itei.next;\n                                while(cx_itej!=null){\n                                    var v=cx_itej.elem();\n                                    {\n                                        var min=2.0;\n                                        {\n                                            var cx_cont=true;\n                                            var cx_itei=s2.polygon.gverts.begin();\n                                            var a=cx_itei.elem();\n                                            var cx_itej=cx_itei.next;\n                                            while(cx_itej!=null){\n                                                var b=cx_itej.elem();\n                                                {\n                                                    var t=0.0;\n                                                    if({\n                                                        var _sx:Float=0.0;\n                                                        var _sy:Float=0.0;\n                                                        {\n                                                            _sx=u.x-a.x;\n                                                            _sy=u.y-a.y;\n                                                        };\n                                                        var _vx:Float=0.0;\n                                                        var _vy:Float=0.0;\n                                                        {\n                                                            _vx=v.x-u.x;\n                                                            _vy=v.y-u.y;\n                                                        };\n                                                        var _qx:Float=0.0;\n                                                        var _qy:Float=0.0;\n                                                        {\n                                                            _qx=b.x-a.x;\n                                                            _qy=b.y-a.y;\n                                                        };\n                                                        var den=(_vy*_qx-_vx*_qy);\n                                                        if(den*den>Config.epsilon*Config.epsilon){\n                                                            den=1/den;\n                                                            var txx=(_qy*_sx-_qx*_sy)*den;\n                                                            if(txx>Config.epsilon&&txx<1-Config.epsilon){\n                                                                var sxx=(_vy*_sx-_vx*_sy)*den;\n                                                                if(sxx>Config.epsilon&&sxx<1-Config.epsilon){\n                                                                    t=txx;\n                                                                    true;\n                                                                }\n                                                                else false;\n                                                            }\n                                                            else false;\n                                                        }\n                                                        else false;\n                                                    }){\n                                                        if(t<min){\n                                                            min=t;\n                                                            ite2=cx_itei;\n                                                        }\n                                                    }\n                                                };\n                                                {\n                                                    cx_itei=cx_itej;\n                                                    a=b;\n                                                    cx_itej=cx_itej.next;\n                                                };\n                                            }\n                                            if(cx_cont){\n                                                do{\n                                                    cx_itej=s2.polygon.gverts.begin();\n                                                    var b=cx_itej.elem();\n                                                    {\n                                                        var t=0.0;\n                                                        if({\n                                                            var _sx:Float=0.0;\n                                                            var _sy:Float=0.0;\n                                                            {\n                                                                _sx=u.x-a.x;\n                                                                _sy=u.y-a.y;\n                                                            };\n                                                            var _vx:Float=0.0;\n                                                            var _vy:Float=0.0;\n                                                            {\n                                                                _vx=v.x-u.x;\n                                                                _vy=v.y-u.y;\n                                                            };\n                                                            var _qx:Float=0.0;\n                                                            var _qy:Float=0.0;\n                                                            {\n                                                                _qx=b.x-a.x;\n                                                                _qy=b.y-a.y;\n                                                            };\n                                                            var den=(_vy*_qx-_vx*_qy);\n                                                            if(den*den>Config.epsilon*Config.epsilon){\n                                                                den=1/den;\n                                                                var txx=(_qy*_sx-_qx*_sy)*den;\n                                                                if(txx>Config.epsilon&&txx<1-Config.epsilon){\n                                                                    var sxx=(_vy*_sx-_vx*_sy)*den;\n                                                                    if(sxx>Config.epsilon&&sxx<1-Config.epsilon){\n                                                                        t=txx;\n                                                                        true;\n                                                                    }\n                                                                    else false;\n                                                                }\n                                                                else false;\n                                                            }\n                                                            else false;\n                                                        }){\n                                                            if(t<min){\n                                                                min=t;\n                                                                ite2=cx_itei;\n                                                            }\n                                                        }\n                                                    };\n                                                }\n                                                while(false);\n                                            }\n                                        };\n                                        if(min!=2.0){\n                                            var cx:Float=0.0;\n                                            var cy:Float=0.0;\n                                            {\n                                                var T=(min);\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !(((T!=T))||T<0.0||T>1.0);\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"min\"+\",out c: \"+\"c\"+\")\");\n                                                    #end\n                                                };\n                                                cx=u.x+(v.x-u.x)*T;\n                                                cy=u.y+(v.y-u.y)*T;\n                                            };\n                                            fst_vert=ZPP_Vec2.get(cx,cy);\n                                            flowpoly.add(fst_vert);\n                                            poly1=true;\n                                            ite1=cx_itei;\n                                            {\n                                                cx_cont=false;\n                                                break;\n                                            };\n                                        }\n                                    };\n                                    {\n                                        cx_itei=cx_itej;\n                                        u=v;\n                                        cx_itej=cx_itej.next;\n                                    };\n                                }\n                                if(cx_cont){\n                                    do{\n                                        cx_itej=s1.polygon.gverts.begin();\n                                        var v=cx_itej.elem();\n                                        {\n                                            var min=2.0;\n                                            {\n                                                var cx_cont=true;\n                                                var cx_itei=s2.polygon.gverts.begin();\n                                                var a=cx_itei.elem();\n                                                var cx_itej=cx_itei.next;\n                                                while(cx_itej!=null){\n                                                    var b=cx_itej.elem();\n                                                    {\n                                                        var t=0.0;\n                                                        if({\n                                                            var _sx:Float=0.0;\n                                                            var _sy:Float=0.0;\n                                                            {\n                                                                _sx=u.x-a.x;\n                                                                _sy=u.y-a.y;\n                                                            };\n                                                            var _vx:Float=0.0;\n                                                            var _vy:Float=0.0;\n                                                            {\n                                                                _vx=v.x-u.x;\n                                                                _vy=v.y-u.y;\n                                                            };\n                                                            var _qx:Float=0.0;\n                                                            var _qy:Float=0.0;\n                                                            {\n                                                                _qx=b.x-a.x;\n                                                                _qy=b.y-a.y;\n                                                            };\n                                                            var den=(_vy*_qx-_vx*_qy);\n                                                            if(den*den>Config.epsilon*Config.epsilon){\n                                                                den=1/den;\n                                                                var txx=(_qy*_sx-_qx*_sy)*den;\n                                                                if(txx>Config.epsilon&&txx<1-Config.epsilon){\n                                                                    var sxx=(_vy*_sx-_vx*_sy)*den;\n                                                                    if(sxx>Config.epsilon&&sxx<1-Config.epsilon){\n                                                                        t=txx;\n                                                                        true;\n                                                                    }\n                                                                    else false;\n                                                                }\n                                                                else false;\n                                                            }\n                                                            else false;\n                                                        }){\n                                                            if(t<min){\n                                                                min=t;\n                                                                ite2=cx_itei;\n                                                            }\n                                                        }\n                                                    };\n                                                    {\n                                                        cx_itei=cx_itej;\n                                                        a=b;\n                                                        cx_itej=cx_itej.next;\n                                                    };\n                                                }\n                                                if(cx_cont){\n                                                    do{\n                                                        cx_itej=s2.polygon.gverts.begin();\n                                                        var b=cx_itej.elem();\n                                                        {\n                                                            var t=0.0;\n                                                            if({\n                                                                var _sx:Float=0.0;\n                                                                var _sy:Float=0.0;\n                                                                {\n                                                                    _sx=u.x-a.x;\n                                                                    _sy=u.y-a.y;\n                                                                };\n                                                                var _vx:Float=0.0;\n                                                                var _vy:Float=0.0;\n                                                                {\n                                                                    _vx=v.x-u.x;\n                                                                    _vy=v.y-u.y;\n                                                                };\n                                                                var _qx:Float=0.0;\n                                                                var _qy:Float=0.0;\n                                                                {\n                                                                    _qx=b.x-a.x;\n                                                                    _qy=b.y-a.y;\n                                                                };\n                                                                var den=(_vy*_qx-_vx*_qy);\n                                                                if(den*den>Config.epsilon*Config.epsilon){\n                                                                    den=1/den;\n                                                                    var txx=(_qy*_sx-_qx*_sy)*den;\n                                                                    if(txx>Config.epsilon&&txx<1-Config.epsilon){\n                                                                        var sxx=(_vy*_sx-_vx*_sy)*den;\n                                                                        if(sxx>Config.epsilon&&sxx<1-Config.epsilon){\n                                                                            t=txx;\n                                                                            true;\n                                                                        }\n                                                                        else false;\n                                                                    }\n                                                                    else false;\n                                                                }\n                                                                else false;\n                                                            }){\n                                                                if(t<min){\n                                                                    min=t;\n                                                                    ite2=cx_itei;\n                                                                }\n                                                            }\n                                                        };\n                                                    }\n                                                    while(false);\n                                                }\n                                            };\n                                            if(min!=2.0){\n                                                var cx:Float=0.0;\n                                                var cy:Float=0.0;\n                                                {\n                                                    var T=(min);\n                                                    {\n                                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                        var res={\n                                                            !(((T!=T))||T<0.0||T>1.0);\n                                                        };\n                                                        if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"min\"+\",out c: \"+\"c\"+\")\");\n                                                        #end\n                                                    };\n                                                    cx=u.x+(v.x-u.x)*T;\n                                                    cy=u.y+(v.y-u.y)*T;\n                                                };\n                                                fst_vert=ZPP_Vec2.get(cx,cy);\n                                                flowpoly.add(fst_vert);\n                                                poly1=true;\n                                                ite1=cx_itei;\n                                                break;\n                                            }\n                                        };\n                                    }\n                                    while(false);\n                                }\n                            };\n                            cnt=2;\n                        }\n                        while(true){\n                            if(poly1){\n                                ite1=ite1.next;\n                                ind1++;\n                                if(ite1==null){\n                                    ite1=s1.polygon.gverts.begin();\n                                    ind1=0;\n                                }\n                                if(!out1[ind1]){\n                                    var ex=ite1.elem();\n                                    if(fst_vert!=null&&ZPP_VecMath.vec_dsq(ex.x,ex.y,fst_vert.x,fst_vert.y)<Config.epsilon)break;\n                                    flowpoly.add(ex);\n                                    if(fst_vert==null)fst_vert=flowpoly.front();\n                                    cnt=1;\n                                }\n                                else{\n                                    var a=flowpoly.front();\n                                    var b=ite1.elem();\n                                    var u=ite2.elem();\n                                    var itm=ite2.next;\n                                    if(itm==null)itm=s2.polygon.gverts.begin();\n                                    var max=-1.0;\n                                    var itmo=null;\n                                    var indo=0;\n                                    var icnt=0;\n                                    {\n                                        var beg_ite=itm;\n                                        var cx_ite=itm;\n                                        do{\n                                            var v=cx_ite.elem();\n                                            {\n                                                var t=0.0;\n                                                if({\n                                                    var _sx:Float=0.0;\n                                                    var _sy:Float=0.0;\n                                                    {\n                                                        _sx=u.x-a.x;\n                                                        _sy=u.y-a.y;\n                                                    };\n                                                    var _vx:Float=0.0;\n                                                    var _vy:Float=0.0;\n                                                    {\n                                                        _vx=v.x-u.x;\n                                                        _vy=v.y-u.y;\n                                                    };\n                                                    var _qx:Float=0.0;\n                                                    var _qy:Float=0.0;\n                                                    {\n                                                        _qx=b.x-a.x;\n                                                        _qy=b.y-a.y;\n                                                    };\n                                                    var den=(_vy*_qx-_vx*_qy);\n                                                    if(den*den>Config.epsilon*Config.epsilon){\n                                                        den=1/den;\n                                                        var txx=(_qy*_sx-_qx*_sy)*den;\n                                                        if(txx>Config.epsilon&&txx<1-Config.epsilon){\n                                                            var sxx=(_vy*_sx-_vx*_sy)*den;\n                                                            if(sxx>Config.epsilon&&sxx<1-Config.epsilon){\n                                                                t=txx;\n                                                                true;\n                                                            }\n                                                            else false;\n                                                        }\n                                                        else false;\n                                                    }\n                                                    else false;\n                                                }){\n                                                    if(t>=max){\n                                                        itmo=ite2;\n                                                        indo=ind2;\n                                                        if(++icnt==cnt){\n                                                            max=t;\n                                                            {\n                                                                cx_ite=beg_ite;\n                                                                break;\n                                                            };\n                                                        }\n                                                        else max=t;\n                                                    }\n                                                }\n                                                u=v;\n                                                ite2=cx_ite;\n                                                ind2++;\n                                                if(ind2>=s2.polygon.edgeCnt)ind2=0;\n                                            };\n                                            cx_ite=cx_ite.next;\n                                            if(cx_ite==null)cx_ite=s2.polygon.gverts.begin();\n                                        }\n                                        while(false);\n                                        while(cx_ite!=beg_ite){\n                                            var v=cx_ite.elem();\n                                            {\n                                                var t=0.0;\n                                                if({\n                                                    var _sx:Float=0.0;\n                                                    var _sy:Float=0.0;\n                                                    {\n                                                        _sx=u.x-a.x;\n                                                        _sy=u.y-a.y;\n                                                    };\n                                                    var _vx:Float=0.0;\n                                                    var _vy:Float=0.0;\n                                                    {\n                                                        _vx=v.x-u.x;\n                                                        _vy=v.y-u.y;\n                                                    };\n                                                    var _qx:Float=0.0;\n                                                    var _qy:Float=0.0;\n                                                    {\n                                                        _qx=b.x-a.x;\n                                                        _qy=b.y-a.y;\n                                                    };\n                                                    var den=(_vy*_qx-_vx*_qy);\n                                                    if(den*den>Config.epsilon*Config.epsilon){\n                                                        den=1/den;\n                                                        var txx=(_qy*_sx-_qx*_sy)*den;\n                                                        if(txx>Config.epsilon&&txx<1-Config.epsilon){\n                                                            var sxx=(_vy*_sx-_vx*_sy)*den;\n                                                            if(sxx>Config.epsilon&&sxx<1-Config.epsilon){\n                                                                t=txx;\n                                                                true;\n                                                            }\n                                                            else false;\n                                                        }\n                                                        else false;\n                                                    }\n                                                    else false;\n                                                }){\n                                                    if(t>=max){\n                                                        itmo=ite2;\n                                                        indo=ind2;\n                                                        if(++icnt==cnt){\n                                                            max=t;\n                                                            {\n                                                                cx_ite=beg_ite;\n                                                                break;\n                                                            };\n                                                        }\n                                                        else max=t;\n                                                    }\n                                                }\n                                                u=v;\n                                                ite2=cx_ite;\n                                                ind2++;\n                                                if(ind2>=s2.polygon.edgeCnt)ind2=0;\n                                            };\n                                            cx_ite=cx_ite.next;\n                                            if(cx_ite==null)cx_ite=s2.polygon.gverts.begin();\n                                        }\n                                    };\n                                    if(itmo==null)break;\n                                    var u=itmo.elem();\n                                    var itm2=itmo.next;\n                                    if(itm2==null)itm2=s2.polygon.gverts.begin();\n                                    var v=itm2.elem();\n                                    var cx:Float=0.0;\n                                    var cy:Float=0.0;\n                                    {\n                                        var T=(max);\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !(((T!=T))||T<0.0||T>1.0);\n                                            };\n                                            if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"max\"+\",out c: \"+\"c\"+\")\");\n                                            #end\n                                        };\n                                        cx=u.x+(v.x-u.x)*T;\n                                        cy=u.y+(v.y-u.y)*T;\n                                    };\n                                    if(fst_vert!=null&&ZPP_VecMath.vec_dsq(cx,cy,fst_vert.x,fst_vert.y)<Config.epsilon)break;\n                                    flowpoly.add(ZPP_Vec2.get(cx,cy));\n                                    if(fst_vert==null)fst_vert=flowpoly.front();\n                                    ite2=itmo;\n                                    ind2=indo;\n                                    poly1=!poly1;\n                                    cnt=2;\n                                }\n                            };\n                            else{\n                                ite2=ite2.next;\n                                ind2++;\n                                if(ite2==null){\n                                    ite2=s2.polygon.gverts.begin();\n                                    ind2=0;\n                                }\n                                if(!out2[ind2]){\n                                    var ex=ite2.elem();\n                                    if(fst_vert!=null&&ZPP_VecMath.vec_dsq(ex.x,ex.y,fst_vert.x,fst_vert.y)<Config.epsilon)break;\n                                    flowpoly.add(ex);\n                                    if(fst_vert==null)fst_vert=flowpoly.front();\n                                    cnt=1;\n                                }\n                                else{\n                                    var a=flowpoly.front();\n                                    var b=ite2.elem();\n                                    var u=ite1.elem();\n                                    var itm=ite1.next;\n                                    if(itm==null)itm=s1.polygon.gverts.begin();\n                                    var max=-1.0;\n                                    var itmo=null;\n                                    var indo=0;\n                                    var icnt=0;\n                                    {\n                                        var beg_ite=itm;\n                                        var cx_ite=itm;\n                                        do{\n                                            var v=cx_ite.elem();\n                                            {\n                                                var t=0.0;\n                                                if({\n                                                    var _sx:Float=0.0;\n                                                    var _sy:Float=0.0;\n                                                    {\n                                                        _sx=u.x-a.x;\n                                                        _sy=u.y-a.y;\n                                                    };\n                                                    var _vx:Float=0.0;\n                                                    var _vy:Float=0.0;\n                                                    {\n                                                        _vx=v.x-u.x;\n                                                        _vy=v.y-u.y;\n                                                    };\n                                                    var _qx:Float=0.0;\n                                                    var _qy:Float=0.0;\n                                                    {\n                                                        _qx=b.x-a.x;\n                                                        _qy=b.y-a.y;\n                                                    };\n                                                    var den=(_vy*_qx-_vx*_qy);\n                                                    if(den*den>Config.epsilon*Config.epsilon){\n                                                        den=1/den;\n                                                        var txx=(_qy*_sx-_qx*_sy)*den;\n                                                        if(txx>Config.epsilon&&txx<1-Config.epsilon){\n                                                            var sxx=(_vy*_sx-_vx*_sy)*den;\n                                                            if(sxx>Config.epsilon&&sxx<1-Config.epsilon){\n                                                                t=txx;\n                                                                true;\n                                                            }\n                                                            else false;\n                                                        }\n                                                        else false;\n                                                    }\n                                                    else false;\n                                                }){\n                                                    if(t>=max){\n                                                        itmo=ite1;\n                                                        indo=ind1;\n                                                        if(++icnt==cnt){\n                                                            max=t;\n                                                            {\n                                                                cx_ite=beg_ite;\n                                                                break;\n                                                            };\n                                                        }\n                                                        else max=t;\n                                                    }\n                                                }\n                                                u=v;\n                                                ite1=cx_ite;\n                                                ind1++;\n                                                if(ind1>=s1.polygon.edgeCnt)ind1=0;\n                                            };\n                                            cx_ite=cx_ite.next;\n                                            if(cx_ite==null)cx_ite=s1.polygon.gverts.begin();\n                                        }\n                                        while(false);\n                                        while(cx_ite!=beg_ite){\n                                            var v=cx_ite.elem();\n                                            {\n                                                var t=0.0;\n                                                if({\n                                                    var _sx:Float=0.0;\n                                                    var _sy:Float=0.0;\n                                                    {\n                                                        _sx=u.x-a.x;\n                                                        _sy=u.y-a.y;\n                                                    };\n                                                    var _vx:Float=0.0;\n                                                    var _vy:Float=0.0;\n                                                    {\n                                                        _vx=v.x-u.x;\n                                                        _vy=v.y-u.y;\n                                                    };\n                                                    var _qx:Float=0.0;\n                                                    var _qy:Float=0.0;\n                                                    {\n                                                        _qx=b.x-a.x;\n                                                        _qy=b.y-a.y;\n                                                    };\n                                                    var den=(_vy*_qx-_vx*_qy);\n                                                    if(den*den>Config.epsilon*Config.epsilon){\n                                                        den=1/den;\n                                                        var txx=(_qy*_sx-_qx*_sy)*den;\n                                                        if(txx>Config.epsilon&&txx<1-Config.epsilon){\n                                                            var sxx=(_vy*_sx-_vx*_sy)*den;\n                                                            if(sxx>Config.epsilon&&sxx<1-Config.epsilon){\n                                                                t=txx;\n                                                                true;\n                                                            }\n                                                            else false;\n                                                        }\n                                                        else false;\n                                                    }\n                                                    else false;\n                                                }){\n                                                    if(t>=max){\n                                                        itmo=ite1;\n                                                        indo=ind1;\n                                                        if(++icnt==cnt){\n                                                            max=t;\n                                                            {\n                                                                cx_ite=beg_ite;\n                                                                break;\n                                                            };\n                                                        }\n                                                        else max=t;\n                                                    }\n                                                }\n                                                u=v;\n                                                ite1=cx_ite;\n                                                ind1++;\n                                                if(ind1>=s1.polygon.edgeCnt)ind1=0;\n                                            };\n                                            cx_ite=cx_ite.next;\n                                            if(cx_ite==null)cx_ite=s1.polygon.gverts.begin();\n                                        }\n                                    };\n                                    if(itmo==null)break;\n                                    var u=itmo.elem();\n                                    var itm2=itmo.next;\n                                    if(itm2==null)itm2=s1.polygon.gverts.begin();\n                                    var v=itm2.elem();\n                                    var cx:Float=0.0;\n                                    var cy:Float=0.0;\n                                    {\n                                        var T=(max);\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !(((T!=T))||T<0.0||T>1.0);\n                                            };\n                                            if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"max\"+\",out c: \"+\"c\"+\")\");\n                                            #end\n                                        };\n                                        cx=u.x+(v.x-u.x)*T;\n                                        cy=u.y+(v.y-u.y)*T;\n                                    };\n                                    if(fst_vert!=null&&ZPP_VecMath.vec_dsq(cx,cy,fst_vert.x,fst_vert.y)<Config.epsilon)break;\n                                    flowpoly.add(ZPP_Vec2.get(cx,cy));\n                                    if(fst_vert==null)fst_vert=flowpoly.front();\n                                    ite1=itmo;\n                                    ind1=indo;\n                                    poly1=!poly1;\n                                    cnt=2;\n                                }\n                            };\n                        }\n                        if(flowpoly.begin()!=null&&flowpoly.begin().next!=null&&flowpoly.begin().next.next!=null){\n                            var area=0.0;\n                            var COMx:Float=0.0;\n                            var COMy:Float=0.0;\n                            {\n                                {\n                                    COMx=0;\n                                    COMy=0;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((COMx!=COMx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(COMx)\"+\") :: \"+(\"vec_set(in n: \"+\"COM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((COMy!=COMy));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(COMy)\"+\") :: \"+(\"vec_set(in n: \"+\"COM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                };\n                                area=0.0;\n                                {\n                                    var cx_ite=flowpoly.begin();\n                                    var u=cx_ite.elem();\n                                    cx_ite=cx_ite.next;\n                                    var v=cx_ite.elem();\n                                    cx_ite=cx_ite.next;\n                                    while(cx_ite!=null){\n                                        var w=cx_ite.elem();\n                                        {\n                                            area+=v.x*(w.y-u.y);\n                                            var cf=(w.y*v.x-w.x*v.y);\n                                            COMx+=(v.x+w.x)*cf;\n                                            COMy+=(v.y+w.y)*cf;\n                                        };\n                                        u=v;\n                                        v=w;\n                                        cx_ite=cx_ite.next;\n                                    }\n                                    cx_ite=flowpoly.begin();\n                                    var w=cx_ite.elem();\n                                    {\n                                        area+=v.x*(w.y-u.y);\n                                        var cf=(w.y*v.x-w.x*v.y);\n                                        COMx+=(v.x+w.x)*cf;\n                                        COMy+=(v.y+w.y)*cf;\n                                    };\n                                    u=v;\n                                    v=w;\n                                    cx_ite=cx_ite.next;\n                                    var w=cx_ite.elem();\n                                    {\n                                        area+=v.x*(w.y-u.y);\n                                        var cf=(w.y*v.x-w.x*v.y);\n                                        COMx+=(v.x+w.x)*cf;\n                                        COMy+=(v.y+w.y)*cf;\n                                    };\n                                };\n                                area*=0.5;\n                                var ia=1/(6*area);\n                                {\n                                    var t=(ia);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"COM\"+\",in s: \"+\"ia\"+\")\");\n                                        #end\n                                    };\n                                    COMx*=t;\n                                    COMy*=t;\n                                };\n                            };\n                            arb.inject(-area,COMx,COMy);\n                            true;\n                        }\n                        else false;\n                    }\n                    else false;\n                }\n                else false;\n            };\n            else{\n                var inte=new Array<Bool>();\n                var total=true;\n                var a0=null,vi=null;\n                var max=-ZPP_Const.FMAX;\n                var cont=true;\n                var vite=s2.polygon.gverts.begin();\n                var ind=0;\n                {\n                    var cx_ite=s2.polygon.edges.begin();\n                    while(cx_ite!=null){\n                        var a=cx_ite.elem();\n                        {\n                            var dist=(a.gnormx*s1.circle.worldCOMx+a.gnormy*s1.circle.worldCOMy);\n                            if(dist>a.gprojection+s1.circle.radius){\n                                cont=false;\n                                break;\n                            }\n                            else if(dist+s1.circle.radius>a.gprojection+Config.epsilon){\n                                total=false;\n                                inte[ind]=true;\n                            }\n                            dist-=a.gprojection+s1.circle.radius;\n                            if(dist>max){\n                                max=dist;\n                                a0=a;\n                                vi=vite;\n                            }\n                            vite=vite.next;\n                            ind++;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                if(cont){\n                    if(total){\n                        arb.inject(s1.circle.area,s1.circle.worldCOMx,s1.circle.worldCOMy);\n                        true;\n                    }\n                    else{\n                        var v0=vi.elem();\n                        var v1=if(vi.next==null)s2.polygon.gverts.front()else vi.next.elem();\n                        var dt=(s1.circle.worldCOMy*a0.gnormx-s1.circle.worldCOMx*a0.gnormy);\n                        if(if(dt<=(v0.y*a0.gnormx-v0.x*a0.gnormy)){\n                            var minDist=s1.circle.radius+0;\n                            var px:Float=0.0;\n                            var py:Float=0.0;\n                            {\n                                px=v0.x-s1.circle.worldCOMx;\n                                py=v0.y-s1.circle.worldCOMy;\n                            };\n                            var distSqr=(px*px+py*py);\n                            distSqr<=minDist*minDist;\n                        }\n                        else if(dt>=(v1.y*a0.gnormx-v1.x*a0.gnormy)){\n                            var minDist=s1.circle.radius+0;\n                            var px:Float=0.0;\n                            var py:Float=0.0;\n                            {\n                                px=v1.x-s1.circle.worldCOMx;\n                                py=v1.y-s1.circle.worldCOMy;\n                            };\n                            var distSqr=(px*px+py*py);\n                            distSqr<=minDist*minDist;\n                        }\n                        else true){\n                            var ins=new Array<Bool>();\n                            var ind=0;\n                            var total=true;\n                            var vi=null;\n                            var vind=0;\n                            {\n                                var cx_ite=s2.polygon.gverts.begin();\n                                while(cx_ite!=null){\n                                    var v=cx_ite.elem();\n                                    {\n                                        var dist=ZPP_VecMath.vec_dsq(v.x,v.y,s1.circle.worldCOMx,s1.circle.worldCOMy);\n                                        if(!(ins[ind]=(dist<=s1.circle.radius*s1.circle.radius)))total=false;\n                                        else{\n                                            vind=ind;\n                                            vi=cx_ite;\n                                        }\n                                        ind++;\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                            if(total){\n                                s2.polygon.validate_worldCOM();\n                                arb.inject(s2.polygon.area,s2.polygon.worldCOMx,s2.polygon.worldCOMy);\n                                true;\n                            }\n                            else{\n                                while(!flowpoly.empty()){\n                                    var p=flowpoly.pop_unsafe();\n                                    if(!p._inuse){\n                                        var o=p;\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"p\"+\")\");\n                                            #end\n                                        };\n                                        o.free();\n                                        o.next=ZPP_Vec2.zpp_pool;\n                                        ZPP_Vec2.zpp_pool=o;\n                                        #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n                                        ZPP_Vec2.POOL_SUB++;\n                                        #end\n                                    };\n                                }\n                                flowsegs.clear();\n                                var fst_vert=null;\n                                var state=1;\n                                if(vi==null){\n                                    vi=s2.polygon.gverts.begin();\n                                    state=2;\n                                }\n                                else flowpoly.add(fst_vert=vi.elem());\n                                while(state!=0){\n                                    if(state==1){\n                                        vi=vi.next;\n                                        if(vi==null)vi=s2.polygon.gverts.begin();\n                                        vind++;\n                                        if(vind>=s2.polygon.edgeCnt)vind=0;\n                                        if(ins[vind]){\n                                            if(ZPP_VecMath.vec_dsq(fst_vert.x,fst_vert.y,vi.elem().x,vi.elem().y)<Config.epsilon)break;\n                                            flowpoly.add(vi.elem());\n                                        }\n                                        else{\n                                            var u=flowpoly.front();\n                                            var v=vi.elem();\n                                            var tval={\n                                                var vx:Float=0.0;\n                                                var vy:Float=0.0;\n                                                {\n                                                    vx=v.x-u.x;\n                                                    vy=v.y-u.y;\n                                                };\n                                                var qx:Float=0.0;\n                                                var qy:Float=0.0;\n                                                {\n                                                    qx=u.x-s1.circle.worldCOMx;\n                                                    qy=u.y-s1.circle.worldCOMy;\n                                                };\n                                                var A=(vx*vx+vy*vy);\n                                                var B=2*(qx*vx+qy*vy);\n                                                var C=(qx*qx+qy*qy)-s1.circle.radius*s1.circle.radius;\n                                                var D=Math.sqrt(B*B-4*A*C);\n                                                A=1/(2*A);\n                                                var t=(-B-D)*A;\n                                                if(t<Config.epsilon)(-B+D)*A;\n                                                else t;\n                                            };\n                                            var cx:Float=0.0;\n                                            var cy:Float=0.0;\n                                            {\n                                                var T=(tval);\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !(((T!=T))||T<0.0||T>1.0);\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"tval\"+\",out c: \"+\"c\"+\")\");\n                                                    #end\n                                                };\n                                                cx=u.x+(v.x-u.x)*T;\n                                                cy=u.y+(v.y-u.y)*T;\n                                            };\n                                            if(ZPP_VecMath.vec_dsq(fst_vert.x,fst_vert.y,cx,cy)<Config.epsilon)break;\n                                            flowpoly.add(ZPP_Vec2.get(cx,cy));\n                                            state=2;\n                                        }\n                                    }\n                                    else if(state==2){\n                                        var vi2=vi.next;\n                                        if(vi2==null)vi2=s2.polygon.gverts.begin();\n                                        var u=vi.elem();\n                                        state=0;\n                                        {\n                                            var beg_ite=vi2;\n                                            var cx_ite=vi2;\n                                            do{\n                                                var v=cx_ite.elem();\n                                                {\n                                                    var vind2=vind+1;\n                                                    if(vind2==s2.polygon.edgeCnt)vind2=0;\n                                                    if(inte[vind]){\n                                                        if(ins[vind2]){\n                                                            var tval={\n                                                                var vx:Float=0.0;\n                                                                var vy:Float=0.0;\n                                                                {\n                                                                    vx=v.x-u.x;\n                                                                    vy=v.y-u.y;\n                                                                };\n                                                                var qx:Float=0.0;\n                                                                var qy:Float=0.0;\n                                                                {\n                                                                    qx=u.x-s1.circle.worldCOMx;\n                                                                    qy=u.y-s1.circle.worldCOMy;\n                                                                };\n                                                                var A=(vx*vx+vy*vy);\n                                                                var B=2*(qx*vx+qy*vy);\n                                                                var C=(qx*qx+qy*qy)-s1.circle.radius*s1.circle.radius;\n                                                                var D=Math.sqrt(B*B-4*A*C);\n                                                                A=1/(2*A);\n                                                                var t=(-B-D)*A;\n                                                                if(t<Config.epsilon)(-B+D)*A;\n                                                                else t;\n                                                            };\n                                                            var cx:Float=0.0;\n                                                            var cy:Float=0.0;\n                                                            {\n                                                                var T=(tval);\n                                                                {\n                                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                                    var res={\n                                                                        !(((T!=T))||T<0.0||T>1.0);\n                                                                    };\n                                                                    if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"tval\"+\",out c: \"+\"c\"+\")\");\n                                                                    #end\n                                                                };\n                                                                cx=u.x+(v.x-u.x)*T;\n                                                                cy=u.y+(v.y-u.y)*T;\n                                                            };\n                                                            if(ZPP_VecMath.vec_dsq(fst_vert.x,fst_vert.y,cx,cy)<Config.epsilon){\n                                                                state=0;\n                                                                {\n                                                                    cx_ite=beg_ite;\n                                                                    break;\n                                                                };\n                                                            }\n                                                            var cp=ZPP_Vec2.get(cx,cy);\n                                                            flowsegs.add(flowpoly.front());\n                                                            flowsegs.add(cp);\n                                                            flowpoly.add(cp);\n                                                            state=1;\n                                                            {\n                                                                cx_ite=beg_ite;\n                                                                break;\n                                                            };\n                                                        }\n                                                        else{\n                                                            var t0=0.0;\n                                                            var t1=0.0;\n                                                            var two={\n                                                                var vx:Float=0.0;\n                                                                var vy:Float=0.0;\n                                                                {\n                                                                    vx=v.x-u.x;\n                                                                    vy=v.y-u.y;\n                                                                };\n                                                                var qx:Float=0.0;\n                                                                var qy:Float=0.0;\n                                                                {\n                                                                    qx=u.x-s1.circle.worldCOMx;\n                                                                    qy=u.y-s1.circle.worldCOMy;\n                                                                };\n                                                                var A=(vx*vx+vy*vy);\n                                                                var B=2*(qx*vx+qy*vy);\n                                                                var C=(qx*qx+qy*qy)-s1.circle.radius*s1.circle.radius;\n                                                                var D=B*B-4*A*C;\n                                                                if(D*D<Config.epsilon){\n                                                                    if(D<0)t0=10.0;\n                                                                    else t0=t1=-B/(2*A);\n                                                                    false;\n                                                                }\n                                                                else{\n                                                                    D=Math.sqrt(D);\n                                                                    A=1/(2*A);\n                                                                    t0=(-B-D)*A;\n                                                                    t1=(-B+D)*A;\n                                                                    true;\n                                                                }\n                                                            };\n                                                            if(t0<1-Config.epsilon&&t1>Config.epsilon){\n                                                                var cx:Float=0.0;\n                                                                var cy:Float=0.0;\n                                                                {\n                                                                    var T=(t0);\n                                                                    {\n                                                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                                        var res={\n                                                                            !(((T!=T))||T<0.0||T>1.0);\n                                                                        };\n                                                                        if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"t0\"+\",out c: \"+\"c\"+\")\");\n                                                                        #end\n                                                                    };\n                                                                    cx=u.x+(v.x-u.x)*T;\n                                                                    cy=u.y+(v.y-u.y)*T;\n                                                                };\n                                                                if(fst_vert!=null&&ZPP_VecMath.vec_dsq(fst_vert.x,fst_vert.y,cx,cy)<Config.epsilon){\n                                                                    state=0;\n                                                                    {\n                                                                        cx_ite=beg_ite;\n                                                                        break;\n                                                                    };\n                                                                }\n                                                                var cp=ZPP_Vec2.get(cx,cy);\n                                                                if(!flowpoly.empty()){\n                                                                    flowsegs.add(flowpoly.front());\n                                                                    flowsegs.add(cp);\n                                                                }\n                                                                flowpoly.add(cp);\n                                                                if(fst_vert==null)fst_vert=flowpoly.front();\n                                                                if(two){\n                                                                    var cx:Float=0.0;\n                                                                    var cy:Float=0.0;\n                                                                    {\n                                                                        var T=(t1);\n                                                                        {\n                                                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                                            var res={\n                                                                                !(((T!=T))||T<0.0||T>1.0);\n                                                                            };\n                                                                            if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"t1\"+\",out c: \"+\"c\"+\")\");\n                                                                            #end\n                                                                        };\n                                                                        cx=u.x+(v.x-u.x)*T;\n                                                                        cy=u.y+(v.y-u.y)*T;\n                                                                    };\n                                                                    flowpoly.add(ZPP_Vec2.get(cx,cy));\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                    u=v;\n                                                    vi=cx_ite;\n                                                    vind=vind2;\n                                                };\n                                                cx_ite=cx_ite.next;\n                                                if(cx_ite==null)cx_ite=s2.polygon.gverts.begin();\n                                            }\n                                            while(false);\n                                            while(cx_ite!=beg_ite){\n                                                var v=cx_ite.elem();\n                                                {\n                                                    var vind2=vind+1;\n                                                    if(vind2==s2.polygon.edgeCnt)vind2=0;\n                                                    if(inte[vind]){\n                                                        if(ins[vind2]){\n                                                            var tval={\n                                                                var vx:Float=0.0;\n                                                                var vy:Float=0.0;\n                                                                {\n                                                                    vx=v.x-u.x;\n                                                                    vy=v.y-u.y;\n                                                                };\n                                                                var qx:Float=0.0;\n                                                                var qy:Float=0.0;\n                                                                {\n                                                                    qx=u.x-s1.circle.worldCOMx;\n                                                                    qy=u.y-s1.circle.worldCOMy;\n                                                                };\n                                                                var A=(vx*vx+vy*vy);\n                                                                var B=2*(qx*vx+qy*vy);\n                                                                var C=(qx*qx+qy*qy)-s1.circle.radius*s1.circle.radius;\n                                                                var D=Math.sqrt(B*B-4*A*C);\n                                                                A=1/(2*A);\n                                                                var t=(-B-D)*A;\n                                                                if(t<Config.epsilon)(-B+D)*A;\n                                                                else t;\n                                                            };\n                                                            var cx:Float=0.0;\n                                                            var cy:Float=0.0;\n                                                            {\n                                                                var T=(tval);\n                                                                {\n                                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                                    var res={\n                                                                        !(((T!=T))||T<0.0||T>1.0);\n                                                                    };\n                                                                    if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"tval\"+\",out c: \"+\"c\"+\")\");\n                                                                    #end\n                                                                };\n                                                                cx=u.x+(v.x-u.x)*T;\n                                                                cy=u.y+(v.y-u.y)*T;\n                                                            };\n                                                            if(ZPP_VecMath.vec_dsq(fst_vert.x,fst_vert.y,cx,cy)<Config.epsilon){\n                                                                state=0;\n                                                                {\n                                                                    cx_ite=beg_ite;\n                                                                    break;\n                                                                };\n                                                            }\n                                                            var cp=ZPP_Vec2.get(cx,cy);\n                                                            flowsegs.add(flowpoly.front());\n                                                            flowsegs.add(cp);\n                                                            flowpoly.add(cp);\n                                                            state=1;\n                                                            {\n                                                                cx_ite=beg_ite;\n                                                                break;\n                                                            };\n                                                        }\n                                                        else{\n                                                            var t0=0.0;\n                                                            var t1=0.0;\n                                                            var two={\n                                                                var vx:Float=0.0;\n                                                                var vy:Float=0.0;\n                                                                {\n                                                                    vx=v.x-u.x;\n                                                                    vy=v.y-u.y;\n                                                                };\n                                                                var qx:Float=0.0;\n                                                                var qy:Float=0.0;\n                                                                {\n                                                                    qx=u.x-s1.circle.worldCOMx;\n                                                                    qy=u.y-s1.circle.worldCOMy;\n                                                                };\n                                                                var A=(vx*vx+vy*vy);\n                                                                var B=2*(qx*vx+qy*vy);\n                                                                var C=(qx*qx+qy*qy)-s1.circle.radius*s1.circle.radius;\n                                                                var D=B*B-4*A*C;\n                                                                if(D*D<Config.epsilon){\n                                                                    if(D<0)t0=10.0;\n                                                                    else t0=t1=-B/(2*A);\n                                                                    false;\n                                                                }\n                                                                else{\n                                                                    D=Math.sqrt(D);\n                                                                    A=1/(2*A);\n                                                                    t0=(-B-D)*A;\n                                                                    t1=(-B+D)*A;\n                                                                    true;\n                                                                }\n                                                            };\n                                                            if(t0<1-Config.epsilon&&t1>Config.epsilon){\n                                                                var cx:Float=0.0;\n                                                                var cy:Float=0.0;\n                                                                {\n                                                                    var T=(t0);\n                                                                    {\n                                                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                                        var res={\n                                                                            !(((T!=T))||T<0.0||T>1.0);\n                                                                        };\n                                                                        if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"t0\"+\",out c: \"+\"c\"+\")\");\n                                                                        #end\n                                                                    };\n                                                                    cx=u.x+(v.x-u.x)*T;\n                                                                    cy=u.y+(v.y-u.y)*T;\n                                                                };\n                                                                if(fst_vert!=null&&ZPP_VecMath.vec_dsq(fst_vert.x,fst_vert.y,cx,cy)<Config.epsilon){\n                                                                    state=0;\n                                                                    {\n                                                                        cx_ite=beg_ite;\n                                                                        break;\n                                                                    };\n                                                                }\n                                                                var cp=ZPP_Vec2.get(cx,cy);\n                                                                if(!flowpoly.empty()){\n                                                                    flowsegs.add(flowpoly.front());\n                                                                    flowsegs.add(cp);\n                                                                }\n                                                                flowpoly.add(cp);\n                                                                if(fst_vert==null)fst_vert=flowpoly.front();\n                                                                if(two){\n                                                                    var cx:Float=0.0;\n                                                                    var cy:Float=0.0;\n                                                                    {\n                                                                        var T=(t1);\n                                                                        {\n                                                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                                            var res={\n                                                                                !(((T!=T))||T<0.0||T>1.0);\n                                                                            };\n                                                                            if(!res)throw \"assert(\"+\"!(assert_isNaN(T)||T<0.0||T>1.0)\"+\") :: \"+(\"vec_interp(in a: \"+\"u.\"+\",in b: \"+\"v.\"+\",in t: \"+\"t1\"+\",out c: \"+\"c\"+\")\");\n                                                                            #end\n                                                                        };\n                                                                        cx=u.x+(v.x-u.x)*T;\n                                                                        cy=u.y+(v.y-u.y)*T;\n                                                                    };\n                                                                    flowpoly.add(ZPP_Vec2.get(cx,cy));\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                    u=v;\n                                                    vi=cx_ite;\n                                                    vind=vind2;\n                                                };\n                                                cx_ite=cx_ite.next;\n                                                if(cx_ite==null)cx_ite=s2.polygon.gverts.begin();\n                                            }\n                                        };\n                                    }\n                                }\n                                if(flowpoly.begin()==null){\n                                    false;\n                                }\n                                else if(flowpoly.begin().next==null){\n                                    var all=true;\n                                    {\n                                        var cx_ite=s2.polygon.edges.begin();\n                                        while(cx_ite!=null){\n                                            var e=cx_ite.elem();\n                                            {\n                                                var dist=(e.gnormx*s1.circle.worldCOMx+e.gnormy*s1.circle.worldCOMy);\n                                                if(dist>e.gprojection){\n                                                    all=false;\n                                                    break;\n                                                }\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                    if(all){\n                                        arb.inject(s1.circle.area,s1.circle.worldCOMx,s1.circle.worldCOMy);\n                                        true;\n                                    }\n                                    else false;\n                                }\n                                else{\n                                    var COMx:Float=0;\n                                    var COMy:Float=0;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((COMx!=COMx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(COMx)\"+\") :: \"+(\"vec_new(in n: \"+\"COM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((COMy!=COMy));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(COMy)\"+\") :: \"+(\"vec_new(in n: \"+\"COM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                    var area=0.0;\n                                    if(flowpoly.begin().next.next!=null){\n                                        var parea=0.0;\n                                        var pCOMx:Float=0.0;\n                                        var pCOMy:Float=0.0;\n                                        {\n                                            {\n                                                pCOMx=0;\n                                                pCOMy=0;\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !((pCOMx!=pCOMx));\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!assert_isNaN(pCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"pCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                                                    #end\n                                                };\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !((pCOMy!=pCOMy));\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!assert_isNaN(pCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"pCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                                                    #end\n                                                };\n                                            };\n                                            parea=0.0;\n                                            {\n                                                var cx_ite=flowpoly.begin();\n                                                var u=cx_ite.elem();\n                                                cx_ite=cx_ite.next;\n                                                var v=cx_ite.elem();\n                                                cx_ite=cx_ite.next;\n                                                while(cx_ite!=null){\n                                                    var w=cx_ite.elem();\n                                                    {\n                                                        parea+=v.x*(w.y-u.y);\n                                                        var cf=(w.y*v.x-w.x*v.y);\n                                                        pCOMx+=(v.x+w.x)*cf;\n                                                        pCOMy+=(v.y+w.y)*cf;\n                                                    };\n                                                    u=v;\n                                                    v=w;\n                                                    cx_ite=cx_ite.next;\n                                                }\n                                                cx_ite=flowpoly.begin();\n                                                var w=cx_ite.elem();\n                                                {\n                                                    parea+=v.x*(w.y-u.y);\n                                                    var cf=(w.y*v.x-w.x*v.y);\n                                                    pCOMx+=(v.x+w.x)*cf;\n                                                    pCOMy+=(v.y+w.y)*cf;\n                                                };\n                                                u=v;\n                                                v=w;\n                                                cx_ite=cx_ite.next;\n                                                var w=cx_ite.elem();\n                                                {\n                                                    parea+=v.x*(w.y-u.y);\n                                                    var cf=(w.y*v.x-w.x*v.y);\n                                                    pCOMx+=(v.x+w.x)*cf;\n                                                    pCOMy+=(v.y+w.y)*cf;\n                                                };\n                                            };\n                                            parea*=0.5;\n                                            var ia=1/(6*parea);\n                                            {\n                                                var t=(ia);\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !((t!=t));\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"pCOM\"+\",in s: \"+\"ia\"+\")\");\n                                                    #end\n                                                };\n                                                pCOMx*=t;\n                                                pCOMy*=t;\n                                            };\n                                        };\n                                        {\n                                            var t=(-parea);\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((t!=t));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"COM\"+\",in b: \"+\"pCOM\"+\",in s: \"+\"-parea\"+\")\");\n                                                #end\n                                            };\n                                            COMx+=pCOMx*t;\n                                            COMy+=pCOMy*t;\n                                        };\n                                        area-=parea;\n                                    }\n                                    else{\n                                        flowsegs.add(flowpoly.front());\n                                        flowsegs.add(flowpoly.begin().next.elem());\n                                    }\n                                    while(!flowsegs.empty()){\n                                        var u=flowsegs.pop_unsafe();\n                                        var v=flowsegs.pop_unsafe();\n                                        var dx:Float=0.0;\n                                        var dy:Float=0.0;\n                                        {\n                                            dx=v.x-u.x;\n                                            dy=v.y-u.y;\n                                        };\n                                        var nx:Float=0.0;\n                                        var ny:Float=0.0;\n                                        {\n                                            nx=dx;\n                                            ny=dy;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((nx!=nx));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(nx)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                                                #end\n                                            };\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((ny!=ny));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(ny)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                                                #end\n                                            };\n                                        };\n                                        {\n                                            {\n                                                var d=(nx*nx+ny*ny);\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        d!=0.0;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"d!=0.0\"+\") :: \"+(\"vec_normalise(in n: \"+\"n\"+\")\");\n                                                    #end\n                                                };\n                                                var imag=ZPP_Math.invsqrt(d);\n                                                {\n                                                    var t=(imag);\n                                                    {\n                                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                        var res={\n                                                            !((t!=t));\n                                                        };\n                                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"n\"+\",in s: \"+\"imag\"+\")\");\n                                                        #end\n                                                    };\n                                                    nx*=t;\n                                                    ny*=t;\n                                                };\n                                            };\n                                            {\n                                                var t=nx;\n                                                nx=-ny;\n                                                ny=t;\n                                            };\n                                        };\n                                        var cx:Float=0.0;\n                                        var cy:Float=0.0;\n                                        {\n                                            cx=u.x+v.x;\n                                            cy=u.y+v.y;\n                                        };\n                                        {\n                                            var t=(1.0/(2));\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((t!=t));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"c\"+\",in s: \"+\"1.0/(2)\"+\")\");\n                                                #end\n                                            };\n                                            cx*=t;\n                                            cy*=t;\n                                        };\n                                        {\n                                            var t=(1.0);\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((t!=t));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_subeq(in a: \"+\"c\"+\",in b: \"+\"s1.circle.worldCOM\"+\",in s: \"+\"1.0\"+\")\");\n                                                #end\n                                            };\n                                            cx-=s1.circle.worldCOMx*t;\n                                            cy-=s1.circle.worldCOMy*t;\n                                        };\n                                        var xd=(nx*cx+ny*cy);\n                                        var carea=0.0;\n                                        var ccom=0.0;\n                                        {\n                                            var X=xd;\n                                            var cos=X/s1.circle.radius;\n                                            var sin=Math.sqrt(1-cos*cos);\n                                            var theta=Math.acos(cos);\n                                            carea=s1.circle.radius*(s1.circle.radius*theta-X*sin);\n                                            ccom=(2/3)*s1.circle.radius*sin*sin*sin/(theta-cos*sin);\n                                        };\n                                        {\n                                            cx=s1.circle.worldCOMx;\n                                            cy=s1.circle.worldCOMy;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((cx!=cx));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(cx)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"s1.circle.worldCOMx\"+\",in y: \"+\"s1.circle.worldCOMy\"+\")\");\n                                                #end\n                                            };\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((cy!=cy));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(cy)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"s1.circle.worldCOMx\"+\",in y: \"+\"s1.circle.worldCOMy\"+\")\");\n                                                #end\n                                            };\n                                        };\n                                        {\n                                            var t=(ccom);\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((t!=t));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c\"+\",in b: \"+\"n\"+\",in s: \"+\"ccom\"+\")\");\n                                                #end\n                                            };\n                                            cx+=nx*t;\n                                            cy+=ny*t;\n                                        };\n                                        {\n                                            var t=(carea);\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    !((t!=t));\n                                                };\n                                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"COM\"+\",in b: \"+\"c\"+\",in s: \"+\"carea\"+\")\");\n                                                #end\n                                            };\n                                            COMx+=cx*t;\n                                            COMy+=cy*t;\n                                        };\n                                        area+=carea;\n                                    }\n                                    {\n                                        var t=(1.0/(area));\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !((t!=t));\n                                            };\n                                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"COM\"+\",in s: \"+\"1.0/(area)\"+\")\");\n                                            #end\n                                        };\n                                        COMx*=t;\n                                        COMy*=t;\n                                    };\n                                    arb.inject(area,COMx,COMy);\n                                    true;\n                                }\n                            }\n                        }\n                        else false;\n                    }\n                }\n                else false;\n            };\n        }\n        else return{\n            var c1=s1.circle;\n            var c2=s2.circle;\n            var deltax:Float=0.0;\n            var deltay:Float=0.0;\n            {\n                deltax=c2.worldCOMx-c1.worldCOMx;\n                deltay=c2.worldCOMy-c1.worldCOMy;\n            };\n            var cr=c1.radius+c2.radius;\n            var ds=(deltax*deltax+deltay*deltay);\n            if(ds>cr*cr)false;\n            else if(ds<Config.epsilon*Config.epsilon){\n                if(c1.radius<c2.radius)arb.inject(c1.area,c1.worldCOMx,c1.worldCOMy);\n                else arb.inject(c2.area,c2.worldCOMx,c2.worldCOMy);\n                true;\n            }\n            else{\n                var d=Math.sqrt(ds);\n                var id=1/d;\n                var x1=0.5*(d-(c2.radius*c2.radius-c1.radius*c1.radius)*id);\n                if(x1<=-c1.radius)arb.inject(c1.area,c1.worldCOMx,c1.worldCOMy);\n                else{\n                    var x2=d-x1;\n                    if(x2<=-c2.radius)arb.inject(c2.area,c2.worldCOMx,c2.worldCOMy);\n                    else{\n                        var area1=0.0;\n                        var y1=0.0;\n                        var area2=0.0;\n                        var y2=0.0;\n                        {\n                            var X=x1;\n                            var cos=X/c1.radius;\n                            var sin=Math.sqrt(1-cos*cos);\n                            var theta=Math.acos(cos);\n                            area1=c1.radius*(c1.radius*theta-X*sin);\n                            y1=(2/3)*c1.radius*sin*sin*sin/(theta-cos*sin);\n                        };\n                        {\n                            var X=x2;\n                            var cos=X/c2.radius;\n                            var sin=Math.sqrt(1-cos*cos);\n                            var theta=Math.acos(cos);\n                            area2=c2.radius*(c2.radius*theta-X*sin);\n                            y2=(2/3)*c2.radius*sin*sin*sin/(theta-cos*sin);\n                        };\n                        var tarea=area1+area2;\n                        var ya=(y1*area1+(d-y2)*area2)/tarea*id;\n                        arb.inject(tarea,c1.worldCOMx+deltax*ya,c1.worldCOMy+deltay*ya);\n                    }\n                }\n                true;\n            }\n        };\n    }\n    public static var flowpoly:ZNPList_ZPP_Vec2=new ZNPList_ZPP_Vec2();\n    public static var flowsegs=new ZNPList_ZPP_Vec2();\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_ConvexRayResult{\n    public var normal:Vec2=null;\n    public var shape:Shape=null;\n    static var convexPool:ZPP_ConvexRayResult=null;\n    public var convex:ConvexResult=null;\n    public var position:Vec2=null;\n    static var rayPool:ZPP_ConvexRayResult=null;\n    public var ray:RayResult=null;\n    public var inner:Bool=false;\n    public var next:ZPP_ConvexRayResult=null;\n    public var toiDistance:Float=0.0;\n    public function new(){}\n    public static var internal=false;\n    public static function getRay(normal:Vec2,time:Float,inner:Bool,shape:Shape){\n        var ret:RayResult;\n        if(rayPool==null){\n            internal=true;\n            ret=new RayResult();\n            ret.zpp_inner=new ZPP_ConvexRayResult();\n            ret.zpp_inner.ray=ret;\n            internal=false;\n        }\n        else{\n            ret=rayPool.ray;\n            rayPool=rayPool.next;\n            ret.zpp_inner.next=null;\n        }\n        var zinner=ret.zpp_inner;\n        zinner.normal=normal;\n        normal.zpp_inner._immutable=true;\n        zinner.toiDistance=time;\n        zinner.inner=inner;\n        zinner.shape=shape;\n        return ret;\n    }\n    public static function getConvex(normal:Vec2,position:Vec2,toiDistance:Float,shape:Shape){\n        var ret:ConvexResult;\n        if(convexPool==null){\n            internal=true;\n            ret=new ConvexResult();\n            ret.zpp_inner=new ZPP_ConvexRayResult();\n            ret.zpp_inner.convex=ret;\n            internal=false;\n        }\n        else{\n            ret=convexPool.convex;\n            convexPool=convexPool.next;\n            ret.zpp_inner.next=null;\n        }\n        var inner=ret.zpp_inner;\n        inner.normal=normal;\n        inner.position=position;\n        normal.zpp_inner._immutable=true;\n        position.zpp_inner._immutable=true;\n        inner.toiDistance=toiDistance;\n        inner.shape=shape;\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function disposed(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(next!=null)throw \"Error: This object has been disposed of and cannot be used\";\n        #end\n    }\n    public function free(){\n        normal.zpp_inner._immutable=false;\n        normal.dispose();\n        if(position!=null){\n            position.zpp_inner._immutable=false;\n            position.dispose();\n        }\n        shape=null;\n        toiDistance=0.0;\n        if(convex!=null){\n            next=convexPool;\n            convexPool=this;\n        }\n        else{\n            next=rayPool;\n            rayPool=this;\n        }\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_GeomVert{\n    public var x:Float=0.0;\n    public var y:Float=0.0;\n    public var prev:ZPP_GeomVert=null;\n    public var next:ZPP_GeomVert=null;\n    public var wrap:Null<Vec2>=null;\n    public var forced:Bool=false;\n    static public var zpp_pool:ZPP_GeomVert=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        if(wrap!=null){\n            wrap.zpp_inner._inuse=false;\n            wrap.dispose();\n            wrap=null;\n        }\n        prev=next=null;\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{\n        forced=false;\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function wrapper():Vec2{\n        if(wrap==null){\n            wrap=Vec2.get(x,y);\n            wrap.zpp_inner._inuse=true;\n            wrap.zpp_inner._invalidate=modwrap;\n            wrap.zpp_inner._validate=getwrap;\n        }\n        return wrap;\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function modwrap(n:ZPP_Vec2):Void{\n        {\n            this.x=n.x;\n            this.y=n.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.x!=this.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.x)\"+\") :: \"+(\"vec_set(in n: \"+\"this.\"+\",in x: \"+\"n.x\"+\",in y: \"+\"n.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.y!=this.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.y)\"+\") :: \"+(\"vec_set(in n: \"+\"this.\"+\",in x: \"+\"n.x\"+\",in y: \"+\"n.y\"+\")\");\n                #end\n            };\n        };\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function getwrap():Void{\n        {\n            wrap.zpp_inner.x=this.x;\n            wrap.zpp_inner.y=this.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap.zpp_inner.x!=wrap.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap.zpp_inner.\"+\",in x: \"+\"this.x\"+\",in y: \"+\"this.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap.zpp_inner.y!=wrap.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap.zpp_inner.\"+\",in x: \"+\"this.x\"+\",in y: \"+\"this.y\"+\")\");\n                #end\n            };\n        };\n    }\n    public static#if NAPE_NO_INLINE#else inline #end\n    function get(x:Float,y:Float):ZPP_GeomVert{\n        var ret;\n        {\n            if(ZPP_GeomVert.zpp_pool==null){\n                ret=new ZPP_GeomVert();\n                #if NAPE_POOL_STATS ZPP_GeomVert.POOL_TOT++;\n                ZPP_GeomVert.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_GeomVert.zpp_pool;\n                ZPP_GeomVert.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_GeomVert.POOL_CNT--;\n                ZPP_GeomVert.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        {\n            ret.x=x;\n            ret.y=y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.x!=ret.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.x)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.y!=ret.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.y)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                #end\n            };\n        };\n        return ret;\n    }\n    public function new(){}\n}\n#if nape_swc@:keep #end\nclass ZPP_GeomPoly{\n    public var outer:GeomPoly=null;\n    public var vertices:Null<ZPP_GeomVert>=null;\n    public function new(outer:GeomPoly){\n        this.outer=outer;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_GeomVertexIterator{\n    public var ptr:ZPP_GeomVert=null;\n    public var start:ZPP_GeomVert=null;\n    public var first:Bool=false;\n    public var forward:Bool=false;\n    public var outer:GeomVertexIterator=null;\n    public var next:ZPP_GeomVertexIterator=null;\n    static public var zpp_pool:ZPP_GeomVertexIterator=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        outer.zpp_inner=null;\n        ptr=start=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    #if(!NAPE_RELEASE_BUILD)\n    public static var internal=false;\n    #end\n    function new(){\n        #if(!NAPE_RELEASE_BUILD)\n        internal=true;\n        #end\n        outer=new GeomVertexIterator();\n        #if(!NAPE_RELEASE_BUILD)\n        internal=false;\n        #end\n    }\n    public static function get(poly:ZPP_GeomVert,forward:Bool){\n        var ret;\n        {\n            if(ZPP_GeomVertexIterator.zpp_pool==null){\n                ret=new ZPP_GeomVertexIterator();\n                #if NAPE_POOL_STATS ZPP_GeomVertexIterator.POOL_TOT++;\n                ZPP_GeomVertexIterator.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_GeomVertexIterator.zpp_pool;\n                ZPP_GeomVertexIterator.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_GeomVertexIterator.POOL_CNT--;\n                ZPP_GeomVertexIterator.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        ret.outer.zpp_inner=ret;\n        ret.ptr=poly;\n        ret.forward=forward;\n        ret.start=poly;\n        ret.first=poly!=null;\n        return ret.outer;\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Mat23{\n    public var outer:Null<Mat23>=null;\n    public function wrapper():Mat23{\n        if(outer==null){\n            outer=new Mat23();\n            {\n                var o=outer.zpp_inner;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Mat23\"+\", in obj: \"+\"outer.zpp_inner\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_Mat23.zpp_pool;\n                ZPP_Mat23.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_Mat23.POOL_CNT++;\n                ZPP_Mat23.POOL_SUB++;\n                #end\n            };\n            outer.zpp_inner=this;\n        }\n        return outer;\n    }\n    public var a:Float=0.0;\n    public var b:Float=0.0;\n    public var c:Float=0.0;\n    public var d:Float=0.0;\n    public var tx:Float=0.0;\n    public var ty:Float=0.0;\n    public var _invalidate:Null<Void->Void>=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate(){\n        if(_invalidate!=null){\n            _invalidate();\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function set(m:ZPP_Mat23):Void{\n        setas(m.a,m.b,m.c,m.d,m.tx,m.ty);\n    }\n    public function setas(a:Float,b:Float,c:Float,d:Float,tx:Float,ty:Float):Void{\n        {\n            this.tx=tx;\n            this.ty=ty;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.tx!=this.tx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.tx)\"+\") :: \"+(\"vec_set(in n: \"+\"this.t\"+\",in x: \"+\"tx\"+\",in y: \"+\"ty\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.ty!=this.ty));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.ty)\"+\") :: \"+(\"vec_set(in n: \"+\"this.t\"+\",in x: \"+\"tx\"+\",in y: \"+\"ty\"+\")\");\n                #end\n            };\n        };\n        {\n            this.a=a;\n            this.b=b;\n            this.c=c;\n            this.d=d;\n        };\n    }\n    public var next:ZPP_Mat23=null;\n    static public var zpp_pool:ZPP_Mat23=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{}\n    public function new(){}\n     public static function get():ZPP_Mat23{\n        var ret;\n        {\n            if(ZPP_Mat23.zpp_pool==null){\n                ret=new ZPP_Mat23();\n                #if NAPE_POOL_STATS ZPP_Mat23.POOL_TOT++;\n                ZPP_Mat23.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_Mat23.zpp_pool;\n                ZPP_Mat23.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_Mat23.POOL_CNT--;\n                ZPP_Mat23.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        return ret;\n    }\n    public static function identity():ZPP_Mat23{\n        var ret=ZPP_Mat23.get();\n        ret.setas(1,0,0,1,0,0);\n        return ret;\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_MatMN{\n    public var outer:MatMN=null;\n    public var m:Int=0;\n    public var n:Int=0;\n    public var x:TArray<Float>=null;\n    public function new(m:Int,n:Int){\n        this.m=m;\n        this.n=n;\n        #if flash10 x=new flash.Vector<Float>(m*n,true);\n        #else x=new Array<Float>();\n        for(i in 0...(m*n)){\n            x.push(0.0);\n        }\n        #end\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_ToiEvent{\n    public var next:ZPP_ToiEvent=null;\n    static public var zpp_pool:ZPP_ToiEvent=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){\n        failed=false;\n        s1=s2=null;\n        arbiter=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){}\n    public var toi:Float=0.0;\n    public var s1:ZPP_Shape=null;\n    public var s2:ZPP_Shape=null;\n    public var arbiter:ZPP_ColArbiter=null;\n    public var frozen1:Bool=false;\n    public var frozen2:Bool=false;\n    public var c1:ZPP_Vec2=null;\n    public var c2:ZPP_Vec2=null;\n    public var axis:ZPP_Vec2=null;\n    public var slipped:Bool=false;\n    public var failed:Bool=false;\n    public var kinematic:Bool=false;\n    public function new(){\n        c1=new ZPP_Vec2();\n        c2=new ZPP_Vec2();\n        axis=new ZPP_Vec2();\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_SweepDistance{\n    static public function dynamicSweep(toi:ZPP_ToiEvent,timeStep:Float,lowerBound:Float,negRadius:Float,userAPI:Bool=false){\n        var s1:ZPP_Shape=toi.s1;\n        var s2:ZPP_Shape=toi.s2;\n        var b1:ZPP_Body=s1.body;\n        var b2:ZPP_Body=s2.body;\n        var deltax:Float=0.0;\n        var deltay:Float=0.0;\n        {\n            deltax=b2.velx-b1.velx;\n            deltay=b2.vely-b1.vely;\n        };\n        var ang1=b1.angvel;\n        if(ang1<0)ang1=-ang1;\n        var ang2=b2.angvel;\n        if(ang2<0)ang2=-ang2;\n        var angBias=(s1.sweepCoef*ang1)+(s2.sweepCoef*ang2);\n        if(!userAPI&&!toi.kinematic&&(deltax*deltax+deltay*deltay)<(Config.dynamicSweepLinearThreshold*Config.dynamicSweepLinearThreshold)&&angBias<Config.dynamicSweepAngularThreshold){\n            toi.toi=-1;\n            toi.failed=true;\n            return;\n        }\n        var c1=toi.c1;\n        var c2=toi.c2;\n        var axis=toi.axis;\n        var curTOI=lowerBound;\n        var curIter=0;\n        while(true){\n            b1.sweepIntegrate(curTOI*timeStep);\n            b1.sweepValidate(s1);\n            b2.sweepIntegrate(curTOI*timeStep);\n            b2.sweepValidate(s2);\n            var sep=distance(s1,s2,c1,c2,axis)+negRadius;\n            var dot=(deltax*axis.x+deltay*axis.y);\n            if(sep<Config.distanceThresholdCCD){\n                if(userAPI){\n                    break;\n                }\n                var d1x:Float=0.0;\n                var d1y:Float=0.0;\n                {\n                    d1x=c1.x-b1.posx;\n                    d1y=c1.y-b1.posy;\n                };\n                var d2x:Float=0.0;\n                var d2y:Float=0.0;\n                {\n                    d2x=c2.x-b2.posx;\n                    d2y=c2.y-b2.posy;\n                };\n                var proj=dot-b1.sweep_angvel*(axis.y*d1x-axis.x*d1y)+b2.sweep_angvel*(axis.y*d2x-axis.x*d2y);\n                if(proj>0){\n                    toi.slipped=true;\n                }\n                if(proj<=0||sep<Config.distanceThresholdCCD*0.5){\n                    break;\n                }\n            }\n            var denom=(angBias-dot)*timeStep;\n            if(denom<=0){\n                curTOI=-1;\n                break;\n            }\n            var delta=sep/denom;\n            if(delta<1e-6)delta=1e-6;\n            curTOI+=delta;\n            if(curTOI>=1){\n                curTOI=1;\n                b1.sweepIntegrate(curTOI*timeStep);\n                b1.sweepValidate(s1);\n                b2.sweepIntegrate(curTOI*timeStep);\n                b2.sweepValidate(s2);\n                var sep=distance(s1,s2,c1,c2,axis)+negRadius;\n                var dot=(deltax*axis.x+deltay*axis.y);\n                if(sep<Config.distanceThresholdCCD){\n                    if(userAPI){\n                        break;\n                    }\n                    var d1x:Float=0.0;\n                    var d1y:Float=0.0;\n                    {\n                        d1x=c1.x-b1.posx;\n                        d1y=c1.y-b1.posy;\n                    };\n                    var d2x:Float=0.0;\n                    var d2y:Float=0.0;\n                    {\n                        d2x=c2.x-b2.posx;\n                        d2y=c2.y-b2.posy;\n                    };\n                    var proj=dot-b1.sweep_angvel*(axis.y*d1x-axis.x*d1y)+b2.sweep_angvel*(axis.y*d2x-axis.x*d2y);\n                    if(proj>0){\n                        toi.slipped=true;\n                    }\n                    if(proj<=0||sep<Config.distanceThresholdCCD*0.5){\n                        break;\n                    }\n                }\n                curTOI=-1;\n                break;\n            }\n            if((++curIter)>=40){\n                if(sep>negRadius){\n                    toi.failed=true;\n                }\n                break;\n            }\n        }\n        toi.toi=curTOI;\n    }\n    static public function staticSweep(toi:ZPP_ToiEvent,timeStep:Float,lowerBound:Float,negRadius:Float){\n        var s1:ZPP_Shape=toi.s1;\n        var s2:ZPP_Shape=toi.s2;\n        var b1:ZPP_Body=s1.body;\n        var b2:ZPP_Body=s2.body;\n        var deltax:Float=0.0;\n        var deltay:Float=0.0;\n        {\n            deltax=-b1.velx;\n            deltay=-b1.vely;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((deltax!=deltax));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(deltax)\"+\") :: \"+(\"vec_set(in n: \"+\"delta\"+\",in x: \"+\"-b1.velx\"+\",in y: \"+\"-b1.vely\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((deltay!=deltay));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(deltay)\"+\") :: \"+(\"vec_set(in n: \"+\"delta\"+\",in x: \"+\"-b1.velx\"+\",in y: \"+\"-b1.vely\"+\")\");\n                #end\n            };\n        };\n        var ang1=b1.sweep_angvel;\n        if(ang1<0)ang1=-ang1;\n        var angBias=(s1.sweepCoef*ang1);\n        var c1=toi.c1;\n        var c2=toi.c2;\n        var axis=toi.axis;\n        var curTOI=lowerBound;\n        var curIter=0;\n        while(true){\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !(curTOI*timeStep!=curTOI*timeStep);\n                };\n                if(!res)throw \"assert(\"+\"!(curTOI*timeStep!=curTOI*timeStep)\"+\") :: \"+(curTOI+\" \"+timeStep);\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !(b1.sweepTime!=b1.sweepTime);\n                };\n                if(!res)throw \"assert(\"+\"!(b1.sweepTime!=b1.sweepTime)\"+\") :: \"+(\"sweeeeep\");\n                #end\n            };\n            b1.sweepIntegrate(curTOI*timeStep);\n            b1.sweepValidate(s1);\n            var sep=distance(s1,s2,c1,c2,axis)+negRadius;\n            var dot=(deltax*axis.x+deltay*axis.y);\n            if(sep<Config.distanceThresholdCCD){\n                var d1x:Float=0.0;\n                var d1y:Float=0.0;\n                {\n                    d1x=c1.x-b1.posx;\n                    d1y=c1.y-b1.posy;\n                };\n                var proj=dot-b1.sweep_angvel*(axis.y*d1x-axis.x*d1y);\n                if(proj>0){\n                    toi.slipped=true;\n                }\n                if(proj<=0||sep<Config.distanceThresholdCCD*0.5){\n                    break;\n                }\n            }\n            var denom=(angBias-dot)*timeStep;\n            if(denom<=0){\n                curTOI=-1;\n                break;\n            }\n            var delta=sep/denom;\n            if(delta<1e-6)delta=1e-6;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !(delta!=delta);\n                };\n                if(!res)throw \"assert(\"+\"!(delta!=delta)\"+\") :: \"+(delta+\" \"+(s1.sweepCoef)+\" \"+ang1);\n                #end\n            };\n            curTOI+=delta;\n            if(curTOI>=1){\n                curTOI=1;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !(curTOI*timeStep!=curTOI*timeStep);\n                    };\n                    if(!res)throw \"assert(\"+\"!(curTOI*timeStep!=curTOI*timeStep)\"+\") :: \"+(curTOI+\" \"+timeStep);\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !(b1.sweepTime!=b1.sweepTime);\n                    };\n                    if(!res)throw \"assert(\"+\"!(b1.sweepTime!=b1.sweepTime)\"+\") :: \"+(\"sweeeeep\");\n                    #end\n                };\n                b1.sweepIntegrate(curTOI*timeStep);\n                b1.sweepValidate(s1);\n                var sep=distance(s1,s2,c1,c2,axis)+negRadius;\n                var dot=(deltax*axis.x+deltay*axis.y);\n                if(sep<Config.distanceThresholdCCD){\n                    var d1x:Float=0.0;\n                    var d1y:Float=0.0;\n                    {\n                        d1x=c1.x-b1.posx;\n                        d1y=c1.y-b1.posy;\n                    };\n                    var proj=dot-b1.sweep_angvel*(axis.y*d1x-axis.x*d1y);\n                    if(proj>0){\n                        toi.slipped=true;\n                    }\n                    if(proj<=0||sep<Config.distanceThresholdCCD*0.5){\n                        break;\n                    }\n                }\n                curTOI=-1;\n                break;\n            }\n            if((++curIter)>=40){\n                if(sep>negRadius){\n                    toi.failed=true;\n                }\n                break;\n            }\n        }\n        toi.toi=curTOI;\n    }\n    static public function distanceBody(b1:ZPP_Body,b2:ZPP_Body,w1:ZPP_Vec2,w2:ZPP_Vec2):Float{\n        var t1;\n        {\n            if(ZPP_Vec2.zpp_pool==null){\n                t1=new ZPP_Vec2();\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_TOT++;\n                ZPP_Vec2.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                t1=ZPP_Vec2.zpp_pool;\n                ZPP_Vec2.zpp_pool=t1.next;\n                t1.next=null;\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT--;\n                ZPP_Vec2.POOL_ADD++;\n                #end\n            }\n            t1.alloc();\n        };\n        var t2;\n        {\n            if(ZPP_Vec2.zpp_pool==null){\n                t2=new ZPP_Vec2();\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_TOT++;\n                ZPP_Vec2.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                t2=ZPP_Vec2.zpp_pool;\n                ZPP_Vec2.zpp_pool=t2.next;\n                t2.next=null;\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT--;\n                ZPP_Vec2.POOL_ADD++;\n                #end\n            }\n            t2.alloc();\n        };\n        var ax;\n        {\n            if(ZPP_Vec2.zpp_pool==null){\n                ax=new ZPP_Vec2();\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_TOT++;\n                ZPP_Vec2.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ax=ZPP_Vec2.zpp_pool;\n                ZPP_Vec2.zpp_pool=ax.next;\n                ax.next=null;\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT--;\n                ZPP_Vec2.POOL_ADD++;\n                #end\n            }\n            ax.alloc();\n        };\n        var min=ZPP_Const.FMAX;\n        {\n            var cx_ite=b1.shapes.begin();\n            while(cx_ite!=null){\n                var s1=cx_ite.elem();\n                {\n                    {\n                        var cx_ite=b2.shapes.begin();\n                        while(cx_ite!=null){\n                            var s2=cx_ite.elem();\n                            {\n                                var dist=distance(s1,s2,t1,t2,ax,min);\n                                if(dist<min){\n                                    min=dist;\n                                    {\n                                        w1.x=t1.x;\n                                        w1.y=t1.y;\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !((w1.x!=w1.x));\n                                            };\n                                            if(!res)throw \"assert(\"+\"!assert_isNaN(w1.x)\"+\") :: \"+(\"vec_set(in n: \"+\"w1.\"+\",in x: \"+\"t1.x\"+\",in y: \"+\"t1.y\"+\")\");\n                                            #end\n                                        };\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !((w1.y!=w1.y));\n                                            };\n                                            if(!res)throw \"assert(\"+\"!assert_isNaN(w1.y)\"+\") :: \"+(\"vec_set(in n: \"+\"w1.\"+\",in x: \"+\"t1.x\"+\",in y: \"+\"t1.y\"+\")\");\n                                            #end\n                                        };\n                                    };\n                                    {\n                                        w2.x=t2.x;\n                                        w2.y=t2.y;\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !((w2.x!=w2.x));\n                                            };\n                                            if(!res)throw \"assert(\"+\"!assert_isNaN(w2.x)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"t2.x\"+\",in y: \"+\"t2.y\"+\")\");\n                                            #end\n                                        };\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                !((w2.y!=w2.y));\n                                            };\n                                            if(!res)throw \"assert(\"+\"!assert_isNaN(w2.y)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"t2.x\"+\",in y: \"+\"t2.y\"+\")\");\n                                            #end\n                                        };\n                                    };\n                                }\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var o=t1;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"t1\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        {\n            var o=t2;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"t2\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        {\n            var o=ax;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"ax\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        return min;\n    }\n    static public#if NAPE_NO_INLINE#else inline #end\n    function distance(s1:ZPP_Shape,s2:ZPP_Shape,w1:ZPP_Vec2,w2:ZPP_Vec2,axis:ZPP_Vec2,upperBound:Float=1e100):Float{\n        if(s1.isCircle()&&s2.isCircle()){\n            var c1=s1.circle;\n            var c2=s2.circle;\n            var dist;\n            {\n                var nx:Float=0.0;\n                var ny:Float=0.0;\n                {\n                    nx=c2.worldCOMx-c1.worldCOMx;\n                    ny=c2.worldCOMy-c1.worldCOMy;\n                };\n                var len=ZPP_Math.sqrt((nx*nx+ny*ny));\n                dist=len-(c1.radius+c2.radius);\n                if(dist<upperBound){\n                    if(len==0){\n                        nx=1;\n                        ny=0;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((nx!=nx));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(nx)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"1\"+\",in y: \"+\"0\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((ny!=ny));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(ny)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"1\"+\",in y: \"+\"0\"+\")\");\n                            #end\n                        };\n                    };\n                    else{\n                        var t=(1.0/(len));\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"n\"+\",in s: \"+\"1.0/(len)\"+\")\");\n                            #end\n                        };\n                        nx*=t;\n                        ny*=t;\n                    };\n                    {\n                        var t=(c1.radius);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                            #end\n                        };\n                        w1.x=c1.worldCOMx+(nx*t);\n                        w1.y=c1.worldCOMy+(ny*t);\n                    };\n                    {\n                        var t=(-c2.radius);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                            #end\n                        };\n                        w2.x=c2.worldCOMx+(nx*t);\n                        w2.y=c2.worldCOMy+(ny*t);\n                    };\n                    {\n                        axis.x=nx;\n                        axis.y=ny;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((axis.x!=axis.x));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(axis.x)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((axis.y!=axis.y));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(axis.y)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                            #end\n                        };\n                    };\n                }\n            };\n            return dist;\n        }\n        else{\n            var swapped=false;\n            if(s1.isCircle()&&s2.isPolygon()){\n                var tmp=s1;\n                s1=s2;\n                s2=tmp;\n                var tmp2=w1;\n                w1=w2;\n                w2=tmp2;\n                swapped=true;\n            }\n            if(s1.isPolygon()&&s2.isCircle()){\n                var poly=s1.polygon;\n                var circle=s2.circle;\n                var best=-ZPP_Const.FMAX;\n                var a0=null;\n                {\n                    var cx_ite=poly.edges.begin();\n                    while(cx_ite!=null){\n                        var a=cx_ite.elem();\n                        {\n                            var dist=(a.gnormx*circle.worldCOMx+a.gnormy*circle.worldCOMy)-a.gprojection-circle.radius;\n                            if(dist>upperBound){\n                                best=dist;\n                                break;\n                            }\n                            if(dist>0){\n                                if(dist>best){\n                                    best=dist;\n                                    a0=a;\n                                }\n                            }\n                            else if(best<0&&dist>best){\n                                best=dist;\n                                a0=a;\n                            }\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                if(best<upperBound){\n                    var v0=a0.gp0;\n                    var v1=a0.gp1;\n                    var dt=(circle.worldCOMy*a0.gnormx-circle.worldCOMx*a0.gnormy);\n                    if(dt<=(v0.y*a0.gnormx-v0.x*a0.gnormy)){\n                        {\n                            var nx:Float=0.0;\n                            var ny:Float=0.0;\n                            {\n                                nx=circle.worldCOMx-v0.x;\n                                ny=circle.worldCOMy-v0.y;\n                            };\n                            var len=ZPP_Math.sqrt((nx*nx+ny*ny));\n                            best=len-(0+circle.radius);\n                            if(best<upperBound){\n                                if(len==0){\n                                    nx=1;\n                                    ny=0;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((nx!=nx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(nx)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"1\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((ny!=ny));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(ny)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"1\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                };\n                                else{\n                                    var t=(1.0/(len));\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"n\"+\",in s: \"+\"1.0/(len)\"+\")\");\n                                        #end\n                                    };\n                                    nx*=t;\n                                    ny*=t;\n                                };\n                                {\n                                    var t=(0);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                        #end\n                                    };\n                                    w1.x=v0.x+(nx*t);\n                                    w1.y=v0.y+(ny*t);\n                                };\n                                {\n                                    var t=(-circle.radius);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                        #end\n                                    };\n                                    w2.x=circle.worldCOMx+(nx*t);\n                                    w2.y=circle.worldCOMy+(ny*t);\n                                };\n                                {\n                                    axis.x=nx;\n                                    axis.y=ny;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((axis.x!=axis.x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(axis.x)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((axis.y!=axis.y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(axis.y)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                                        #end\n                                    };\n                                };\n                            }\n                        };\n                    }\n                    else if(dt>=(v1.y*a0.gnormx-v1.x*a0.gnormy)){\n                        {\n                            var nx:Float=0.0;\n                            var ny:Float=0.0;\n                            {\n                                nx=circle.worldCOMx-v1.x;\n                                ny=circle.worldCOMy-v1.y;\n                            };\n                            var len=ZPP_Math.sqrt((nx*nx+ny*ny));\n                            best=len-(0+circle.radius);\n                            if(best<upperBound){\n                                if(len==0){\n                                    nx=1;\n                                    ny=0;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((nx!=nx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(nx)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"1\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((ny!=ny));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(ny)\"+\") :: \"+(\"vec_set(in n: \"+\"n\"+\",in x: \"+\"1\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                };\n                                else{\n                                    var t=(1.0/(len));\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"n\"+\",in s: \"+\"1.0/(len)\"+\")\");\n                                        #end\n                                    };\n                                    nx*=t;\n                                    ny*=t;\n                                };\n                                {\n                                    var t=(0);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                        #end\n                                    };\n                                    w1.x=v1.x+(nx*t);\n                                    w1.y=v1.y+(ny*t);\n                                };\n                                {\n                                    var t=(-circle.radius);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                        #end\n                                    };\n                                    w2.x=circle.worldCOMx+(nx*t);\n                                    w2.y=circle.worldCOMy+(ny*t);\n                                };\n                                {\n                                    axis.x=nx;\n                                    axis.y=ny;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((axis.x!=axis.x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(axis.x)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((axis.y!=axis.y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(axis.y)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"nx\"+\",in y: \"+\"ny\"+\")\");\n                                        #end\n                                    };\n                                };\n                            }\n                        };\n                    }\n                    else{\n                        {\n                            var t=(-circle.radius);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                #end\n                            };\n                            w2.x=circle.worldCOMx+(a0.gnormx*t);\n                            w2.y=circle.worldCOMy+(a0.gnormy*t);\n                        };\n                        {\n                            var t=(-best);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                #end\n                            };\n                            w1.x=w2.x+(a0.gnormx*t);\n                            w1.y=w2.y+(a0.gnormy*t);\n                        };\n                        {\n                            axis.x=a0.gnormx;\n                            axis.y=a0.gnormy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((axis.x!=axis.x));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(axis.x)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"a0.gnormx\"+\",in y: \"+\"a0.gnormy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((axis.y!=axis.y));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(axis.y)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"a0.gnormx\"+\",in y: \"+\"a0.gnormy\"+\")\");\n                                #end\n                            };\n                        };\n                    }\n                }\n                if(swapped){\n                    axis.x=-axis.x;\n                    axis.y=-axis.y;\n                };\n                return best;\n            }\n            else{\n                var p1=s1.polygon;\n                var p2=s2.polygon;\n                var best=-ZPP_Const.FMAX;\n                var a1=null;\n                var a2=null;\n                var besti=0;\n                {\n                    var cx_ite=p1.edges.begin();\n                    while(cx_ite!=null){\n                        var a=cx_ite.elem();\n                        {\n                            var min=ZPP_Const.FMAX;\n                            {\n                                var cx_ite=p2.gverts.begin();\n                                while(cx_ite!=null){\n                                    var v=cx_ite.elem();\n                                    {\n                                        var k=(a.gnormx*v.x+a.gnormy*v.y);\n                                        if(k<min)min=k;\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                            min-=a.gprojection;\n                            if(min>upperBound){\n                                best=min;\n                                break;\n                            }\n                            if(min>0){\n                                if(min>best){\n                                    best=min;\n                                    a1=a;\n                                    besti=1;\n                                }\n                            }\n                            else if(best<0&&min>best){\n                                best=min;\n                                a1=a;\n                                besti=1;\n                            }\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                if(best<upperBound){\n                    {\n                        var cx_ite=p2.edges.begin();\n                        while(cx_ite!=null){\n                            var a=cx_ite.elem();\n                            {\n                                var min=ZPP_Const.FMAX;\n                                {\n                                    var cx_ite=p1.gverts.begin();\n                                    while(cx_ite!=null){\n                                        var v=cx_ite.elem();\n                                        {\n                                            var k=(a.gnormx*v.x+a.gnormy*v.y);\n                                            if(k<min)min=k;\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                min-=a.gprojection;\n                                if(min>upperBound){\n                                    best=min;\n                                    break;\n                                }\n                                if(min>0){\n                                    if(min>best){\n                                        best=min;\n                                        a2=a;\n                                        besti=2;\n                                    }\n                                }\n                                else if(best<0&&min>best){\n                                    best=min;\n                                    a2=a;\n                                    besti=2;\n                                }\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    if(best<upperBound){\n                        var q1,q2;\n                        var ax;\n                        if(besti==1){\n                            q1=p1;\n                            q2=p2;\n                            ax=a1;\n                        }\n                        else{\n                            q1=p2;\n                            q2=p1;\n                            ax=a2;\n                            var tmp=w1;\n                            w1=w2;\n                            w2=tmp;\n                            swapped=!swapped;\n                        }\n                        var ay:ZPP_Edge=null;\n                        var min=ZPP_Const.FMAX;\n                        {\n                            var cx_ite=q2.edges.begin();\n                            while(cx_ite!=null){\n                                var a=cx_ite.elem();\n                                {\n                                    var k=(ax.gnormx*a.gnormx+ax.gnormy*a.gnormy);\n                                    if(k<min){\n                                        min=k;\n                                        ay=a;\n                                    }\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                        if(swapped){\n                            axis.x=-ax.gnormx;\n                            axis.y=-ax.gnormy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((axis.x!=axis.x));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(axis.x)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"-ax.gnormx\"+\",in y: \"+\"-ax.gnormy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((axis.y!=axis.y));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(axis.y)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"-ax.gnormx\"+\",in y: \"+\"-ax.gnormy\"+\")\");\n                                #end\n                            };\n                        };\n                        else{\n                            axis.x=ax.gnormx;\n                            axis.y=ax.gnormy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((axis.x!=axis.x));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(axis.x)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"ax.gnormx\"+\",in y: \"+\"ax.gnormy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((axis.y!=axis.y));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(axis.y)\"+\") :: \"+(\"vec_set(in n: \"+\"axis.\"+\",in x: \"+\"ax.gnormx\"+\",in y: \"+\"ax.gnormy\"+\")\");\n                                #end\n                            };\n                        };\n                        if(best>=0){\n                            var v0=ax.gp0;\n                            var v1=ax.gp1;\n                            var q0=ay.gp0;\n                            var q1=ay.gp1;\n                            var vx:Float=0.0;\n                            var vy:Float=0.0;\n                            var qx:Float=0.0;\n                            var qy:Float=0.0;\n                            {\n                                vx=v1.x-v0.x;\n                                vy=v1.y-v0.y;\n                            };\n                            {\n                                qx=q1.x-q0.x;\n                                qy=q1.y-q0.y;\n                            };\n                            var vdot=1/(vx*vx+vy*vy);\n                            var qdot=1/(qx*qx+qy*qy);\n                            var t1=-(vx*(v0.x-q0.x)+vy*(v0.y-q0.y))*vdot;\n                            var t2=-(vx*(v0.x-q1.x)+vy*(v0.y-q1.y))*vdot;\n                            var s1=-(qx*(q0.x-v0.x)+qy*(q0.y-v0.y))*qdot;\n                            var s2=-(qx*(q0.x-v1.x)+qy*(q0.y-v1.y))*qdot;\n                            if(t1<0)t1=0;\n                            else if(t1>1)t1=1;\n                            if(t2<0)t2=0;\n                            else if(t2>1)t2=1;\n                            if(s1<0)s1=0;\n                            else if(s1>1)s1=1;\n                            if(s2<0)s2=0;\n                            else if(s2>1)s2=1;\n                            var f1x:Float=0.0;\n                            var f1y:Float=0.0;\n                            {\n                                var t=(t1);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                    #end\n                                };\n                                f1x=v0.x+(vx*t);\n                                f1y=v0.y+(vy*t);\n                            };\n                            var f2x:Float=0.0;\n                            var f2y:Float=0.0;\n                            {\n                                var t=(t2);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                    #end\n                                };\n                                f2x=v0.x+(vx*t);\n                                f2y=v0.y+(vy*t);\n                            };\n                            var g1x:Float=0.0;\n                            var g1y:Float=0.0;\n                            {\n                                var t=(s1);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                    #end\n                                };\n                                g1x=q0.x+(qx*t);\n                                g1y=q0.y+(qy*t);\n                            };\n                            var g2x:Float=0.0;\n                            var g2y:Float=0.0;\n                            {\n                                var t=(s2);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                    #end\n                                };\n                                g2x=q0.x+(qx*t);\n                                g2y=q0.y+(qy*t);\n                            };\n                            var d1=ZPP_VecMath.vec_dsq(f1x,f1y,q0.x,q0.y);\n                            var d2=ZPP_VecMath.vec_dsq(f2x,f2y,q1.x,q1.y);\n                            var e1=ZPP_VecMath.vec_dsq(g1x,g1y,v0.x,v0.y);\n                            var e2=ZPP_VecMath.vec_dsq(g2x,g2y,v1.x,v1.y);\n                            var minfx:Float=0.0;\n                            var minfy:Float=0.0;\n                            var minq=null;\n                            if(d1<d2){\n                                {\n                                    minfx=f1x;\n                                    minfy=f1y;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((minfx!=minfx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(minfx)\"+\") :: \"+(\"vec_set(in n: \"+\"minf\"+\",in x: \"+\"f1x\"+\",in y: \"+\"f1y\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((minfy!=minfy));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(minfy)\"+\") :: \"+(\"vec_set(in n: \"+\"minf\"+\",in x: \"+\"f1x\"+\",in y: \"+\"f1y\"+\")\");\n                                        #end\n                                    };\n                                };\n                                minq=q0;\n                            }\n                            else{\n                                {\n                                    minfx=f2x;\n                                    minfy=f2y;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((minfx!=minfx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(minfx)\"+\") :: \"+(\"vec_set(in n: \"+\"minf\"+\",in x: \"+\"f2x\"+\",in y: \"+\"f2y\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((minfy!=minfy));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(minfy)\"+\") :: \"+(\"vec_set(in n: \"+\"minf\"+\",in x: \"+\"f2x\"+\",in y: \"+\"f2y\"+\")\");\n                                        #end\n                                    };\n                                };\n                                minq=q1;\n                                d1=d2;\n                            }\n                            var mingx:Float=0.0;\n                            var mingy:Float=0.0;\n                            var minv=null;\n                            if(e1<e2){\n                                {\n                                    mingx=g1x;\n                                    mingy=g1y;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((mingx!=mingx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(mingx)\"+\") :: \"+(\"vec_set(in n: \"+\"ming\"+\",in x: \"+\"g1x\"+\",in y: \"+\"g1y\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((mingy!=mingy));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(mingy)\"+\") :: \"+(\"vec_set(in n: \"+\"ming\"+\",in x: \"+\"g1x\"+\",in y: \"+\"g1y\"+\")\");\n                                        #end\n                                    };\n                                };\n                                minv=v0;\n                            }\n                            else{\n                                {\n                                    mingx=g2x;\n                                    mingy=g2y;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((mingx!=mingx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(mingx)\"+\") :: \"+(\"vec_set(in n: \"+\"ming\"+\",in x: \"+\"g2x\"+\",in y: \"+\"g2y\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((mingy!=mingy));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(mingy)\"+\") :: \"+(\"vec_set(in n: \"+\"ming\"+\",in x: \"+\"g2x\"+\",in y: \"+\"g2y\"+\")\");\n                                        #end\n                                    };\n                                };\n                                minv=v1;\n                                e1=e2;\n                            }\n                            if(d1<e1){\n                                {\n                                    w1.x=minfx;\n                                    w1.y=minfy;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w1.x!=w1.x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w1.x)\"+\") :: \"+(\"vec_set(in n: \"+\"w1.\"+\",in x: \"+\"minfx\"+\",in y: \"+\"minfy\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w1.y!=w1.y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w1.y)\"+\") :: \"+(\"vec_set(in n: \"+\"w1.\"+\",in x: \"+\"minfx\"+\",in y: \"+\"minfy\"+\")\");\n                                        #end\n                                    };\n                                };\n                                {\n                                    w2.x=minq.x;\n                                    w2.y=minq.y;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w2.x!=w2.x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w2.x)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"minq.x\"+\",in y: \"+\"minq.y\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w2.y!=w2.y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w2.y)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"minq.x\"+\",in y: \"+\"minq.y\"+\")\");\n                                        #end\n                                    };\n                                };\n                                best=Math.sqrt(d1);\n                            }\n                            else{\n                                {\n                                    w2.x=mingx;\n                                    w2.y=mingy;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w2.x!=w2.x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w2.x)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"mingx\"+\",in y: \"+\"mingy\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w2.y!=w2.y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w2.y)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"mingx\"+\",in y: \"+\"mingy\"+\")\");\n                                        #end\n                                    };\n                                };\n                                {\n                                    w1.x=minv.x;\n                                    w1.y=minv.y;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w1.x!=w1.x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w1.x)\"+\") :: \"+(\"vec_set(in n: \"+\"w1.\"+\",in x: \"+\"minv.x\"+\",in y: \"+\"minv.y\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w1.y!=w1.y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w1.y)\"+\") :: \"+(\"vec_set(in n: \"+\"w1.\"+\",in x: \"+\"minv.x\"+\",in y: \"+\"minv.y\"+\")\");\n                                        #end\n                                    };\n                                };\n                                best=Math.sqrt(e1);\n                            }\n                            if(best!=0){\n                                {\n                                    axis.x=w2.x-w1.x;\n                                    axis.y=w2.y-w1.y;\n                                };\n                                {\n                                    var t=(1.0/(best));\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"axis.\"+\",in s: \"+\"1.0/(best)\"+\")\");\n                                        #end\n                                    };\n                                    axis.x*=t;\n                                    axis.y*=t;\n                                };\n                                if(swapped){\n                                    axis.x=-axis.x;\n                                    axis.y=-axis.y;\n                                };\n                            }\n                            return best;\n                        }\n                        else{\n                            var c0x:Float=0.0;\n                            var c0y:Float=0.0;\n                            {\n                                c0x=ay.gp0.x;\n                                c0y=ay.gp0.y;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((c0x!=c0x));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(c0x)\"+\") :: \"+(\"vec_set(in n: \"+\"c0\"+\",in x: \"+\"ay.gp0.x\"+\",in y: \"+\"ay.gp0.y\"+\")\");\n                                    #end\n                                };\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((c0y!=c0y));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(c0y)\"+\") :: \"+(\"vec_set(in n: \"+\"c0\"+\",in x: \"+\"ay.gp0.x\"+\",in y: \"+\"ay.gp0.y\"+\")\");\n                                    #end\n                                };\n                            };\n                            var c1x:Float=0.0;\n                            var c1y:Float=0.0;\n                            {\n                                c1x=ay.gp1.x;\n                                c1y=ay.gp1.y;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((c1x!=c1x));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(c1x)\"+\") :: \"+(\"vec_set(in n: \"+\"c1\"+\",in x: \"+\"ay.gp1.x\"+\",in y: \"+\"ay.gp1.y\"+\")\");\n                                    #end\n                                };\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((c1y!=c1y));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(c1y)\"+\") :: \"+(\"vec_set(in n: \"+\"c1\"+\",in x: \"+\"ay.gp1.x\"+\",in y: \"+\"ay.gp1.y\"+\")\");\n                                    #end\n                                };\n                            };\n                            var dvx:Float=0.0;\n                            var dvy:Float=0.0;\n                            {\n                                dvx=c1x-c0x;\n                                dvy=c1y-c0y;\n                            };\n                            var d0=(ax.gnormy*c0x-ax.gnormx*c0y);\n                            var d1=(ax.gnormy*c1x-ax.gnormx*c1y);\n                            var den=1/(d1-d0);\n                            var t=(-ax.tp1-d0)*den;\n                            if(t>Config.epsilon){\n                                var t=(t);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c0\"+\",in b: \"+\"dv\"+\",in s: \"+\"t\"+\")\");\n                                    #end\n                                };\n                                c0x+=dvx*t;\n                                c0y+=dvy*t;\n                            };\n                            var t=(-ax.tp0-d1)*den;\n                            if(t<-Config.epsilon){\n                                var t=(t);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c1\"+\",in b: \"+\"dv\"+\",in s: \"+\"t\"+\")\");\n                                    #end\n                                };\n                                c1x+=dvx*t;\n                                c1y+=dvy*t;\n                            };\n                            var c0d=(c0x*ax.gnormx+c0y*ax.gnormy)-ax.gprojection;\n                            var c1d=(c1x*ax.gnormx+c1y*ax.gnormy)-ax.gprojection;\n                            if(c0d<c1d){\n                                {\n                                    w2.x=c0x;\n                                    w2.y=c0y;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w2.x!=w2.x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w2.x)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"c0x\"+\",in y: \"+\"c0y\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w2.y!=w2.y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w2.y)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"c0x\"+\",in y: \"+\"c0y\"+\")\");\n                                        #end\n                                    };\n                                };\n                                {\n                                    var t=(-c0d);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                        #end\n                                    };\n                                    w1.x=w2.x+(ax.gnormx*t);\n                                    w1.y=w2.y+(ax.gnormy*t);\n                                };\n                                return c0d;\n                            }\n                            else{\n                                {\n                                    w2.x=c1x;\n                                    w2.y=c1y;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w2.x!=w2.x));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w2.x)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"c1x\"+\",in y: \"+\"c1y\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((w2.y!=w2.y));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(w2.y)\"+\") :: \"+(\"vec_set(in n: \"+\"w2.\"+\",in x: \"+\"c1x\"+\",in y: \"+\"c1y\"+\")\");\n                                        #end\n                                    };\n                                };\n                                {\n                                    var t=(-c1d);\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((t!=t));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addmul()\");\n                                        #end\n                                    };\n                                    w1.x=w2.x+(ax.gnormx*t);\n                                    w1.y=w2.y+(ax.gnormy*t);\n                                };\n                                return c1d;\n                            }\n                        }\n                    }\n                    else return upperBound;\n                }\n                else return upperBound;\n            }\n        }\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Vec2{\n    public var _invalidate:Null<ZPP_Vec2->Void>=null;\n    public var _validate:Null<Void->Void>=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate():Void{\n        if(_validate!=null){\n            _validate();\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate():Void{\n        if(_invalidate!=null){\n            _invalidate(this);\n        }\n    }\n    public var _immutable:Bool=false;\n    public var _isimmutable:Null<Void->Void>=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function immutable():Void{\n        #if(!NAPE_RELEASE_BUILD)\n        if(_immutable){\n            throw \"Error: Vec2 is immutable\";\n        }\n        if(_isimmutable!=null){\n            _isimmutable();\n        }\n        #end\n    }\n    public var outer:Null<Vec2>=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function wrapper():Vec2{\n        if(outer==null){\n            outer=new Vec2();\n            {\n                var o=outer.zpp_inner;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"outer.zpp_inner\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_Vec2.zpp_pool;\n                ZPP_Vec2.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n                ZPP_Vec2.POOL_SUB++;\n                #end\n            };\n            outer.zpp_inner=this;\n        }\n        return outer;\n    }\n    public var weak:Bool=false;\n    static public var zpp_pool:ZPP_Vec2=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free():Void{\n        if(outer!=null){\n            outer.zpp_inner=null;\n            outer=null;\n        }\n        _isimmutable=null;\n        _validate=null;\n        _invalidate=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc():Void{\n        weak=false;\n    }\n    public var next:ZPP_Vec2=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Vec2{\n        return this;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZPP_Vec2{\n        return next;\n    }\n    public var _inuse:Bool=false;\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZPP_Vec2):Void{\n        next=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Vec2):ZPP_Vec2{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Vec2):ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        temp.next=begin();\n        next=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZPP_Vec2):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZPP_Vec2,o:ZPP_Vec2):ZPP_Vec2{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZPP_Vec2,o:ZPP_Vec2):ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        if(cur==null){\n            temp.next=begin();\n            next=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        next=ret.next;\n        {\n            ret.elem()._inuse=false;\n        };\n        {};\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Vec2{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Vec2):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Vec2):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Vec2):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Vec2):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZPP_Vec2):ZPP_Vec2{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZPP_Vec2):ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZPP_Vec2;\n        var ret:ZPP_Vec2;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            next=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {\n            old.elem()._inuse=false;\n        };\n        {};\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZPP_Vec2,n:Int):ZPP_Vec2{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(false){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            next=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Vec2):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Vec2):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Vec2{\n        return begin().elem();\n    }\n    public function back():ZPP_Vec2{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Vec2{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Vec2\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n    public var x:Float=0.0;\n    public var y:Float=0.0;\n    public function new(){}\n    public static#if NAPE_NO_INLINE#else inline #end\n    function get(x:Float,y:Float,immutable:Bool=false):ZPP_Vec2{\n        var ret;\n        {\n            if(ZPP_Vec2.zpp_pool==null){\n                ret=new ZPP_Vec2();\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_TOT++;\n                ZPP_Vec2.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_Vec2.zpp_pool;\n                ZPP_Vec2.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT--;\n                ZPP_Vec2.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        ret._immutable=immutable;\n        {\n            ret.x=x;\n            ret.y=y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.x!=ret.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.x)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.y!=ret.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.y)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.\"+\",in x: \"+\"x\"+\",in y: \"+\"y\"+\")\");\n                #end\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function copy():ZPP_Vec2{\n        return get(x,y);\n    }\n    public function toString():String{\n        return \"{ x: \"+x+\" y: \"+y+\" }\";\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Vec3{\n    public var outer:Vec3=null;\n    public var x:Float=0.0;\n    public var y:Float=0.0;\n    public var z:Float=0.0;\n    public var immutable:Bool=false;\n    public var _validate:Null<Void->Void>=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate():Void{\n        if(_validate!=null){\n            _validate();\n        }\n    }\n    public function new(){\n        immutable=false;\n        _validate=null;\n    }\n}\n","package zpp_nape.geom;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_VecMath{\n    public static#if NAPE_NO_INLINE#else inline #end\n    function vec_dsq(ax:Float,ay:Float,bx:Float,by:Float):Float{\n        var dx:Float=0.0;\n        var dy:Float=0.0;\n        {\n            dx=ax-bx;\n            dy=ay-by;\n        };\n        return(dx*dx+dy*dy);\n    }\n    public static#if NAPE_NO_INLINE#else inline #end\n    function vec_distance(ax:Float,ay:Float,bx:Float,by:Float):Float{\n        var dx:Float=0.0;\n        var dy:Float=0.0;\n        {\n            dx=ax-bx;\n            dy=ay-by;\n        };\n        return ZPP_Math.sqrt((dx*dx+dy*dy));\n    }\n}\n","package zpp_nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Interactor{\n    public var outer_i:Interactor=null;\n    public var id:Int=0;\n    public var userData:Dynamic<Dynamic>=null;\n    public var ishape:ZPP_Shape=null;\n    public var ibody:ZPP_Body=null;\n    public var icompound:ZPP_Compound=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isShape(){\n        return ishape!=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isBody(){\n        return ibody!=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isCompound(){\n        return icompound!=null;\n    }\n    public function __iaddedToSpace(){\n        if(group!=null)group.addInteractor(this);\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                cb.addInteractor(this);\n                cx_ite=cx_ite.next;\n            }\n        };\n        alloc_cbSet();\n    }\n    public function __iremovedFromSpace(){\n        if(group!=null)group.remInteractor(this);\n        {\n            var cx_ite=cbTypes.begin();\n            while(cx_ite!=null){\n                var cb=cx_ite.elem();\n                cb.remInteractor(this);\n                cx_ite=cx_ite.next;\n            }\n        };\n        dealloc_cbSet();\n    }\n    public function wake(){\n        if(isShape()){\n            var body=ishape.body;\n            if(body!=null&&body.space!=null)body.space.non_inlined_wake(body);\n            true;\n        }\n        else if(isBody()){\n            if(ibody.space!=null)ibody.space.non_inlined_wake(ibody)else false;\n        }\n        else{\n            if(icompound.space!=null)icompound.space.wakeCompound(icompound);\n            true;\n        }\n    }\n    public var cbsets:ZNPList_ZPP_CallbackSet=null;\n    public static function get(i1:ZPP_Interactor,i2:ZPP_Interactor){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                i1!=i2;\n            };\n            if(!res)throw \"assert(\"+\"i1!=i2\"+\") :: \"+(\"trying to get cbset between interactor and itself?\");\n            #end\n        };\n        var id=if(i1.id<i2.id)i1.id else i2.id;\n        var di=if(i1.id<i2.id)i2.id else i1.id;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                id<di;\n            };\n            if(!res)throw \"assert(\"+\"id<di\"+\") :: \"+(\"interactor id's not ordered well when getting cbset\");\n            #end\n        };\n        var xs=if(i1.cbsets.length<i2.cbsets.length)i1.cbsets else i2.cbsets;\n        var ret:ZPP_CallbackSet=null;\n        {\n            var cx_ite=xs.begin();\n            while(cx_ite!=null){\n                var x=cx_ite.elem();\n                {\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !(x.id==di&&x.di==id);\n                        };\n                        if(!res)throw \"assert(\"+\"!(x.id==di&&x.di==id)\"+\") :: \"+(\"cbset order doesn't match interactor order getting cbset?\");\n                        #end\n                    };\n                    if(x.id==id&&x.di==di){\n                        ret=x;\n                        break;\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function getSpace(){\n        return if(isShape())ishape.body==null?null:ishape.body.space else if(isBody())ibody.space else icompound.space;\n    }\n    public var group:ZPP_InteractionGroup=null;\n    public var cbTypes:ZNPList_ZPP_CbType=null;\n    public var cbSet:ZPP_CbSet=null;\n    public var wrap_cbTypes:CbTypeList=null;\n    public function setupcbTypes(){\n        wrap_cbTypes=ZPP_CbTypeList.get(cbTypes);\n        wrap_cbTypes.zpp_inner.adder=wrap_cbTypes_adder;\n        wrap_cbTypes.zpp_inner.subber=wrap_cbTypes_subber;\n        wrap_cbTypes.zpp_inner.dontremove=true;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_cbTypes.zpp_inner._modifiable=immutable_cbTypes;\n        #end\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    function immutable_cbTypes(){\n        immutable_midstep(\"Interactor::cbTypes\");\n    }\n    #end\n    function wrap_cbTypes_subber(pcb:CbType):Void{\n        var cb=pcb.zpp_inner;\n        if(cbTypes.has(cb)){\n            var space=getSpace();\n            if(space!=null){\n                dealloc_cbSet();\n                cb.remInteractor(this);\n            }\n            cbTypes.remove(cb);\n            if(space!=null){\n                alloc_cbSet();\n                wake();\n            }\n        }\n    }\n    function wrap_cbTypes_adder(cb:CbType):Bool{\n        insert_cbtype(cb.zpp_inner);\n        return false;\n    }\n    public function insert_cbtype(cb:ZPP_CbType){\n        if(!cbTypes.has(cb)){\n            var space=getSpace();\n            if(space!=null){\n                dealloc_cbSet();\n                cb.addInteractor(this);\n            }\n            {\n                var pre=null;\n                {\n                    var cx_ite=cbTypes.begin();\n                    while(cx_ite!=null){\n                        var j=cx_ite.elem();\n                        {\n                            if(ZPP_CbType.setlt(cb,j))break;\n                            pre=cx_ite;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                cbTypes.inlined_insert(pre,cb);\n            };\n            if(space!=null){\n                alloc_cbSet();\n                wake();\n            }\n        }\n    }\n    public function alloc_cbSet(){\n        var space=getSpace();\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                space!=null;\n            };\n            if(!res)throw \"assert(\"+\"space!=null\"+\") :: \"+(\"space null in alloc_cbSet\");\n            #end\n        };\n        if((cbSet=space.cbsets.get(cbTypes))!=null){\n            cbSet.increment();\n            cbSet.addInteractor(this);\n            cbSet.validate();\n            space.freshInteractorType(this);\n        }\n    }\n    public function dealloc_cbSet(){\n        var space=getSpace();\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                space!=null;\n            };\n            if(!res)throw \"assert(\"+\"space!=null\"+\") :: \"+(\"space null in dealloc_cbSet\");\n            #end\n        };\n        if(cbSet!=null){\n            cbSet.remInteractor(this);\n            space.nullInteractorType(this);\n            if(cbSet.decrement()){\n                space.cbsets.remove(cbSet);\n                {\n                    var o=cbSet;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_CbSet\"+\", in obj: \"+\"cbSet\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_CbSet.zpp_pool;\n                    ZPP_CbSet.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_CbSet.POOL_CNT++;\n                    ZPP_CbSet.POOL_SUB++;\n                    #end\n                };\n            }\n            cbSet=null;\n        }\n    }\n    public function setGroup(group:ZPP_InteractionGroup){\n        if(this.group!=group){\n            var inspace=getSpace()!=null;\n            if(inspace&&this.group!=null)this.group.remInteractor(this);\n            this.group=group;\n            if(inspace&&group!=null)group.addInteractor(this);\n            if(inspace){\n                if(isShape())ishape.body.wake();\n                else if(isBody())ibody.wake();\n                else icompound.wake();\n            }\n        }\n    }\n    public function immutable_midstep(n:String){\n        if(isBody())ibody.__immutable_midstep(n);\n        else if(isShape())ishape.__immutable_midstep(n);\n        else icompound.__imutable_midstep(n);\n    }\n    public function new(){\n        id=ZPP_ID.Interactor();\n        cbsets=new ZNPList_ZPP_CallbackSet();\n        cbTypes=new ZNPList_ZPP_CbType();\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    static function int_callback(set:ZPP_CallbackSet,x:ZPP_InteractionListener,cb:ZPP_Callback){\n        var o1=set.int1;\n        var o2=set.int2;\n        if(x.options1.compatible(o1.cbTypes)&&x.options2.compatible(o2.cbTypes)){\n            cb.int1=o1;\n            cb.int2=o2;\n        }\n        else{\n            cb.int1=o2;\n            cb.int2=o1;\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function lookup_group(){\n        var cur:ZPP_Interactor=this;\n        while(cur!=null&&cur.group==null){\n            if(cur.isShape())cur=cur.ishape.body;\n            else if(cur.isCompound())cur=cur.icompound.compound;\n            else cur=cur.ibody.compound;\n        }\n        return if(cur==null)null else cur.group;\n    }\n    public function copyto(ret:Interactor){\n        ret.zpp_inner_i.group=group;\n        for(cb in outer_i.cbTypes)ret.cbTypes.add(cb);\n        if(userData!=null)ret.zpp_inner_i.userData=Reflect.copy(userData);\n    }\n}\n","package zpp_nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Body extends ZPP_Interactor{\n    public var outer:Body=null;\n    public var world:Bool=false;\n    public var type:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isStatic(){\n        return type==ZPP_Flags.id_BodyType_STATIC;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isDynamic(){\n        return type==ZPP_Flags.id_BodyType_DYNAMIC;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isKinematic(){\n        return type==ZPP_Flags.id_BodyType_KINEMATIC;\n    }\n    public static var types:Array<BodyType>=[null,BodyType.STATIC,BodyType.DYNAMIC,BodyType.KINEMATIC];\n    public function invalidate_type(){\n        invalidate_mass();\n        invalidate_inertia();\n    }\n    public var compound:ZPP_Compound=null;\n    public var shapes:ZNPList_ZPP_Shape=null;\n    public var wrap_shapes:ShapeList=null;\n    public function invalidate_shapes(){\n        invalidate_aabb();\n        invalidate_localCOM();\n        invalidate_mass();\n        invalidate_inertia();\n    }\n    public var space:ZPP_Space=null;\n    public var arbiters:ZNPList_ZPP_Arbiter=null;\n    public var wrap_arbiters:ArbiterList=null;\n    public var constraints:ZNPList_ZPP_Constraint=null;\n    public var wrap_constraints:ConstraintList=null;\n    public var component:ZPP_Component=null;\n    static var bodystack:ZNPList_ZPP_Body=null;\n    static var bodyset:ZPP_Set_ZPP_Body=null;\n    static function bodysetlt(a:ZPP_Body,b:ZPP_Body){\n        return a.id<b.id;\n    }\n    public var graph_depth:Int=0;\n    #if NAPE_NO_INLINE#else inline #end\n    function init_bodysetlist(){\n        if(bodyset==null){\n            bodyset=new ZPP_Set_ZPP_Body();\n            bodyset.lt=bodysetlt;\n            bodystack=new ZNPList_ZPP_Body();\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                bodyset.empty();\n            };\n            if(!res)throw \"assert(\"+\"bodyset.empty()\"+\") :: \"+(\"non-empty bodyset in connected bodies at init.\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                bodystack.empty();\n            };\n            if(!res)throw \"assert(\"+\"bodystack.empty()\"+\") :: \"+(\"non-empty bodystack in connected bodies at init.\");\n            #end\n        };\n    }\n    static var cur_graph_depth:Int=0;\n    function connectedBodies_cont(b:Body){\n        if(bodyset.try_insert_bool(b.zpp_inner)){\n            bodystack.add(b.zpp_inner);\n            b.zpp_inner.graph_depth=cur_graph_depth+1;\n        }\n    }\n    public function connectedBodies(depth:Int,output:BodyList):BodyList{\n        init_bodysetlist();\n        var ret=(output==null?new BodyList():output);\n        bodystack.add(this);\n        bodyset.insert(this);\n        graph_depth=0;\n        while(!bodystack.empty()){\n            var cur=bodystack.pop_unsafe();\n            if(cur.graph_depth==depth)continue;\n            cur_graph_depth=cur.graph_depth;\n            {\n                var cx_ite=cur.constraints.begin();\n                while(cx_ite!=null){\n                    var c=cx_ite.elem();\n                    c.outer.visitBodies(connectedBodies_cont);\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n        bodyset.clear_with(function(b:ZPP_Body){\n            if(b!=this)ret.add(b.outer);\n        });\n        return ret;\n    }\n    public function interactingBodies(arbiter_type:Int,depth:Int,output:BodyList):BodyList{\n        init_bodysetlist();\n        var ret=(output==null?new BodyList():output);\n        bodyset.insert(this);\n        bodystack.add(this);\n        graph_depth=0;\n        while(!bodystack.empty()){\n            var cur=bodystack.pop_unsafe();\n            if(cur.graph_depth==depth)continue;\n            {\n                var cx_ite=cur.arbiters.begin();\n                while(cx_ite!=null){\n                    var arb=cx_ite.elem();\n                    {\n                        if((arb.type&arbiter_type)!=0){\n                            var other=if(arb.b1==cur)arb.b2 else arb.b1;\n                            if(bodyset.try_insert_bool(other)){\n                                bodystack.add(other);\n                                other.graph_depth=cur.graph_depth+1;\n                            }\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n        bodyset.clear_with(function(b:ZPP_Body){\n            if(b!=this)ret.add(b.outer);\n        });\n        return ret;\n    }\n    public function atRest(dt:Float){\n        if(!isDynamic())return component.sleeping;\n        else{\n            var linSq=Config.linearSleepThreshold;\n            linSq*=linSq;\n            var cansleep=if((velx*velx+vely*vely)>linSq)false;\n            else if(ZPP_VecMath.vec_dsq(posx,posy,pre_posx,pre_posy)>0.25*linSq*dt*dt)false else{\n                var dx:Float=0.0;\n                var dy:Float=0.0;\n                {\n                    dx=aabb.maxx-aabb.minx;\n                    dy=aabb.maxy-aabb.miny;\n                };\n                var idl=(dx*dx+dy*dy);\n                var angSq=Config.angularSleepThreshold;\n                angSq*=angSq;\n                if(4*angvel*angvel*idl>angSq)false else{\n                    var dr=rot-pre_rot;\n                    if(dr*dr*idl>angSq*dt*dt)false else true;\n                }\n            }\n            if(!cansleep)component.waket=space.stamp;\n            return component.waket+Config.sleepDelay<space.stamp;\n        }\n    }\n    public function refreshArbiters(){\n        {\n            var cx_ite=arbiters.begin();\n            while(cx_ite!=null){\n                var arb=cx_ite.elem();\n                arb.invalidated=true;\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public var sweepTime:Float=0.0;\n    public var sweep_angvel:Float=0.0;\n    public var sweepFrozen:Bool=false;\n    public var sweepRadius:Float=0.0;\n    public var bullet:Bool=false;\n    public var bulletEnabled:Bool=false;\n    public var disableCCD:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function sweepIntegrate(dt:Float){\n        var delta=dt-sweepTime;\n        if(delta!=0){\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !(delta!=delta);\n                };\n                if(!res)throw \"assert(\"+\"!(delta!=delta)\"+\") :: \"+(delta+\" \"+dt+\" \"+sweepTime);\n                #end\n            };\n            sweepTime=dt;\n            {\n                var t=(delta);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"pos\"+\",in b: \"+\"vel\"+\",in s: \"+\"delta\"+\")\");\n                    #end\n                };\n                posx+=velx*t;\n                posy+=vely*t;\n            };\n            if(angvel!=0)delta_rot(sweep_angvel*delta);\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function sweepValidate(s:ZPP_Shape){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                s.body==this;\n            };\n            if(!res)throw \"assert(\"+\"s.body==this\"+\") :: \"+(\"sweepValidate with non owned shape\");\n            #end\n        };\n        if(s.isCircle()){\n            {\n                s.worldCOMx=posx+(axisy*s.localCOMx-axisx*s.localCOMy);\n                s.worldCOMy=posy+(s.localCOMx*axisx+s.localCOMy*axisy);\n            };\n        }\n        else{\n            var p=s.polygon;\n            var li=p.lverts.begin();\n            {\n                var cx_ite=p.gverts.begin();\n                while(cx_ite!=null){\n                    var g=cx_ite.elem();\n                    {\n                        var l=li.elem();\n                        li=li.next;\n                        {\n                            g.x=posx+(axisy*l.x-axisx*l.y);\n                            g.y=posy+(l.x*axisx+l.y*axisy);\n                        };\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            var ite=p.edges.begin();\n            {\n                var cx_ite=p.gverts.begin();\n                var u=cx_ite.elem();\n                cx_ite=cx_ite.next;\n                while(cx_ite!=null){\n                    var v=cx_ite.elem();\n                    {\n                        var e=ite.elem();\n                        ite=ite.next;\n                        {\n                            e.gnormx=(axisy*e.lnormx-axisx*e.lnormy);\n                            e.gnormy=(e.lnormx*axisx+e.lnormy*axisy);\n                        };\n                        e.gprojection=(posx*e.gnormx+posy*e.gnormy)+e.lprojection;\n                        e.tp0=(u.y*e.gnormx-u.x*e.gnormy);\n                        e.tp1=(v.y*e.gnormx-v.x*e.gnormy);\n                    };\n                    u=v;\n                    cx_ite=cx_ite.next;\n                }\n                var v=p.gverts.front();\n                {\n                    var e=ite.elem();\n                    ite=ite.next;\n                    {\n                        e.gnormx=(axisy*e.lnormx-axisx*e.lnormy);\n                        e.gnormy=(e.lnormx*axisx+e.lnormy*axisy);\n                    };\n                    e.gprojection=(posx*e.gnormx+posy*e.gnormy)+e.lprojection;\n                    e.tp0=(u.y*e.gnormx-u.x*e.gnormy);\n                    e.tp1=(v.y*e.gnormx-v.x*e.gnormy);\n                };\n            };\n        }\n    }\n    public var pre_posx:Float=0.0;\n    public var pre_posy:Float=0.0;\n    public var posx:Float=0.0;\n    public var posy:Float=0.0;\n    public var wrap_pos:Vec2=null;\n    public var velx:Float=0.0;\n    public var vely:Float=0.0;\n    public var wrap_vel:Vec2=null;\n    public var forcex:Float=0.0;\n    public var forcey:Float=0.0;\n    public var wrap_force:Vec2=null;\n    public var kinvelx:Float=0.0;\n    public var kinvely:Float=0.0;\n    public var wrap_kinvel:Vec2=null;\n    public var svelx:Float=0.0;\n    public var svely:Float=0.0;\n    public var wrap_svel:Vec2=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_pos(){\n        {\n            var cx_ite=shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                {\n                    if(s.type==ZPP_Flags.id_ShapeType_POLYGON){\n                        s.polygon.invalidate_gverts();\n                        s.polygon.invalidate_gaxi();\n                    }\n                    s.invalidate_worldCOM();\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        invalidate_worldCOM();\n    }\n    private function pos_invalidate(pos:ZPP_Vec2){\n        immutable_midstep(\"Body::position\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(isStatic()&&space!=null)throw \"Error: Cannot move a static object once inside a Space\";\n        #end\n        if(!(posx==pos.x&&posy==pos.y)){\n            {\n                posx=pos.x;\n                posy=pos.y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((posx!=posx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(posx)\"+\") :: \"+(\"vec_set(in n: \"+\"pos\"+\",in x: \"+\"pos.x\"+\",in y: \"+\"pos.y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((posy!=posy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(posy)\"+\") :: \"+(\"vec_set(in n: \"+\"pos\"+\",in x: \"+\"pos.x\"+\",in y: \"+\"pos.y\"+\")\");\n                    #end\n                };\n            };\n            invalidate_pos();\n            wake();\n        }\n    }\n    private function pos_validate(){\n        {\n            wrap_pos.zpp_inner.x=posx;\n            wrap_pos.zpp_inner.y=posy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_pos.zpp_inner.x!=wrap_pos.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_pos.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_pos.zpp_inner.\"+\",in x: \"+\"posx\"+\",in y: \"+\"posy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_pos.zpp_inner.y!=wrap_pos.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_pos.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_pos.zpp_inner.\"+\",in x: \"+\"posx\"+\",in y: \"+\"posy\"+\")\");\n                #end\n            };\n        };\n    }\n    private function vel_invalidate(vel:ZPP_Vec2){\n        #if(!NAPE_RELEASE_BUILD)\n        if(isStatic())throw \"Error: Static body cannot have its velocity set.\";\n        #end\n        {\n            velx=vel.x;\n            vely=vel.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((velx!=velx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(velx)\"+\") :: \"+(\"vec_set(in n: \"+\"vel\"+\",in x: \"+\"vel.x\"+\",in y: \"+\"vel.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((vely!=vely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(vely)\"+\") :: \"+(\"vec_set(in n: \"+\"vel\"+\",in x: \"+\"vel.x\"+\",in y: \"+\"vel.y\"+\")\");\n                #end\n            };\n        };\n        invalidate_wake();\n    }\n    private function vel_validate(){\n        {\n            wrap_vel.zpp_inner.x=velx;\n            wrap_vel.zpp_inner.y=vely;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_vel.zpp_inner.x!=wrap_vel.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_vel.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_vel.zpp_inner.\"+\",in x: \"+\"velx\"+\",in y: \"+\"vely\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_vel.zpp_inner.y!=wrap_vel.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_vel.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_vel.zpp_inner.\"+\",in x: \"+\"velx\"+\",in y: \"+\"vely\"+\")\");\n                #end\n            };\n        };\n    }\n    private function kinvel_invalidate(vel:ZPP_Vec2){\n        {\n            kinvelx=vel.x;\n            kinvely=vel.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((kinvelx!=kinvelx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(kinvelx)\"+\") :: \"+(\"vec_set(in n: \"+\"kinvel\"+\",in x: \"+\"vel.x\"+\",in y: \"+\"vel.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((kinvely!=kinvely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(kinvely)\"+\") :: \"+(\"vec_set(in n: \"+\"kinvel\"+\",in x: \"+\"vel.x\"+\",in y: \"+\"vel.y\"+\")\");\n                #end\n            };\n        };\n        invalidate_wake();\n    }\n    private function kinvel_validate(){\n        {\n            wrap_kinvel.zpp_inner.x=kinvelx;\n            wrap_kinvel.zpp_inner.y=kinvely;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_kinvel.zpp_inner.x!=wrap_kinvel.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_kinvel.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_kinvel.zpp_inner.\"+\",in x: \"+\"kinvelx\"+\",in y: \"+\"kinvely\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_kinvel.zpp_inner.y!=wrap_kinvel.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_kinvel.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_kinvel.zpp_inner.\"+\",in x: \"+\"kinvelx\"+\",in y: \"+\"kinvely\"+\")\");\n                #end\n            };\n        };\n    }\n    private function svel_invalidate(vel:ZPP_Vec2){\n        {\n            svelx=vel.x;\n            svely=vel.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((svelx!=svelx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(svelx)\"+\") :: \"+(\"vec_set(in n: \"+\"svel\"+\",in x: \"+\"vel.x\"+\",in y: \"+\"vel.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((svely!=svely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(svely)\"+\") :: \"+(\"vec_set(in n: \"+\"svel\"+\",in x: \"+\"vel.x\"+\",in y: \"+\"vel.y\"+\")\");\n                #end\n            };\n        };\n        invalidate_wake();\n    }\n    private function svel_validate(){\n        {\n            wrap_svel.zpp_inner.x=svelx;\n            wrap_svel.zpp_inner.y=svely;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_svel.zpp_inner.x!=wrap_svel.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_svel.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_svel.zpp_inner.\"+\",in x: \"+\"svelx\"+\",in y: \"+\"svely\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_svel.zpp_inner.y!=wrap_svel.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_svel.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_svel.zpp_inner.\"+\",in x: \"+\"svelx\"+\",in y: \"+\"svely\"+\")\");\n                #end\n            };\n        };\n    }\n    private function force_invalidate(force:ZPP_Vec2){\n        #if(!NAPE_RELEASE_BUILD)\n        if(!isDynamic())throw \"Error: Non-dynamic body cannot have force applied.\";\n        #end\n        {\n            forcex=force.x;\n            forcey=force.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((forcex!=forcex));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(forcex)\"+\") :: \"+(\"vec_set(in n: \"+\"force\"+\",in x: \"+\"force.x\"+\",in y: \"+\"force.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((forcey!=forcey));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(forcey)\"+\") :: \"+(\"vec_set(in n: \"+\"force\"+\",in x: \"+\"force.x\"+\",in y: \"+\"force.y\"+\")\");\n                #end\n            };\n        };\n        invalidate_wake();\n    }\n    private function force_validate(){\n        wrap_force.zpp_inner.x=forcex;\n        wrap_force.zpp_inner.y=forcey;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((wrap_force.zpp_inner.x!=wrap_force.zpp_inner.x));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_force.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_force.zpp_inner.\"+\",in x: \"+\"forcex\"+\",in y: \"+\"forcey\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((wrap_force.zpp_inner.y!=wrap_force.zpp_inner.y));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_force.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_force.zpp_inner.\"+\",in x: \"+\"forcex\"+\",in y: \"+\"forcey\"+\")\");\n            #end\n        };\n    }\n    public function setupPosition(){\n        wrap_pos=Vec2.get(posx,posy);\n        wrap_pos.zpp_inner._inuse=true;\n        if(world)wrap_pos.zpp_inner._immutable=true;\n        else{\n            wrap_pos.zpp_inner._invalidate=pos_invalidate;\n            wrap_pos.zpp_inner._validate=pos_validate;\n        }\n    }\n    public function setupVelocity(){\n        wrap_vel=Vec2.get(velx,vely);\n        wrap_vel.zpp_inner._inuse=true;\n        if(world)wrap_vel.zpp_inner._immutable=true;\n        else{\n            wrap_vel.zpp_inner._invalidate=vel_invalidate;\n            wrap_vel.zpp_inner._validate=vel_validate;\n        }\n    }\n    public function setupkinvel(){\n        wrap_kinvel=Vec2.get(kinvelx,kinvely);\n        wrap_kinvel.zpp_inner._inuse=true;\n        if(world)wrap_kinvel.zpp_inner._immutable=true;\n        else{\n            wrap_kinvel.zpp_inner._invalidate=kinvel_invalidate;\n            wrap_kinvel.zpp_inner._validate=kinvel_validate;\n        }\n    }\n    public function setupsvel(){\n        wrap_svel=Vec2.get(svelx,svely);\n        wrap_svel.zpp_inner._inuse=true;\n        if(world)wrap_svel.zpp_inner._immutable=true;\n        else{\n            wrap_svel.zpp_inner._invalidate=svel_invalidate;\n            wrap_svel.zpp_inner._validate=svel_validate;\n        }\n    }\n    public function setupForce(){\n        wrap_force=Vec2.get(forcex,forcey);\n        wrap_force.zpp_inner._inuse=true;\n        if(world)wrap_force.zpp_inner._immutable=true;\n        else{\n            wrap_force.zpp_inner._invalidate=force_invalidate;\n            wrap_force.zpp_inner._validate=force_validate;\n        }\n    }\n    private function cvel_validate(){\n        wrapcvel.zpp_inner.x=velx+kinvelx;\n        wrapcvel.zpp_inner.y=vely+kinvely;\n        wrapcvel.zpp_inner.z=angvel+kinangvel;\n    }\n    public var wrapcvel:Vec3=null;\n    public function setup_cvel(){\n        var me=this;\n        wrapcvel=Vec3.get();\n        wrapcvel.zpp_inner.immutable=true;\n        wrapcvel.zpp_inner._validate=cvel_validate;\n    }\n    public var angvel:Float=0.0;\n    public var torque:Float=0.0;\n    public var kinangvel:Float=0.0;\n    public var pre_rot:Float=0.0;\n    public var rot:Float=0.0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_rot(){\n        zip_axis=true;\n        {\n            var cx_ite=shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                {\n                    if(s.type==ZPP_Flags.id_ShapeType_POLYGON){\n                        s.polygon.invalidate_gverts();\n                        s.polygon.invalidate_gaxi();\n                    }\n                    s.invalidate_worldCOM();\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        invalidate_worldCOM();\n    }\n    public var axisx:Float=0.0;\n    public var axisy:Float=0.0;\n    public var zip_axis:Bool=false;\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_axis(){\n        if(zip_axis){\n            zip_axis=false;\n            quick_validate_axis();\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function quick_validate_axis(){\n        {\n            axisx=Math.sin(rot);\n            axisy=Math.cos(rot);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((axisx!=axisx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(axisx)\"+\") :: \"+(\"vec_set(in n: \"+\"axis\"+\",in x: \"+\"Math.sin(rot)\"+\",in y: \"+\"Math.cos(rot)\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((axisy!=axisy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(axisy)\"+\") :: \"+(\"vec_set(in n: \"+\"axis\"+\",in x: \"+\"Math.sin(rot)\"+\",in y: \"+\"Math.cos(rot)\"+\")\");\n                #end\n            };\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function delta_rot(dr:Float){\n        rot+=dr;\n        if(dr*dr>0.0001)quick_validate_axis();\n        else{\n            var d2=dr*dr;\n            var p=1-0.5*d2;\n            var m=1-d2*d2/8;\n            var nx=(p*axisx+dr*axisy)*m;\n            axisy=(p*axisy-dr*axisx)*m;\n            axisx=nx;\n        }\n    }\n    public var kinematicDelaySleep:Bool;\n    public var mass:Float=0.0;\n    public var zip_mass:Bool=false;\n    public var massMode:Int=0;\n    public var imass:Float=0.0;\n    public var smass:Float=0.0;\n    public var cmass:Float=0.0;\n    public var nomove:Bool=false;\n    public function invalidate_mass(){\n        zip_mass=true;\n        invalidate_gravMass();\n    }\n    public function validate_mass(){\n        var exist=false;\n        if(zip_mass||(massMode==ZPP_Flags.id_MassMode_DEFAULT&&exist)){\n            zip_mass=false;\n            if(massMode==ZPP_Flags.id_MassMode_DEFAULT){\n                cmass=0;\n                {\n                    var cx_ite=shapes.begin();\n                    while(cx_ite!=null){\n                        var s=cx_ite.elem();\n                        {\n                            s.refmaterial.density=s.material.density;\n                            s.validate_area_inertia();\n                            cmass+=s.area*s.material.density;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            if(isDynamic()&&!nomove){\n                mass=cmass;\n                imass=smass=1.0/mass;\n            }\n            else{\n                mass=ZPP_Const.POSINF();\n                imass=smass=0.0;\n            }\n            if(exist)invalidate_inertia();\n        }\n    }\n    public var gravMass:Float=0.0;\n    public var zip_gravMass:Bool=false;\n    public var gravMassMode:Int=0;\n    public var gravMassScale:Float=0.0;\n    public var zip_gravMassScale:Bool=false;\n    public function invalidate_gravMass(){\n        if(gravMassMode!=ZPP_Flags.id_GravMassMode_FIXED)zip_gravMass=true;\n        if(gravMassMode!=ZPP_Flags.id_GravMassMode_SCALED)zip_gravMassScale=true;\n        wake();\n    }\n    public function validate_gravMass(){\n        if(zip_gravMass){\n            zip_gravMass=false;\n            validate_mass();\n            if(gravMassMode==ZPP_Flags.id_GravMassMode_DEFAULT){\n                validate_mass();\n                gravMass=cmass;\n            }\n            else if(gravMassMode==ZPP_Flags.id_GravMassMode_SCALED){\n                validate_mass();\n                gravMass=cmass*gravMassScale;\n            }\n        }\n    }\n    public function invalidate_gravMassScale(){\n        if(gravMassMode!=ZPP_Flags.id_GravMassMode_SCALED)zip_gravMassScale=true;\n        else invalidate_gravMass();\n    }\n    public function validate_gravMassScale(){\n        if(zip_gravMassScale){\n            zip_gravMassScale=false;\n            if(gravMassMode==ZPP_Flags.id_GravMassMode_DEFAULT)gravMassScale=1.0;\n            else if(gravMassMode==ZPP_Flags.id_GravMassMode_FIXED){\n                validate_mass();\n                gravMassScale=gravMass/cmass;\n            }\n        }\n    }\n    public var inertiaMode:Int=0;\n    public var inertia:Float=0.0;\n    public var zip_inertia:Bool=false;\n    public var cinertia:Float=0.0;\n    public var iinertia:Float=0.0;\n    public var sinertia:Float=0.0;\n    public var norotate:Bool=false;\n    public function invalidate_inertia(){\n        zip_inertia=true;\n        wake();\n    }\n    public function validate_inertia(){\n        var exist=false;\n        if(zip_inertia||(inertiaMode==ZPP_Flags.id_InertiaMode_DEFAULT&&exist)){\n            zip_inertia=false;\n            if(inertiaMode==ZPP_Flags.id_InertiaMode_DEFAULT){\n                cinertia=0;\n                {\n                    var cx_ite=shapes.begin();\n                    while(cx_ite!=null){\n                        var s=cx_ite.elem();\n                        {\n                            s.refmaterial.density=s.material.density;\n                            s.validate_area_inertia();\n                            cinertia+=s.inertia*s.area*s.material.density;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            if(isDynamic()&&!norotate){\n                inertia=cinertia;\n                sinertia=iinertia=1.0/inertia;\n            }\n            else{\n                inertia=ZPP_Const.POSINF();\n                sinertia=iinertia=0;\n            }\n            if(exist)invalidate_inertia();\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_wake(){\n        wake();\n    }\n    public var aabb:ZPP_AABB=null;\n    public var zip_aabb:Bool=false;\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_aabb(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(shapes.empty())throw \"Error: Body bounds only makes sense if it contains shapes\";\n        #end\n        if(zip_aabb){\n            zip_aabb=false;\n            {\n                aabb.minx=ZPP_Const.POSINF();\n                aabb.miny=ZPP_Const.POSINF();\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((aabb.minx!=aabb.minx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.minx)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.min\"+\",in x: \"+\"ZPP_Const.POSINF()\"+\",in y: \"+\"ZPP_Const.POSINF()\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((aabb.miny!=aabb.miny));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.miny)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.min\"+\",in x: \"+\"ZPP_Const.POSINF()\"+\",in y: \"+\"ZPP_Const.POSINF()\"+\")\");\n                    #end\n                };\n            };\n            {\n                aabb.maxx=ZPP_Const.NEGINF();\n                aabb.maxy=ZPP_Const.NEGINF();\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((aabb.maxx!=aabb.maxx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.maxx)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.max\"+\",in x: \"+\"ZPP_Const.NEGINF()\"+\",in y: \"+\"ZPP_Const.NEGINF()\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((aabb.maxy!=aabb.maxy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.maxy)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.max\"+\",in x: \"+\"ZPP_Const.NEGINF()\"+\",in y: \"+\"ZPP_Const.NEGINF()\"+\")\");\n                    #end\n                };\n            };\n            {\n                var cx_ite=shapes.begin();\n                while(cx_ite!=null){\n                    var s=cx_ite.elem();\n                    {\n                        s.validate_aabb();\n                        aabb.combine(s.aabb);\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_aabb(){\n        zip_aabb=true;\n    }\n    public var localCOMx:Float=0.0;\n    public var localCOMy:Float=0.0;\n    public var zip_localCOM:Bool=false;\n    public var worldCOMx:Float=0.0;\n    public var worldCOMy:Float=0.0;\n    public var zip_worldCOM:Bool=false;\n    public var wrap_localCOM:Vec2=null;\n    public var wrap_worldCOM:Vec2=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_localCOM(){\n        zip_localCOM=true;\n        invalidate_worldCOM();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_worldCOM(){\n        zip_worldCOM=true;\n    }\n    public function validate_localCOM(){\n        if(zip_localCOM){\n            zip_localCOM=false;\n            var tempx:Float=0;\n            var tempy:Float=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((tempx!=tempx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(tempx)\"+\") :: \"+(\"vec_new(in n: \"+\"temp\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((tempy!=tempy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(tempy)\"+\") :: \"+(\"vec_new(in n: \"+\"temp\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            var msum=0.0;\n            {\n                var cx_ite=shapes.begin();\n                while(cx_ite!=null){\n                    var s=cx_ite.elem();\n                    {\n                        s.validate_localCOM();\n                        s.validate_area_inertia();\n                        {\n                            var t=(s.area*s.material.density);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"temp\"+\",in b: \"+\"s.localCOM\"+\",in s: \"+\"s.area*s.material.density\"+\")\");\n                                #end\n                            };\n                            tempx+=s.localCOMx*t;\n                            tempy+=s.localCOMy*t;\n                        };\n                        msum+=s.area*s.material.density;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            if(msum!=0){\n                {\n                    var t=(1.0/(msum));\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_mul(in a: \"+\"temp\"+\",in s: \"+\"1.0/(msum)\"+\",out r: \"+\"localCOM\"+\")\");\n                        #end\n                    };\n                    localCOMx=tempx*t;\n                    localCOMy=tempy*t;\n                };\n            }\n            if(wrap_localCOM!=null){\n                wrap_localCOM.zpp_inner.x=localCOMx;\n                wrap_localCOM.zpp_inner.y=localCOMy;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((wrap_localCOM.zpp_inner.x!=wrap_localCOM.zpp_inner.x));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_localCOM.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_localCOM.zpp_inner.\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((wrap_localCOM.zpp_inner.y!=wrap_localCOM.zpp_inner.y));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_localCOM.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_localCOM.zpp_inner.\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n                    #end\n                };\n            };\n            if(zip_mass&&massMode==ZPP_Flags.id_MassMode_DEFAULT){\n                zip_mass=false;\n                cmass=msum;\n                if(isDynamic()){\n                    mass=cmass;\n                    imass=smass=1.0/mass;\n                }\n                else{\n                    mass=ZPP_Const.POSINF();\n                    imass=smass=0.0;\n                }\n            }\n        }\n    }\n    public function validate_worldCOM(){\n        if(zip_worldCOM){\n            zip_worldCOM=false;\n            validate_localCOM();\n            validate_axis();\n            {\n                worldCOMx=posx+(axisy*localCOMx-axisx*localCOMy);\n                worldCOMy=posy+(localCOMx*axisx+localCOMy*axisy);\n            };\n            if(wrap_worldCOM!=null){\n                wrap_worldCOM.zpp_inner.x=worldCOMx;\n                wrap_worldCOM.zpp_inner.y=worldCOMy;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((wrap_worldCOM.zpp_inner.x!=wrap_worldCOM.zpp_inner.x));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_worldCOM.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_worldCOM.zpp_inner.\"+\",in x: \"+\"worldCOMx\"+\",in y: \"+\"worldCOMy\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((wrap_worldCOM.zpp_inner.y!=wrap_worldCOM.zpp_inner.y));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_worldCOM.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_worldCOM.zpp_inner.\"+\",in x: \"+\"worldCOMx\"+\",in y: \"+\"worldCOMy\"+\")\");\n                    #end\n                };\n            };\n        }\n    }\n    public function getlocalCOM(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(shapes.empty())throw \"Error: localCOM only makes sense when Body has Shapes\";\n        #end\n        validate_localCOM();\n    }\n    public function getworldCOM(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(shapes.empty())throw \"Error: worldCOM only makes sense when Body has Shapes\";\n        #end\n        validate_worldCOM();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function __immutable_midstep(name:String){\n        #if(!NAPE_RELEASE_BUILD)\n        if(space!=null&&space.midstep)throw \"Error: \"+name+\" cannot be set during a space step()\";\n        #end\n    }\n    public function clear(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(space!=null)throw \"Error: Cannot clear a Body if it is currently being used by a Space!\";\n        #end\n        #if(!NAPE_RELEASE_BUILD)\n        if(!constraints.empty())throw \"Error: Cannot clear a Body if it is currently being used by a constraint!\";\n        #end\n        {\n            while(!shapes.empty()){\n                var s=shapes.pop_unsafe();\n                {\n                    s.removedFromBody();\n                    s.body=null;\n                };\n            }\n        };\n        invalidate_shapes();\n        {\n            pre_posx=0;\n            pre_posy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((pre_posx!=pre_posx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(pre_posx)\"+\") :: \"+(\"vec_set(in n: \"+\"pre_pos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((pre_posy!=pre_posy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(pre_posy)\"+\") :: \"+(\"vec_set(in n: \"+\"pre_pos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            posx=0;\n            posy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((posx!=posx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(posx)\"+\") :: \"+(\"vec_set(in n: \"+\"pos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((posy!=posy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(posy)\"+\") :: \"+(\"vec_set(in n: \"+\"pos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            velx=0;\n            vely=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((velx!=velx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(velx)\"+\") :: \"+(\"vec_set(in n: \"+\"vel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((vely!=vely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(vely)\"+\") :: \"+(\"vec_set(in n: \"+\"vel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            forcex=0;\n            forcey=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((forcex!=forcex));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(forcex)\"+\") :: \"+(\"vec_set(in n: \"+\"force\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((forcey!=forcey));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(forcey)\"+\") :: \"+(\"vec_set(in n: \"+\"force\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            kinvelx=0;\n            kinvely=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((kinvelx!=kinvelx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(kinvelx)\"+\") :: \"+(\"vec_set(in n: \"+\"kinvel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((kinvely!=kinvely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(kinvely)\"+\") :: \"+(\"vec_set(in n: \"+\"kinvel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            svelx=0;\n            svely=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((svelx!=svelx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(svelx)\"+\") :: \"+(\"vec_set(in n: \"+\"svel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((svely!=svely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(svely)\"+\") :: \"+(\"vec_set(in n: \"+\"svel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        angvel=torque=kinangvel=pre_rot=rot=0;\n        invalidate_pos();\n        invalidate_rot();\n        {\n            axisx=0;\n            axisy=1;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((axisx!=axisx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(axisx)\"+\") :: \"+(\"vec_set(in n: \"+\"axis\"+\",in x: \"+\"0\"+\",in y: \"+\"1\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((axisy!=axisy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(axisy)\"+\") :: \"+(\"vec_set(in n: \"+\"axis\"+\",in x: \"+\"0\"+\",in y: \"+\"1\"+\")\");\n                #end\n            };\n        };\n        zip_axis=false;\n        massMode=ZPP_Flags.id_MassMode_DEFAULT;\n        gravMassMode=ZPP_Flags.id_GravMassMode_DEFAULT;\n        gravMassScale=1.0;\n        inertiaMode=ZPP_Flags.id_InertiaMode_DEFAULT;\n        norotate=false;\n        nomove=false;\n    }\n    public static function __static():Body{\n        var ret=new Body(BodyType.STATIC);\n        var si=ret.zpp_inner;\n        si.world=true;\n        si.wrap_shapes.zpp_inner.immutable=true;\n        si.smass=si.imass=si.cmass=si.mass=si.gravMass=0.0;\n        si.sinertia=si.iinertia=si.cinertia=si.inertia=0.0;\n        si.cbTypes.clear();\n        return ret;\n    }\n    private function aabb_validate(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(shapes.empty())throw \"Error: bounds only makes sense when Body has shapes\";\n        #end\n        validate_aabb();\n    }\n    private function shapes_adder(s:Shape){\n        if(s.zpp_inner.body!=this){\n            if(s.zpp_inner.body!=null)s.zpp_inner.body.wrap_shapes.remove(s);\n            s.zpp_inner.body=this;\n            s.zpp_inner.addedToBody();\n            if(space!=null)space.added_shape(s.zpp_inner);\n            if(s.zpp_inner.isPolygon()){\n                s.zpp_inner.polygon.invalidate_gaxi();\n                s.zpp_inner.polygon.invalidate_gverts();\n            }\n            return true;\n        }\n        else return false;\n    }\n    private function shapes_subber(s:Shape){\n        if(space!=null)space.removed_shape(s.zpp_inner);\n        s.zpp_inner.body=null;\n        s.zpp_inner.removedFromBody();\n    }\n    private function shapes_invalidate(_){\n        invalidate_shapes();\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function shapes_modifiable(){\n        immutable_midstep(\"Body::shapes\");\n        if(isStatic()&&space!=null)throw \"Error: Cannot modifiy shapes of static object once added to Space\";\n    }\n    #end\n    public function new(){\n        super();\n        ibody=this;\n        world=false;\n        bulletEnabled=false;\n        sweepTime=0;\n        sweep_angvel=0;\n        norotate=nomove=false;\n        disableCCD=false;\n        {\n            posx=0;\n            posy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((posx!=posx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(posx)\"+\") :: \"+(\"vec_set(in n: \"+\"pos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((posy!=posy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(posy)\"+\") :: \"+(\"vec_set(in n: \"+\"pos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        rot=0;\n        {\n            axisx=0;\n            axisy=1;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((axisx!=axisx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(axisx)\"+\") :: \"+(\"vec_set(in n: \"+\"axis\"+\",in x: \"+\"0\"+\",in y: \"+\"1\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((axisy!=axisy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(axisy)\"+\") :: \"+(\"vec_set(in n: \"+\"axis\"+\",in x: \"+\"0\"+\",in y: \"+\"1\"+\")\");\n                #end\n            };\n        };\n        {\n            svelx=0;\n            svely=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((svelx!=svelx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(svelx)\"+\") :: \"+(\"vec_set(in n: \"+\"svel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((svely!=svely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(svely)\"+\") :: \"+(\"vec_set(in n: \"+\"svel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            velx=0;\n            vely=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((velx!=velx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(velx)\"+\") :: \"+(\"vec_set(in n: \"+\"vel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((vely!=vely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(vely)\"+\") :: \"+(\"vec_set(in n: \"+\"vel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            kinvelx=0;\n            kinvely=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((kinvelx!=kinvelx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(kinvelx)\"+\") :: \"+(\"vec_set(in n: \"+\"kinvel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((kinvely!=kinvely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(kinvely)\"+\") :: \"+(\"vec_set(in n: \"+\"kinvel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            forcex=0;\n            forcey=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((forcex!=forcex));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(forcex)\"+\") :: \"+(\"vec_set(in n: \"+\"force\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((forcey!=forcey));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(forcey)\"+\") :: \"+(\"vec_set(in n: \"+\"force\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        torque=angvel=kinangvel=0;\n        {\n            pre_posx=ZPP_Const.POSINF();\n            pre_posy=ZPP_Const.POSINF();\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((pre_posx!=pre_posx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(pre_posx)\"+\") :: \"+(\"vec_set(in n: \"+\"pre_pos\"+\",in x: \"+\"ZPP_Const.POSINF()\"+\",in y: \"+\"ZPP_Const.POSINF()\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((pre_posy!=pre_posy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(pre_posy)\"+\") :: \"+(\"vec_set(in n: \"+\"pre_pos\"+\",in x: \"+\"ZPP_Const.POSINF()\"+\",in y: \"+\"ZPP_Const.POSINF()\"+\")\");\n                #end\n            };\n        };\n        pre_rot=ZPP_Const.POSINF();\n        {\n            localCOMx=0;\n            localCOMy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((localCOMx!=localCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((localCOMy!=localCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            worldCOMx=0;\n            worldCOMy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((worldCOMx!=worldCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(worldCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"worldCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((worldCOMy!=worldCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(worldCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"worldCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        zip_aabb=true;\n        aabb=ZPP_AABB.get(0,0,0,0);\n        aabb._immutable=true;\n        var me=this;\n        aabb._validate=aabb_validate;\n        massMode=ZPP_Flags.id_MassMode_DEFAULT;\n        gravMassMode=ZPP_Flags.id_GravMassMode_DEFAULT;\n        gravMassScale=1.0;\n        inertiaMode=ZPP_Flags.id_InertiaMode_DEFAULT;\n        arbiters=new ZNPList_ZPP_Arbiter();\n        constraints=new ZNPList_ZPP_Constraint();\n        shapes=new ZNPList_ZPP_Shape();\n        wrap_shapes=ZPP_ShapeList.get(shapes);\n        wrap_shapes.zpp_inner.adder=shapes_adder;\n        wrap_shapes.zpp_inner.subber=shapes_subber;\n        wrap_shapes.zpp_inner._invalidate=shapes_invalidate;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_shapes.zpp_inner._modifiable=shapes_modifiable;\n        #end\n        kinematicDelaySleep=false;\n    }\n    public function addedToSpace(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                component==null;\n            };\n            if(!res)throw \"assert(\"+\"component==null\"+\") :: \"+(\"already has a component?\");\n            #end\n        };\n        {\n            if(ZPP_Component.zpp_pool==null){\n                component=new ZPP_Component();\n                #if NAPE_POOL_STATS ZPP_Component.POOL_TOT++;\n                ZPP_Component.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                component=ZPP_Component.zpp_pool;\n                ZPP_Component.zpp_pool=component.next;\n                component.next=null;\n                #if NAPE_POOL_STATS ZPP_Component.POOL_CNT--;\n                ZPP_Component.POOL_ADD++;\n                #end\n            }\n            component.alloc();\n        };\n        component.isBody=true;\n        component.body=this;\n        __iaddedToSpace();\n    }\n    public function removedFromSpace(){\n        while(!arbiters.empty()){\n            var arb=arbiters.pop_unsafe();\n            arb.lazyRetire(space,this);\n        }\n        {\n            var o=component;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Component\"+\", in obj: \"+\"component\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Component.zpp_pool;\n            ZPP_Component.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Component.POOL_CNT++;\n            ZPP_Component.POOL_SUB++;\n            #end\n        };\n        component=null;\n        __iremovedFromSpace();\n    }\n    public function copy(){\n        var ret=new Body().zpp_inner;\n        ret.type=type;\n        ret.bulletEnabled=bulletEnabled;\n        ret.disableCCD=disableCCD;\n        {\n            var cx_ite=shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                {\n                    ret.outer.shapes.add(s.outer.copy());\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            ret.posx=posx;\n            ret.posy=posy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.posx!=ret.posx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.posx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.pos\"+\",in x: \"+\"posx\"+\",in y: \"+\"posy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.posy!=ret.posy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.posy)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.pos\"+\",in x: \"+\"posx\"+\",in y: \"+\"posy\"+\")\");\n                #end\n            };\n        };\n        {\n            ret.velx=velx;\n            ret.vely=vely;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.velx!=ret.velx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.velx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.vel\"+\",in x: \"+\"velx\"+\",in y: \"+\"vely\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.vely!=ret.vely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.vely)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.vel\"+\",in x: \"+\"velx\"+\",in y: \"+\"vely\"+\")\");\n                #end\n            };\n        };\n        {\n            ret.forcex=forcex;\n            ret.forcey=forcey;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.forcex!=ret.forcex));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.forcex)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.force\"+\",in x: \"+\"forcex\"+\",in y: \"+\"forcey\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.forcey!=ret.forcey));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.forcey)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.force\"+\",in x: \"+\"forcex\"+\",in y: \"+\"forcey\"+\")\");\n                #end\n            };\n        };\n        ret.rot=rot;\n        ret.angvel=angvel;\n        ret.torque=torque;\n        {\n            ret.kinvelx=kinvelx;\n            ret.kinvely=kinvely;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.kinvelx!=ret.kinvelx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.kinvelx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.kinvel\"+\",in x: \"+\"kinvelx\"+\",in y: \"+\"kinvely\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.kinvely!=ret.kinvely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.kinvely)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.kinvel\"+\",in x: \"+\"kinvelx\"+\",in y: \"+\"kinvely\"+\")\");\n                #end\n            };\n        };\n        ret.kinangvel=kinangvel;\n        {\n            ret.svelx=svelx;\n            ret.svely=svely;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.svelx!=ret.svelx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.svelx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.svel\"+\",in x: \"+\"svelx\"+\",in y: \"+\"svely\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.svely!=ret.svely));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.svely)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.svel\"+\",in x: \"+\"svelx\"+\",in y: \"+\"svely\"+\")\");\n                #end\n            };\n        };\n        if(!zip_axis){\n            ret.axisx=axisx;\n            ret.axisy=axisy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.axisx!=ret.axisx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.axisx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.axis\"+\",in x: \"+\"axisx\"+\",in y: \"+\"axisy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.axisy!=ret.axisy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.axisy)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.axis\"+\",in x: \"+\"axisx\"+\",in y: \"+\"axisy\"+\")\");\n                #end\n            };\n        };\n        else ret.invalidate_rot();\n        ret.rot=rot;\n        ret.massMode=massMode;\n        ret.gravMassMode=gravMassMode;\n        ret.inertiaMode=inertiaMode;\n        ret.norotate=norotate;\n        ret.nomove=nomove;\n        ret.cmass=cmass;\n        ret.cinertia=cinertia;\n        if(!zip_mass)ret.mass=mass;\n        else ret.invalidate_mass();\n        if(!zip_gravMass)ret.gravMass=gravMass;\n        else ret.invalidate_gravMass();\n        if(!zip_gravMassScale)ret.gravMassScale=gravMassScale;\n        else ret.invalidate_gravMassScale();\n        if(!zip_inertia)ret.inertia=inertia;\n        else ret.invalidate_inertia();\n        if(!zip_aabb){\n            {\n                ret.aabb.minx=aabb.minx;\n                ret.aabb.miny=aabb.miny;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((ret.aabb.minx!=ret.aabb.minx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(ret.aabb.minx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.aabb.min\"+\",in x: \"+\"aabb.minx\"+\",in y: \"+\"aabb.miny\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((ret.aabb.miny!=ret.aabb.miny));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(ret.aabb.miny)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.aabb.min\"+\",in x: \"+\"aabb.minx\"+\",in y: \"+\"aabb.miny\"+\")\");\n                    #end\n                };\n            };\n            {\n                ret.aabb.maxx=aabb.maxx;\n                ret.aabb.maxy=aabb.maxy;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((ret.aabb.maxx!=ret.aabb.maxx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(ret.aabb.maxx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.aabb.max\"+\",in x: \"+\"aabb.maxx\"+\",in y: \"+\"aabb.maxy\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((ret.aabb.maxy!=ret.aabb.maxy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(ret.aabb.maxy)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.aabb.max\"+\",in x: \"+\"aabb.maxx\"+\",in y: \"+\"aabb.maxy\"+\")\");\n                    #end\n                };\n            };\n        }\n        else ret.invalidate_aabb();\n        if(!zip_localCOM){\n            ret.localCOMx=localCOMx;\n            ret.localCOMy=localCOMy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.localCOMx!=ret.localCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.localCOM\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.localCOMy!=ret.localCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.localCOM\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n                #end\n            };\n        };\n        else ret.invalidate_localCOM();\n        if(!zip_worldCOM){\n            ret.worldCOMx=worldCOMx;\n            ret.worldCOMy=worldCOMy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.worldCOMx!=ret.worldCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.worldCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.worldCOM\"+\",in x: \"+\"worldCOMx\"+\",in y: \"+\"worldCOMy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.worldCOMy!=ret.worldCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.worldCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.worldCOM\"+\",in x: \"+\"worldCOMx\"+\",in y: \"+\"worldCOMy\"+\")\");\n                #end\n            };\n        };\n        else ret.invalidate_worldCOM();\n        copyto(ret.outer);\n        return ret.outer;\n    }\n}\n","package zpp_nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Compound extends ZPP_Interactor{\n    public var outer:Compound=null;\n    public var bodies:ZNPList_ZPP_Body=null;\n    public var constraints:ZNPList_ZPP_Constraint=null;\n    public var compounds:ZNPList_ZPP_Compound=null;\n    public var wrap_bodies:BodyList=null;\n    public var wrap_constraints:ConstraintList=null;\n    public var wrap_compounds:CompoundList=null;\n    public var depth:Int=0;\n    public var compound:ZPP_Compound=null;\n    public var space:ZPP_Space=null;\n    public function __imutable_midstep(name:String){\n        #if(!NAPE_RELEASE_BUILD)\n        if(space!=null&&space.midstep)throw \"Error: \"+name+\" cannot be set during space step()\";\n        #end\n    }\n    public function addedToSpace(){\n        __iaddedToSpace();\n    }\n    public function removedFromSpace(){\n        __iremovedFromSpace();\n    }\n    public function breakApart(){\n        if(space!=null){\n            __iremovedFromSpace();\n            space.nullInteractorType(this);\n        }\n        if(compound!=null)compound.compounds.remove(this);\n        else if(space!=null)space.compounds.remove(this);\n        {\n            while(!bodies.empty()){\n                var b=bodies.pop_unsafe();\n                {\n                    if((b.compound=compound)!=null)compound.bodies.add(b);\n                    else if(space!=null)space.bodies.add(b);\n                    if(space!=null)space.freshInteractorType(b);\n                };\n            }\n        };\n        {\n            while(!constraints.empty()){\n                var c=constraints.pop_unsafe();\n                {\n                    if((c.compound=compound)!=null)compound.constraints.add(c);\n                    else if(space!=null)space.constraints.add(c);\n                };\n            }\n        };\n        {\n            while(!compounds.empty()){\n                var c=compounds.pop_unsafe();\n                {\n                    if((c.compound=compound)!=null)compound.compounds.add(c);\n                    else if(space!=null)space.compounds.add(c);\n                    if(space!=null)space.freshInteractorType(c);\n                };\n            }\n        };\n        compound=null;\n        space=null;\n    }\n    \n    private function bodies_adder(x:Body){\n        {}\n        if(x.zpp_inner.compound!=this){\n            if(x.zpp_inner.compound!=null)x.zpp_inner.compound.wrap_bodies.remove(x);\n            else if(x.zpp_inner.space!=null)x.zpp_inner.space.wrap_bodies.remove(x);\n            x.zpp_inner.compound=this;\n            {};\n            if(space!=null)space.addBody(x.zpp_inner);\n            return true;\n        }\n        else return false;\n    }\n    private function bodies_subber(x:Body){\n        x.zpp_inner.compound=null;\n        {};\n        if(space!=null)space.remBody(x.zpp_inner);\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function bodies_modifiable(){\n        immutable_midstep(\"Compound::\"+\"bodies\");\n    }\n    #end\n    private function constraints_adder(x:Constraint){\n        {}\n        if(x.zpp_inner.compound!=this){\n            if(x.zpp_inner.compound!=null)x.zpp_inner.compound.wrap_constraints.remove(x);\n            else if(x.zpp_inner.space!=null)x.zpp_inner.space.wrap_constraints.remove(x);\n            x.zpp_inner.compound=this;\n            {};\n            if(space!=null)space.addConstraint(x.zpp_inner);\n            return true;\n        }\n        else return false;\n    }\n    private function constraints_subber(x:Constraint){\n        x.zpp_inner.compound=null;\n        {};\n        if(space!=null)space.remConstraint(x.zpp_inner);\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function constraints_modifiable(){\n        immutable_midstep(\"Compound::\"+\"constraints\");\n    }\n    #end\n    private function compounds_adder(x:Compound){\n        #if(!NAPE_RELEASE_BUILD)\n        var cur=this;\n        while(cur!=null&&cur!=x.zpp_inner)cur=cur.compound;\n        if(cur==x.zpp_inner){\n            throw \"Error: Assignment would cause a cycle in the Compound tree: assigning \"+x.toString()+\".compound = \"+outer.toString();\n            return false;\n        }\n        #end\n        if(x.zpp_inner.compound!=this){\n            if(x.zpp_inner.compound!=null)x.zpp_inner.compound.wrap_compounds.remove(x);\n            else if(x.zpp_inner.space!=null)x.zpp_inner.space.wrap_compounds.remove(x);\n            x.zpp_inner.compound=this;\n            x.zpp_inner.depth=depth+1;\n            if(space!=null)space.addCompound(x.zpp_inner);\n            return true;\n        }\n        else return false;\n    }\n    private function compounds_subber(x:Compound){\n        x.zpp_inner.compound=null;\n        x.zpp_inner.depth=1;\n        if(space!=null)space.remCompound(x.zpp_inner);\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function compounds_modifiable(){\n        immutable_midstep(\"Compound::\"+\"compounds\");\n    }\n    #end\n    public function new(){\n        super();\n        icompound=this;\n        depth=1;\n        var me=this;\n        bodies=new ZNPList_ZPP_Body();\n        wrap_bodies=ZPP_BodyList.get(bodies);\n        wrap_bodies.zpp_inner.adder=bodies_adder;\n        wrap_bodies.zpp_inner.subber=bodies_subber;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_bodies.zpp_inner._modifiable=bodies_modifiable;\n        #end\n        constraints=new ZNPList_ZPP_Constraint();\n        wrap_constraints=ZPP_ConstraintList.get(constraints);\n        wrap_constraints.zpp_inner.adder=constraints_adder;\n        wrap_constraints.zpp_inner.subber=constraints_subber;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_constraints.zpp_inner._modifiable=constraints_modifiable;\n        #end\n        compounds=new ZNPList_ZPP_Compound();\n        wrap_compounds=ZPP_CompoundList.get(compounds);\n        wrap_compounds.zpp_inner.adder=compounds_adder;\n        wrap_compounds.zpp_inner.subber=compounds_subber;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_compounds.zpp_inner._modifiable=compounds_modifiable;\n        #end\n    }\n    public function copy(dict:Array<ZPP_CopyHelper>=null,todo:Array<ZPP_CopyHelper>=null):Compound{\n        var root=dict==null;\n        if(dict==null)dict=new Array<ZPP_CopyHelper>();\n        if(todo==null)todo=new Array<ZPP_CopyHelper>();\n        var ret=new Compound();\n        {\n            var cx_ite=compounds.begin();\n            while(cx_ite!=null){\n                var c=cx_ite.elem();\n                {\n                    var cc=c.copy(dict,todo);\n                    cc.compound=ret;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=bodies.begin();\n            while(cx_ite!=null){\n                var b=cx_ite.elem();\n                {\n                    var bc=b.outer.copy();\n                    dict.push(ZPP_CopyHelper.dict(b.id,bc));\n                    bc.compound=ret;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=constraints.begin();\n            while(cx_ite!=null){\n                var c=cx_ite.elem();\n                {\n                    var cc=c.copy(dict,todo);\n                    cc.compound=ret;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(root){\n            while(todo.length>0){\n                var xcb=todo.pop();\n                for(idc in dict){\n                    if(idc.id==xcb.id){\n                        xcb.cb(idc.bc);\n                        break;\n                    }\n                }\n            }\n        }\n        copyto(ret);\n        return ret;\n    }\n}\n","package zpp_nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_FluidProperties{\n    public var next:ZPP_FluidProperties=null;\n    static public var zpp_pool:ZPP_FluidProperties=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var userData:Dynamic<Dynamic>=null;\n    public var outer:FluidProperties=null;\n    public function wrapper(){\n        if(outer==null){\n            outer=new FluidProperties();\n            {\n                var o=outer.zpp_inner;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_FluidProperties\"+\", in obj: \"+\"outer.zpp_inner\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_FluidProperties.zpp_pool;\n                ZPP_FluidProperties.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_FluidProperties.POOL_CNT++;\n                ZPP_FluidProperties.POOL_SUB++;\n                #end\n            };\n            outer.zpp_inner=this;\n        }\n        return outer;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        outer=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var shapes:ZNPList_ZPP_Shape=null;\n    public var wrap_shapes:ShapeList=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function feature_cons(){\n        shapes=new ZNPList_ZPP_Shape();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addShape(shape:ZPP_Shape){\n        shapes.add(shape);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remShape(shape:ZPP_Shape){\n        shapes.remove(shape);\n    }\n    public function copy(){\n        var ret;\n        {\n            if(ZPP_FluidProperties.zpp_pool==null){\n                ret=new ZPP_FluidProperties();\n                #if NAPE_POOL_STATS ZPP_FluidProperties.POOL_TOT++;\n                ZPP_FluidProperties.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_FluidProperties.zpp_pool;\n                ZPP_FluidProperties.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_FluidProperties.POOL_CNT--;\n                ZPP_FluidProperties.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        ret.viscosity=viscosity;\n        ret.density=density;\n        return ret;\n    }\n    public function new(){\n        feature_cons();\n        density=viscosity=1;\n        wrap_gravity=null;\n        {\n            gravityx=0;\n            gravityy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((gravityx!=gravityx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(gravityx)\"+\") :: \"+(\"vec_set(in n: \"+\"gravity\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((gravityy!=gravityy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(gravityy)\"+\") :: \"+(\"vec_set(in n: \"+\"gravity\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n    }\n    public var viscosity:Float=0.0;\n    public var density:Float=0.0;\n    public var gravityx:Float=0.0;\n    public var gravityy:Float=0.0;\n    public var wrap_gravity:Vec2=null;\n    private function gravity_invalidate(x:ZPP_Vec2){\n        {\n            gravityx=x.x;\n            gravityy=x.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((gravityx!=gravityx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(gravityx)\"+\") :: \"+(\"vec_set(in n: \"+\"gravity\"+\",in x: \"+\"x.x\"+\",in y: \"+\"x.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((gravityy!=gravityy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(gravityy)\"+\") :: \"+(\"vec_set(in n: \"+\"gravity\"+\",in x: \"+\"x.x\"+\",in y: \"+\"x.y\"+\")\");\n                #end\n            };\n        };\n        invalidate();\n    }\n    private function gravity_validate(){\n        {\n            wrap_gravity.zpp_inner.x=gravityx;\n            wrap_gravity.zpp_inner.y=gravityy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_gravity.zpp_inner.x!=wrap_gravity.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_gravity.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_gravity.zpp_inner.\"+\",in x: \"+\"gravityx\"+\",in y: \"+\"gravityy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_gravity.zpp_inner.y!=wrap_gravity.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_gravity.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_gravity.zpp_inner.\"+\",in x: \"+\"gravityx\"+\",in y: \"+\"gravityy\"+\")\");\n                #end\n            };\n        };\n    }\n    public function getgravity(){\n        wrap_gravity=Vec2.get(gravityx,gravityy);\n        wrap_gravity.zpp_inner._inuse=true;\n        wrap_gravity.zpp_inner._invalidate=gravity_invalidate;\n        wrap_gravity.zpp_inner._validate=gravity_validate;\n    }\n    public function invalidate(){\n        {\n            var cx_ite=shapes.begin();\n            while(cx_ite!=null){\n                var shape=cx_ite.elem();\n                shape.invalidate_fluidprops();\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n}\n","package zpp_nape.phys;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Material{\n    public var next:ZPP_Material=null;\n    static public var zpp_pool:ZPP_Material=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var userData:Dynamic<Dynamic>=null;\n    public var outer:Material=null;\n    public function wrapper(){\n        if(outer==null){\n            outer=new Material();\n            {\n                var o=outer.zpp_inner;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Material\"+\", in obj: \"+\"outer.zpp_inner\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_Material.zpp_pool;\n                ZPP_Material.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_Material.POOL_CNT++;\n                ZPP_Material.POOL_SUB++;\n                #end\n            };\n            outer.zpp_inner=this;\n        }\n        return outer;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        outer=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var shapes:ZNPList_ZPP_Shape=null;\n    public var wrap_shapes:ShapeList=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function feature_cons(){\n        shapes=new ZNPList_ZPP_Shape();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function addShape(shape:ZPP_Shape){\n        shapes.add(shape);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function remShape(shape:ZPP_Shape){\n        shapes.remove(shape);\n    }\n    public var dynamicFriction:Float=0.0;\n    public var staticFriction:Float=0.0;\n    public var density:Float=0.0;\n    public var elasticity:Float=0.0;\n    public var rollingFriction:Float=0.0;\n    public function new(){\n        feature_cons();\n        elasticity=0;\n        dynamicFriction=1;\n        staticFriction=2;\n        density=0.001;\n        rollingFriction=0.01;\n    }\n    public function copy(){\n        var ret=new ZPP_Material();\n        ret.dynamicFriction=dynamicFriction;\n        ret.staticFriction=staticFriction;\n        ret.density=density;\n        ret.elasticity=elasticity;\n        ret.rollingFriction=rollingFriction;\n        return ret;\n    }\n    public function set(x:ZPP_Material){\n        dynamicFriction=x.dynamicFriction;\n        staticFriction=x.staticFriction;\n        density=x.density;\n        elasticity=x.elasticity;\n        rollingFriction=x.rollingFriction;\n    }\n     public static var WAKE=1;\n     public static var PROPS=2;\n     public static var ANGDRAG=4;\n     public static var ARBITERS=8;\n    public function invalidate(x:Int){\n        {\n            var cx_ite=shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                s.invalidate_material(x);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n}\n","package zpp_nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Shape extends ZPP_Interactor{\n    public var outer:Shape=null;\n    public var body:ZPP_Body=null;\n    public var type:Int=0;\n    public static var types:Array<ShapeType>=[ShapeType.CIRCLE,ShapeType.POLYGON];\n    public#if NAPE_NO_INLINE#else inline #end\n    function isCircle(){\n        return type==ZPP_Flags.id_ShapeType_CIRCLE;\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function isPolygon(){\n        return type==ZPP_Flags.id_ShapeType_POLYGON;\n    }\n    public var area:Float=0.0;\n    public var zip_area_inertia:Bool=false;\n    public var inertia:Float=0.0;\n    public var angDrag:Float=0.0;\n    public var zip_angDrag:Bool=false;\n    public var localCOMx:Float=0.0;\n    public var localCOMy:Float=0.0;\n    public var zip_localCOM:Bool=false;\n    public var worldCOMx:Float=0.0;\n    public var worldCOMy:Float=0.0;\n    public var zip_worldCOM:Bool=false;\n    public var wrap_localCOM:Vec2=null;\n    public var wrap_worldCOM:Vec2=null;\n    public var sweepRadius:Float=0.0;\n    public var zip_sweepRadius:Bool=false;\n    public var sweepCoef:Float=0.0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_sweepRadius(){\n        zip_sweepRadius=true;\n    }\n    public function validate_sweepRadius(){\n        if(zip_sweepRadius){\n            zip_sweepRadius=false;\n            if(isCircle())circle.__validate_sweepRadius();\n            else polygon.__validate_sweepRadius();\n        }\n    }\n    public var circle:ZPP_Circle=null;\n    public var polygon:ZPP_Polygon=null;\n    public var refmaterial:ZPP_Material=null;\n    public var material:ZPP_Material=null;\n    public var filter:ZPP_InteractionFilter=null;\n    public var fluidProperties:ZPP_FluidProperties=null;\n    public var fluidEnabled:Bool=false;\n    public var sensorEnabled:Bool=false;\n    public var sweep:ZPP_SweepData=null;\n    public var node:ZPP_AABBNode=null;\n    public var pairs:ZNPList_ZPP_AABBPair=null;\n    public function clear(){\n        if(isCircle())circle.__clear();\n        else polygon.__clear();\n    }\n    public var aabb:ZPP_AABB=null;\n    public var zip_aabb:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_aabb(){\n        if(zip_aabb){\n            if(body!=null){\n                zip_aabb=false;\n                if(isCircle())circle.__validate_aabb();\n                else polygon.__validate_aabb();\n            }\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function force_validate_aabb(){\n        if(isCircle())circle._force_validate_aabb();\n        else polygon._force_validate_aabb();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function invalidate_aabb(){\n        zip_aabb=true;\n        if(body!=null)body.invalidate_aabb();\n    }\n    public function validate_area_inertia(){\n        if(zip_area_inertia){\n            zip_area_inertia=false;\n            if(isCircle())circle.__validate_area_inertia();\n            else polygon.__validate_area_inertia();\n        }\n    }\n    public function validate_angDrag(){\n        if(zip_angDrag||refmaterial.dynamicFriction!=material.dynamicFriction){\n            zip_angDrag=false;\n            refmaterial.dynamicFriction=material.dynamicFriction;\n            if(isCircle())circle.__validate_angDrag();\n            else polygon.__validate_angDrag();\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_localCOM(){\n        if(zip_localCOM){\n            zip_localCOM=false;\n            if(isPolygon())polygon.__validate_localCOM();\n            if(wrap_localCOM!=null){\n                wrap_localCOM.zpp_inner.x=localCOMx;\n                wrap_localCOM.zpp_inner.y=localCOMy;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((wrap_localCOM.zpp_inner.x!=wrap_localCOM.zpp_inner.x));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_localCOM.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_localCOM.zpp_inner.\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((wrap_localCOM.zpp_inner.y!=wrap_localCOM.zpp_inner.y));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_localCOM.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_localCOM.zpp_inner.\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n                    #end\n                };\n            };\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_worldCOM(){\n        if(zip_worldCOM){\n            if(body!=null){\n                zip_worldCOM=false;\n                validate_localCOM();\n                body.validate_axis();\n                {\n                    worldCOMx=body.posx+(body.axisy*localCOMx-body.axisx*localCOMy);\n                    worldCOMy=body.posy+(localCOMx*body.axisx+localCOMy*body.axisy);\n                };\n            }\n        }\n    }\n    public function getworldCOM(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(body==null)throw \"Error: worldCOM only makes sense when Shape belongs to a Body\";\n        #end\n        validate_worldCOM();\n        {\n            wrap_worldCOM.zpp_inner.x=worldCOMx;\n            wrap_worldCOM.zpp_inner.y=worldCOMy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_worldCOM.zpp_inner.x!=wrap_worldCOM.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_worldCOM.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_worldCOM.zpp_inner.\"+\",in x: \"+\"worldCOMx\"+\",in y: \"+\"worldCOMy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_worldCOM.zpp_inner.y!=wrap_worldCOM.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_worldCOM.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_worldCOM.zpp_inner.\"+\",in x: \"+\"worldCOMx\"+\",in y: \"+\"worldCOMy\"+\")\");\n                #end\n            };\n        };\n    }\n    public function invalidate_area_inertia(){\n        zip_area_inertia=true;\n        if(body!=null){\n            body.invalidate_localCOM();\n            body.invalidate_mass();\n            body.invalidate_inertia();\n        }\n    }\n    public function invalidate_angDrag(){\n        zip_angDrag=true;\n    }\n    public function invalidate_localCOM(){\n        zip_localCOM=true;\n        invalidate_area_inertia();\n        if(isCircle())invalidate_sweepRadius();\n        invalidate_angDrag();\n        invalidate_worldCOM();\n        if(body!=null)body.invalidate_localCOM();\n    }\n    public function invalidate_worldCOM(){\n        zip_worldCOM=true;\n        invalidate_aabb();\n    }\n    public function invalidate_material(flags:Int){\n        if((flags&ZPP_Material.WAKE)!=0)wake();\n        if((flags&ZPP_Material.ARBITERS)!=0){\n            if(body!=null)body.refreshArbiters();\n        }\n        if((flags&ZPP_Material.PROPS)!=0){\n            if(body!=null){\n                body.invalidate_localCOM();\n                body.invalidate_mass();\n                body.invalidate_inertia();\n            }\n        }\n        if((flags&ZPP_Material.ANGDRAG)!=0){\n            invalidate_angDrag();\n        }\n        refmaterial.set(material);\n    }\n    public function invalidate_filter(){\n        wake();\n    }\n    public function invalidate_fluidprops(){\n        if(fluidEnabled)wake();\n    }\n    private function aabb_validate(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(body==null)throw \"Error: bounds only makes sense when Shape belongs to a Body\";\n        #end\n        validate_aabb();\n    }\n    function new(type:Int){\n        super();\n        pairs=new ZNPList_ZPP_AABBPair();\n        ishape=this;\n        this.type=type;\n        aabb=ZPP_AABB.get(0,0,0,0);\n        aabb._immutable=true;\n        var me=this;\n        aabb._validate=aabb_validate;\n        zip_area_inertia=zip_angDrag=zip_localCOM=zip_sweepRadius=true;\n        {\n            localCOMx=0;\n            localCOMy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((localCOMx!=localCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((localCOMy!=localCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            worldCOMx=0;\n            worldCOMy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((worldCOMx!=worldCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(worldCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"worldCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((worldCOMy!=worldCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(worldCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"worldCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        fluidEnabled=false;\n        sensorEnabled=false;\n        fluidProperties=null;\n        body=null;\n        refmaterial=new ZPP_Material();\n        sweepRadius=sweepCoef=0;\n    }\n    public function setMaterial(material:ZPP_Material){\n        if(this.material!=material){\n            if(body!=null&&body.space!=null){\n                if(this.material!=null)this.material.remShape(this);\n            }\n            this.material=material;\n            if(body!=null&&body.space!=null)material.addShape(this);\n            wake();\n            if(body!=null)body.refreshArbiters();\n        }\n    }\n    public function setFilter(filter:ZPP_InteractionFilter){\n        if(this.filter!=filter){\n            if(body!=null&&body.space!=null){\n                if(this.filter!=null)this.filter.remShape(this);\n            }\n            this.filter=filter;\n            if(body!=null&&body.space!=null)filter.addShape(this);\n            wake();\n        }\n    }\n    public function setFluid(fluid:ZPP_FluidProperties){\n        if(fluidProperties!=fluid){\n            if(body!=null&&body.space!=null){\n                if(fluidProperties!=null)fluidProperties.remShape(this);\n            }\n            fluidProperties=fluid;\n            if(body!=null&&body.space!=null)fluid.addShape(this);\n            if(fluidEnabled)wake();\n        }\n    }\n    public function __immutable_midstep(name:String){\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body.space!=null&&body.space.midstep)throw \"Error: \"+name+\" cannot be set during a space step()\";\n        #end\n    }\n    public function addedToBody(){\n        invalidate_worldCOM();\n        invalidate_aabb();\n    }\n    public function removedFromBody(){}\n    public function addedToSpace(){\n        __iaddedToSpace();\n        material.addShape(this);\n        filter.addShape(this);\n        if(fluidProperties!=null)fluidProperties.addShape(this);\n    }\n    public function removedFromSpace(){\n        __iremovedFromSpace();\n        material.remShape(this);\n        filter.remShape(this);\n        if(fluidProperties!=null)fluidProperties.remShape(this);\n    }\n    public function copy(){\n        var ret:ZPP_Shape=null;\n        if(isCircle())ret=circle.__copy();\n        else ret=polygon.__copy();\n        if(!zip_area_inertia){\n            ret.area=area;\n            ret.inertia=inertia;\n        }\n        else ret.invalidate_area_inertia();\n        if(!zip_sweepRadius){\n            ret.sweepRadius=sweepRadius;\n            ret.sweepCoef=sweepCoef;\n        }\n        else ret.invalidate_sweepRadius();\n        if(!zip_angDrag)ret.angDrag=angDrag;\n        else ret.invalidate_angDrag();\n        if(!zip_aabb){\n            {\n                ret.aabb.minx=aabb.minx;\n                ret.aabb.miny=aabb.miny;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((ret.aabb.minx!=ret.aabb.minx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(ret.aabb.minx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.aabb.min\"+\",in x: \"+\"aabb.minx\"+\",in y: \"+\"aabb.miny\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((ret.aabb.miny!=ret.aabb.miny));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(ret.aabb.miny)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.aabb.min\"+\",in x: \"+\"aabb.minx\"+\",in y: \"+\"aabb.miny\"+\")\");\n                    #end\n                };\n            };\n            {\n                ret.aabb.maxx=aabb.maxx;\n                ret.aabb.maxy=aabb.maxy;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((ret.aabb.maxx!=ret.aabb.maxx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(ret.aabb.maxx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.aabb.max\"+\",in x: \"+\"aabb.maxx\"+\",in y: \"+\"aabb.maxy\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((ret.aabb.maxy!=ret.aabb.maxy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(ret.aabb.maxy)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.aabb.max\"+\",in x: \"+\"aabb.maxx\"+\",in y: \"+\"aabb.maxy\"+\")\");\n                    #end\n                };\n            };\n        }\n        else ret.invalidate_aabb();\n        {\n            var o=ret.material;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Material\"+\", in obj: \"+\"ret.material\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Material.zpp_pool;\n            ZPP_Material.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Material.POOL_CNT++;\n            ZPP_Material.POOL_SUB++;\n            #end\n        };\n        {\n            var o=ret.filter;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_InteractionFilter\"+\", in obj: \"+\"ret.filter\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_InteractionFilter.zpp_pool;\n            ZPP_InteractionFilter.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_InteractionFilter.POOL_CNT++;\n            ZPP_InteractionFilter.POOL_SUB++;\n            #end\n        };\n        ret.material=material;\n        ret.filter=filter;\n        if(fluidProperties!=null)ret.fluidProperties=fluidProperties;\n        ret.fluidEnabled=fluidEnabled;\n        ret.sensorEnabled=sensorEnabled;\n        if(userData!=null)ret.userData=Reflect.copy(userData);\n        copyto(ret.outer);\n        return ret.outer;\n    }\n}\n","package zpp_nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Circle extends ZPP_Shape{\n    public var outer_zn:Circle=null;\n    public var radius:Float=0.0;\n    public function new(){\n        super(ZPP_Flags.id_ShapeType_CIRCLE);\n        circle=this;\n        zip_localCOM=false;\n    }\n    public function __clear(){}\n    public function invalidate_radius(){\n        invalidate_area_inertia();\n        invalidate_angDrag();\n        invalidate_aabb();\n        if(body!=null)body.wake();\n    }\n    private function localCOM_validate(){\n        wrap_localCOM.zpp_inner.x=localCOMx;\n        wrap_localCOM.zpp_inner.y=localCOMy;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((wrap_localCOM.zpp_inner.x!=wrap_localCOM.zpp_inner.x));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_localCOM.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_localCOM.zpp_inner.\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((wrap_localCOM.zpp_inner.y!=wrap_localCOM.zpp_inner.y));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_localCOM.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_localCOM.zpp_inner.\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n            #end\n        };\n    }\n    private function localCOM_invalidate(x:ZPP_Vec2){\n        {\n            localCOMx=x.x;\n            localCOMy=x.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((localCOMx!=localCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"x.x\"+\",in y: \"+\"x.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((localCOMy!=localCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"x.x\"+\",in y: \"+\"x.y\"+\")\");\n                #end\n            };\n        };\n        invalidate_localCOM();\n        if(body!=null)body.wake();\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function localCOM_immutable(){\n        if(body!=null&&body.isStatic()&&body.space!=null)throw \"Error: Cannot modify localCOM of Circle added to a static Body whilst within a Space\";\n    }\n    #end\n    public function setupLocalCOM(){\n        var me=this;\n        wrap_localCOM=Vec2.get(localCOMx,localCOMy);\n        wrap_localCOM.zpp_inner._inuse=true;\n        wrap_localCOM.zpp_inner._validate=localCOM_validate;\n        wrap_localCOM.zpp_inner._invalidate=localCOM_invalidate;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_localCOM.zpp_inner._isimmutable=localCOM_immutable;\n        #end\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function __validate_aabb(){\n        validate_worldCOM();\n        var rx:Float=radius;\n        var ry:Float=radius;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((rx!=rx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(rx)\"+\") :: \"+(\"vec_new(in n: \"+\"r\"+\",in x: \"+\"radius\"+\",in y: \"+\"radius\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((ry!=ry));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(ry)\"+\") :: \"+(\"vec_new(in n: \"+\"r\"+\",in x: \"+\"radius\"+\",in y: \"+\"radius\"+\")\");\n            #end\n        };\n        {\n            aabb.minx=worldCOMx-rx;\n            aabb.miny=worldCOMy-ry;\n        };\n        {\n            aabb.maxx=worldCOMx+rx;\n            aabb.maxy=worldCOMy+ry;\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function _force_validate_aabb(){\n        {\n            worldCOMx=body.posx+(body.axisy*localCOMx-body.axisx*localCOMy);\n            worldCOMy=body.posy+(localCOMx*body.axisx+localCOMy*body.axisy);\n        };\n        aabb.minx=worldCOMx-radius;\n        aabb.miny=worldCOMy-radius;\n        aabb.maxx=worldCOMx+radius;\n        aabb.maxy=worldCOMy+radius;\n    }\n    public function __validate_sweepRadius(){\n        sweepCoef=Math.sqrt((localCOMx*localCOMx+localCOMy*localCOMy));\n        sweepRadius=sweepCoef+radius;\n    }\n    public function __validate_area_inertia(){\n        var r2=radius*radius;\n        area=r2*Math.PI;\n        inertia=r2*0.5+(localCOMx*localCOMx+localCOMy*localCOMy);\n    }\n    public function __validate_angDrag(){\n        var lc=(localCOMx*localCOMx+localCOMy*localCOMy);\n        var r2=radius*radius;\n        var skin=material.dynamicFriction*Config.fluidAngularDragFriction;\n        angDrag=(lc+2*r2)*skin+0.5*Config.fluidAngularDrag*(1+Config.fluidVacuumDrag)*lc;\n        angDrag/=(2*(lc+0.5*r2));\n    }\n    public function __scale(sx:Float,sy:Float){\n        var factor=((sx<0?-sx:sx)+(sy<0?-sy:sy))/2;\n        radius*=factor<0?-factor:factor;\n        invalidate_radius();\n        if((localCOMx*localCOMx+localCOMy*localCOMy)>0){\n            localCOMx*=sx;\n            localCOMy*=sy;\n            invalidate_localCOM();\n        }\n    }\n    public function __translate(x:Float,y:Float){\n        {\n            var t=(1.0);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((t!=t));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"localCOM\"+\",in b: \"+\"\"+\",in s: \"+\"1.0\"+\")\");\n                #end\n            };\n            localCOMx+=x*t;\n            localCOMy+=y*t;\n        };\n        invalidate_localCOM();\n    }\n    public function __rotate(x:Float,y:Float){\n        if((localCOMx*localCOMx+localCOMy*localCOMy)>0){\n            var tx:Float=0.0;\n            var ty:Float=0.0;\n            {\n                tx=(y*localCOMx-x*localCOMy);\n                ty=(localCOMx*x+localCOMy*y);\n            };\n            {\n                localCOMx=tx;\n                localCOMy=ty;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((localCOMx!=localCOMx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"tx\"+\",in y: \"+\"ty\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((localCOMy!=localCOMy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"tx\"+\",in y: \"+\"ty\"+\")\");\n                    #end\n                };\n            };\n            invalidate_localCOM();\n        }\n    }\n    public function __transform(m:Mat23){\n        var det=(m.a*m.d-m.b*m.c);\n        if(det<0)det=-det;\n        radius*=Math.sqrt(det);\n        {\n            var t=m.a*localCOMx+m.b*localCOMy+m.tx;\n            localCOMy=m.c*localCOMx+m.d*localCOMy+m.ty;\n            localCOMx=t;\n        };\n        invalidate_radius();\n        invalidate_localCOM();\n    }\n    public function __copy(){\n        var ret=new Circle(radius).zpp_inner_zn;\n        {\n            ret.localCOMx=localCOMx;\n            ret.localCOMy=localCOMy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.localCOMx!=ret.localCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.localCOM\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((ret.localCOMy!=ret.localCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(ret.localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"ret.localCOM\"+\",in x: \"+\"localCOMx\"+\",in y: \"+\"localCOMy\"+\")\");\n                #end\n            };\n        };\n        ret.zip_localCOM=false;\n        return ret;\n    }\n}\n","package zpp_nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Edge{\n    public var next:ZPP_Edge=null;\n    static public var zpp_pool:ZPP_Edge=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        polygon=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var polygon:ZPP_Polygon=null;\n    static public var internal:Bool=false;\n    public var outer:Edge=null;\n    public function wrapper(){\n        if(outer==null){\n            internal=true;\n            outer=new Edge();\n            internal=false;\n            outer.zpp_inner=this;\n        }\n        return outer;\n    }\n    public var lnormx:Float=0.0;\n    public var lnormy:Float=0.0;\n    public var wrap_lnorm:Vec2=null;\n    public var gnormx:Float=0.0;\n    public var gnormy:Float=0.0;\n    public var wrap_gnorm:Vec2=null;\n    public var length:Float=0.0;\n    public var lprojection:Float=0.0;\n    public var gprojection:Float=0.0;\n    public var lp0:ZPP_Vec2=null;\n    public var gp0:ZPP_Vec2=null;\n    public var lp1:ZPP_Vec2=null;\n    public var gp1:ZPP_Vec2=null;\n    public var tp0:Float=0.0;\n    public var tp1:Float=0.0;\n    private function lnorm_validate(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(polygon==null)throw \"Error: Edge not currently in use\";\n        #end\n        polygon.validate_laxi();\n        {\n            wrap_lnorm.zpp_inner.x=lnormx;\n            wrap_lnorm.zpp_inner.y=lnormy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_lnorm.zpp_inner.x!=wrap_lnorm.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_lnorm.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_lnorm.zpp_inner.\"+\",in x: \"+\"lnormx\"+\",in y: \"+\"lnormy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_lnorm.zpp_inner.y!=wrap_lnorm.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_lnorm.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_lnorm.zpp_inner.\"+\",in x: \"+\"lnormx\"+\",in y: \"+\"lnormy\"+\")\");\n                #end\n            };\n        };\n    }\n    private function gnorm_validate(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(polygon==null)throw \"Error: Edge not currently in use\";\n        if(polygon.body==null)throw \"Error: Edge worldNormal only makes sense if the parent Polygon is contained within a rigid body\";\n        #end\n        polygon.validate_gaxi();\n        {\n            wrap_gnorm.zpp_inner.x=gnormx;\n            wrap_gnorm.zpp_inner.y=gnormy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_gnorm.zpp_inner.x!=wrap_gnorm.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_gnorm.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_gnorm.zpp_inner.\"+\",in x: \"+\"gnormx\"+\",in y: \"+\"gnormy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_gnorm.zpp_inner.y!=wrap_gnorm.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_gnorm.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_gnorm.zpp_inner.\"+\",in x: \"+\"gnormx\"+\",in y: \"+\"gnormy\"+\")\");\n                #end\n            };\n        };\n    }\n    public function getlnorm(){\n        wrap_lnorm=Vec2.get(lnormx,lnormy);\n        wrap_lnorm.zpp_inner._immutable=true;\n        wrap_lnorm.zpp_inner._validate=lnorm_validate;\n    }\n    public function getgnorm(){\n        wrap_gnorm=Vec2.get(gnormx,gnormy);\n        wrap_gnorm.zpp_inner._immutable=true;\n        wrap_gnorm.zpp_inner._validate=gnorm_validate;\n    }\n    public function new(){\n        {\n            lnormx=0;\n            lnormy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((lnormx!=lnormx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(lnormx)\"+\") :: \"+(\"vec_set(in n: \"+\"lnorm\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((lnormy!=lnormy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(lnormy)\"+\") :: \"+(\"vec_set(in n: \"+\"lnorm\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        {\n            gnormx=0;\n            gnormy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((gnormx!=gnormx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(gnormx)\"+\") :: \"+(\"vec_set(in n: \"+\"gnorm\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((gnormy!=gnormy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(gnormy)\"+\") :: \"+(\"vec_set(in n: \"+\"gnorm\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        length=0;\n        lprojection=0;\n        gprojection=0;\n    }\n}\n","package zpp_nape.shape;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Polygon extends ZPP_Shape{\n    public var outer_zn:Polygon=null;\n    public var lverts:ZPP_Vec2=null;\n    public var wrap_lverts:Vec2List=null;\n    public var gverts:ZPP_Vec2=null;\n    public var wrap_gverts:Vec2List=null;\n    public var edges:ZNPList_ZPP_Edge=null;\n    public var wrap_edges:EdgeList=null;\n    public var edgeCnt:Int=0;\n    public var reverse_flag:Bool=false;\n    public function __clear(){}\n    private function lverts_pa_invalidate(x:ZPP_Vec2){\n        invalidate_lverts();\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function lverts_pa_immutable(){\n        if(body!=null&&body.isStatic()&&body.space!=null)throw \"Error: Cannot modify local vertex of Polygon added to a static body whilst within a Space\";\n    }\n    #end\n    private function gverts_pa_validate(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(body==null)throw \"Error: World vertex only makes sense when Polygon is contained in a rigid body\";\n        #end\n        validate_gverts();\n    }\n    private function lverts_post_adder(x:Vec2){\n        x.zpp_inner._invalidate=lverts_pa_invalidate;\n        #if(!NAPE_RELEASE_BUILD)\n        x.zpp_inner._isimmutable=lverts_pa_immutable;\n        #end\n        var ite:ZPP_Vec2=null;\n        var ite2:ZNPNode_ZPP_Edge=null;\n        {\n            var cx_ite=lverts.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                {\n                    if(i==x.zpp_inner)break;\n                    else{\n                        ite=ite==null?gverts.begin():ite.next;\n                        ite2=ite2==null?edges.begin():ite2.next;\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        var vec=ZPP_Vec2.get(0,0,true);\n        gverts.insert(ite,vec);\n        if(lverts.begin().next!=null){\n            if(lverts.begin().next.next==null){\n                var ed:ZPP_Edge;\n                {\n                    if(ZPP_Edge.zpp_pool==null){\n                        ed=new ZPP_Edge();\n                        #if NAPE_POOL_STATS ZPP_Edge.POOL_TOT++;\n                        ZPP_Edge.POOL_ADDNEW++;\n                        #end\n                    }\n                    else{\n                        ed=ZPP_Edge.zpp_pool;\n                        ZPP_Edge.zpp_pool=ed.next;\n                        ed.next=null;\n                        #if NAPE_POOL_STATS ZPP_Edge.POOL_CNT--;\n                        ZPP_Edge.POOL_ADD++;\n                        #end\n                    }\n                    ed.alloc();\n                };\n                ed.polygon=this;\n                edges.add(ed);\n                var ed:ZPP_Edge;\n                {\n                    if(ZPP_Edge.zpp_pool==null){\n                        ed=new ZPP_Edge();\n                        #if NAPE_POOL_STATS ZPP_Edge.POOL_TOT++;\n                        ZPP_Edge.POOL_ADDNEW++;\n                        #end\n                    }\n                    else{\n                        ed=ZPP_Edge.zpp_pool;\n                        ZPP_Edge.zpp_pool=ed.next;\n                        ed.next=null;\n                        #if NAPE_POOL_STATS ZPP_Edge.POOL_CNT--;\n                        ZPP_Edge.POOL_ADD++;\n                        #end\n                    }\n                    ed.alloc();\n                };\n                ed.polygon=this;\n                edges.add(ed);\n                edgeCnt+=2;\n            }\n            else{\n                var ed:ZPP_Edge;\n                {\n                    if(ZPP_Edge.zpp_pool==null){\n                        ed=new ZPP_Edge();\n                        #if NAPE_POOL_STATS ZPP_Edge.POOL_TOT++;\n                        ZPP_Edge.POOL_ADDNEW++;\n                        #end\n                    }\n                    else{\n                        ed=ZPP_Edge.zpp_pool;\n                        ZPP_Edge.zpp_pool=ed.next;\n                        ed.next=null;\n                        #if NAPE_POOL_STATS ZPP_Edge.POOL_CNT--;\n                        ZPP_Edge.POOL_ADD++;\n                        #end\n                    }\n                    ed.alloc();\n                };\n                ed.polygon=this;\n                edges.insert(ite2,ed);\n                edgeCnt++;\n            }\n        }\n        vec._validate=gverts_pa_validate;\n    }\n    private function lverts_subber(x:Vec2){\n        cleanup_lvert(x.zpp_inner);\n    }\n    private function lverts_invalidate(_){\n        invalidate_lverts();\n    }\n    private function lverts_validate(){\n        validate_lverts();\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function lverts_modifiable(){\n        immutable_midstep(\"Polygon::localVerts\");\n        #if(!NAPE_RELEASE_BUILD)\n        if(body!=null&&body.isStatic()&&body.space!=null)throw \"Error: Cannot modifiy shapes of static object once added to Space\";\n        #end\n    }\n    #end\n    private function gverts_validate(){\n        validate_gverts();\n    }\n    private function edges_validate(){\n        validate_lverts();\n    }\n    #if nape_swc@:keep #end\n    public function getlverts(){\n        var me=this;\n        wrap_lverts=ZPP_MixVec2List.get(lverts);\n        wrap_lverts.zpp_inner.post_adder=lverts_post_adder;\n        wrap_lverts.zpp_inner.subber=lverts_subber;\n        wrap_lverts.zpp_inner._invalidate=lverts_invalidate;\n        wrap_lverts.zpp_inner._validate=lverts_validate;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_lverts.zpp_inner._modifiable=lverts_modifiable;\n        #end\n        wrap_lverts.zpp_inner.reverse_flag=reverse_flag;\n    }\n    public function getgverts(){\n        var me=this;\n        wrap_gverts=ZPP_MixVec2List.get(gverts,true);\n        wrap_gverts.zpp_inner.reverse_flag=reverse_flag;\n        wrap_gverts.zpp_inner._validate=gverts_validate;\n    }\n    public function getedges(){\n        var me=this;\n        wrap_edges=ZPP_EdgeList.get(edges,true);\n        wrap_edges.zpp_inner.reverse_flag=reverse_flag;\n        wrap_edges.zpp_inner._validate=edges_validate;\n    }\n    public var zip_lverts:Bool=false;\n    public function invalidate_lverts(){\n        invalidate_laxi();\n        invalidate_area_inertia();\n        invalidate_angDrag();\n        invalidate_localCOM();\n        invalidate_gverts();\n        zip_lverts=true;\n        zip_valid=true;\n        zip_sanitation=true;\n        if(body!=null)body.wake();\n    }\n    public var zip_laxi:Bool=false;\n    public function invalidate_laxi(){\n        invalidate_gaxi();\n        invalidate_sweepRadius();\n        zip_laxi=true;\n    }\n    public var zip_gverts:Bool=false;\n    public function invalidate_gverts(){\n        invalidate_aabb();\n        zip_gverts=true;\n    }\n    public var zip_gaxi:Bool=false;\n    public function invalidate_gaxi(){\n        zip_gaxi=true;\n    }\n    public var zip_valid:Bool=false;\n    public var validation:ValidationResult;\n    public function valid(){\n        if(zip_valid){\n            zip_valid=false;\n            splice_collinear();\n            if(lverts.size()<3)return validation=ValidationResult.DEGENERATE;\n            else{\n                validate_lverts();\n                validate_area_inertia();\n                if(area<Config.epsilon)return validation=ValidationResult.DEGENERATE;\n                else{\n                    var neg=false;\n                    var pos=false;\n                    {\n                        var cx_cont=true;\n                        var cx_ite=lverts.begin();\n                        var u=cx_ite.elem();\n                        cx_ite=cx_ite.next;\n                        var v=cx_ite.elem();\n                        cx_ite=cx_ite.next;\n                        while(cx_ite!=null){\n                            var w=cx_ite.elem();\n                            {\n                                var ax:Float=0.0;\n                                var ay:Float=0.0;\n                                {\n                                    ax=w.x-v.x;\n                                    ay=w.y-v.y;\n                                };\n                                var bx:Float=0.0;\n                                var by:Float=0.0;\n                                {\n                                    bx=v.x-u.x;\n                                    by=v.y-u.y;\n                                };\n                                var dot=(by*ax-bx*ay);\n                                if(dot>Config.epsilon)pos=true;\n                                else if(dot<-Config.epsilon)neg=true;\n                                if(pos&&neg){\n                                    cx_cont=false;\n                                    break;\n                                };\n                            };\n                            {\n                                u=v;\n                                v=w;\n                                cx_ite=cx_ite.next;\n                            };\n                        }\n                        if(cx_cont){\n                            cx_ite=lverts.begin();\n                            var w=cx_ite.elem();\n                            do{\n                                {\n                                    var ax:Float=0.0;\n                                    var ay:Float=0.0;\n                                    {\n                                        ax=w.x-v.x;\n                                        ay=w.y-v.y;\n                                    };\n                                    var bx:Float=0.0;\n                                    var by:Float=0.0;\n                                    {\n                                        bx=v.x-u.x;\n                                        by=v.y-u.y;\n                                    };\n                                    var dot=(by*ax-bx*ay);\n                                    if(dot>Config.epsilon)pos=true;\n                                    else if(dot<-Config.epsilon)neg=true;\n                                    if(pos&&neg){\n                                        cx_cont=false;\n                                        break;\n                                    };\n                                };\n                            }\n                            while(false);\n                            if(cx_cont){\n                                {\n                                    u=v;\n                                    v=w;\n                                    cx_ite=cx_ite.next;\n                                };\n                                var w=cx_ite.elem();\n                                do{\n                                    {\n                                        var ax:Float=0.0;\n                                        var ay:Float=0.0;\n                                        {\n                                            ax=w.x-v.x;\n                                            ay=w.y-v.y;\n                                        };\n                                        var bx:Float=0.0;\n                                        var by:Float=0.0;\n                                        {\n                                            bx=v.x-u.x;\n                                            by=v.y-u.y;\n                                        };\n                                        var dot=(by*ax-bx*ay);\n                                        if(dot>Config.epsilon)pos=true;\n                                        else if(dot<-Config.epsilon)neg=true;\n                                        if(pos&&neg)break;\n                                    };\n                                }\n                                while(false);\n                            }\n                        }\n                    };\n                    if(pos&&neg)return validation=ValidationResult.CONCAVE;\n                    else{\n                        var cont=true;\n                        {\n                            var cx_cont=true;\n                            var cx_ite=lverts.begin();\n                            var u=cx_ite.elem();\n                            cx_ite=cx_ite.next;\n                            while(cx_ite!=null){\n                                var v=cx_ite.elem();\n                                {\n                                    if(!cont){\n                                        cx_cont=false;\n                                        break;\n                                    };\n                                    {\n                                        var cx_cont=true;\n                                        var cx_ite=lverts.begin();\n                                        var a=cx_ite.elem();\n                                        cx_ite=cx_ite.next;\n                                        while(cx_ite!=null){\n                                            var b=cx_ite.elem();\n                                            {\n                                                if(u==a||u==b||v==a||v==b){\n                                                    {\n                                                        a=b;\n                                                        cx_ite=cx_ite.next;\n                                                    };\n                                                    continue;\n                                                };\n                                                var sx:Float=0.0;\n                                                var sy:Float=0.0;\n                                                {\n                                                    sx=u.x-a.x;\n                                                    sy=u.y-a.y;\n                                                };\n                                                var vx:Float=0.0;\n                                                var vy:Float=0.0;\n                                                {\n                                                    vx=v.x-u.x;\n                                                    vy=v.y-u.y;\n                                                };\n                                                var qx:Float=0.0;\n                                                var qy:Float=0.0;\n                                                {\n                                                    qx=b.x-a.x;\n                                                    qy=b.y-a.y;\n                                                };\n                                                var den=(vy*qx-vx*qy);\n                                                if(den*den>Config.epsilon){\n                                                    den=1/den;\n                                                    var t=(qy*sx-qx*sy)*den;\n                                                    if(t>Config.epsilon&&t<1-Config.epsilon){\n                                                        var s=(vy*sx-vx*sy)*den;\n                                                        if(s>Config.epsilon&&s<1-Config.epsilon){\n                                                            cont=false;\n                                                            {\n                                                                cx_cont=false;\n                                                                break;\n                                                            };\n                                                        }\n                                                    }\n                                                }\n                                            };\n                                            {\n                                                a=b;\n                                                cx_ite=cx_ite.next;\n                                            };\n                                        }\n                                        if(cx_cont){\n                                            do{\n                                                var b=lverts.front();\n                                                {\n                                                    if(u==a||u==b||v==a||v==b)break;\n                                                    var sx:Float=0.0;\n                                                    var sy:Float=0.0;\n                                                    {\n                                                        sx=u.x-a.x;\n                                                        sy=u.y-a.y;\n                                                    };\n                                                    var vx:Float=0.0;\n                                                    var vy:Float=0.0;\n                                                    {\n                                                        vx=v.x-u.x;\n                                                        vy=v.y-u.y;\n                                                    };\n                                                    var qx:Float=0.0;\n                                                    var qy:Float=0.0;\n                                                    {\n                                                        qx=b.x-a.x;\n                                                        qy=b.y-a.y;\n                                                    };\n                                                    var den=(vy*qx-vx*qy);\n                                                    if(den*den>Config.epsilon){\n                                                        den=1/den;\n                                                        var t=(qy*sx-qx*sy)*den;\n                                                        if(t>Config.epsilon&&t<1-Config.epsilon){\n                                                            var s=(vy*sx-vx*sy)*den;\n                                                            if(s>Config.epsilon&&s<1-Config.epsilon){\n                                                                cont=false;\n                                                                break;\n                                                            }\n                                                        }\n                                                    }\n                                                };\n                                            }\n                                            while(false);\n                                        }\n                                    };\n                                };\n                                {\n                                    u=v;\n                                    cx_ite=cx_ite.next;\n                                };\n                            }\n                            if(cx_cont){\n                                do{\n                                    var v=lverts.front();\n                                    {\n                                        if(!cont)break;\n                                        {\n                                            var cx_cont=true;\n                                            var cx_ite=lverts.begin();\n                                            var a=cx_ite.elem();\n                                            cx_ite=cx_ite.next;\n                                            while(cx_ite!=null){\n                                                var b=cx_ite.elem();\n                                                {\n                                                    if(u==a||u==b||v==a||v==b){\n                                                        {\n                                                            a=b;\n                                                            cx_ite=cx_ite.next;\n                                                        };\n                                                        continue;\n                                                    };\n                                                    var sx:Float=0.0;\n                                                    var sy:Float=0.0;\n                                                    {\n                                                        sx=u.x-a.x;\n                                                        sy=u.y-a.y;\n                                                    };\n                                                    var vx:Float=0.0;\n                                                    var vy:Float=0.0;\n                                                    {\n                                                        vx=v.x-u.x;\n                                                        vy=v.y-u.y;\n                                                    };\n                                                    var qx:Float=0.0;\n                                                    var qy:Float=0.0;\n                                                    {\n                                                        qx=b.x-a.x;\n                                                        qy=b.y-a.y;\n                                                    };\n                                                    var den=(vy*qx-vx*qy);\n                                                    if(den*den>Config.epsilon){\n                                                        den=1/den;\n                                                        var t=(qy*sx-qx*sy)*den;\n                                                        if(t>Config.epsilon&&t<1-Config.epsilon){\n                                                            var s=(vy*sx-vx*sy)*den;\n                                                            if(s>Config.epsilon&&s<1-Config.epsilon){\n                                                                cont=false;\n                                                                {\n                                                                    cx_cont=false;\n                                                                    break;\n                                                                };\n                                                            }\n                                                        }\n                                                    }\n                                                };\n                                                {\n                                                    a=b;\n                                                    cx_ite=cx_ite.next;\n                                                };\n                                            }\n                                            if(cx_cont){\n                                                do{\n                                                    var b=lverts.front();\n                                                    {\n                                                        if(u==a||u==b||v==a||v==b)break;\n                                                        var sx:Float=0.0;\n                                                        var sy:Float=0.0;\n                                                        {\n                                                            sx=u.x-a.x;\n                                                            sy=u.y-a.y;\n                                                        };\n                                                        var vx:Float=0.0;\n                                                        var vy:Float=0.0;\n                                                        {\n                                                            vx=v.x-u.x;\n                                                            vy=v.y-u.y;\n                                                        };\n                                                        var qx:Float=0.0;\n                                                        var qy:Float=0.0;\n                                                        {\n                                                            qx=b.x-a.x;\n                                                            qy=b.y-a.y;\n                                                        };\n                                                        var den=(vy*qx-vx*qy);\n                                                        if(den*den>Config.epsilon){\n                                                            den=1/den;\n                                                            var t=(qy*sx-qx*sy)*den;\n                                                            if(t>Config.epsilon&&t<1-Config.epsilon){\n                                                                var s=(vy*sx-vx*sy)*den;\n                                                                if(s>Config.epsilon&&s<1-Config.epsilon){\n                                                                    cont=false;\n                                                                    break;\n                                                                }\n                                                            }\n                                                        }\n                                                    };\n                                                }\n                                                while(false);\n                                            }\n                                        };\n                                    };\n                                }\n                                while(false);\n                            }\n                        };\n                        if(!cont)return validation=ValidationResult.SELF_INTERSECTING;\n                        else return validation=ValidationResult.VALID;\n                    }\n                }\n            }\n        }\n        else return validation;\n    }\n    public function validate_lverts(){\n        if(zip_lverts){\n            zip_lverts=false;\n            if(lverts.size()>2){\n                validate_area_inertia();\n                if(area<0){\n                    reverse_vertices();\n                    area=-area;\n                }\n            }\n        }\n    }\n    public function cleanup_lvert(x:ZPP_Vec2){\n        var ite:ZPP_Vec2=null;\n        var ite2:ZNPNode_ZPP_Edge=null;\n        {\n            var cx_ite=lverts.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                {\n                    if(i==x)break;\n                    else{\n                        ite=ite==null?gverts.begin():ite.next;\n                        ite2=ite2==null?edges.begin():ite2.next;\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        var rem=(ite==null?gverts.front():ite.next.elem());\n        gverts.erase(ite);\n        {\n            var o=rem;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"rem\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        if(edgeCnt==2){\n            var rem=edges.pop_unsafe();\n            {\n                var o=rem;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Edge\"+\", in obj: \"+\"rem\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_Edge.zpp_pool;\n                ZPP_Edge.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_Edge.POOL_CNT++;\n                ZPP_Edge.POOL_SUB++;\n                #end\n            };\n            rem=edges.pop_unsafe();\n            {\n                var o=rem;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Edge\"+\", in obj: \"+\"rem\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_Edge.zpp_pool;\n                ZPP_Edge.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_Edge.POOL_CNT++;\n                ZPP_Edge.POOL_SUB++;\n                #end\n            };\n            edgeCnt=0;\n        }\n        else if(edgeCnt!=0){\n            var rem=(ite2==null?edges.front():ite2.next.elem());\n            edges.erase(ite2);\n            {\n                var o=rem;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Edge\"+\", in obj: \"+\"rem\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_Edge.zpp_pool;\n                ZPP_Edge.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_Edge.POOL_CNT++;\n                ZPP_Edge.POOL_SUB++;\n                #end\n            };\n            edgeCnt--;\n        }\n    }\n    public var zip_sanitation:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function splice_collinear(){\n        if(zip_sanitation){\n            zip_sanitation=false;\n            splice_collinear_real();\n        }\n    }\n    public function splice_collinear_real(){\n        if(lverts.begin()==null)return;\n        if(lverts.begin().next==null)return;\n        if(lverts.begin().next.next==null)return;\n        var pre=null;\n        var cur=lverts.begin();\n        while(cur!=null){\n            var nxt=if(cur.next==null)lverts.begin()else cur.next;\n            var u=cur.elem();\n            var v=nxt.elem();\n            if(ZPP_VecMath.vec_dsq(u.x,u.y,v.x,v.y)<Config.epsilon*Config.epsilon){\n                cleanup_lvert(cur.elem());\n                cur=lverts.erase(pre);\n            }\n            else{\n                pre=cur;\n                cur=cur.next;\n            }\n        }\n        if(lverts.empty())return;\n        var removed;\n        do{\n            removed=false;\n            var pre=lverts.begin();\n            while(pre!=null){\n                var cur=if(pre.next==null)lverts.begin()else pre.next;\n                var nxt=if(cur.next==null)lverts.begin()else cur.next;\n                var u=pre.elem();\n                var v=cur.elem();\n                var w=nxt.elem();\n                var ax:Float=0.0;\n                var ay:Float=0.0;\n                {\n                    ax=v.x-u.x;\n                    ay=v.y-u.y;\n                };\n                var bx:Float=0.0;\n                var by:Float=0.0;\n                {\n                    bx=w.x-v.x;\n                    by=w.y-v.y;\n                };\n                var crs=(by*ax-bx*ay);\n                if(crs*crs>=Config.epsilon*Config.epsilon){\n                    pre=pre.next;\n                }\n                else{\n                    cleanup_lvert(cur.elem());\n                    lverts.erase(pre.next==null?null:pre);\n                    removed=true;\n                    pre=pre.next;\n                }\n            }\n        }\n        while(removed);\n    }\n    public function reverse_vertices(){\n        lverts.reverse();\n        gverts.reverse();\n        edges.reverse();\n        var ite=edges.iterator_at(edgeCnt-1);\n        var elem=edges.pop_unsafe();\n        edges.insert(ite,elem);\n        reverse_flag=!reverse_flag;\n        if(wrap_lverts!=null)wrap_lverts.zpp_inner.reverse_flag=reverse_flag;\n        if(wrap_gverts!=null)wrap_gverts.zpp_inner.reverse_flag=reverse_flag;\n        if(wrap_edges!=null)wrap_edges.zpp_inner.reverse_flag=reverse_flag;\n    }\n    public function validate_laxi(){\n        if(zip_laxi){\n            zip_laxi=false;\n            validate_lverts();\n            var ite=edges.begin();\n            {\n                var cx_ite=lverts.begin();\n                var u=cx_ite.elem();\n                cx_ite=cx_ite.next;\n                while(cx_ite!=null){\n                    var v=cx_ite.elem();\n                    {\n                        var edge=ite.elem();\n                        ite=ite.next;\n                        edge.lp0=u;\n                        edge.lp1=v;\n                        var dx:Float=0.0;\n                        var dy:Float=0.0;\n                        {\n                            dx=u.x-v.x;\n                            dy=u.y-v.y;\n                        };\n                        var l=Math.sqrt((dx*dx+dy*dy));\n                        edge.length=l;\n                        {\n                            var t=(1.0/(l));\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"d\"+\",in s: \"+\"1.0/(l)\"+\")\");\n                                #end\n                            };\n                            dx*=t;\n                            dy*=t;\n                        };\n                        {\n                            var t=dx;\n                            dx=-dy;\n                            dy=t;\n                        };\n                        edge.lprojection=(dx*u.x+dy*u.y);\n                        {\n                            edge.lnormx=dx;\n                            edge.lnormy=dy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((edge.lnormx!=edge.lnormx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(edge.lnormx)\"+\") :: \"+(\"vec_set(in n: \"+\"edge.lnorm\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((edge.lnormy!=edge.lnormy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(edge.lnormy)\"+\") :: \"+(\"vec_set(in n: \"+\"edge.lnorm\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                                #end\n                            };\n                        };\n                        if(edge.wrap_lnorm!=null){\n                            edge.wrap_lnorm.zpp_inner.x=dx;\n                            edge.wrap_lnorm.zpp_inner.y=dy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((edge.wrap_lnorm.zpp_inner.x!=edge.wrap_lnorm.zpp_inner.x));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(edge.wrap_lnorm.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"edge.wrap_lnorm.zpp_inner.\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((edge.wrap_lnorm.zpp_inner.y!=edge.wrap_lnorm.zpp_inner.y));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(edge.wrap_lnorm.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"edge.wrap_lnorm.zpp_inner.\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                                #end\n                            };\n                        };\n                    };\n                    u=v;\n                    cx_ite=cx_ite.next;\n                }\n                var v=lverts.front();\n                {\n                    var edge=ite.elem();\n                    ite=ite.next;\n                    edge.lp0=u;\n                    edge.lp1=v;\n                    var dx:Float=0.0;\n                    var dy:Float=0.0;\n                    {\n                        dx=u.x-v.x;\n                        dy=u.y-v.y;\n                    };\n                    var l=Math.sqrt((dx*dx+dy*dy));\n                    edge.length=l;\n                    {\n                        var t=(1.0/(l));\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((t!=t));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"d\"+\",in s: \"+\"1.0/(l)\"+\")\");\n                            #end\n                        };\n                        dx*=t;\n                        dy*=t;\n                    };\n                    {\n                        var t=dx;\n                        dx=-dy;\n                        dy=t;\n                    };\n                    edge.lprojection=(dx*u.x+dy*u.y);\n                    {\n                        edge.lnormx=dx;\n                        edge.lnormy=dy;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((edge.lnormx!=edge.lnormx));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(edge.lnormx)\"+\") :: \"+(\"vec_set(in n: \"+\"edge.lnorm\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((edge.lnormy!=edge.lnormy));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(edge.lnormy)\"+\") :: \"+(\"vec_set(in n: \"+\"edge.lnorm\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                            #end\n                        };\n                    };\n                    if(edge.wrap_lnorm!=null){\n                        edge.wrap_lnorm.zpp_inner.x=dx;\n                        edge.wrap_lnorm.zpp_inner.y=dy;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((edge.wrap_lnorm.zpp_inner.x!=edge.wrap_lnorm.zpp_inner.x));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(edge.wrap_lnorm.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"edge.wrap_lnorm.zpp_inner.\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((edge.wrap_lnorm.zpp_inner.y!=edge.wrap_lnorm.zpp_inner.y));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(edge.wrap_lnorm.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"edge.wrap_lnorm.zpp_inner.\"+\",in x: \"+\"dx\"+\",in y: \"+\"dy\"+\")\");\n                            #end\n                        };\n                    };\n                };\n            };\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_gverts(){\n        if(zip_gverts){\n            if(body!=null){\n                zip_gverts=false;\n                validate_lverts();\n                body.validate_axis();\n                var li=lverts.begin();\n                {\n                    var cx_ite=gverts.begin();\n                    while(cx_ite!=null){\n                        var g=cx_ite.elem();\n                        {\n                            var l=li.elem();\n                            li=li.next;\n                            {\n                                g.x=body.posx+(body.axisy*l.x-body.axisx*l.y);\n                                g.y=body.posy+(l.x*body.axisx+l.y*body.axisy);\n                            };\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        }\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate_gaxi(){\n        if(zip_gaxi){\n            if(body!=null){\n                zip_gaxi=false;\n                validate_laxi();\n                body.validate_axis();\n                validate_gverts();\n                var ite=edges.begin();\n                {\n                    var cx_ite=gverts.begin();\n                    var u=cx_ite.elem();\n                    cx_ite=cx_ite.next;\n                    while(cx_ite!=null){\n                        var v=cx_ite.elem();\n                        {\n                            var e=ite.elem();\n                            ite=ite.next;\n                            e.gp0=u;\n                            e.gp1=v;\n                            {\n                                e.gnormx=(body.axisy*e.lnormx-body.axisx*e.lnormy);\n                                e.gnormy=(e.lnormx*body.axisx+e.lnormy*body.axisy);\n                            };\n                            e.gprojection=(body.posx*e.gnormx+body.posy*e.gnormy)+e.lprojection;\n                            if(e.wrap_gnorm!=null){\n                                e.wrap_gnorm.zpp_inner.x=e.gnormx;\n                                e.wrap_gnorm.zpp_inner.y=e.gnormy;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((e.wrap_gnorm.zpp_inner.x!=e.wrap_gnorm.zpp_inner.x));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(e.wrap_gnorm.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"e.wrap_gnorm.zpp_inner.\"+\",in x: \"+\"e.gnormx\"+\",in y: \"+\"e.gnormy\"+\")\");\n                                    #end\n                                };\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((e.wrap_gnorm.zpp_inner.y!=e.wrap_gnorm.zpp_inner.y));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(e.wrap_gnorm.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"e.wrap_gnorm.zpp_inner.\"+\",in x: \"+\"e.gnormx\"+\",in y: \"+\"e.gnormy\"+\")\");\n                                    #end\n                                };\n                            };\n                            e.tp0=(e.gp0.y*e.gnormx-e.gp0.x*e.gnormy);\n                            e.tp1=(e.gp1.y*e.gnormx-e.gp1.x*e.gnormy);\n                        };\n                        u=v;\n                        cx_ite=cx_ite.next;\n                    }\n                    var v=gverts.front();\n                    {\n                        var e=ite.elem();\n                        ite=ite.next;\n                        e.gp0=u;\n                        e.gp1=v;\n                        {\n                            e.gnormx=(body.axisy*e.lnormx-body.axisx*e.lnormy);\n                            e.gnormy=(e.lnormx*body.axisx+e.lnormy*body.axisy);\n                        };\n                        e.gprojection=(body.posx*e.gnormx+body.posy*e.gnormy)+e.lprojection;\n                        if(e.wrap_gnorm!=null){\n                            e.wrap_gnorm.zpp_inner.x=e.gnormx;\n                            e.wrap_gnorm.zpp_inner.y=e.gnormy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((e.wrap_gnorm.zpp_inner.x!=e.wrap_gnorm.zpp_inner.x));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(e.wrap_gnorm.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"e.wrap_gnorm.zpp_inner.\"+\",in x: \"+\"e.gnormx\"+\",in y: \"+\"e.gnormy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((e.wrap_gnorm.zpp_inner.y!=e.wrap_gnorm.zpp_inner.y));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(e.wrap_gnorm.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"e.wrap_gnorm.zpp_inner.\"+\",in x: \"+\"e.gnormx\"+\",in y: \"+\"e.gnormy\"+\")\");\n                                #end\n                            };\n                        };\n                        e.tp0=(e.gp0.y*e.gnormx-e.gp0.x*e.gnormy);\n                        e.tp1=(e.gp1.y*e.gnormx-e.gp1.x*e.gnormy);\n                    };\n                };\n            }\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function __validate_aabb(){\n        validate_gverts();\n        #if(!NAPE_RELEASE_BUILD)\n        if(lverts.empty())throw \"Error: An empty polygon has no meaningful bounds\";\n        #end\n        var p0=gverts.front();\n        {\n            aabb.minx=p0.x;\n            aabb.miny=p0.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((aabb.minx!=aabb.minx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.minx)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.min\"+\",in x: \"+\"p0.x\"+\",in y: \"+\"p0.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((aabb.miny!=aabb.miny));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.miny)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.min\"+\",in x: \"+\"p0.x\"+\",in y: \"+\"p0.y\"+\")\");\n                #end\n            };\n        };\n        {\n            aabb.maxx=p0.x;\n            aabb.maxy=p0.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((aabb.maxx!=aabb.maxx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.maxx)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.max\"+\",in x: \"+\"p0.x\"+\",in y: \"+\"p0.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((aabb.maxy!=aabb.maxy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.maxy)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.max\"+\",in x: \"+\"p0.x\"+\",in y: \"+\"p0.y\"+\")\");\n                #end\n            };\n        };\n        {\n            var cx_ite=gverts.begin().next;\n            while(cx_ite!=null){\n                var p=cx_ite.elem();\n                {\n                    if(p.x<aabb.minx)aabb.minx=p.x;\n                    if(p.x>aabb.maxx)aabb.maxx=p.x;\n                    if(p.y<aabb.miny)aabb.miny=p.y;\n                    if(p.y>aabb.maxy)aabb.maxy=p.y;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function _force_validate_aabb(){\n        var li=lverts.begin();\n        var p0=gverts.front();\n        var l=li.elem();\n        li=li.next;\n        {\n            p0.x=body.posx+(body.axisy*l.x-body.axisx*l.y);\n            p0.y=body.posy+(l.x*body.axisx+l.y*body.axisy);\n        };\n        {\n            aabb.minx=p0.x;\n            aabb.miny=p0.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((aabb.minx!=aabb.minx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.minx)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.min\"+\",in x: \"+\"p0.x\"+\",in y: \"+\"p0.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((aabb.miny!=aabb.miny));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.miny)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.min\"+\",in x: \"+\"p0.x\"+\",in y: \"+\"p0.y\"+\")\");\n                #end\n            };\n        };\n        {\n            aabb.maxx=p0.x;\n            aabb.maxy=p0.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((aabb.maxx!=aabb.maxx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.maxx)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.max\"+\",in x: \"+\"p0.x\"+\",in y: \"+\"p0.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((aabb.maxy!=aabb.maxy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(aabb.maxy)\"+\") :: \"+(\"vec_set(in n: \"+\"aabb.max\"+\",in x: \"+\"p0.x\"+\",in y: \"+\"p0.y\"+\")\");\n                #end\n            };\n        };\n        {\n            var cx_ite=gverts.begin().next;\n            while(cx_ite!=null){\n                var p=cx_ite.elem();\n                {\n                    var l=li.elem();\n                    li=li.next;\n                    {\n                        p.x=body.posx+(body.axisy*l.x-body.axisx*l.y);\n                        p.y=body.posy+(l.x*body.axisx+l.y*body.axisy);\n                    };\n                    if(p.x<aabb.minx)aabb.minx=p.x;\n                    if(p.x>aabb.maxx)aabb.maxx=p.x;\n                    if(p.y<aabb.miny)aabb.miny=p.y;\n                    if(p.y>aabb.maxy)aabb.maxy=p.y;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function __validate_sweepRadius(){\n        var maxRadius=0.0;\n        var minRadius=0.0;\n        validate_laxi();\n        {\n            var cx_ite=lverts.begin();\n            while(cx_ite!=null){\n                var x=cx_ite.elem();\n                {\n                    var r=(x.x*x.x+x.y*x.y);\n                    if(r>maxRadius){\n                        maxRadius=r;\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=edges.begin();\n            while(cx_ite!=null){\n                var e=cx_ite.elem();\n                {\n                    if(e.lprojection<minRadius){\n                        minRadius=e.lprojection;\n                        if(minRadius<0)break;\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(minRadius<0)minRadius=0;\n        sweepRadius=Math.sqrt(maxRadius);\n        sweepCoef=sweepRadius-minRadius;\n    }\n    public function __validate_area_inertia(){\n        if(lverts.begin()==null||lverts.begin().next==null||lverts.begin().next.next==null){\n            area=0;\n            inertia=0;\n        }\n        else{\n            area=0.0;\n            var s1=0.0;\n            var s2=0.0;\n            {\n                var cx_ite=lverts.begin();\n                var u=cx_ite.elem();\n                cx_ite=cx_ite.next;\n                var v=cx_ite.elem();\n                cx_ite=cx_ite.next;\n                while(cx_ite!=null){\n                    var w=cx_ite.elem();\n                    {\n                        var a=(v.y*u.x-v.x*u.y);\n                        var b=(v.x*v.x+v.y*v.y)+(v.x*u.x+v.y*u.y)+(u.x*u.x+u.y*u.y);\n                        s1+=a*b;\n                        s2+=a;\n                        area+=v.x*(w.y-u.y);\n                    };\n                    u=v;\n                    v=w;\n                    cx_ite=cx_ite.next;\n                }\n                cx_ite=lverts.begin();\n                var w=cx_ite.elem();\n                {\n                    var a=(v.y*u.x-v.x*u.y);\n                    var b=(v.x*v.x+v.y*v.y)+(v.x*u.x+v.y*u.y)+(u.x*u.x+u.y*u.y);\n                    s1+=a*b;\n                    s2+=a;\n                    area+=v.x*(w.y-u.y);\n                };\n                u=v;\n                v=w;\n                cx_ite=cx_ite.next;\n                var w=cx_ite.elem();\n                {\n                    var a=(v.y*u.x-v.x*u.y);\n                    var b=(v.x*v.x+v.y*v.y)+(v.x*u.x+v.y*u.y)+(u.x*u.x+u.y*u.y);\n                    s1+=a*b;\n                    s2+=a;\n                    area+=v.x*(w.y-u.y);\n                };\n            };\n            inertia=s1/(6*s2);\n            area*=0.5;\n            if(area<0){\n                area=-area;\n                reverse_vertices();\n            }\n        }\n    }\n    public function __validate_angDrag(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lverts.size()<3)throw \"Error: Polygon's with less than 3 vertices have no meaningful angDrag\";\n        #end\n        validate_area_inertia();\n        validate_laxi();\n        var accum=0.0;\n        var ei=edges.begin();\n        var perim=0.0;\n        {\n            var cx_cont=true;\n            var cx_itei=lverts.begin();\n            var u=cx_itei.elem();\n            var cx_itej=cx_itei.next;\n            while(cx_itej!=null){\n                var v=cx_itej.elem();\n                {\n                    var edge=ei.elem();\n                    ei=ei.next;\n                    perim+=edge.length;\n                    var dx:Float=0.0;\n                    var dy:Float=0.0;\n                    {\n                        dx=v.x-u.x;\n                        dy=v.y-u.y;\n                    };\n                    accum+=edge.length*Config.fluidAngularDragFriction*material.dynamicFriction*edge.lprojection*edge.lprojection;\n                    var t=-(u.y*edge.lnormx-u.x*edge.lnormy)/(dy*edge.lnormx-dx*edge.lnormy);\n                    if(t>0){\n                        var ta=if(t>1)1 else t;\n                        var cx:Float=0.0;\n                        var cy:Float=0.0;\n                        {\n                            cx=u.x;\n                            cy=u.y;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cx!=cx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cx)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"u.x\"+\",in y: \"+\"u.y\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cy!=cy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cy)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"u.x\"+\",in y: \"+\"u.y\"+\")\");\n                                #end\n                            };\n                        };\n                        {\n                            var t=(ta);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c\"+\",in b: \"+\"d\"+\",in s: \"+\"ta\"+\")\");\n                                #end\n                            };\n                            cx+=dx*t;\n                            cy+=dy*t;\n                        };\n                        var dota=(edge.lnormy*u.x-edge.lnormx*u.y);\n                        var dotb=(edge.lnormy*cx-edge.lnormx*cy);\n                        var dots=(dotb*dotb*dotb-dota*dota*dota)/(3*(dotb-dota));\n                        accum+=dots*ta*edge.length*Config.fluidAngularDrag;\n                    }\n                    if(t<1){\n                        var tb=if(t<0)0 else t;\n                        var cx:Float=0.0;\n                        var cy:Float=0.0;\n                        {\n                            cx=u.x;\n                            cy=u.y;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cx!=cx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cx)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"u.x\"+\",in y: \"+\"u.y\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cy!=cy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cy)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"u.x\"+\",in y: \"+\"u.y\"+\")\");\n                                #end\n                            };\n                        };\n                        {\n                            var t=(tb);\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((t!=t));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c\"+\",in b: \"+\"d\"+\",in s: \"+\"tb\"+\")\");\n                                #end\n                            };\n                            cx+=dx*t;\n                            cy+=dy*t;\n                        };\n                        var dota=(edge.lnormy*cx-edge.lnormx*cy);\n                        var dotb=(edge.lnormy*v.x-edge.lnormx*v.y);\n                        var dots=(dotb*dotb*dotb-dota*dota*dota)/(3*(dotb-dota));\n                        accum+=dots*Config.fluidVacuumDrag*(1-tb)*edge.length*Config.fluidAngularDrag;\n                    }\n                };\n                {\n                    cx_itei=cx_itej;\n                    u=v;\n                    cx_itej=cx_itej.next;\n                };\n            }\n            if(cx_cont){\n                do{\n                    cx_itej=lverts.begin();\n                    var v=cx_itej.elem();\n                    {\n                        var edge=ei.elem();\n                        ei=ei.next;\n                        perim+=edge.length;\n                        var dx:Float=0.0;\n                        var dy:Float=0.0;\n                        {\n                            dx=v.x-u.x;\n                            dy=v.y-u.y;\n                        };\n                        accum+=edge.length*Config.fluidAngularDragFriction*material.dynamicFriction*edge.lprojection*edge.lprojection;\n                        var t=-(u.y*edge.lnormx-u.x*edge.lnormy)/(dy*edge.lnormx-dx*edge.lnormy);\n                        if(t>0){\n                            var ta=if(t>1)1 else t;\n                            var cx:Float=0.0;\n                            var cy:Float=0.0;\n                            {\n                                cx=u.x;\n                                cy=u.y;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((cx!=cx));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(cx)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"u.x\"+\",in y: \"+\"u.y\"+\")\");\n                                    #end\n                                };\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((cy!=cy));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(cy)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"u.x\"+\",in y: \"+\"u.y\"+\")\");\n                                    #end\n                                };\n                            };\n                            {\n                                var t=(ta);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c\"+\",in b: \"+\"d\"+\",in s: \"+\"ta\"+\")\");\n                                    #end\n                                };\n                                cx+=dx*t;\n                                cy+=dy*t;\n                            };\n                            var dota=(edge.lnormy*u.x-edge.lnormx*u.y);\n                            var dotb=(edge.lnormy*cx-edge.lnormx*cy);\n                            var dots=(dotb*dotb*dotb-dota*dota*dota)/(3*(dotb-dota));\n                            accum+=dots*ta*edge.length*Config.fluidAngularDrag;\n                        }\n                        if(t<1){\n                            var tb=if(t<0)0 else t;\n                            var cx:Float=0.0;\n                            var cy:Float=0.0;\n                            {\n                                cx=u.x;\n                                cy=u.y;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((cx!=cx));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(cx)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"u.x\"+\",in y: \"+\"u.y\"+\")\");\n                                    #end\n                                };\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((cy!=cy));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(cy)\"+\") :: \"+(\"vec_set(in n: \"+\"c\"+\",in x: \"+\"u.x\"+\",in y: \"+\"u.y\"+\")\");\n                                    #end\n                                };\n                            };\n                            {\n                                var t=(tb);\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !((t!=t));\n                                    };\n                                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"c\"+\",in b: \"+\"d\"+\",in s: \"+\"tb\"+\")\");\n                                    #end\n                                };\n                                cx+=dx*t;\n                                cy+=dy*t;\n                            };\n                            var dota=(edge.lnormy*cx-edge.lnormx*cy);\n                            var dotb=(edge.lnormy*v.x-edge.lnormx*v.y);\n                            var dots=(dotb*dotb*dotb-dota*dota*dota)/(3*(dotb-dota));\n                            accum+=dots*Config.fluidVacuumDrag*(1-tb)*edge.length*Config.fluidAngularDrag;\n                        }\n                    };\n                }\n                while(false);\n            }\n        };\n        angDrag=accum/(inertia*perim);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function __validate_localCOM(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lverts.empty())throw \"Error: An empty polygon has no meaningful localCOM\";\n        #end\n        if(lverts.begin().next==null){\n            localCOMx=lverts.front().x;\n            localCOMy=lverts.front().y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((localCOMx!=localCOMx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"lverts.front().x\"+\",in y: \"+\"lverts.front().y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((localCOMy!=localCOMy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"lverts.front().x\"+\",in y: \"+\"lverts.front().y\"+\")\");\n                #end\n            };\n        };\n        else if(lverts.begin().next.next==null){\n            {\n                localCOMx=lverts.front().x;\n                localCOMy=lverts.front().y;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((localCOMx!=localCOMx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"lverts.front().x\"+\",in y: \"+\"lverts.front().y\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((localCOMy!=localCOMy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"lverts.front().x\"+\",in y: \"+\"lverts.front().y\"+\")\");\n                    #end\n                };\n            };\n            {\n                var t=(1.0);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"localCOM\"+\",in b: \"+\"lverts.begin().next.elem().\"+\",in s: \"+\"1.0\"+\")\");\n                    #end\n                };\n                localCOMx+=lverts.begin().next.elem().x*t;\n                localCOMy+=lverts.begin().next.elem().y*t;\n            };\n            {\n                var t=(0.5);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"localCOM\"+\",in s: \"+\"0.5\"+\")\");\n                    #end\n                };\n                localCOMx*=t;\n                localCOMy*=t;\n            };\n        }\n        else{\n            {\n                localCOMx=0;\n                localCOMy=0;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((localCOMx!=localCOMx));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMx)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((localCOMy!=localCOMy));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(localCOMy)\"+\") :: \"+(\"vec_set(in n: \"+\"localCOM\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                    #end\n                };\n            };\n            var area=0.0;\n            {\n                var cx_ite=lverts.begin();\n                var u=cx_ite.elem();\n                cx_ite=cx_ite.next;\n                var v=cx_ite.elem();\n                cx_ite=cx_ite.next;\n                while(cx_ite!=null){\n                    var w=cx_ite.elem();\n                    {\n                        area+=v.x*(w.y-u.y);\n                        var cf=(w.y*v.x-w.x*v.y);\n                        localCOMx+=(v.x+w.x)*cf;\n                        localCOMy+=(v.y+w.y)*cf;\n                    };\n                    u=v;\n                    v=w;\n                    cx_ite=cx_ite.next;\n                }\n                cx_ite=lverts.begin();\n                var w=cx_ite.elem();\n                {\n                    area+=v.x*(w.y-u.y);\n                    var cf=(w.y*v.x-w.x*v.y);\n                    localCOMx+=(v.x+w.x)*cf;\n                    localCOMy+=(v.y+w.y)*cf;\n                };\n                u=v;\n                v=w;\n                cx_ite=cx_ite.next;\n                var w=cx_ite.elem();\n                {\n                    area+=v.x*(w.y-u.y);\n                    var cf=(w.y*v.x-w.x*v.y);\n                    localCOMx+=(v.x+w.x)*cf;\n                    localCOMy+=(v.y+w.y)*cf;\n                };\n            };\n            area=1/(3*area);\n            {\n                var t=(area);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !((t!=t));\n                    };\n                    if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_muleq(in a: \"+\"localCOM\"+\",in s: \"+\"area\"+\")\");\n                    #end\n                };\n                localCOMx*=t;\n                localCOMy*=t;\n            };\n        }\n    }\n    private function localCOM_validate(){\n        #if(!NAPE_RELEASE_BUILD)\n        if(lverts.empty())throw \"Error: An empty polygon does not have any meaningful localCOM\";\n        #end\n        validate_localCOM();\n    }\n    private function localCOM_invalidate(x:ZPP_Vec2){\n        validate_localCOM();\n        var delx:Float=0;\n        var dely:Float=0;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((delx!=delx));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(delx)\"+\") :: \"+(\"vec_new(in n: \"+\"del\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((dely!=dely));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(dely)\"+\") :: \"+(\"vec_new(in n: \"+\"del\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n            #end\n        };\n        {\n            delx=x.x-localCOMx;\n            dely=x.y-localCOMy;\n        };\n        {\n            var cx_ite=lverts.begin();\n            while(cx_ite!=null){\n                var p=cx_ite.elem();\n                {\n                    var t=(1.0);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"p.\"+\",in b: \"+\"del\"+\",in s: \"+\"1.0\"+\")\");\n                        #end\n                    };\n                    p.x+=delx*t;\n                    p.y+=dely*t;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        invalidate_lverts();\n    }\n    public function setupLocalCOM(){\n        wrap_localCOM=Vec2.get(localCOMx,localCOMy);\n        wrap_localCOM.zpp_inner._inuse=true;\n        wrap_localCOM.zpp_inner._validate=localCOM_validate;\n        wrap_localCOM.zpp_inner._invalidate=localCOM_invalidate;\n    }\n    public function new(){\n        super(ZPP_Flags.id_ShapeType_POLYGON);\n        polygon=this;\n        lverts=new ZPP_Vec2();\n        gverts=new ZPP_Vec2();\n        edges=new ZNPList_ZPP_Edge();\n        edgeCnt=0;\n    }\n    public function __translate(dx:Float,dy:Float){\n        {\n            var cx_ite=lverts.begin();\n            while(cx_ite!=null){\n                var p=cx_ite.elem();\n                {\n                    var t=(1.0);\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !((t!=t));\n                        };\n                        if(!res)throw \"assert(\"+\"!assert_isNaN(t)\"+\") :: \"+(\"vec_addeq(in a: \"+\"p.\"+\",in b: \"+\"d\"+\",in s: \"+\"1.0\"+\")\");\n                        #end\n                    };\n                    p.x+=dx*t;\n                    p.y+=dy*t;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        invalidate_lverts();\n    }\n    public function __scale(sx:Float,sy:Float){\n        {\n            var cx_ite=lverts.begin();\n            while(cx_ite!=null){\n                var p=cx_ite.elem();\n                {\n                    p.x*=sx;\n                    p.y*=sy;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        invalidate_lverts();\n    }\n    public function __rotate(ax:Float,ay:Float){\n        {\n            var cx_ite=lverts.begin();\n            while(cx_ite!=null){\n                var p=cx_ite.elem();\n                {\n                    var tempx:Float=0.0;\n                    var tempy:Float=0.0;\n                    {\n                        tempx=(ay*p.x-ax*p.y);\n                        tempy=(p.x*ax+p.y*ay);\n                    };\n                    {\n                        p.x=tempx;\n                        p.y=tempy;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((p.x!=p.x));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(p.x)\"+\") :: \"+(\"vec_set(in n: \"+\"p.\"+\",in x: \"+\"tempx\"+\",in y: \"+\"tempy\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((p.y!=p.y));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(p.y)\"+\") :: \"+(\"vec_set(in n: \"+\"p.\"+\",in x: \"+\"tempx\"+\",in y: \"+\"tempy\"+\")\");\n                            #end\n                        };\n                    };\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        invalidate_lverts();\n    }\n    public function __transform(mat:Mat23){\n        {\n            var cx_ite=lverts.begin();\n            while(cx_ite!=null){\n                var p=cx_ite.elem();\n                {\n                    {\n                        var t=mat.a*p.x+mat.b*p.y+mat.tx;\n                        p.y=mat.c*p.x+mat.d*p.y+mat.ty;\n                        p.x=t;\n                    };\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        invalidate_lverts();\n    }\n    public function __copy(){\n        var ret=new Polygon(outer_zn.localVerts).zpp_inner_zn;\n        return ret;\n    }\n}\n","package zpp_nape.space;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Broadphase{\n    public var space:ZPP_Space=null;\n    public var is_sweep:Bool=false;\n    public var sweep:ZPP_SweepPhase=null;\n    public var dynab:ZPP_DynAABBPhase=null;\n    public function insert(shape:ZPP_Shape){\n        if(is_sweep)sweep.__insert(shape);\n        else dynab.__insert(shape);\n    }\n    public function remove(shape:ZPP_Shape){\n        if(is_sweep)sweep.__remove(shape);\n        else dynab.__remove(shape);\n    }\n    public function sync(shape:ZPP_Shape){\n        if(is_sweep)sweep.__sync(shape);\n        else dynab.__sync(shape);\n    }\n    public function broadphase(space:ZPP_Space,discrete:Bool){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                false;\n            };\n            if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"not implemented\");\n            #end\n        };\n    }\n    public function clear(){}\n    public function shapesUnderPoint(x:Float,y:Float,filter:ZPP_InteractionFilter,output:ShapeList):ShapeList{\n        return null;\n    }\n    public function bodiesUnderPoint(x:Float,y:Float,filter:ZPP_InteractionFilter,output:BodyList):BodyList{\n        return null;\n    }\n    public var aabbShape:Shape=null;\n    public var matrix:Mat23=null;\n    public function updateAABBShape(aabb:ZPP_AABB){\n        if(aabbShape==null){\n            var body=new Body(BodyType.STATIC);\n            body.shapes.add(aabbShape=new Polygon(Polygon.rect(aabb.minx,aabb.miny,aabb.width(),aabb.height())));\n        }\n        else{\n            var ab=aabbShape.zpp_inner.aabb;\n            var sx=aabb.width()/ab.width();\n            var sy=aabb.height()/ab.height();\n            if(matrix==null)matrix=new Mat23();\n            matrix.a=sx;\n            matrix.b=matrix.c=0;\n            matrix.d=sy;\n            matrix.tx=aabb.minx-sx*ab.minx;\n            matrix.ty=aabb.miny-sy*ab.miny;\n            aabbShape.transform(matrix);\n        }\n        aabbShape.zpp_inner.validate_aabb();\n        aabbShape.zpp_inner.polygon.validate_gaxi();\n    }\n    public function shapesInAABB(aabb:ZPP_AABB,strict:Bool,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList):ShapeList{\n        return null;\n    }\n    public function bodiesInAABB(aabb:ZPP_AABB,strict:Bool,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList):BodyList{\n        return null;\n    }\n    public var circShape:Shape=null;\n    public function updateCircShape(x:Float,y:Float,r:Float){\n        if(circShape==null){\n            var body=new Body(BodyType.STATIC);\n            body.shapes.add(circShape=new Circle(r,Vec2.get(x,y)));\n        }\n        else{\n            var ci=circShape.zpp_inner.circle;\n            var ss=r/ci.radius;\n            if(matrix==null)matrix=new Mat23();\n            matrix.a=matrix.d=ss;\n            matrix.b=matrix.c=0;\n            matrix.tx=x-ss*ci.localCOMx;\n            matrix.ty=y-ss*ci.localCOMy;\n            circShape.transform(matrix);\n        }\n        circShape.zpp_inner.validate_aabb();\n    }\n    public function shapesInCircle(x:Float,y:Float,r:Float,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList):ShapeList{\n        return null;\n    }\n    public function bodiesInCircle(x:Float,y:Float,r:Float,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList):BodyList{\n        return null;\n    }\n    public function validateShape(s:ZPP_Shape){\n        if(s.isPolygon())s.polygon.validate_gaxi();\n        s.validate_aabb();\n        s.validate_worldCOM();\n    }\n    public function shapesInShape(shape:ZPP_Shape,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList):ShapeList{\n        return null;\n    }\n    public function bodiesInShape(shape:ZPP_Shape,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList):BodyList{\n        return null;\n    }\n    public function rayCast(ray:ZPP_Ray,inner:Bool,filter:ZPP_InteractionFilter):RayResult{\n        return null;\n    }\n    public function rayMultiCast(ray:ZPP_Ray,inner:Bool,filter:ZPP_InteractionFilter,output:RayResultList):RayResultList{\n        return null;\n    }\n}\n","package zpp_nape.space;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_AABBNode{\n    public var aabb:ZPP_AABB=null;\n    public var shape:ZPP_Shape=null;\n    public var dyn:Bool=false;\n    public var parent:ZPP_AABBNode=null;\n    public var child1:ZPP_AABBNode=null;\n    public var child2:ZPP_AABBNode=null;\n    public var height:Int=0;\n    public var rayt:Float=0.0;\n    public function new(){\n        height=-1;\n    }\n    public var next:ZPP_AABBNode=null;\n    static public var zpp_pool:ZPP_AABBNode=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){\n        {\n            if(ZPP_AABB.zpp_pool==null){\n                aabb=new ZPP_AABB();\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_TOT++;\n                ZPP_AABB.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                aabb=ZPP_AABB.zpp_pool;\n                ZPP_AABB.zpp_pool=aabb.next;\n                aabb.next=null;\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT--;\n                ZPP_AABB.POOL_ADD++;\n                #end\n            }\n            aabb.alloc();\n        };\n        moved=false;\n        synced=false;\n        first_sync=false;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        height=-1;\n        {\n            var o=aabb;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABB\"+\", in obj: \"+\"aabb\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_AABB.zpp_pool;\n            ZPP_AABB.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT++;\n            ZPP_AABB.POOL_SUB++;\n            #end\n        };\n        child1=child2=parent=null;\n        next=null;\n        snext=null;\n        mnext=null;\n    }\n    public var mnext:ZPP_AABBNode=null;\n    public var moved:Bool=false;\n    public var snext:ZPP_AABBNode=null;\n    public var synced:Bool=false;\n    public var first_sync:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function isLeaf(){\n        return child1==null;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_AABBPair{\n    public var n1:ZPP_AABBNode=null;\n    public var n2:ZPP_AABBNode=null;\n    public var first:Bool=false;\n    public var sleeping:Bool=false;\n    public var id:Int=0;\n    public var di:Int=0;\n    public var arb:ZPP_Arbiter=null;\n    public var next:ZPP_AABBPair=null;\n    static public var zpp_pool:ZPP_AABBPair=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                arb==null;\n            };\n            if(!res)throw \"assert(\"+\"arb==null\"+\") :: \"+(\"node still has an arbiter when going into pool??\");\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                arb==null;\n            };\n            if(!res)throw \"assert(\"+\"arb==null\"+\") :: \"+(\"node still has an arbiter when going into pool??\");\n            #end\n        };\n        n1=n2=null;\n        sleeping=false;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_AABBTree{\n    public var root:ZPP_AABBNode=null;\n    public function new(){}\n    public function clear(){\n        if(root==null)return;\n        var stack:ZPP_AABBNode=null;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    root.next==null;\n                };\n                if(!res)throw \"assert(\"+\"root.next==null\"+\") :: \"+(\"object already in list\");\n                #end\n            };\n            root.next=stack;\n            stack=root;\n        };\n        while(stack!=null){\n            var node=({\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        stack!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"stack!=null\"+\") :: \"+(\"pop from empty list!\");\n                    #end\n                };\n                var ret=stack;\n                stack=ret.next;\n                ret.next=null;\n                ret;\n            });\n            if(node.isLeaf()){\n                node.shape.node=null;\n                node.shape.removedFromSpace();\n                node.shape=null;\n            }\n            else{\n                if(node.child1!=null){\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            node.child1.next==null;\n                        };\n                        if(!res)throw \"assert(\"+\"node.child1.next==null\"+\") :: \"+(\"object already in list\");\n                        #end\n                    };\n                    node.child1.next=stack;\n                    stack=node.child1;\n                };\n                if(node.child2!=null){\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            node.child2.next==null;\n                        };\n                        if(!res)throw \"assert(\"+\"node.child2.next==null\"+\") :: \"+(\"object already in list\");\n                        #end\n                    };\n                    node.child2.next=stack;\n                    stack=node.child2;\n                };\n            }\n            {\n                var o=node;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABBNode\"+\", in obj: \"+\"node\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_AABBNode.zpp_pool;\n                ZPP_AABBNode.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_AABBNode.POOL_CNT++;\n                ZPP_AABBNode.POOL_SUB++;\n                #end\n            };\n        }\n        root=null;\n    }\n    public static var tmpaabb=new ZPP_AABB();\n    function insertLeaf(leaf:ZPP_AABBNode){\n        inlined_insertLeaf(leaf);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insertLeaf(leaf:ZPP_AABBNode){\n        if(root==null){\n            root=leaf;\n            root.parent=null;\n        }\n        else{\n            var leafaabb=leaf.aabb;\n            var node=root;\n            while(!node.isLeaf()){\n                var child1=node.child1;\n                var child2=node.child2;\n                var area=node.aabb.perimeter();\n                tmpaabb.setCombine(node.aabb,leafaabb);\n                var carea=tmpaabb.perimeter();\n                var cost=2*carea;\n                var icost=2*(carea-area);\n                var cost1=({\n                    tmpaabb.setCombine(leafaabb,child1.aabb);\n                    if(child1.isLeaf())tmpaabb.perimeter()+icost;\n                    else{\n                        var oarea=child1.aabb.perimeter();\n                        var narea=tmpaabb.perimeter();\n                        (narea-oarea)+icost;\n                    }\n                });\n                var cost2=({\n                    tmpaabb.setCombine(leafaabb,child2.aabb);\n                    if(child2.isLeaf())tmpaabb.perimeter()+icost;\n                    else{\n                        var oarea=child2.aabb.perimeter();\n                        var narea=tmpaabb.perimeter();\n                        (narea-oarea)+icost;\n                    }\n                });\n                if(cost<cost1&&cost<cost2)break;\n                else node=cost1<cost2?child1:child2;\n            }\n            var sibling=node;\n            var oparent=sibling.parent;\n            var nparent;\n            {\n                if(ZPP_AABBNode.zpp_pool==null){\n                    nparent=new ZPP_AABBNode();\n                    #if NAPE_POOL_STATS ZPP_AABBNode.POOL_TOT++;\n                    ZPP_AABBNode.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    nparent=ZPP_AABBNode.zpp_pool;\n                    ZPP_AABBNode.zpp_pool=nparent.next;\n                    nparent.next=null;\n                    #if NAPE_POOL_STATS ZPP_AABBNode.POOL_CNT--;\n                    ZPP_AABBNode.POOL_ADD++;\n                    #end\n                }\n                nparent.alloc();\n            };\n            nparent.parent=oparent;\n            nparent.aabb.setCombine(leafaabb,sibling.aabb);\n            nparent.height=sibling.height+1;\n            if(oparent!=null){\n                if(oparent.child1==sibling)oparent.child1=nparent;\n                else oparent.child2=nparent;\n                nparent.child1=sibling;\n                nparent.child2=leaf;\n                sibling.parent=nparent;\n                leaf.parent=nparent;\n            }\n            else{\n                nparent.child1=sibling;\n                nparent.child2=leaf;\n                sibling.parent=nparent;\n                leaf.parent=nparent;\n                root=nparent;\n            }\n            node=leaf.parent;\n            while(node!=null){\n                node=balance(node);\n                var child1=node.child1;\n                var child2=node.child2;\n                node.height=1+({\n                    var x=child1.height;\n                    var y=child2.height;\n                    x>y?x:y;\n                });\n                node.aabb.setCombine(child1.aabb,child2.aabb);\n                node=node.parent;\n            }\n        }\n    }\n    public function removeLeaf(leaf:ZPP_AABBNode){\n        inlined_removeLeaf(leaf);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_removeLeaf(leaf:ZPP_AABBNode){\n        if(leaf==root){\n            root=null;\n            return;\n        }\n        else{\n            var parent=leaf.parent;\n            var gparent=parent.parent;\n            var sibling=if(parent.child1==leaf)parent.child2 else parent.child1;\n            if(gparent!=null){\n                if(gparent.child1==parent)gparent.child1=sibling;\n                else gparent.child2=sibling;\n                sibling.parent=gparent;\n                {\n                    var o=parent;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABBNode\"+\", in obj: \"+\"parent\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_AABBNode.zpp_pool;\n                    ZPP_AABBNode.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_AABBNode.POOL_CNT++;\n                    ZPP_AABBNode.POOL_SUB++;\n                    #end\n                };\n                var node=gparent;\n                while(node!=null){\n                    node=balance(node);\n                    var child1=node.child1;\n                    var child2=node.child2;\n                    node.aabb.setCombine(child1.aabb,child2.aabb);\n                    node.height=1+({\n                        var x=child1.height;\n                        var y=child2.height;\n                        x>y?x:y;\n                    });\n                    node=node.parent;\n                }\n            }\n            else{\n                root=sibling;\n                sibling.parent=null;\n                {\n                    var o=parent;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABBNode\"+\", in obj: \"+\"parent\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_AABBNode.zpp_pool;\n                    ZPP_AABBNode.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_AABBNode.POOL_CNT++;\n                    ZPP_AABBNode.POOL_SUB++;\n                    #end\n                };\n            }\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function balance(a:ZPP_AABBNode){\n        if(a.isLeaf()||a.height<2)return a;\n        else{\n            var b=a.child1;\n            var c=a.child2;\n            var balance=c.height-b.height;\n            if(balance>1){\n                var f=c.child1;\n                var g=c.child2;\n                c.child1=a;\n                c.parent=a.parent;\n                a.parent=c;\n                if(c.parent!=null){\n                    if(c.parent.child1==a)c.parent.child1=c;\n                    else c.parent.child2=c;\n                }\n                else root=c;\n                if(f.height>g.height){\n                    c.child2=f;\n                    a.child2=g;\n                    g.parent=a;\n                    a.aabb.setCombine(b.aabb,g.aabb);\n                    c.aabb.setCombine(a.aabb,f.aabb);\n                    a.height=1+({\n                        var x=b.height;\n                        var y=g.height;\n                        x>y?x:y;\n                    });\n                    c.height=1+({\n                        var x=a.height;\n                        var y=f.height;\n                        x>y?x:y;\n                    });\n                };\n                else{\n                    c.child2=g;\n                    a.child2=f;\n                    f.parent=a;\n                    a.aabb.setCombine(b.aabb,f.aabb);\n                    c.aabb.setCombine(a.aabb,g.aabb);\n                    a.height=1+({\n                        var x=b.height;\n                        var y=f.height;\n                        x>y?x:y;\n                    });\n                    c.height=1+({\n                        var x=a.height;\n                        var y=g.height;\n                        x>y?x:y;\n                    });\n                };\n                return c;\n            };\n            else if(balance<-1){\n                var f=b.child1;\n                var g=b.child2;\n                b.child1=a;\n                b.parent=a.parent;\n                a.parent=b;\n                if(b.parent!=null){\n                    if(b.parent.child1==a)b.parent.child1=b;\n                    else b.parent.child2=b;\n                }\n                else root=b;\n                if(f.height>g.height){\n                    b.child2=f;\n                    a.child1=g;\n                    g.parent=a;\n                    a.aabb.setCombine(c.aabb,g.aabb);\n                    b.aabb.setCombine(a.aabb,f.aabb);\n                    a.height=1+({\n                        var x=c.height;\n                        var y=g.height;\n                        x>y?x:y;\n                    });\n                    b.height=1+({\n                        var x=a.height;\n                        var y=f.height;\n                        x>y?x:y;\n                    });\n                };\n                else{\n                    b.child2=g;\n                    a.child1=f;\n                    f.parent=a;\n                    a.aabb.setCombine(c.aabb,f.aabb);\n                    b.aabb.setCombine(a.aabb,g.aabb);\n                    a.height=1+({\n                        var x=c.height;\n                        var y=f.height;\n                        x>y?x:y;\n                    });\n                    b.height=1+({\n                        var x=a.height;\n                        var y=g.height;\n                        x>y?x:y;\n                    });\n                };\n                return b;\n            };\n            else return a;\n        }\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_DynAABBPhase extends ZPP_Broadphase{\n    #if NAPE_NO_INLINE#else inline #end\n    static var FATTEN=3.0;\n    #if NAPE_NO_INLINE#else inline #end\n    static var VEL_STEPS=2.0;\n    public var stree:ZPP_AABBTree=null;\n    public var dtree:ZPP_AABBTree=null;\n    public var pairs:ZPP_AABBPair=null;\n    public var syncs:ZPP_AABBNode=null;\n    public var moves:ZPP_AABBNode=null;\n    public function new(space:ZPP_Space){\n        this.space=space;\n        is_sweep=false;\n        dynab=this;\n        stree=new ZPP_AABBTree();\n        dtree=new ZPP_AABBTree();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function dyn(shape:ZPP_Shape){\n        if(shape.body.isStatic())return false;\n        else return!shape.body.component.sleeping;\n    }\n    public function __insert(shape:ZPP_Shape){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                shape.node==null;\n            };\n            if(!res)throw \"assert(\"+\"shape.node==null\"+\") :: \"+(\"shape has been inserted already\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                shape.body!=null;\n            };\n            if(!res)throw \"assert(\"+\"shape.body!=null\"+\") :: \"+(\"shape inserted with no body\");\n            #end\n        };\n        var node;\n        {\n            if(ZPP_AABBNode.zpp_pool==null){\n                node=new ZPP_AABBNode();\n                #if NAPE_POOL_STATS ZPP_AABBNode.POOL_TOT++;\n                ZPP_AABBNode.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                node=ZPP_AABBNode.zpp_pool;\n                ZPP_AABBNode.zpp_pool=node.next;\n                node.next=null;\n                #if NAPE_POOL_STATS ZPP_AABBNode.POOL_CNT--;\n                ZPP_AABBNode.POOL_ADD++;\n                #end\n            }\n            node.alloc();\n        };\n        node.shape=shape;\n        shape.node=node;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !node.synced;\n            };\n            if(!res)throw \"assert(\"+\"!node.synced\"+\") :: \"+(\"node is already in sync list?\");\n            #end\n        };\n        node.synced=true;\n        node.first_sync=true;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    node.snext==null;\n                };\n                if(!res)throw \"assert(\"+\"node.snext==null\"+\") :: \"+(\"object already in list\");\n                #end\n            };\n            node.snext=syncs;\n            syncs=node;\n        };\n    }\n    public function __remove(shape:ZPP_Shape){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                shape.body!=null;\n            };\n            if(!res)throw \"assert(\"+\"shape.body!=null\"+\") :: \"+(\"do i need this assertion?\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                shape.node!=null;\n            };\n            if(!res)throw \"assert(\"+\"shape.node!=null\"+\") :: \"+(\"shape has no node?\");\n            #end\n        };\n        var node=shape.node;\n        if(!node.first_sync){\n            if(node.dyn)dtree.removeLeaf(node);\n            else stree.removeLeaf(node);\n        }\n        shape.node=null;\n        if(node.synced){\n            {\n                var pre=null;\n                var cur=syncs;\n                while(cur!=null){\n                    if(cur==node)break;\n                    pre=cur;\n                    cur=cur.snext;\n                }\n                {\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            cur!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"cur = null\");\n                        #end\n                    };\n                    if(pre==null)syncs=cur.snext;\n                    else pre.snext=cur.snext;\n                    cur.snext=null;\n                };\n            };\n            node.synced=false;\n        }\n        if(node.moved){\n            {\n                var pre=null;\n                var cur=moves;\n                while(cur!=null){\n                    if(cur==node)break;\n                    pre=cur;\n                    cur=cur.mnext;\n                }\n                {\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            cur!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"cur = null\");\n                        #end\n                    };\n                    if(pre==null)moves=cur.mnext;\n                    else pre.mnext=cur.mnext;\n                    cur.mnext=null;\n                };\n            };\n            node.moved=false;\n        }\n        var pre=null;\n        var cur=pairs;\n        while(cur!=null){\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !cur.sleeping;\n                };\n                if(!res)throw \"assert(\"+\"!cur.sleeping\"+\") :: \"+(\"sleeping pair in pairs\");\n                #end\n            };\n            var nxt=cur.next;\n            if(cur.n1==node||cur.n2==node){\n                if(pre==null)pairs=nxt;\n                else pre.next=nxt;\n                if(cur.arb!=null)cur.arb.pair=null;\n                cur.arb=null;\n                cur.n1.shape.pairs.remove(cur);\n                cur.n2.shape.pairs.remove(cur);\n                {\n                    var o=cur;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABBPair\"+\", in obj: \"+\"cur\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_AABBPair.zpp_pool;\n                    ZPP_AABBPair.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_AABBPair.POOL_CNT++;\n                    ZPP_AABBPair.POOL_SUB++;\n                    #end\n                };\n                cur=nxt;\n                continue;\n            }\n            pre=cur;\n            cur=nxt;\n        }\n        while(!shape.pairs.empty()){\n            var cur=shape.pairs.pop_unsafe();\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    cur.sleeping;\n                };\n                if(!res)throw \"assert(\"+\"cur.sleeping\"+\") :: \"+(\"non-sleeping pair remaining after removing them from pairs\");\n                #end\n            };\n            if(cur.n1==node)cur.n2.shape.pairs.remove(cur);\n            else cur.n1.shape.pairs.remove(cur);\n            if(cur.arb!=null)cur.arb.pair=null;\n            cur.arb=null;\n            {\n                var o=cur;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABBPair\"+\", in obj: \"+\"cur\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_AABBPair.zpp_pool;\n                ZPP_AABBPair.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_AABBPair.POOL_CNT++;\n                ZPP_AABBPair.POOL_SUB++;\n                #end\n            };\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABBNode\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_AABBNode.zpp_pool;\n            ZPP_AABBNode.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_AABBNode.POOL_CNT++;\n            ZPP_AABBNode.POOL_SUB++;\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function __sync(shape:ZPP_Shape){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !shape.body.isStatic();\n            };\n            if(!res)throw \"assert(\"+\"!shape.body.isStatic()\"+\") :: \"+(\"static shape being synced?\");\n            #end\n        };\n        var node=shape.node;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"shape has no node?\");\n            #end\n        };\n        if(!node.synced){\n            if(!space.continuous)shape.validate_aabb();\n            var sync=node.dyn!=dyn(shape)||!node.aabb.contains(shape.aabb);\n            if(sync){\n                #if NAPE_TIMES Debug.BROADCLASH++;\n                #end\n                node.synced=true;\n                {\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            node.snext==null;\n                        };\n                        if(!res)throw \"assert(\"+\"node.snext==null\"+\") :: \"+(\"object already in list\");\n                        #end\n                    };\n                    node.snext=syncs;\n                    syncs=node;\n                };\n            }\n            #if NAPE_TIMES Debug.BROADTOTAL++;\n            #end\n        }\n    }\n    public function sync_broadphase(){\n        space.validation();\n        if(syncs!=null){\n            if(moves==null){\n                var node=syncs;\n                while(node!=null){\n                    {\n                        var shape=node.shape;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node.synced;\n                            };\n                            if(!res)throw \"assert(\"+\"node.synced\"+\") :: \"+(\"node doesn't need syncing?\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                shape.body!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"shape.body!=null\"+\") :: \"+(\"shape with no body can't be synced\");\n                            #end\n                        };\n                        if(!node.first_sync){\n                            var tree=if(node.dyn)dtree else stree;\n                            tree.inlined_removeLeaf(node);\n                        }\n                        else node.first_sync=false;\n                        var aabb=node.aabb;\n                        if(!space.continuous)shape.validate_aabb();\n                        aabb.setExpand(shape.aabb,FATTEN);\n                        var tree=if(node.dyn=dyn(shape))dtree else stree;\n                        tree.inlined_insertLeaf(node);\n                        node.synced=false;\n                    };\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !node.moved;\n                        };\n                        if(!res)throw \"assert(\"+\"!node.moved\"+\") :: \"+(\"node already moved apparently?\");\n                        #end\n                    };\n                    node.moved=true;\n                    node.mnext=node.snext;\n                    node.snext=null;\n                    node=node.mnext;\n                }\n                {\n                    var t=syncs;\n                    syncs=moves;\n                    moves=t;\n                }\n            }\n            else{\n                while(syncs!=null){\n                    var node=({\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                syncs!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"syncs!=null\"+\") :: \"+(\"pop from empty list!\");\n                            #end\n                        };\n                        var ret=syncs;\n                        syncs=ret.snext;\n                        ret.snext=null;\n                        ret;\n                    });\n                    {\n                        var shape=node.shape;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node.synced;\n                            };\n                            if(!res)throw \"assert(\"+\"node.synced\"+\") :: \"+(\"node doesn't need syncing?\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                shape.body!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"shape.body!=null\"+\") :: \"+(\"shape with no body can't be synced\");\n                            #end\n                        };\n                        if(!node.first_sync){\n                            var tree=if(node.dyn)dtree else stree;\n                            tree.inlined_removeLeaf(node);\n                        }\n                        else node.first_sync=false;\n                        var aabb=node.aabb;\n                        if(!space.continuous)shape.validate_aabb();\n                        aabb.setExpand(shape.aabb,FATTEN);\n                        var tree=if(node.dyn=dyn(shape))dtree else stree;\n                        tree.inlined_insertLeaf(node);\n                        node.synced=false;\n                    };\n                    if(!node.moved){\n                        node.moved=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    node.mnext==null;\n                                };\n                                if(!res)throw \"assert(\"+\"node.mnext==null\"+\") :: \"+(\"object already in list\");\n                                #end\n                            };\n                            node.mnext=moves;\n                            moves=node;\n                        };\n                    }\n                }\n            }\n        }\n    }\n    public override function broadphase(space:ZPP_Space,discrete:Bool){\n        var node=syncs;\n        while(node!=null){\n            {\n                var shape=node.shape;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        node.synced;\n                    };\n                    if(!res)throw \"assert(\"+\"node.synced\"+\") :: \"+(\"node doesn't need syncing?\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        shape.body!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"shape.body!=null\"+\") :: \"+(\"shape with no body can't be synced\");\n                    #end\n                };\n                if(!node.first_sync){\n                    var tree=if(node.dyn)dtree else stree;\n                    tree.inlined_removeLeaf(node);\n                }\n                else node.first_sync=false;\n                var aabb=node.aabb;\n                if(!space.continuous)shape.validate_aabb();\n                aabb.setExpand(shape.aabb,FATTEN);\n                var tree=if(node.dyn=dyn(shape))dtree else stree;\n                tree.inlined_insertLeaf(node);\n                node.synced=false;\n            };\n            node=node.snext;\n        }\n        {\n            while(syncs!=null){\n                var leaf=({\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            syncs!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"syncs!=null\"+\") :: \"+(\"pop from empty list!\");\n                        #end\n                    };\n                    var ret=syncs;\n                    syncs=ret.snext;\n                    ret.snext=null;\n                    ret;\n                });\n                if(\"syncs\"!=\"moves\"&&leaf.moved)continue;\n                leaf.moved=false;\n                var lshape=leaf.shape;\n                var lbody=lshape.body;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !(lbody.component.sleeping&&lbody.isStatic());\n                    };\n                    if(!res)throw \"assert(\"+\"!(lbody.component.sleeping&&lbody.isStatic())\"+\") :: \"+(\"a sleeping static?\");\n                    #end\n                };\n                if(lbody.component.sleeping)continue;\n                var ab=leaf.aabb;\n                var stack=null;\n                {\n                    if(dtree.root!=null){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                dtree.root.next==null;\n                            };\n                            if(!res)throw \"assert(\"+\"dtree.root.next==null\"+\") :: \"+(\"object already in list\");\n                            #end\n                        };\n                        dtree.root.next=stack;\n                        stack=dtree.root;\n                    };\n                    while(stack!=null){\n                        var node=({\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    stack!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"stack!=null\"+\") :: \"+(\"pop from empty list!\");\n                                #end\n                            };\n                            var ret=stack;\n                            stack=ret.next;\n                            ret.next=null;\n                            ret;\n                        });\n                        if(node==leaf)continue;\n                        if(node.isLeaf()){\n                            var shape=node.shape;\n                            if(shape.body!=lshape.body&&!(shape.body.isStatic()&&lshape.body.isStatic())){\n                                if(ab.intersect(node.aabb)){\n                                    var id:Int;\n                                    var di:Int;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            lshape!=shape;\n                                        };\n                                        if(!res)throw \"assert(\"+\"lshape!=shape\"+\") :: \"+(\"narrowphase area of dyn-aabb with same shape?\");\n                                        #end\n                                    };\n                                    if(lshape.id<shape.id){\n                                        id=lshape.id;\n                                        di=shape.id;\n                                    }\n                                    else{\n                                        id=shape.id;\n                                        di=lshape.id;\n                                    }\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            id<di;\n                                        };\n                                        if(!res)throw \"assert(\"+\"id<di\"+\") :: \"+(\"id's not well ordered in dyn-aabb narrowphase\");\n                                        #end\n                                    };\n                                    var s=if(lshape.pairs.length<shape.pairs.length)lshape else shape;\n                                    var p:ZPP_AABBPair=null;\n                                    {\n                                        var cx_ite=s.pairs.begin();\n                                        while(cx_ite!=null){\n                                            var px=cx_ite.elem();\n                                            {\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !(px.id==di&&px.di==id);\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!(px.id==di&&px.di==id)\"+\") :: \"+(\"dyn-pair id didn't match shape id's\");\n                                                    #end\n                                                };\n                                                if(px.id==id&&px.di==di){\n                                                    p=px;\n                                                    break;\n                                                }\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                    if(p!=null){\n                                        if(p.sleeping){\n                                            p.sleeping=false;\n                                            p.next=pairs;\n                                            pairs=p;\n                                            p.first=true;\n                                        }\n                                        continue;\n                                    }\n                                    {\n                                        if(ZPP_AABBPair.zpp_pool==null){\n                                            p=new ZPP_AABBPair();\n                                            #if NAPE_POOL_STATS ZPP_AABBPair.POOL_TOT++;\n                                            ZPP_AABBPair.POOL_ADDNEW++;\n                                            #end\n                                        }\n                                        else{\n                                            p=ZPP_AABBPair.zpp_pool;\n                                            ZPP_AABBPair.zpp_pool=p.next;\n                                            p.next=null;\n                                            #if NAPE_POOL_STATS ZPP_AABBPair.POOL_CNT--;\n                                            ZPP_AABBPair.POOL_ADD++;\n                                            #end\n                                        }\n                                        p.alloc();\n                                    };\n                                    p.n1=leaf;\n                                    p.n2=node;\n                                    p.id=id;\n                                    p.di=di;\n                                    p.next=pairs;\n                                    pairs=p;\n                                    p.first=true;\n                                    lshape.pairs.inlined_add(p);\n                                    shape.pairs.inlined_add(p);\n                                }\n                            }\n                        }\n                        else if(ab.intersect(node.aabb)){\n                            if(node.child1!=null){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        node.child1.next==null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"node.child1.next==null\"+\") :: \"+(\"object already in list\");\n                                    #end\n                                };\n                                node.child1.next=stack;\n                                stack=node.child1;\n                            };\n                            if(node.child2!=null){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        node.child2.next==null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"node.child2.next==null\"+\") :: \"+(\"object already in list\");\n                                    #end\n                                };\n                                node.child2.next=stack;\n                                stack=node.child2;\n                            };\n                        }\n                    }\n                };\n                {\n                    if(stree.root!=null){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                stree.root.next==null;\n                            };\n                            if(!res)throw \"assert(\"+\"stree.root.next==null\"+\") :: \"+(\"object already in list\");\n                            #end\n                        };\n                        stree.root.next=stack;\n                        stack=stree.root;\n                    };\n                    while(stack!=null){\n                        var node=({\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    stack!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"stack!=null\"+\") :: \"+(\"pop from empty list!\");\n                                #end\n                            };\n                            var ret=stack;\n                            stack=ret.next;\n                            ret.next=null;\n                            ret;\n                        });\n                        if(node==leaf)continue;\n                        if(node.isLeaf()){\n                            var shape=node.shape;\n                            if(shape.body!=lshape.body&&!(shape.body.isStatic()&&lshape.body.isStatic())){\n                                if(ab.intersect(node.aabb)){\n                                    var id:Int;\n                                    var di:Int;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            lshape!=shape;\n                                        };\n                                        if(!res)throw \"assert(\"+\"lshape!=shape\"+\") :: \"+(\"narrowphase area of dyn-aabb with same shape?\");\n                                        #end\n                                    };\n                                    if(lshape.id<shape.id){\n                                        id=lshape.id;\n                                        di=shape.id;\n                                    }\n                                    else{\n                                        id=shape.id;\n                                        di=lshape.id;\n                                    }\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            id<di;\n                                        };\n                                        if(!res)throw \"assert(\"+\"id<di\"+\") :: \"+(\"id's not well ordered in dyn-aabb narrowphase\");\n                                        #end\n                                    };\n                                    var s=if(lshape.pairs.length<shape.pairs.length)lshape else shape;\n                                    var p:ZPP_AABBPair=null;\n                                    {\n                                        var cx_ite=s.pairs.begin();\n                                        while(cx_ite!=null){\n                                            var px=cx_ite.elem();\n                                            {\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !(px.id==di&&px.di==id);\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!(px.id==di&&px.di==id)\"+\") :: \"+(\"dyn-pair id didn't match shape id's\");\n                                                    #end\n                                                };\n                                                if(px.id==id&&px.di==di){\n                                                    p=px;\n                                                    break;\n                                                }\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                    if(p!=null){\n                                        if(p.sleeping){\n                                            p.sleeping=false;\n                                            p.next=pairs;\n                                            pairs=p;\n                                            p.first=true;\n                                        }\n                                        continue;\n                                    }\n                                    {\n                                        if(ZPP_AABBPair.zpp_pool==null){\n                                            p=new ZPP_AABBPair();\n                                            #if NAPE_POOL_STATS ZPP_AABBPair.POOL_TOT++;\n                                            ZPP_AABBPair.POOL_ADDNEW++;\n                                            #end\n                                        }\n                                        else{\n                                            p=ZPP_AABBPair.zpp_pool;\n                                            ZPP_AABBPair.zpp_pool=p.next;\n                                            p.next=null;\n                                            #if NAPE_POOL_STATS ZPP_AABBPair.POOL_CNT--;\n                                            ZPP_AABBPair.POOL_ADD++;\n                                            #end\n                                        }\n                                        p.alloc();\n                                    };\n                                    p.n1=leaf;\n                                    p.n2=node;\n                                    p.id=id;\n                                    p.di=di;\n                                    p.next=pairs;\n                                    pairs=p;\n                                    p.first=true;\n                                    lshape.pairs.inlined_add(p);\n                                    shape.pairs.inlined_add(p);\n                                }\n                            }\n                        }\n                        else if(ab.intersect(node.aabb)){\n                            if(node.child1!=null){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        node.child1.next==null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"node.child1.next==null\"+\") :: \"+(\"object already in list\");\n                                    #end\n                                };\n                                node.child1.next=stack;\n                                stack=node.child1;\n                            };\n                            if(node.child2!=null){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        node.child2.next==null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"node.child2.next==null\"+\") :: \"+(\"object already in list\");\n                                    #end\n                                };\n                                node.child2.next=stack;\n                                stack=node.child2;\n                            };\n                        }\n                    }\n                };\n            }\n        }\n        {\n            while(moves!=null){\n                var leaf=({\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            moves!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"moves!=null\"+\") :: \"+(\"pop from empty list!\");\n                        #end\n                    };\n                    var ret=moves;\n                    moves=ret.mnext;\n                    ret.mnext=null;\n                    ret;\n                });\n                if(\"moves\"!=\"moves\"&&leaf.moved)continue;\n                leaf.moved=false;\n                var lshape=leaf.shape;\n                var lbody=lshape.body;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !(lbody.component.sleeping&&lbody.isStatic());\n                    };\n                    if(!res)throw \"assert(\"+\"!(lbody.component.sleeping&&lbody.isStatic())\"+\") :: \"+(\"a sleeping static?\");\n                    #end\n                };\n                if(lbody.component.sleeping)continue;\n                var ab=leaf.aabb;\n                var stack=null;\n                {\n                    if(dtree.root!=null){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                dtree.root.next==null;\n                            };\n                            if(!res)throw \"assert(\"+\"dtree.root.next==null\"+\") :: \"+(\"object already in list\");\n                            #end\n                        };\n                        dtree.root.next=stack;\n                        stack=dtree.root;\n                    };\n                    while(stack!=null){\n                        var node=({\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    stack!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"stack!=null\"+\") :: \"+(\"pop from empty list!\");\n                                #end\n                            };\n                            var ret=stack;\n                            stack=ret.next;\n                            ret.next=null;\n                            ret;\n                        });\n                        if(node==leaf)continue;\n                        if(node.isLeaf()){\n                            var shape=node.shape;\n                            if(shape.body!=lshape.body&&!(shape.body.isStatic()&&lshape.body.isStatic())){\n                                if(ab.intersect(node.aabb)){\n                                    var id:Int;\n                                    var di:Int;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            lshape!=shape;\n                                        };\n                                        if(!res)throw \"assert(\"+\"lshape!=shape\"+\") :: \"+(\"narrowphase area of dyn-aabb with same shape?\");\n                                        #end\n                                    };\n                                    if(lshape.id<shape.id){\n                                        id=lshape.id;\n                                        di=shape.id;\n                                    }\n                                    else{\n                                        id=shape.id;\n                                        di=lshape.id;\n                                    }\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            id<di;\n                                        };\n                                        if(!res)throw \"assert(\"+\"id<di\"+\") :: \"+(\"id's not well ordered in dyn-aabb narrowphase\");\n                                        #end\n                                    };\n                                    var s=if(lshape.pairs.length<shape.pairs.length)lshape else shape;\n                                    var p:ZPP_AABBPair=null;\n                                    {\n                                        var cx_ite=s.pairs.begin();\n                                        while(cx_ite!=null){\n                                            var px=cx_ite.elem();\n                                            {\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !(px.id==di&&px.di==id);\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!(px.id==di&&px.di==id)\"+\") :: \"+(\"dyn-pair id didn't match shape id's\");\n                                                    #end\n                                                };\n                                                if(px.id==id&&px.di==di){\n                                                    p=px;\n                                                    break;\n                                                }\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                    if(p!=null){\n                                        if(p.sleeping){\n                                            p.sleeping=false;\n                                            p.next=pairs;\n                                            pairs=p;\n                                            p.first=true;\n                                        }\n                                        continue;\n                                    }\n                                    {\n                                        if(ZPP_AABBPair.zpp_pool==null){\n                                            p=new ZPP_AABBPair();\n                                            #if NAPE_POOL_STATS ZPP_AABBPair.POOL_TOT++;\n                                            ZPP_AABBPair.POOL_ADDNEW++;\n                                            #end\n                                        }\n                                        else{\n                                            p=ZPP_AABBPair.zpp_pool;\n                                            ZPP_AABBPair.zpp_pool=p.next;\n                                            p.next=null;\n                                            #if NAPE_POOL_STATS ZPP_AABBPair.POOL_CNT--;\n                                            ZPP_AABBPair.POOL_ADD++;\n                                            #end\n                                        }\n                                        p.alloc();\n                                    };\n                                    p.n1=leaf;\n                                    p.n2=node;\n                                    p.id=id;\n                                    p.di=di;\n                                    p.next=pairs;\n                                    pairs=p;\n                                    p.first=true;\n                                    lshape.pairs.inlined_add(p);\n                                    shape.pairs.inlined_add(p);\n                                }\n                            }\n                        }\n                        else if(ab.intersect(node.aabb)){\n                            if(node.child1!=null){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        node.child1.next==null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"node.child1.next==null\"+\") :: \"+(\"object already in list\");\n                                    #end\n                                };\n                                node.child1.next=stack;\n                                stack=node.child1;\n                            };\n                            if(node.child2!=null){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        node.child2.next==null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"node.child2.next==null\"+\") :: \"+(\"object already in list\");\n                                    #end\n                                };\n                                node.child2.next=stack;\n                                stack=node.child2;\n                            };\n                        }\n                    }\n                };\n                {\n                    if(stree.root!=null){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                stree.root.next==null;\n                            };\n                            if(!res)throw \"assert(\"+\"stree.root.next==null\"+\") :: \"+(\"object already in list\");\n                            #end\n                        };\n                        stree.root.next=stack;\n                        stack=stree.root;\n                    };\n                    while(stack!=null){\n                        var node=({\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    stack!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"stack!=null\"+\") :: \"+(\"pop from empty list!\");\n                                #end\n                            };\n                            var ret=stack;\n                            stack=ret.next;\n                            ret.next=null;\n                            ret;\n                        });\n                        if(node==leaf)continue;\n                        if(node.isLeaf()){\n                            var shape=node.shape;\n                            if(shape.body!=lshape.body&&!(shape.body.isStatic()&&lshape.body.isStatic())){\n                                if(ab.intersect(node.aabb)){\n                                    var id:Int;\n                                    var di:Int;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            lshape!=shape;\n                                        };\n                                        if(!res)throw \"assert(\"+\"lshape!=shape\"+\") :: \"+(\"narrowphase area of dyn-aabb with same shape?\");\n                                        #end\n                                    };\n                                    if(lshape.id<shape.id){\n                                        id=lshape.id;\n                                        di=shape.id;\n                                    }\n                                    else{\n                                        id=shape.id;\n                                        di=lshape.id;\n                                    }\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            id<di;\n                                        };\n                                        if(!res)throw \"assert(\"+\"id<di\"+\") :: \"+(\"id's not well ordered in dyn-aabb narrowphase\");\n                                        #end\n                                    };\n                                    var s=if(lshape.pairs.length<shape.pairs.length)lshape else shape;\n                                    var p:ZPP_AABBPair=null;\n                                    {\n                                        var cx_ite=s.pairs.begin();\n                                        while(cx_ite!=null){\n                                            var px=cx_ite.elem();\n                                            {\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        !(px.id==di&&px.di==id);\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"!(px.id==di&&px.di==id)\"+\") :: \"+(\"dyn-pair id didn't match shape id's\");\n                                                    #end\n                                                };\n                                                if(px.id==id&&px.di==di){\n                                                    p=px;\n                                                    break;\n                                                }\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                    if(p!=null){\n                                        if(p.sleeping){\n                                            p.sleeping=false;\n                                            p.next=pairs;\n                                            pairs=p;\n                                            p.first=true;\n                                        }\n                                        continue;\n                                    }\n                                    {\n                                        if(ZPP_AABBPair.zpp_pool==null){\n                                            p=new ZPP_AABBPair();\n                                            #if NAPE_POOL_STATS ZPP_AABBPair.POOL_TOT++;\n                                            ZPP_AABBPair.POOL_ADDNEW++;\n                                            #end\n                                        }\n                                        else{\n                                            p=ZPP_AABBPair.zpp_pool;\n                                            ZPP_AABBPair.zpp_pool=p.next;\n                                            p.next=null;\n                                            #if NAPE_POOL_STATS ZPP_AABBPair.POOL_CNT--;\n                                            ZPP_AABBPair.POOL_ADD++;\n                                            #end\n                                        }\n                                        p.alloc();\n                                    };\n                                    p.n1=leaf;\n                                    p.n2=node;\n                                    p.id=id;\n                                    p.di=di;\n                                    p.next=pairs;\n                                    pairs=p;\n                                    p.first=true;\n                                    lshape.pairs.inlined_add(p);\n                                    shape.pairs.inlined_add(p);\n                                }\n                            }\n                        }\n                        else if(ab.intersect(node.aabb)){\n                            if(node.child1!=null){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        node.child1.next==null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"node.child1.next==null\"+\") :: \"+(\"object already in list\");\n                                    #end\n                                };\n                                node.child1.next=stack;\n                                stack=node.child1;\n                            };\n                            if(node.child2!=null){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        node.child2.next==null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"node.child2.next==null\"+\") :: \"+(\"object already in list\");\n                                    #end\n                                };\n                                node.child2.next=stack;\n                                stack=node.child2;\n                            };\n                        }\n                    }\n                };\n            }\n        }\n        var pre:ZPP_AABBPair=null;\n        var cur=pairs;\n        while(cur!=null){\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !cur.sleeping;\n                };\n                if(!res)throw \"assert(\"+\"!cur.sleeping\"+\") :: \"+(\"non-sleeping pair in pairs\");\n                #end\n            };\n            if(!cur.first&&!cur.n1.aabb.intersect(cur.n2.aabb)){\n                if(pre==null)pairs=cur.next;\n                else pre.next=cur.next;\n                cur.n1.shape.pairs.inlined_remove(cur);\n                cur.n2.shape.pairs.inlined_remove(cur);\n                var nxt=cur.next;\n                if(cur.arb!=null)cur.arb.pair=null;\n                cur.arb=null;\n                {\n                    var o=cur;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABBPair\"+\", in obj: \"+\"cur\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_AABBPair.zpp_pool;\n                    ZPP_AABBPair.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_AABBPair.POOL_CNT++;\n                    ZPP_AABBPair.POOL_SUB++;\n                    #end\n                };\n                cur=nxt;\n                continue;\n            }\n            var s1=cur.n1.shape;\n            var b1=s1.body;\n            var s2=cur.n2.shape;\n            var b2=s2.body;\n            if(!cur.first){\n                if((b1.component.sleeping||b1.isStatic())&&(b2.component.sleeping||b2.isStatic())){\n                    cur.sleeping=true;\n                    if(pre==null)pairs=cur.next;\n                    else pre.next=cur.next;\n                    cur=cur.next;\n                    continue;\n                }\n            }\n            cur.first=false;\n            if(s1.aabb.intersect(s2.aabb)){\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        cur.arb==null||cur.arb.pair==cur;\n                    };\n                    if(!res)throw \"assert(\"+\"cur.arb==null||cur.arb.pair==cur\"+\") :: \"+(\"arbiter/pair don't match up\");\n                    #end\n                };\n                var oarb=cur.arb;\n                if(discrete)cur.arb=space.narrowPhase(s1,s2,!b1.isDynamic()||!b2.isDynamic(),cur.arb,false);\n                else cur.arb=space.continuousEvent(s1,s2,!b1.isDynamic()||!b2.isDynamic(),cur.arb,false);\n                if(cur.arb==null){\n                    if(oarb!=null)oarb.pair=null;\n                }\n                else cur.arb.pair=cur;\n                #if NAPE_ASSERT if(cur.arb!=oarb){\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        oarb==null||oarb.pair==null;\n                    };\n                    if(!res)throw \"assert(\"+\"oarb==null||oarb.pair==null\"+\") :: \"+(\"oh deary me\");\n                    #end\n                };\n                #end\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n    }\n    public override function clear(){\n        while(syncs!=null){\n            var next=syncs.snext;\n            syncs.snext=null;\n            if(syncs.first_sync){\n                syncs.shape.node=null;\n                syncs.shape.removedFromSpace();\n                syncs.shape=null;\n            }\n            syncs=next;\n        }\n        while(moves!=null){\n            var next=moves.mnext;\n            moves.mnext=null;\n            if(moves.first_sync){\n                moves.shape.node=null;\n                moves.shape.removedFromSpace();\n                moves.shape=null;\n            }\n            moves=next;\n        }\n        while(pairs!=null){\n            var nxt=pairs.next;\n            if(pairs.arb!=null)pairs.arb.pair=null;\n            pairs.arb=null;\n            pairs.n1.shape.pairs.inlined_remove(pairs);\n            pairs.n2.shape.pairs.inlined_remove(pairs);\n            {\n                var o=pairs;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABBPair\"+\", in obj: \"+\"pairs\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_AABBPair.zpp_pool;\n                ZPP_AABBPair.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_AABBPair.POOL_CNT++;\n                ZPP_AABBPair.POOL_SUB++;\n                #end\n            };\n            pairs=nxt;\n        }\n        dtree.clear();\n        stree.clear();\n    }\n    var treeStack:ZNPList_ZPP_AABBNode=null;\n    public override function shapesUnderPoint(x:Float,y:Float,filter:ZPP_InteractionFilter,output:ShapeList){\n        sync_broadphase();\n        var v=ZPP_Vec2.get(x,y);\n        var ret=(output==null?new ShapeList():output);\n        {\n            {\n                if(stree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(stree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.containsPoint(v)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(node.shape.isCircle()){\n                                            if(ZPP_Collide.circleContains(node.shape.circle,v))ret.push(node.shape.outer);\n                                        }\n                                        else{\n                                            if(ZPP_Collide.polyContains(node.shape.polygon,v))ret.push(node.shape.outer);\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            {\n                if(dtree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(dtree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.containsPoint(v)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(node.shape.isCircle()){\n                                            if(ZPP_Collide.circleContains(node.shape.circle,v))ret.push(node.shape.outer);\n                                        }\n                                        else{\n                                            if(ZPP_Collide.polyContains(node.shape.polygon,v))ret.push(node.shape.outer);\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            var o=v;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"v\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public override function bodiesUnderPoint(x:Float,y:Float,filter:ZPP_InteractionFilter,output:BodyList){\n        sync_broadphase();\n        var v=ZPP_Vec2.get(x,y);\n        var ret=(output==null?new BodyList():output);\n        {\n            {\n                if(stree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(stree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.containsPoint(v)){\n                            if(node.isLeaf()){\n                                {\n                                    var body=node.shape.body.outer;\n                                    if(!ret.has(body)){\n                                        if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                            if(node.shape.isCircle()){\n                                                if(ZPP_Collide.circleContains(node.shape.circle,v))ret.push(body);\n                                            }\n                                            else{\n                                                if(ZPP_Collide.polyContains(node.shape.polygon,v))ret.push(body);\n                                            }\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            {\n                if(dtree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(dtree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.containsPoint(v)){\n                            if(node.isLeaf()){\n                                {\n                                    var body=node.shape.body.outer;\n                                    if(!ret.has(body)){\n                                        if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                            if(node.shape.isCircle()){\n                                                if(ZPP_Collide.circleContains(node.shape.circle,v))ret.push(body);\n                                            }\n                                            else{\n                                                if(ZPP_Collide.polyContains(node.shape.polygon,v))ret.push(body);\n                                            }\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            var o=v;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"v\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public var treeStack2:ZNPList_ZPP_AABBNode=null;\n    public override function shapesInAABB(aabb:ZPP_AABB,strict:Bool,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        sync_broadphase();\n        updateAABBShape(aabb);\n        var ab=aabbShape.zpp_inner.aabb;\n        var ret=(output==null?new ShapeList():output);\n        {\n            {\n                if(stree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(stree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(ab.contains(node.aabb)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        ret.push(node.shape.outer);\n                                    }\n                                };\n                            }\n                            else{\n                                if(treeStack2==null){\n                                    treeStack2=new ZNPList_ZPP_AABBNode();\n                                }\n                                treeStack2.add(node);\n                                while(!treeStack2.empty()){\n                                    var node=treeStack2.pop_unsafe();\n                                    if(node.isLeaf()){\n                                        if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                            ret.push(node.shape.outer);\n                                        }\n                                    };\n                                    else{\n                                        if(node.child1!=null)treeStack2.add(node.child1);\n                                        if(node.child2!=null)treeStack2.add(node.child2);\n                                    }\n                                }\n                            }\n                        }\n                        else if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(strict){\n                                            if(containment){\n                                                if(ZPP_Collide.containTest(aabbShape.zpp_inner,node.shape))ret.push(node.shape.outer);\n                                            }\n                                            else{\n                                                if(ab.contains(node.shape.aabb))ret.push(node.shape.outer);\n                                                else if(ZPP_Collide.testCollide_safe(node.shape,aabbShape.zpp_inner))ret.push(node.shape.outer);\n                                            }\n                                        }\n                                        else if(!containment||ab.contains(node.shape.aabb))ret.push(node.shape.outer);\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            {\n                if(dtree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(dtree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(ab.contains(node.aabb)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        ret.push(node.shape.outer);\n                                    }\n                                };\n                            }\n                            else{\n                                if(treeStack2==null){\n                                    treeStack2=new ZNPList_ZPP_AABBNode();\n                                }\n                                treeStack2.add(node);\n                                while(!treeStack2.empty()){\n                                    var node=treeStack2.pop_unsafe();\n                                    if(node.isLeaf()){\n                                        if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                            ret.push(node.shape.outer);\n                                        }\n                                    };\n                                    else{\n                                        if(node.child1!=null)treeStack2.add(node.child1);\n                                        if(node.child2!=null)treeStack2.add(node.child2);\n                                    }\n                                }\n                            }\n                        }\n                        else if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(strict){\n                                            if(containment){\n                                                if(ZPP_Collide.containTest(aabbShape.zpp_inner,node.shape))ret.push(node.shape.outer);\n                                            }\n                                            else{\n                                                if(ab.contains(node.shape.aabb))ret.push(node.shape.outer);\n                                                else if(ZPP_Collide.testCollide_safe(node.shape,aabbShape.zpp_inner))ret.push(node.shape.outer);\n                                            }\n                                        }\n                                        else if(!containment||ab.contains(node.shape.aabb))ret.push(node.shape.outer);\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n    public var failed:BodyList=null;\n    public override function bodiesInAABB(aabb:ZPP_AABB,strict:Bool,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        sync_broadphase();\n        updateAABBShape(aabb);\n        var ab=aabbShape.zpp_inner.aabb;\n        var ret=(output==null?new BodyList():output);\n        if(failed==null)failed=new BodyList();\n        {\n            {\n                if(stree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(stree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(ab.contains(node.aabb)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        var body=node.shape.body.outer;\n                                        if(!ret.has(body))ret.push(body);\n                                    }\n                                };\n                            }\n                            else{\n                                if(treeStack2==null){\n                                    treeStack2=new ZNPList_ZPP_AABBNode();\n                                }\n                                treeStack2.add(node);\n                                while(!treeStack2.empty()){\n                                    var node=treeStack2.pop_unsafe();\n                                    if(node.isLeaf()){\n                                        if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                            var body=node.shape.body.outer;\n                                            if(!ret.has(body))ret.push(body);\n                                        }\n                                    };\n                                    else{\n                                        if(node.child1!=null)treeStack2.add(node.child1);\n                                        if(node.child2!=null)treeStack2.add(node.child2);\n                                    }\n                                }\n                            }\n                        }\n                        else if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    var body=node.shape.body.outer;\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(strict){\n                                            if(containment){\n                                                if(!failed.has(body)){\n                                                    var col=ZPP_Collide.containTest(aabbShape.zpp_inner,node.shape);\n                                                    if(!ret.has(body)&&col)ret.push(body);\n                                                    else if(!col){\n                                                        ret.remove(body);\n                                                        failed.push(body);\n                                                    }\n                                                }\n                                            }\n                                            else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(node.shape,aabbShape.zpp_inner)){\n                                                ret.push(body);\n                                            }\n                                        }\n                                        else{\n                                            if(containment){\n                                                if(!failed.has(body)){\n                                                    var col=ab.contains(node.shape.aabb);\n                                                    if(!ret.has(body)&&col)ret.push(body);\n                                                    else if(!col){\n                                                        ret.remove(body);\n                                                        failed.push(body);\n                                                    }\n                                                }\n                                            }\n                                            else if(!ret.has(body)&&ab.contains(node.shape.aabb)){\n                                                ret.push(body);\n                                            }\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            {\n                if(dtree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(dtree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(ab.contains(node.aabb)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        var body=node.shape.body.outer;\n                                        if(!ret.has(body))ret.push(body);\n                                    }\n                                };\n                            }\n                            else{\n                                if(treeStack2==null){\n                                    treeStack2=new ZNPList_ZPP_AABBNode();\n                                }\n                                treeStack2.add(node);\n                                while(!treeStack2.empty()){\n                                    var node=treeStack2.pop_unsafe();\n                                    if(node.isLeaf()){\n                                        if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                            var body=node.shape.body.outer;\n                                            if(!ret.has(body))ret.push(body);\n                                        }\n                                    };\n                                    else{\n                                        if(node.child1!=null)treeStack2.add(node.child1);\n                                        if(node.child2!=null)treeStack2.add(node.child2);\n                                    }\n                                }\n                            }\n                        }\n                        else if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    var body=node.shape.body.outer;\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(strict){\n                                            if(containment){\n                                                if(!failed.has(body)){\n                                                    var col=ZPP_Collide.containTest(aabbShape.zpp_inner,node.shape);\n                                                    if(!ret.has(body)&&col)ret.push(body);\n                                                    else if(!col){\n                                                        ret.remove(body);\n                                                        failed.push(body);\n                                                    }\n                                                }\n                                            }\n                                            else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(node.shape,aabbShape.zpp_inner)){\n                                                ret.push(body);\n                                            }\n                                        }\n                                        else{\n                                            if(containment){\n                                                if(!failed.has(body)){\n                                                    var col=ab.contains(node.shape.aabb);\n                                                    if(!ret.has(body)&&col)ret.push(body);\n                                                    else if(!col){\n                                                        ret.remove(body);\n                                                        failed.push(body);\n                                                    }\n                                                }\n                                            }\n                                            else if(!ret.has(body)&&ab.contains(node.shape.aabb)){\n                                                ret.push(body);\n                                            }\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        failed.clear();\n        return ret;\n    }\n    public override function shapesInCircle(x:Float,y:Float,r:Float,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        sync_broadphase();\n        updateCircShape(x,y,r);\n        var ab=circShape.zpp_inner.aabb;\n        var ret=(output==null?new ShapeList():output);\n        {\n            {\n                if(stree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(stree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(containment){\n                                            if(ZPP_Collide.containTest(circShape.zpp_inner,node.shape))ret.push(node.shape.outer);\n                                        }\n                                        else if(ZPP_Collide.testCollide_safe(node.shape,circShape.zpp_inner))ret.push(node.shape.outer);\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            {\n                if(dtree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(dtree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(containment){\n                                            if(ZPP_Collide.containTest(circShape.zpp_inner,node.shape))ret.push(node.shape.outer);\n                                        }\n                                        else if(ZPP_Collide.testCollide_safe(node.shape,circShape.zpp_inner))ret.push(node.shape.outer);\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n    public override function bodiesInCircle(x:Float,y:Float,r:Float,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        sync_broadphase();\n        updateCircShape(x,y,r);\n        var ab=circShape.zpp_inner.aabb;\n        var ret=(output==null?new BodyList():output);\n        if(failed==null)failed=new BodyList();\n        {\n            {\n                if(stree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(stree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    var body=node.shape.body.outer;\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(containment){\n                                            if(!failed.has(body)){\n                                                var col=ZPP_Collide.containTest(circShape.zpp_inner,node.shape);\n                                                if(!ret.has(body)&&col)ret.push(body);\n                                                else if(!col){\n                                                    ret.remove(body);\n                                                    failed.push(body);\n                                                }\n                                            }\n                                        }\n                                        else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(node.shape,circShape.zpp_inner)){\n                                            ret.push(body);\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            {\n                if(dtree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(dtree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    var body=node.shape.body.outer;\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(containment){\n                                            if(!failed.has(body)){\n                                                var col=ZPP_Collide.containTest(circShape.zpp_inner,node.shape);\n                                                if(!ret.has(body)&&col)ret.push(body);\n                                                else if(!col){\n                                                    ret.remove(body);\n                                                    failed.push(body);\n                                                }\n                                            }\n                                        }\n                                        else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(node.shape,circShape.zpp_inner)){\n                                            ret.push(body);\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        failed.clear();\n        return ret;\n    }\n    public override function shapesInShape(shp:ZPP_Shape,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        sync_broadphase();\n        validateShape(shp);\n        var ab=shp.aabb;\n        var ret=(output==null?new ShapeList():output);\n        {\n            {\n                if(stree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(stree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(containment){\n                                            if(ZPP_Collide.containTest(shp,node.shape))ret.push(node.shape.outer);\n                                        }\n                                        else if(ZPP_Collide.testCollide_safe(node.shape,shp))ret.push(node.shape.outer);\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            {\n                if(dtree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(dtree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(containment){\n                                            if(ZPP_Collide.containTest(shp,node.shape))ret.push(node.shape.outer);\n                                        }\n                                        else if(ZPP_Collide.testCollide_safe(node.shape,shp))ret.push(node.shape.outer);\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n    public override function bodiesInShape(shp:ZPP_Shape,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        sync_broadphase();\n        validateShape(shp);\n        var ab=shp.aabb;\n        var ret=(output==null?new BodyList():output);\n        if(failed==null)failed=new BodyList();\n        {\n            {\n                if(stree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(stree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    var body=node.shape.body.outer;\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(containment){\n                                            if(!failed.has(body)){\n                                                var col=ZPP_Collide.containTest(shp,node.shape);\n                                                if(!ret.has(body)&&col)ret.push(body);\n                                                else if(!col){\n                                                    ret.remove(body);\n                                                    failed.push(body);\n                                                }\n                                            }\n                                        }\n                                        else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(node.shape,shp)){\n                                            ret.push(body);\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        {\n            {\n                if(dtree.root!=null){\n                    if(treeStack==null)treeStack=new ZNPList_ZPP_AABBNode();\n                    treeStack.add(dtree.root);\n                    while(!treeStack.empty()){\n                        var node=treeStack.pop_unsafe();\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                node!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"null node\");\n                            #end\n                        };\n                        if(node.aabb.intersect(ab)){\n                            if(node.isLeaf()){\n                                {\n                                    var body=node.shape.body.outer;\n                                    if(filter==null||node.shape.filter.shouldCollide(filter)){\n                                        if(containment){\n                                            if(!failed.has(body)){\n                                                var col=ZPP_Collide.containTest(shp,node.shape);\n                                                if(!ret.has(body)&&col)ret.push(body);\n                                                else if(!col){\n                                                    ret.remove(body);\n                                                    failed.push(body);\n                                                }\n                                            }\n                                        }\n                                        else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(node.shape,shp)){\n                                            ret.push(body);\n                                        }\n                                    }\n                                };\n                            }\n                            else{\n                                if(node.child1!=null)treeStack.add(node.child1);\n                                if(node.child2!=null)treeStack.add(node.child2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        failed.clear();\n        return ret;\n    }\n    public var openlist:ZNPList_ZPP_AABBNode=null;\n    public override function rayCast(ray:ZPP_Ray,inner:Bool,filter:ZPP_InteractionFilter){\n        if(openlist==null)openlist=new ZNPList_ZPP_AABBNode();\n        sync_broadphase();\n        ray.validate_dir();\n        var mint=ray.maxdist;\n        {\n            if(dtree.root!=null){\n                if(ray.aabbtest(dtree.root.aabb)){\n                    var t=ray.aabbsect(dtree.root.aabb);\n                    if(t>=0&&t<mint){\n                        dtree.root.rayt=t;\n                        {\n                            var pre=null;\n                            {\n                                var cx_ite=openlist.begin();\n                                while(cx_ite!=null){\n                                    var j=cx_ite.elem();\n                                    {\n                                        if((dtree.root.rayt<j.rayt))break;\n                                        pre=cx_ite;\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                            openlist.inlined_insert(pre,dtree.root);\n                        };\n                    }\n                }\n            }\n        };\n        {\n            if(stree.root!=null){\n                if(ray.aabbtest(stree.root.aabb)){\n                    var t=ray.aabbsect(stree.root.aabb);\n                    if(t>=0&&t<mint){\n                        stree.root.rayt=t;\n                        {\n                            var pre=null;\n                            {\n                                var cx_ite=openlist.begin();\n                                while(cx_ite!=null){\n                                    var j=cx_ite.elem();\n                                    {\n                                        if((stree.root.rayt<j.rayt))break;\n                                        pre=cx_ite;\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                            openlist.inlined_insert(pre,stree.root);\n                        };\n                    }\n                }\n            }\n        };\n        var minres:RayResult=null;\n        while(!openlist.empty()){\n            var cnode=openlist.pop_unsafe();\n            if(cnode.rayt>=mint)break;\n            if(cnode.isLeaf()){\n                var shape=cnode.shape;\n                if(filter==null||shape.filter.shouldCollide(filter)){\n                    var result=if(shape.isCircle())ray.circlesect(shape.circle,inner,mint)else if(ray.aabbtest(shape.aabb))ray.polysect(shape.polygon,inner,mint);\n                    else null;\n                    if(result!=null){\n                        mint=result.distance;\n                        if(minres!=null){\n                            minres.dispose();\n                        }\n                        minres=result;\n                    }\n                }\n            }\n            else{\n                {\n                    if(cnode.child1!=null){\n                        if(ray.aabbtest(cnode.child1.aabb)){\n                            var t=ray.aabbsect(cnode.child1.aabb);\n                            if(t>=0&&t<mint){\n                                cnode.child1.rayt=t;\n                                {\n                                    var pre=null;\n                                    {\n                                        var cx_ite=openlist.begin();\n                                        while(cx_ite!=null){\n                                            var j=cx_ite.elem();\n                                            {\n                                                if((cnode.child1.rayt<j.rayt))break;\n                                                pre=cx_ite;\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                    openlist.inlined_insert(pre,cnode.child1);\n                                };\n                            }\n                        }\n                    }\n                };\n                {\n                    if(cnode.child2!=null){\n                        if(ray.aabbtest(cnode.child2.aabb)){\n                            var t=ray.aabbsect(cnode.child2.aabb);\n                            if(t>=0&&t<mint){\n                                cnode.child2.rayt=t;\n                                {\n                                    var pre=null;\n                                    {\n                                        var cx_ite=openlist.begin();\n                                        while(cx_ite!=null){\n                                            var j=cx_ite.elem();\n                                            {\n                                                if((cnode.child2.rayt<j.rayt))break;\n                                                pre=cx_ite;\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                    openlist.inlined_insert(pre,cnode.child2);\n                                };\n                            }\n                        }\n                    }\n                };\n            }\n        }\n        openlist.clear();\n        return minres;\n    }\n    public override function rayMultiCast(ray:ZPP_Ray,inner:Bool,filter:ZPP_InteractionFilter,output:RayResultList){\n        if(openlist==null)openlist=new ZNPList_ZPP_AABBNode();\n        sync_broadphase();\n        ray.validate_dir();\n        var inf=ray.maxdist>=ZPP_Const.POSINF();\n        var ret=(output==null?new RayResultList():output);\n        {\n            if(dtree.root!=null){\n                if(ray.aabbtest(dtree.root.aabb)){\n                    if(inf)openlist.add(dtree.root);\n                    else{\n                        var t=ray.aabbsect(dtree.root.aabb);\n                        if(t>=0&&t<ray.maxdist)openlist.add(dtree.root);\n                    }\n                }\n            }\n        };\n        {\n            if(stree.root!=null){\n                if(ray.aabbtest(stree.root.aabb)){\n                    if(inf)openlist.add(stree.root);\n                    else{\n                        var t=ray.aabbsect(stree.root.aabb);\n                        if(t>=0&&t<ray.maxdist)openlist.add(stree.root);\n                    }\n                }\n            }\n        };\n        while(!openlist.empty()){\n            var cnode=openlist.pop_unsafe();\n            if(cnode.isLeaf()){\n                var shape=cnode.shape;\n                if(filter==null||shape.filter.shouldCollide(filter)){\n                    if(shape.isCircle())ray.circlesect2(shape.circle,inner,ret);\n                    else if(ray.aabbtest(shape.aabb))ray.polysect2(shape.polygon,inner,ret);\n                }\n            }\n            else{\n                {\n                    if(cnode.child1!=null){\n                        if(ray.aabbtest(cnode.child1.aabb)){\n                            if(inf)openlist.add(cnode.child1);\n                            else{\n                                var t=ray.aabbsect(cnode.child1.aabb);\n                                if(t>=0&&t<ray.maxdist)openlist.add(cnode.child1);\n                            }\n                        }\n                    }\n                };\n                {\n                    if(cnode.child2!=null){\n                        if(ray.aabbtest(cnode.child2.aabb)){\n                            if(inf)openlist.add(cnode.child2);\n                            else{\n                                var t=ray.aabbsect(cnode.child2.aabb);\n                                if(t>=0&&t<ray.maxdist)openlist.add(cnode.child2);\n                            }\n                        }\n                    }\n                };\n            }\n        }\n        openlist.clear();\n        return ret;\n    }\n}\n","package zpp_nape.space;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Island{\n    public var next:ZPP_Island=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_Island{\n        return this;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZPP_Island{\n        return next;\n    }\n    public var _inuse:Bool=false;\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZPP_Island):Void{\n        next=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_Island):ZPP_Island{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_Island):ZPP_Island{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        temp.next=begin();\n        next=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZPP_Island):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZPP_Island,o:ZPP_Island):ZPP_Island{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZPP_Island,o:ZPP_Island):ZPP_Island{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        if(cur==null){\n            temp.next=begin();\n            next=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        next=ret.next;\n        {\n            ret.elem()._inuse=false;\n        };\n        {};\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_Island{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_Island{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_Island):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_Island):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_Island):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_Island):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZPP_Island):ZPP_Island{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZPP_Island):ZPP_Island{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZPP_Island;\n        var ret:ZPP_Island;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            next=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {\n            old.elem()._inuse=false;\n        };\n        {};\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZPP_Island,n:Int):ZPP_Island{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(false){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            next=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_Island):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_Island):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_Island{\n        return begin().elem();\n    }\n    public function back():ZPP_Island{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZPP_Island{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_Island{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_Island\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n    public var comps:ZNPList_ZPP_Component=null;\n    public var sleep:Bool=false;\n    public var waket:Int=0;\n    static public var zpp_pool:ZPP_Island=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                comps.empty();\n            };\n            if(!res)throw \"assert(\"+\"comps.empty()\"+\") :: \"+(\"Island freed with components in island\");\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){\n        waket=0;\n    }\n    public function new(){\n        comps=new ZNPList_ZPP_Component();\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Component{\n    public var next:ZPP_Component=null;\n    static public var zpp_pool:ZPP_Component=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var parent:ZPP_Component=null;\n    public var rank:Int=0;\n    public var isBody:Bool=false;\n    public var body:ZPP_Body=null;\n    public var constraint:ZPP_Constraint=null;\n    public var island:ZPP_Island=null;\n    public var sleeping:Bool=false;\n    public var waket:Int=0;\n    public var woken:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        body=null;\n        constraint=null;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                island==null;\n            };\n            if(!res)throw \"assert(\"+\"island==null\"+\") :: \"+(\"component freeed whilst connected to an island?\");\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public function new(){\n        reset();\n        woken=false;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function reset(){\n        sleeping=false;\n        island=null;\n        parent=this;\n        rank=0;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_CallbackSet{\n    public var id:Int=0;\n    public var di:Int=0;\n    public var int1:ZPP_Interactor=null;\n    public var int2:ZPP_Interactor=null;\n    public static function get(i1:ZPP_Interactor,i2:ZPP_Interactor){\n        var ret;\n        {\n            if(ZPP_CallbackSet.zpp_pool==null){\n                ret=new ZPP_CallbackSet();\n                #if NAPE_POOL_STATS ZPP_CallbackSet.POOL_TOT++;\n                ZPP_CallbackSet.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                ret=ZPP_CallbackSet.zpp_pool;\n                ZPP_CallbackSet.zpp_pool=ret.next;\n                ret.next=null;\n                #if NAPE_POOL_STATS ZPP_CallbackSet.POOL_CNT--;\n                ZPP_CallbackSet.POOL_ADD++;\n                #end\n            }\n            ret.alloc();\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                i1!=i2;\n            };\n            if(!res)throw \"assert(\"+\"i1!=i2\"+\") :: \"+(\"CallbackSet between the same interactor?\");\n            #end\n        };\n        if(i1.id<i2.id){\n            ret.int1=i1;\n            ret.int2=i2;\n        }\n        else{\n            ret.int1=i2;\n            ret.int2=i1;\n        }\n        ret.id=ret.int1.id;\n        ret.di=ret.int2.id;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ret.id<ret.di;\n            };\n            if(!res)throw \"assert(\"+\"ret.id<ret.di\"+\") :: \"+(\"badly ordered id's in callback set?\");\n            #end\n        };\n        return ret;\n    }\n    public var arbiters:ZNPList_ZPP_Arbiter;\n    public var COLLISIONstate:Int;\n    public var COLLISIONstamp:Int;\n    public var SENSORstate:Int;\n    public var SENSORstamp:Int;\n    public var FLUIDstate:Int;\n    public var FLUIDstamp:Int;\n    public var next:ZPP_CallbackSet=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function elem():ZPP_CallbackSet{\n        return this;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function begin():ZPP_CallbackSet{\n        return next;\n    }\n    public var _inuse:Bool=false;\n    public var modified:Bool=false;\n    public var pushmod:Bool=false;\n    public var length:Int=0;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function setbegin(i:ZPP_CallbackSet):Void{\n        next=i;\n        modified=true;\n        pushmod=true;\n    }\n    public function add(o:ZPP_CallbackSet):ZPP_CallbackSet{\n        return inlined_add(o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_add(o:ZPP_CallbackSet):ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] add -> o=\"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        temp.next=begin();\n        next=temp;\n        modified=true;\n        length++;\n        return o;\n    }\n    public function addAll(x:ZPP_CallbackSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x!=null;\n            };\n            if(!res)throw \"assert(\"+\"x!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] addAll -> \"+x);\n            #end\n        };\n        {\n            var cx_ite=x.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function insert(cur:ZPP_CallbackSet,o:ZPP_CallbackSet):ZPP_CallbackSet{\n        return inlined_insert(cur,o);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_insert(cur:ZPP_CallbackSet,o:ZPP_CallbackSet):ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o!=null&&!has(o);\n            };\n            if(!res)throw \"assert(\"+\"o!=null&&!has(o)\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] cur -> \"+cur+\" -> \"+o);\n            #end\n        };\n        var temp={\n            o._inuse=true;\n            o;\n        };\n        if(cur==null){\n            temp.next=begin();\n            next=temp;\n        }\n        else{\n            temp.next=cur.next;\n            cur.next=temp;\n        }\n        pushmod=modified=true;\n        length++;\n        return temp;\n    }\n    public function pop():Void{\n        inlined_pop();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop():Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] pop\");\n            #end\n        };\n        var ret=begin();\n        next=ret.next;\n        {\n            ret.elem()._inuse=false;\n        };\n        {};\n        if(empty())pushmod=true;\n        modified=true;\n        length--;\n    }\n    public function pop_unsafe():ZPP_CallbackSet{\n        return inlined_pop_unsafe();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_pop_unsafe():ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] pop_unsafe\");\n            #end\n        };\n        var ret=front();\n        pop();\n        return ret;\n    }\n    public function remove(obj:ZPP_CallbackSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    public function try_remove(obj:ZPP_CallbackSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_remove(obj:ZPP_CallbackSet):Void{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"removed but didn't exist\");\n            #end\n        };\n        inlined_try_remove(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_try_remove(obj:ZPP_CallbackSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] remove -> \"+obj);\n            #end\n        };\n        var pre=null;\n        var cur=begin();\n        var ret=false;\n        while(cur!=null){\n            if(cur.elem()==obj){\n                inlined_erase(pre);\n                ret=true;\n                break;\n            }\n            pre=cur;\n            cur=cur.next;\n        }\n        return ret;\n    }\n    public function erase(pre:ZPP_CallbackSet):ZPP_CallbackSet{\n        return inlined_erase(pre);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_erase(pre:ZPP_CallbackSet):ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] erase -> \"+pre);\n            #end\n        };\n        var old:ZPP_CallbackSet;\n        var ret:ZPP_CallbackSet;\n        if(pre==null){\n            old=begin();\n            ret=old.next;\n            next=ret;\n            if(empty())pushmod=true;\n        }\n        else{\n            old=pre.next;\n            ret=old.next;\n            pre.next=ret;\n            if(ret==null)pushmod=true;\n        }\n        {\n            old.elem()._inuse=false;\n        };\n        {};\n        modified=true;\n        length--;\n        pushmod=true;\n        return ret;\n    }\n    public function splice(pre:ZPP_CallbackSet,n:Int):ZPP_CallbackSet{\n        while(n-->0&&pre.next!=null)erase(pre);\n        return pre.next;\n    }\n    public function clear():Void{\n        inlined_clear();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_clear():Void{\n        if(false){\n            while(!empty())inlined_pop();\n            pushmod=true;\n        }\n    }\n    public function reverse():Void{\n        var cur=begin();\n        var pre=null;\n        while(cur!=null){\n            var nx=cur.next;\n            cur.next=pre;\n            next=cur;\n            pre=cur;\n            cur=nx;\n        }\n        modified=true;\n        pushmod=true;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function empty():Bool{\n        return begin()==null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function size():Int{\n        return length;\n    }\n    public function has(obj:ZPP_CallbackSet):Bool{\n        return inlined_has(obj);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_has(obj:ZPP_CallbackSet):Bool{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                obj!=null;\n            };\n            if(!res)throw \"assert(\"+\"obj!=null\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] has -> \"+obj);\n            #end\n        };\n        var ret;\n        {\n            ret=false;\n            {\n                var cx_ite=this.begin();\n                while(cx_ite!=null){\n                    var npite=cx_ite.elem();\n                    {\n                        if(npite==obj){\n                            ret=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function front():ZPP_CallbackSet{\n        return begin().elem();\n    }\n    public function back():ZPP_CallbackSet{\n        var ret=begin();\n        var cur=ret;\n        while(cur!=null){\n            ret=cur;\n            cur=cur.next;\n        }\n        return ret.elem();\n    }\n    public function iterator_at(ind:Int):ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=-1&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=-1&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] iterator_at -> \"+ind);\n            #end\n        };\n        var ret=begin();\n        while(ind-->0&&ret!=null)ret=ret.next;\n        return ret;\n    }\n    public function at(ind:Int):ZPP_CallbackSet{\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                ind>=0&&ind<size();\n            };\n            if(!res)throw \"assert(\"+\"ind>=0&&ind<size()\"+\") :: \"+(\"[ListMixin(\"+\"ZPP_CallbackSet\"+\"] at -> \"+ind);\n            #end\n        };\n        var it=iterator_at(ind);\n        return if(it!=null)it.elem()else null;\n    }\n    static public var zpp_pool:ZPP_CallbackSet=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var freed:Bool=false;\n    public var lazydel:Bool=false;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        int1=int2=null;\n        id=di=-1;\n        freed=true;\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                arbiters.empty();\n            };\n            if(!res)throw \"assert(\"+\"arbiters.empty()\"+\") :: \"+(\"callbackset released with lingering arbs\");\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){\n        freed=false;\n        lazydel=false;\n        \n        COLLISIONstate=ZPP_Flags.id_PreFlag_ACCEPT;\n        COLLISIONstamp=0;\n        SENSORstate=ZPP_Flags.id_PreFlag_ACCEPT;\n        SENSORstamp=0;\n        FLUIDstate=ZPP_Flags.id_PreFlag_ACCEPT;\n        FLUIDstamp=0;\n    }\n    public function new(){\n        arbiters=new ZNPList_ZPP_Arbiter();\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function add_arb(x:ZPP_Arbiter){\n        if(!arbiters.inlined_has(x)){\n            arbiters.inlined_add(x);\n            return true;\n        }\n        else return false;\n    }\n    public function try_remove_arb(x:ZPP_Arbiter){\n        return arbiters.inlined_try_remove(x);\n    }\n    public function remove_arb(x:ZPP_Arbiter){\n        arbiters.inlined_remove(x);\n    }\n    public function empty_arb(type:Int){\n        var retvar;\n        {\n            retvar=true;\n            {\n                var cx_ite=arbiters.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if((x.type&type)==0){\n                            {\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                        }\n                        else{\n                            retvar=false;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return retvar;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function really_empty(){\n        return arbiters.empty();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function sleeping(){\n        var ret;\n        {\n            ret=true;\n            {\n                var cx_ite=arbiters.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        if(x.sleeping){\n                            {\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                        }\n                        else{\n                            ret=false;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        return ret;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_CbSetManager{\n    public var cbsets:ZPP_Set_ZPP_CbSet=null;\n    public var space:ZPP_Space=null;\n    public function get(cbTypes:ZNPList_ZPP_CbType){\n        if(cbTypes.empty())return null;\n        #if NAPE_ASSERT ZPP_CbSet.assert_cbTypes(cbTypes);\n        #end\n        var fake;\n        {\n            if(ZPP_CbSet.zpp_pool==null){\n                fake=new ZPP_CbSet();\n                #if NAPE_POOL_STATS ZPP_CbSet.POOL_TOT++;\n                ZPP_CbSet.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                fake=ZPP_CbSet.zpp_pool;\n                ZPP_CbSet.zpp_pool=fake.next;\n                fake.next=null;\n                #if NAPE_POOL_STATS ZPP_CbSet.POOL_CNT--;\n                ZPP_CbSet.POOL_ADD++;\n                #end\n            }\n            fake.alloc();\n        };\n        var faketypes=fake.cbTypes;\n        fake.cbTypes=cbTypes;\n        var res=cbsets.find_weak(fake);\n        var ret=if(res!=null)res.data else{\n            var set=ZPP_CbSet.get(cbTypes);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !cbsets.has_weak(set);\n                };\n                if(!res)throw \"assert(\"+\"!cbsets.has_weak(set)\"+\") :: \"+(\"CbSet exists in Set already, but not found??\");\n                #end\n            };\n            cbsets.insert(set);\n            set.manager=this;\n            set;\n        }\n        fake.cbTypes=faketypes;\n        {\n            var o=fake;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_CbSet\"+\", in obj: \"+\"fake\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_CbSet.zpp_pool;\n            ZPP_CbSet.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_CbSet.POOL_CNT++;\n            ZPP_CbSet.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function remove(set:ZPP_CbSet){\n        cbsets.remove(set);\n        {\n            while(!set.cbpairs.empty()){\n                var pair=set.cbpairs.pop_unsafe();\n                {\n                    if(pair.a!=pair.b){\n                        if(set==pair.a)pair.b.cbpairs.remove(pair);\n                        else pair.a.cbpairs.remove(pair);\n                    }\n                    {\n                        var o=pair;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                o!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_CbSetPair\"+\", in obj: \"+\"pair\"+\")\");\n                            #end\n                        };\n                        o.free();\n                        o.next=ZPP_CbSetPair.zpp_pool;\n                        ZPP_CbSetPair.zpp_pool=o;\n                        #if NAPE_POOL_STATS ZPP_CbSetPair.POOL_CNT++;\n                        ZPP_CbSetPair.POOL_SUB++;\n                        #end\n                    };\n                };\n            }\n        };\n        set.manager=null;\n    }\n    public function clear(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cbsets.empty();\n            };\n            if(!res)throw \"assert(\"+\"cbsets.empty()\"+\") :: \"+(\"space cleared, called setmanager clear(), and tree was non-empty. wuh\");\n            #end\n        };\n    }\n    public function new(space:ZPP_Space){\n        {\n            if(ZPP_Set_ZPP_CbSet.zpp_pool==null){\n                cbsets=new ZPP_Set_ZPP_CbSet();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_TOT++;\n                ZPP_Set_ZPP_CbSet.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                cbsets=ZPP_Set_ZPP_CbSet.zpp_pool;\n                ZPP_Set_ZPP_CbSet.zpp_pool=cbsets.next;\n                cbsets.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT--;\n                ZPP_Set_ZPP_CbSet.POOL_ADD++;\n                #end\n            }\n            cbsets.alloc();\n        };\n        cbsets.lt=ZPP_CbSet.setlt;\n        this.space=space;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function validate(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    cbsets!=null;\n                };\n                if(!res)throw \"assert(\"+\"cbsets!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!cbsets.empty()){\n                var set_ite=cbsets.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var cb=set_ite.data;\n                    cb.validate();\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function pair(a:ZPP_CbSet,b:ZPP_CbSet){\n        var ret:ZPP_CbSetPair=null;\n        var pairs=if(a.cbpairs.length<b.cbpairs.length)a.cbpairs else b.cbpairs;\n        {\n            var cx_ite=pairs.begin();\n            while(cx_ite!=null){\n                var p=cx_ite.elem();\n                {\n                    if((p.a==a&&p.b==b)||(p.a==b&&p.b==a)){\n                        ret=p;\n                        break;\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(ret==null){\n            ret=ZPP_CbSetPair.get(a,b);\n            a.cbpairs.add(ret);\n            if(b!=a)b.cbpairs.add(ret);\n        }\n        ret.validate();\n        return ret;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function valid_listener(i:ZPP_Listener){\n        return i.space==this.space;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Space{\n    public var outer:Space=null;\n    public var userData:Dynamic<Dynamic>=null;\n    public var gravityx:Float=0.0;\n    public var gravityy:Float=0.0;\n    public var wrap_gravity:Vec2=null;\n    public function getgravity(){\n        wrap_gravity=Vec2.get(gravityx,gravityy);\n        wrap_gravity.zpp_inner._inuse=true;\n        wrap_gravity.zpp_inner._invalidate=gravity_invalidate;\n        wrap_gravity.zpp_inner._validate=gravity_validate;\n    }\n    private function gravity_invalidate(x:ZPP_Vec2){\n        #if(!NAPE_RELEASE_BUILD)\n        if(midstep)throw \"Error: Space::gravity cannot be set during space step\";\n        #end\n        {\n            gravityx=x.x;\n            gravityy=x.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((gravityx!=gravityx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(gravityx)\"+\") :: \"+(\"vec_set(in n: \"+\"gravity\"+\",in x: \"+\"x.x\"+\",in y: \"+\"x.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((gravityy!=gravityy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(gravityy)\"+\") :: \"+(\"vec_set(in n: \"+\"gravity\"+\",in x: \"+\"x.x\"+\",in y: \"+\"x.y\"+\")\");\n                #end\n            };\n        };\n        var stack=new ZNPList_ZPP_Compound();\n        {\n            var cx_ite=bodies.begin();\n            while(cx_ite!=null){\n                var x=cx_ite.elem();\n                {\n                    var o=x;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o.space==this;\n                        };\n                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                        #end\n                    };\n                    if(!o.world){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                o.component!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                            #end\n                        };\n                        o.component.waket=stamp+(midstep?0:1);\n                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                        if(o.component.sleeping){\n                            really_wake(o,false);\n                        }\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=compounds.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                stack.add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        while(!stack.empty()){\n            var s=stack.pop_unsafe();\n            {\n                var cx_ite=s.bodies.begin();\n                while(cx_ite!=null){\n                    var x=cx_ite.elem();\n                    {\n                        var o=x;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                o.space==this;\n                            };\n                            if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                            #end\n                        };\n                        if(!o.world){\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    o.component!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                #end\n                            };\n                            o.component.waket=stamp+(midstep?0:1);\n                            if(o.isKinematic())o.kinematicDelaySleep=true;\n                            if(o.component.sleeping){\n                                really_wake(o,false);\n                            }\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var cx_ite=s.compounds.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    stack.add(i);\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n    }\n    private function gravity_validate(){\n        {\n            wrap_gravity.zpp_inner.x=gravityx;\n            wrap_gravity.zpp_inner.y=gravityy;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_gravity.zpp_inner.x!=wrap_gravity.zpp_inner.x));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_gravity.zpp_inner.x)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_gravity.zpp_inner.\"+\",in x: \"+\"gravityx\"+\",in y: \"+\"gravityy\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((wrap_gravity.zpp_inner.y!=wrap_gravity.zpp_inner.y));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(wrap_gravity.zpp_inner.y)\"+\") :: \"+(\"vec_set(in n: \"+\"wrap_gravity.zpp_inner.\"+\",in x: \"+\"gravityx\"+\",in y: \"+\"gravityy\"+\")\");\n                #end\n            };\n        };\n    }\n    public var bodies:ZNPList_ZPP_Body=null;\n    public var wrap_bodies:BodyList=null;\n    public var compounds:ZNPList_ZPP_Compound=null;\n    public var wrap_compounds:CompoundList=null;\n    public var constraints:ZNPList_ZPP_Constraint=null;\n    public var wrap_constraints:ConstraintList=null;\n    public var kinematics:ZNPList_ZPP_Body=null;\n    public var bphase:ZPP_Broadphase=null;\n    public var __static:Body=null;\n    public var global_lin_drag:Float=0.0;\n    public var global_ang_drag:Float=0.0;\n    public var stamp:Int=0;\n    public var midstep:Bool=false;\n    public var time:Float=0.0;\n    public var sortcontacts:Bool=false;\n    \n    public var c_arbiters_true:ZNPList_ZPP_ColArbiter=null;\n    public var c_arbiters_false:ZNPList_ZPP_ColArbiter=null;\n    public var f_arbiters:ZNPList_ZPP_FluidArbiter=null;\n    public var s_arbiters:ZNPList_ZPP_SensorArbiter=null;\n    public var wrap_arbiters:ArbiterList=null;\n    public var live:ZNPList_ZPP_Body=null;\n    public var wrap_live:BodyList=null;\n    public var live_constraints:ZNPList_ZPP_Constraint=null;\n    public var wrap_livecon:ConstraintList=null;\n    public var staticsleep:ZNPList_ZPP_Body=null;\n    public var islands:ZPP_Island=null;\n    public var listeners:ZNPList_ZPP_Listener=null;\n    public var wrap_listeners:ListenerList=null;\n    public var callbacks:ZPP_Callback=null;\n    public var callbackset_list:ZPP_CallbackSet=null;\n    public var cbsets:ZPP_CbSetManager=null;\n    public function clear(){\n        {\n            while(!listeners.empty()){\n                var c=listeners.pop_unsafe();\n                remListener(c);\n            }\n        };\n        {\n            while(!callbackset_list.empty()){\n                var c=callbackset_list.pop_unsafe();\n                {\n                    c.arbiters.clear();\n                    {\n                        var o=c;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                o!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_CallbackSet\"+\", in obj: \"+\"c\"+\")\");\n                            #end\n                        };\n                        o.free();\n                        o.next=ZPP_CallbackSet.zpp_pool;\n                        ZPP_CallbackSet.zpp_pool=o;\n                        #if NAPE_POOL_STATS ZPP_CallbackSet.POOL_CNT++;\n                        ZPP_CallbackSet.POOL_SUB++;\n                        #end\n                    };\n                };\n            }\n        };\n        {\n            while(!c_arbiters_true.empty()){\n                var arb=c_arbiters_true.pop_unsafe();\n                arb.retire();\n            }\n        };\n        {\n            while(!c_arbiters_false.empty()){\n                var arb=c_arbiters_false.pop_unsafe();\n                arb.retire();\n            }\n        };\n        {\n            while(!s_arbiters.empty()){\n                var arb=s_arbiters.pop_unsafe();\n                arb.retire();\n            }\n        };\n        {\n            while(!f_arbiters.empty()){\n                var arb=f_arbiters.pop_unsafe();\n                arb.retire();\n            }\n        };\n        bphase.clear();\n        {\n            while(!bodies.empty()){\n                var b=bodies.pop_unsafe();\n                {\n                    {\n                        if(b.component!=null){\n                            var i=b.component.island;\n                            if(i!=null){\n                                {\n                                    while(!i.comps.empty()){\n                                        var c=i.comps.pop_unsafe();\n                                        c.reset();\n                                    }\n                                };\n                                {\n                                    var o=i;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o!=null;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Island\"+\", in obj: \"+\"i\"+\")\");\n                                        #end\n                                    };\n                                    o.free();\n                                    o.next=ZPP_Island.zpp_pool;\n                                    ZPP_Island.zpp_pool=o;\n                                    #if NAPE_POOL_STATS ZPP_Island.POOL_CNT++;\n                                    ZPP_Island.POOL_SUB++;\n                                    #end\n                                };\n                            }\n                        }\n                    };\n                    b.removedFromSpace();\n                    b.space=null;\n                };\n            }\n        };\n        {\n            while(!constraints.empty()){\n                var c=constraints.pop_unsafe();\n                {\n                    {\n                        if(c.component!=null){\n                            var i=c.component.island;\n                            if(i!=null){\n                                {\n                                    while(!i.comps.empty()){\n                                        var c=i.comps.pop_unsafe();\n                                        c.reset();\n                                    }\n                                };\n                                {\n                                    var o=i;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o!=null;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Island\"+\", in obj: \"+\"i\"+\")\");\n                                        #end\n                                    };\n                                    o.free();\n                                    o.next=ZPP_Island.zpp_pool;\n                                    ZPP_Island.zpp_pool=o;\n                                    #if NAPE_POOL_STATS ZPP_Island.POOL_CNT++;\n                                    ZPP_Island.POOL_SUB++;\n                                    #end\n                                };\n                            }\n                        }\n                    };\n                    c.removedFromSpace();\n                    c.space=null;\n                };\n            }\n        };\n        kinematics.clear();\n        var stack=new ZNPList_ZPP_Compound();\n        {\n            while(!compounds.empty()){\n                var c=compounds.pop_unsafe();\n                stack.add(c);\n            }\n        };\n        while(!stack.empty()){\n            var comp=stack.pop_unsafe();\n            comp.removedFromSpace();\n            comp.space=null;\n            {\n                var cx_ite=comp.bodies.begin();\n                while(cx_ite!=null){\n                    var b=cx_ite.elem();\n                    {\n                        {\n                            if(b.component!=null){\n                                var i=b.component.island;\n                                if(i!=null){\n                                    {\n                                        while(!i.comps.empty()){\n                                            var c=i.comps.pop_unsafe();\n                                            c.reset();\n                                        }\n                                    };\n                                    {\n                                        var o=i;\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Island\"+\", in obj: \"+\"i\"+\")\");\n                                            #end\n                                        };\n                                        o.free();\n                                        o.next=ZPP_Island.zpp_pool;\n                                        ZPP_Island.zpp_pool=o;\n                                        #if NAPE_POOL_STATS ZPP_Island.POOL_CNT++;\n                                        ZPP_Island.POOL_SUB++;\n                                        #end\n                                    };\n                                }\n                            }\n                        };\n                        b.removedFromSpace();\n                        b.space=null;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var cx_ite=comp.constraints.begin();\n                while(cx_ite!=null){\n                    var c=cx_ite.elem();\n                    {\n                        {\n                            if(c.component!=null){\n                                var i=c.component.island;\n                                if(i!=null){\n                                    {\n                                        while(!i.comps.empty()){\n                                            var c=i.comps.pop_unsafe();\n                                            c.reset();\n                                        }\n                                    };\n                                    {\n                                        var o=i;\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Island\"+\", in obj: \"+\"i\"+\")\");\n                                            #end\n                                        };\n                                        o.free();\n                                        o.next=ZPP_Island.zpp_pool;\n                                        ZPP_Island.zpp_pool=o;\n                                        #if NAPE_POOL_STATS ZPP_Island.POOL_CNT++;\n                                        ZPP_Island.POOL_SUB++;\n                                        #end\n                                    };\n                                }\n                            }\n                        };\n                        c.removedFromSpace();\n                        c.space=null;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var cx_ite=comp.compounds.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    stack.add(i);\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                islands.empty();\n            };\n            if(!res)throw \"assert(\"+\"islands.empty()\"+\") :: \"+(\"islands exist... wuh?\");\n            #end\n        };\n        staticsleep.clear();\n        live.clear();\n        live_constraints.clear();\n        stamp=0;\n        time=0.0;\n        #if NAPE_TIMES Debug.FOR=Debug.BROAD=Debug.PRE=Debug.POS=Debug.VEL=Debug.DRAW=Debug.SORT=0;\n        Debug.ltime=0;\n        #end\n        mrca1.clear();\n        mrca2.clear();\n        prelisteners.clear();\n        cbsets.clear();\n    }\n    private function bodies_adder(x:Body){\n        #if(!NAPE_RELEASE_BUILD)\n        if(x.zpp_inner.compound!=null)throw \"Error: Cannot set the space of a Body belonging to a Compound, only the root Compound space can be set\";\n        #end\n        if(x.zpp_inner.space!=this){\n            if(x.zpp_inner.space!=null)x.zpp_inner.space.outer.bodies.remove(x);\n            addBody(x.zpp_inner);\n            return true;\n        }\n        else return false;\n    }\n    private function bodies_subber(x:Body){\n        remBody(x.zpp_inner);\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function bodies_modifiable(){\n        if(midstep)throw \"Error: Space::bodies cannot be set during space step()\";\n    }\n    #end\n    private function compounds_adder(x:Compound){\n        #if(!NAPE_RELEASE_BUILD)\n        if(x.zpp_inner.compound!=null)throw \"Error: Cannot set the space of an inner Compound, only the root Compound space can be set\";\n        #end\n        if(x.zpp_inner.space!=this){\n            if(x.zpp_inner.space!=null)x.zpp_inner.space.wrap_compounds.remove(x);\n            addCompound(x.zpp_inner);\n            return true;\n        }\n        else return false;\n    }\n    private function compounds_subber(x:Compound){\n        remCompound(x.zpp_inner);\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function compounds_modifiable(){\n        if(midstep)throw \"Error: Space::compounds cannot be set during space step()\";\n    }\n    #end\n    private function constraints_adder(x:Constraint){\n        #if(!NAPE_RELEASE_BUILD)\n        if(x.zpp_inner.compound!=null)throw \"Error: Cannot set the space of a Constraint belonging to a Compound, only the root Compound space can be set\";\n        #end\n        if(x.zpp_inner.space!=this){\n            if(x.zpp_inner.space!=null)x.zpp_inner.space.outer.constraints.remove(x);\n            this.addConstraint(x.zpp_inner);\n            return true;\n        }\n        else return false;\n    }\n    private function constraints_subber(x:Constraint){\n        remConstraint(x.zpp_inner);\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function constraints_modifiable(){\n        if(midstep)throw \"Error: Space::constraints cannot be set during space step()\";\n    }\n    #end\n    private function listeners_adder(x:Listener){\n        if(x.zpp_inner.space!=this){\n            if(x.zpp_inner.space!=null)x.zpp_inner.space.outer.listeners.remove(x);\n            addListener(x.zpp_inner);\n            return true;\n        }\n        else return false;\n    }\n    private function listeners_subber(x:Listener){\n        remListener(x.zpp_inner);\n    }\n    #if(!NAPE_RELEASE_BUILD)\n    private function listeners_modifiable(){\n        if(midstep)throw \"Error: Space::listeners cannot be set during space step()\";\n    }\n    #end\n    public function new(gravity:ZPP_Vec2,broadphase:Broadphase){\n        toiEvents=new ZNPList_ZPP_ToiEvent();\n        global_lin_drag=0.015;\n        global_ang_drag=0.015;\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Callback.internal=true;\n        #end\n        precb=new PreCallback();\n        precb.zpp_inner=new ZPP_Callback();\n        #if(!NAPE_RELEASE_BUILD)\n        ZPP_Callback.internal=false;\n        #end\n        sortcontacts=true;\n        pre_dt=0.0;\n        if(broadphase==null||broadphase==Broadphase.DYNAMIC_AABB_TREE)bphase=new ZPP_DynAABBPhase(this);\n        else if(broadphase==Broadphase.SWEEP_AND_PRUNE)bphase=new ZPP_SweepPhase(this);\n        time=0.0;\n        var me=this;\n        if(gravity!=null){\n            this.gravityx=gravity.x;\n            this.gravityy=gravity.y;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.gravityx!=this.gravityx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.gravityx)\"+\") :: \"+(\"vec_set(in n: \"+\"this.gravity\"+\",in x: \"+\"gravity.x\"+\",in y: \"+\"gravity.y\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.gravityy!=this.gravityy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.gravityy)\"+\") :: \"+(\"vec_set(in n: \"+\"this.gravity\"+\",in x: \"+\"gravity.x\"+\",in y: \"+\"gravity.y\"+\")\");\n                #end\n            };\n        };\n        else{\n            this.gravityx=0;\n            this.gravityy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.gravityx!=this.gravityx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.gravityx)\"+\") :: \"+(\"vec_set(in n: \"+\"this.gravity\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((this.gravityy!=this.gravityy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(this.gravityy)\"+\") :: \"+(\"vec_set(in n: \"+\"this.gravity\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        bodies=new ZNPList_ZPP_Body();\n        wrap_bodies=ZPP_BodyList.get(bodies);\n        wrap_bodies.zpp_inner.adder=bodies_adder;\n        wrap_bodies.zpp_inner.subber=bodies_subber;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_bodies.zpp_inner._modifiable=bodies_modifiable;\n        #end\n        compounds=new ZNPList_ZPP_Compound();\n        wrap_compounds=ZPP_CompoundList.get(compounds);\n        wrap_compounds.zpp_inner.adder=compounds_adder;\n        wrap_compounds.zpp_inner.subber=compounds_subber;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_compounds.zpp_inner._modifiable=compounds_modifiable;\n        #end\n        kinematics=new ZNPList_ZPP_Body();\n        c_arbiters_true=new ZNPList_ZPP_ColArbiter();\n        c_arbiters_false=new ZNPList_ZPP_ColArbiter();\n        f_arbiters=new ZNPList_ZPP_FluidArbiter();\n        s_arbiters=new ZNPList_ZPP_SensorArbiter();\n        islands=new ZPP_Island();\n        live=new ZNPList_ZPP_Body();\n        wrap_live=ZPP_BodyList.get(live,true);\n        staticsleep=new ZNPList_ZPP_Body();\n        constraints=new ZNPList_ZPP_Constraint();\n        wrap_constraints=ZPP_ConstraintList.get(constraints);\n        wrap_constraints.zpp_inner.adder=constraints_adder;\n        wrap_constraints.zpp_inner.subber=constraints_subber;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_constraints.zpp_inner._modifiable=constraints_modifiable;\n        #end\n        live_constraints=new ZNPList_ZPP_Constraint();\n        wrap_livecon=ZPP_ConstraintList.get(live_constraints,true);\n        __static=ZPP_Body.__static();\n        __static.zpp_inner.space=this;\n        callbacks=new ZPP_Callback();\n        midstep=false;\n        listeners=new ZNPList_ZPP_Listener();\n        wrap_listeners=ZPP_ListenerList.get(listeners);\n        wrap_listeners.zpp_inner.adder=listeners_adder;\n        wrap_listeners.zpp_inner.subber=listeners_subber;\n        #if(!NAPE_RELEASE_BUILD)\n        wrap_listeners.zpp_inner._modifiable=listeners_modifiable;\n        #end\n        callbackset_list=new ZPP_CallbackSet();\n        mrca1=new ZNPList_ZPP_Interactor();\n        mrca2=new ZNPList_ZPP_Interactor();\n        prelisteners=new ZNPList_ZPP_InteractionListener();\n        cbsets=new ZPP_CbSetManager(this);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function revoke_listener(x:ZPP_InteractionListener){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function unrevoke_listener(x:ZPP_InteractionListener){}\n    public function addListener(x:ZPP_Listener){\n        x.space=this;\n        x.addedToSpace();\n        if(x.interaction!=null){\n            unrevoke_listener(x.interaction);\n        }\n    }\n    public function remListener(x:ZPP_Listener){\n        if(x.interaction!=null){\n            revoke_listener(x.interaction);\n        }\n        x.removedFromSpace();\n        x.space=null;\n    }\n    public function add_callbackset(cb:ZPP_CallbackSet){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !(cb.freed||cb.lazydel);\n            };\n            if(!res)throw \"assert(\"+\"!(cb.freed||cb.lazydel)\"+\") :: \"+(\"adding callbacket which is freed or lazydel??\");\n            #end\n        };\n        cb.int1.cbsets.inlined_add(cb);\n        cb.int2.cbsets.inlined_add(cb);\n        callbackset_list.inlined_add(cb);\n    }\n    public function remove_callbackset(cb:ZPP_CallbackSet){\n        cb.lazydel=true;\n        cb.int1.cbsets.inlined_remove(cb);\n        cb.int2.cbsets.inlined_remove(cb);\n    }\n    public function transmitType(p:ZPP_Body,new_type:Int){\n        {\n            var o=p;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o.space==this;\n                };\n                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                #end\n            };\n            if(!o.world){\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o.component!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                    #end\n                };\n                o.component.waket=stamp+(midstep?0:1);\n                if(o.isKinematic())o.kinematicDelaySleep=true;\n                if(o.component.sleeping){\n                    really_wake(o,false);\n                }\n            }\n        };\n        if(p.type==ZPP_Flags.id_BodyType_DYNAMIC){\n            live.remove(p);\n        }\n        else if(p.type==ZPP_Flags.id_BodyType_KINEMATIC){\n            kinematics.remove(p);\n            staticsleep.remove(p);\n        }\n        else if(p.type==ZPP_Flags.id_BodyType_STATIC){\n            staticsleep.remove(p);\n        }\n        p.type=new_type;\n        if(p.type==ZPP_Flags.id_BodyType_KINEMATIC)kinematics.add(p);\n        if(p.type==ZPP_Flags.id_BodyType_STATIC)static_validation(p);\n        p.component.sleeping=true;\n        {\n            var o=p;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o.space==this;\n                };\n                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                #end\n            };\n            if(!o.world){\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o.component!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                    #end\n                };\n                o.component.waket=stamp+(midstep?0:1);\n                if(o.isKinematic())o.kinematicDelaySleep=true;\n                if(o.component.sleeping){\n                    really_wake(o,true);\n                }\n            }\n        };\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function added_shape(s:ZPP_Shape,dontwake:Bool=false){\n        if(!dontwake){\n            {\n                var o=s.body;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o.space==this;\n                    };\n                    if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                    #end\n                };\n                if(!o.world){\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o.component!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                        #end\n                    };\n                    o.component.waket=stamp+(midstep?0:1);\n                    if(o.isKinematic())o.kinematicDelaySleep=true;\n                    if(o.component.sleeping){\n                        really_wake(o,false);\n                    }\n                }\n            };\n        }\n        bphase.insert(s);\n        s.addedToSpace();\n    }\n    public function removed_shape(s:ZPP_Shape,deleting=false){\n        var body=s.body;\n        if(!deleting){\n            body.wake();\n        }\n        var pre=null;\n        {\n            var cx_ite=body.arbiters.begin();\n            while(cx_ite!=null){\n                var xarb=cx_ite.elem();\n                {\n                    var rem=xarb.ws1==s||xarb.ws2==s;\n                    if(rem){\n                        if(xarb.present!=0){\n                            MRCA_chains(xarb.ws1,xarb.ws2);\n                            {\n                                var cx_ite=mrca1.begin();\n                                while(cx_ite!=null){\n                                    var i1=cx_ite.elem();\n                                    {\n                                        {\n                                            var cx_ite=mrca2.begin();\n                                            while(cx_ite!=null){\n                                                var i2=cx_ite.elem();\n                                                {\n                                                    var cb1=i1.cbSet;\n                                                    var cb2=i2.cbSet;\n                                                    {\n                                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                        var res={\n                                                            cb1!=null&&cb2!=null;\n                                                        };\n                                                        if(!res)throw \"assert(\"+\"cb1!=null&&cb2!=null\"+\") :: \"+(\"null cbsets from MRCA_chains?\");\n                                                        #end\n                                                    };\n                                                    cb1.validate();\n                                                    cb2.validate();\n                                                    if(ZPP_CbSet.empty_intersection(cb1,cb2)){\n                                                        cx_ite=cx_ite.next;\n                                                        continue;\n                                                    };\n                                                    var callbackset=ZPP_Interactor.get(i1,i2);\n                                                    {\n                                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                        var res={\n                                                            callbackset!=null;\n                                                        };\n                                                        if(!res)throw \"assert(\"+\"callbackset!=null\"+\") :: \"+(\"null callbackset on arbiter deletion?\");\n                                                        #end\n                                                    };\n                                                    callbackset.remove_arb(xarb);\n                                                    xarb.present--;\n                                                    ZPP_CbSet.find_all(cb1,cb2,ZPP_Flags.id_CbEvent_END,function(listener:ZPP_InteractionListener){\n                                                        if((listener.itype&xarb.type)!=0&&callbackset.empty_arb(listener.itype)){\n                                                            var cb=push_callback(listener);\n                                                            cb.event=ZPP_Flags.id_CbEvent_END;\n                                                            ZPP_Interactor.int_callback(callbackset,listener,cb);\n                                                            cb.set=callbackset;\n                                                        }\n                                                    });\n                                                    if(callbackset.really_empty()){\n                                                        remove_callbackset(callbackset);\n                                                    }\n                                                };\n                                                cx_ite=cx_ite.next;\n                                            }\n                                        };\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    xarb.present>=0;\n                                };\n                                if(!res)throw \"assert(\"+\"xarb.present>=0\"+\") :: \"+(\"xarb present < 0?\");\n                                #end\n                            };\n                        }\n                        if(xarb.b1!=body&&xarb.b1.isDynamic()){\n                            var o=xarb.b1;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    o.space==this;\n                                };\n                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                #end\n                            };\n                            if(!o.world){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        o.component!=null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                    #end\n                                };\n                                o.component.waket=stamp+(midstep?0:1);\n                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                if(o.component.sleeping){\n                                    really_wake(o,false);\n                                }\n                            }\n                        };\n                        if(xarb.b2!=body&&xarb.b2.isDynamic()){\n                            var o=xarb.b2;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    o.space==this;\n                                };\n                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                #end\n                            };\n                            if(!o.world){\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        o.component!=null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                    #end\n                                };\n                                o.component.waket=stamp+(midstep?0:1);\n                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                if(o.component.sleeping){\n                                    really_wake(o,false);\n                                }\n                            }\n                        };\n                        xarb.lazyRetire(this,body);\n                        cx_ite=body.arbiters.erase(pre);\n                        continue;\n                    }\n                    pre=cx_ite;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        bphase.remove(s);\n        s.removedFromSpace();\n    }\n    public function addConstraint(con:ZPP_Constraint){\n        con.space=this;\n        con.addedToSpace();\n        if(con.active){\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    con.component.island==null;\n                };\n                if(!res)throw \"assert(\"+\"con.component.island==null\"+\") :: \"+(\"newly added constraint has an island??\");\n                #end\n            };\n            con.component.sleeping=true;\n            wake_constraint(con,true);\n        }\n    }\n    public function remConstraint(con:ZPP_Constraint){\n        if(con.active){\n            wake_constraint(con,true);\n            live_constraints.remove(con);\n        }\n        con.removedFromSpace();\n        con.space=null;\n    }\n    public function addCompound(x:ZPP_Compound){\n        x.space=this;\n        x.addedToSpace();\n        {\n            var cx_ite=x.bodies.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                addBody(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=x.constraints.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                addConstraint(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=x.compounds.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                addCompound(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function remCompound(x:ZPP_Compound){\n        {\n            var cx_ite=x.bodies.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                remBody(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=x.constraints.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                remConstraint(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=x.compounds.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                remCompound(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        x.removedFromSpace();\n        x.space=null;\n    }\n    public function addBody(body:ZPP_Body,flag:Int=-1){\n        body.space=this;\n        body.addedToSpace();\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                body.component.island==null;\n            };\n            if(!res)throw \"assert(\"+\"body.component.island==null\"+\") :: \"+(\"newly added body has an island??\");\n            #end\n        };\n        body.component.sleeping=true;\n        {\n            var o=body;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o.space==this;\n                };\n                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                #end\n            };\n            if(!o.world){\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o.component!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                    #end\n                };\n                o.component.waket=stamp+(midstep?0:1);\n                if(o.isKinematic())o.kinematicDelaySleep=true;\n                if(o.component.sleeping){\n                    really_wake(o,true);\n                }\n            }\n        };\n        {\n            var cx_ite=body.shapes.begin();\n            while(cx_ite!=null){\n                var shape=cx_ite.elem();\n                added_shape(shape,true);\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(body.isStatic()){\n            static_validation(body);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    staticsleep.has(body);\n                };\n                if(!res)throw \"assert(\"+\"staticsleep.has(body)\"+\") :: \"+(\"a2b f=\"+flag);\n                #end\n            };\n        }\n        else{\n            if(body.isDynamic()){\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        live.has(body);\n                    };\n                    if(!res)throw \"assert(\"+\"live.has(body)\"+\") :: \"+(\"a4b f=\"+flag);\n                    #end\n                };\n            }\n            else{\n                if(flag!=ZPP_Flags.id_BodyType_KINEMATIC)kinematics.add(body);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        staticsleep.has(body);\n                    };\n                    if(!res)throw \"assert(\"+\"staticsleep.has(body)\"+\") :: \"+(\"a6b f=\"+flag);\n                    #end\n                };\n            }\n        }\n    }\n    public function remBody(body:ZPP_Body,flag:Int=-1){\n        if(body.isStatic()){\n            {\n                var o=body;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o.space==this;\n                    };\n                    if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                    #end\n                };\n                if(!o.world){\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o.component!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                        #end\n                    };\n                    o.component.waket=stamp+(midstep?0:1);\n                    if(o.isKinematic())o.kinematicDelaySleep=true;\n                    if(o.component.sleeping){\n                        really_wake(o,true);\n                    }\n                }\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !body.component.sleeping;\n                };\n                if(!res)throw \"assert(\"+\"!body.component.sleeping\"+\") :: \"+(\"as3\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    staticsleep.has(body);\n                };\n                if(!res)throw \"assert(\"+\"staticsleep.has(body)\"+\") :: \"+(\"as4\");\n                #end\n            };\n            staticsleep.remove(body);\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !staticsleep.has(body);\n                };\n                if(!res)throw \"assert(\"+\"!staticsleep.has(body)\"+\") :: \"+(\"e1\");\n                #end\n            };\n        }\n        else{\n            if(body.isDynamic()){\n                {\n                    var o=body;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o.space==this;\n                        };\n                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                        #end\n                    };\n                    if(!o.world){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                o.component!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                            #end\n                        };\n                        o.component.waket=stamp+(midstep?0:1);\n                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                        if(o.component.sleeping){\n                            really_wake(o,true);\n                        }\n                    }\n                };\n                live.remove(body);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !live.has(body);\n                    };\n                    if(!res)throw \"assert(\"+\"!live.has(body)\"+\") :: \"+(\"e3b\");\n                    #end\n                };\n            }\n            else{\n                if(flag!=ZPP_Flags.id_BodyType_KINEMATIC)kinematics.remove(body);\n                {\n                    var o=body;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o.space==this;\n                        };\n                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                        #end\n                    };\n                    if(!o.world){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                o.component!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                            #end\n                        };\n                        o.component.waket=stamp+(midstep?0:1);\n                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                        if(o.component.sleeping){\n                            really_wake(o,true);\n                        }\n                    }\n                };\n                staticsleep.remove(body);\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !staticsleep.has(body);\n                    };\n                    if(!res)throw \"assert(\"+\"!staticsleep.has(body)\"+\") :: \"+(\"e4\");\n                    #end\n                };\n            }\n        }\n        {\n            var cx_ite=body.shapes.begin();\n            while(cx_ite!=null){\n                var shape=cx_ite.elem();\n                removed_shape(shape,true);\n                cx_ite=cx_ite.next;\n            }\n        };\n        body.removedFromSpace();\n        body.space=null;\n    }\n    public function shapesUnderPoint(x:Float,y:Float,filter:ZPP_InteractionFilter,output:ShapeList){\n        return bphase.shapesUnderPoint(x,y,filter,output);\n    }\n    public function bodiesUnderPoint(x:Float,y:Float,filter:ZPP_InteractionFilter,output:BodyList){\n        return bphase.bodiesUnderPoint(x,y,filter,output);\n    }\n    public function shapesInAABB(aabb:AABB,strict:Bool,cont:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        return bphase.shapesInAABB(aabb.zpp_inner,strict,cont,filter,output);\n    }\n    public function bodiesInAABB(aabb:AABB,strict:Bool,cont:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        return bphase.bodiesInAABB(aabb.zpp_inner,strict,cont,filter,output);\n    }\n    public function shapesInCircle(pos:Vec2,rad:Float,cont:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        return bphase.shapesInCircle(pos.x,pos.y,rad,cont,filter,output);\n    }\n    public function bodiesInCircle(pos:Vec2,rad:Float,cont:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        return bphase.bodiesInCircle(pos.x,pos.y,rad,cont,filter,output);\n    }\n    public function shapesInShape(shape:ZPP_Shape,cont:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        return bphase.shapesInShape(shape,cont,filter,output);\n    }\n    public function bodiesInShape(shape:ZPP_Shape,cont:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        return bphase.bodiesInShape(shape,cont,filter,output);\n    }\n    public function rayCast(ray:Ray,inner:Bool,filter:InteractionFilter){\n        return bphase.rayCast(ray.zpp_inner,inner,filter==null?null:filter.zpp_inner);\n    }\n    public function rayMultiCast(ray:Ray,inner:Bool,filter:InteractionFilter,output:RayResultList){\n        return bphase.rayMultiCast(ray.zpp_inner,inner,filter==null?null:filter.zpp_inner,output);\n    }\n    var convexShapeList:ShapeList=null;\n    public function convexCast(shape:ZPP_Shape,deltaTime:Float,filter:InteractionFilter,dynamics:Bool){\n        var toi;\n        {\n            if(ZPP_ToiEvent.zpp_pool==null){\n                toi=new ZPP_ToiEvent();\n                #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_TOT++;\n                ZPP_ToiEvent.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                toi=ZPP_ToiEvent.zpp_pool;\n                ZPP_ToiEvent.zpp_pool=toi.next;\n                toi.next=null;\n                #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT--;\n                ZPP_ToiEvent.POOL_ADD++;\n                #end\n            }\n            toi.alloc();\n        };\n        prepareCast(shape);\n        var body=shape.body;\n        var prex=body.posx;\n        var prey=body.posy;\n        body.sweepTime=0;\n        body.sweep_angvel=body.angvel;\n        body.sweepIntegrate(deltaTime);\n        var postx=body.posx;\n        var posty=body.posy;\n        shape.validate_sweepRadius();\n        var rad=shape.sweepRadius;\n        var aabb;\n        {\n            if(ZPP_AABB.zpp_pool==null){\n                aabb=new ZPP_AABB();\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_TOT++;\n                ZPP_AABB.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                aabb=ZPP_AABB.zpp_pool;\n                ZPP_AABB.zpp_pool=aabb.next;\n                aabb.next=null;\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT--;\n                ZPP_AABB.POOL_ADD++;\n                #end\n            }\n            aabb.alloc();\n        };\n        aabb.minx=({\n            var x=prex;\n            var y=postx;\n            x<y?x:y;\n        })-rad;\n        aabb.maxx=({\n            var x=prex;\n            var y=postx;\n            x>y?x:y;\n        })+rad;\n        aabb.miny=({\n            var x=prey;\n            var y=posty;\n            x<y?x:y;\n        })-rad;\n        aabb.maxy=({\n            var x=prey;\n            var y=posty;\n            x>y?x:y;\n        })+rad;\n        var list=convexShapeList=bphase.shapesInAABB(aabb,false,false,filter==null?null:filter.zpp_inner,convexShapeList);\n        {\n            var o=aabb;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABB\"+\", in obj: \"+\"aabb\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_AABB.zpp_pool;\n            ZPP_AABB.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT++;\n            ZPP_AABB.POOL_SUB++;\n            #end\n        };\n        var minAxisx:Float=0.0;\n        var minAxisy:Float=0.0;\n        {\n            minAxisx=0;\n            minAxisy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((minAxisx!=minAxisx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(minAxisx)\"+\") :: \"+(\"vec_set(in n: \"+\"minAxis\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((minAxisy!=minAxisy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(minAxisy)\"+\") :: \"+(\"vec_set(in n: \"+\"minAxis\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        var minPosx:Float=0.0;\n        var minPosy:Float=0.0;\n        {\n            minPosx=0;\n            minPosy=0;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((minPosx!=minPosx));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(minPosx)\"+\") :: \"+(\"vec_set(in n: \"+\"minPos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !((minPosy!=minPosy));\n                };\n                if(!res)throw \"assert(\"+\"!assert_isNaN(minPosy)\"+\") :: \"+(\"vec_set(in n: \"+\"minPos\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                #end\n            };\n        };\n        var mins=null;\n        var mint=deltaTime+1;\n        for(s in list){\n            if(s!=shape.outer&&s.body!=body.outer){\n                toi.s1=shape;\n                toi.s2=s.zpp_inner;\n                if(dynamics){\n                    s.zpp_inner.validate_sweepRadius();\n                    s.body.zpp_inner.sweep_angvel=s.body.zpp_inner.angvel;\n                    s.body.zpp_inner.sweepTime=0;\n                    ZPP_SweepDistance.dynamicSweep(toi,deltaTime,0,0,true);\n                    s.body.zpp_inner.sweepIntegrate(0);\n                    s.body.zpp_inner.sweepValidate(s.zpp_inner);\n                }\n                else{\n                    ZPP_SweepDistance.staticSweep(toi,deltaTime,0,0);\n                }\n                toi.toi*=deltaTime;\n                if(toi.toi>0&&toi.toi<mint){\n                    mint=toi.toi;\n                    {\n                        minAxisx=toi.axis.x;\n                        minAxisy=toi.axis.y;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((minAxisx!=minAxisx));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(minAxisx)\"+\") :: \"+(\"vec_set(in n: \"+\"minAxis\"+\",in x: \"+\"toi.axis.x\"+\",in y: \"+\"toi.axis.y\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((minAxisy!=minAxisy));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(minAxisy)\"+\") :: \"+(\"vec_set(in n: \"+\"minAxis\"+\",in x: \"+\"toi.axis.x\"+\",in y: \"+\"toi.axis.y\"+\")\");\n                            #end\n                        };\n                    };\n                    {\n                        minPosx=toi.c2.x;\n                        minPosy=toi.c2.y;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((minPosx!=minPosx));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(minPosx)\"+\") :: \"+(\"vec_set(in n: \"+\"minPos\"+\",in x: \"+\"toi.c2.x\"+\",in y: \"+\"toi.c2.y\"+\")\");\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !((minPosy!=minPosy));\n                            };\n                            if(!res)throw \"assert(\"+\"!assert_isNaN(minPosy)\"+\") :: \"+(\"vec_set(in n: \"+\"minPos\"+\",in x: \"+\"toi.c2.x\"+\",in y: \"+\"toi.c2.y\"+\")\");\n                            #end\n                        };\n                    };\n                    mins=s;\n                }\n            }\n        }\n        list.clear();\n        {\n            var o=toi;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ToiEvent\"+\", in obj: \"+\"toi\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_ToiEvent.zpp_pool;\n            ZPP_ToiEvent.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT++;\n            ZPP_ToiEvent.POOL_SUB++;\n            #end\n        };\n        body.sweepIntegrate(0);\n        body.sweepValidate(shape);\n        if(mint<=deltaTime){\n            return ZPP_ConvexRayResult.getConvex(Vec2.get(-minAxisx,-minAxisy),Vec2.get(minPosx,minPosy),mint,mins);\n        }\n        else return null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    #if NAPE_NO_INLINE#else inline #end\n    function prepareCast(s:ZPP_Shape){\n        if(s.isCircle())s.circle.validate_worldCOM();\n        else s.polygon.validate_gaxi();\n    }\n    public function convexMultiCast(shape:ZPP_Shape,deltaTime:Float,filter:InteractionFilter,dynamics:Bool,output:ConvexResultList){\n        var toi;\n        {\n            if(ZPP_ToiEvent.zpp_pool==null){\n                toi=new ZPP_ToiEvent();\n                #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_TOT++;\n                ZPP_ToiEvent.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                toi=ZPP_ToiEvent.zpp_pool;\n                ZPP_ToiEvent.zpp_pool=toi.next;\n                toi.next=null;\n                #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT--;\n                ZPP_ToiEvent.POOL_ADD++;\n                #end\n            }\n            toi.alloc();\n        };\n        prepareCast(shape);\n        var body=shape.body;\n        var prex=body.posx;\n        var prey=body.posy;\n        body.sweepTime=0;\n        body.sweep_angvel=body.angvel;\n        body.sweepIntegrate(deltaTime);\n        var postx=body.posx;\n        var posty=body.posy;\n        shape.validate_sweepRadius();\n        var rad=shape.sweepRadius;\n        var aabb;\n        {\n            if(ZPP_AABB.zpp_pool==null){\n                aabb=new ZPP_AABB();\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_TOT++;\n                ZPP_AABB.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                aabb=ZPP_AABB.zpp_pool;\n                ZPP_AABB.zpp_pool=aabb.next;\n                aabb.next=null;\n                #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT--;\n                ZPP_AABB.POOL_ADD++;\n                #end\n            }\n            aabb.alloc();\n        };\n        aabb.minx=({\n            var x=prex;\n            var y=postx;\n            x<y?x:y;\n        })-rad;\n        aabb.maxx=({\n            var x=prex;\n            var y=postx;\n            x>y?x:y;\n        })+rad;\n        aabb.miny=({\n            var x=prey;\n            var y=posty;\n            x<y?x:y;\n        })-rad;\n        aabb.maxy=({\n            var x=prey;\n            var y=posty;\n            x>y?x:y;\n        })+rad;\n        var list=convexShapeList=bphase.shapesInAABB(aabb,false,false,filter==null?null:filter.zpp_inner,convexShapeList);\n        {\n            var o=aabb;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABB\"+\", in obj: \"+\"aabb\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_AABB.zpp_pool;\n            ZPP_AABB.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT++;\n            ZPP_AABB.POOL_SUB++;\n            #end\n        };\n        var ret=(output==null?new ConvexResultList():output);\n        for(s in list){\n            if(s!=shape.outer&&s.body!=body.outer){\n                toi.s1=shape;\n                toi.s2=s.zpp_inner;\n                if(dynamics){\n                    s.zpp_inner.validate_sweepRadius();\n                    s.body.zpp_inner.sweep_angvel=s.body.zpp_inner.angvel;\n                    s.body.zpp_inner.sweepTime=0;\n                    ZPP_SweepDistance.dynamicSweep(toi,deltaTime,0,0,true);\n                    s.body.zpp_inner.sweepIntegrate(0);\n                    s.body.zpp_inner.sweepValidate(s.zpp_inner);\n                }\n                else{\n                    ZPP_SweepDistance.staticSweep(toi,deltaTime,0,0);\n                }\n                toi.toi*=deltaTime;\n                if(toi.toi>0){\n                    var res=ZPP_ConvexRayResult.getConvex(Vec2.get(-toi.axis.x,-toi.axis.y),Vec2.get(toi.c2.x,toi.c2.y),toi.toi,s);\n                    {\n                        var pre=null;\n                        {\n                            var cx_ite=ret.zpp_inner.inner.begin();\n                            while(cx_ite!=null){\n                                var j=cx_ite.elem();\n                                {\n                                    if((res.toi<j.toi))break;\n                                    pre=cx_ite;\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                        ret.zpp_inner.inner.inlined_insert(pre,res);\n                    };\n                }\n            }\n        }\n        list.clear();\n        {\n            var o=toi;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ToiEvent\"+\", in obj: \"+\"toi\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_ToiEvent.zpp_pool;\n            ZPP_ToiEvent.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT++;\n            ZPP_ToiEvent.POOL_SUB++;\n            #end\n        };\n        body.sweepIntegrate(0);\n        body.sweepValidate(shape);\n        return ret;\n    }\n    public function push_callback(i:ZPP_Listener){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                i!=null;\n            };\n            if(!res)throw \"assert(\"+\"i!=null\"+\") :: \"+(\"null listenere for push_callback?\");\n            #end\n        };\n        var cb;\n        {\n            if(ZPP_Callback.zpp_pool==null){\n                cb=new ZPP_Callback();\n                #if NAPE_POOL_STATS ZPP_Callback.POOL_TOT++;\n                ZPP_Callback.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                cb=ZPP_Callback.zpp_pool;\n                ZPP_Callback.zpp_pool=cb.next;\n                cb.next=null;\n                #if NAPE_POOL_STATS ZPP_Callback.POOL_CNT--;\n                ZPP_Callback.POOL_ADD++;\n                #end\n            }\n            cb.alloc();\n        };\n        callbacks.push(cb);\n        cb.listener=i;\n        return cb;\n    }\n    public var pre_dt:Float=0.0;\n    public function step(deltaTime:Float,velocityIterations:Int,positionIterations:Int){\n        #if(!NAPE_RELEASE_BUILD)\n        if(midstep)throw \"Error: ... REALLY?? you're going to call space.step() inside of space.step()? COME ON!!\";\n        #end\n        time+=deltaTime;\n        pre_dt=deltaTime;\n        midstep=true;\n        stamp++;\n        #if NAPE_TIMES var pt=flash.Lib.getTimer();\n        #end\n        validation();\n        #if NAPE_TIMES Debug.VALID+=flash.Lib.getTimer()-pt;\n        #end\n        #if NAPE_TIMES var pt=flash.Lib.getTimer();\n        #end\n        bphase.broadphase(this,true);\n        #if NAPE_TIMES Debug.BROAD+=flash.Lib.getTimer()-pt;\n        #end\n        #if NAPE_TIMES Debug.ACNT=0;\n        Debug.AACNT=0;\n        Debug.CCNT=0;\n        Debug.ACCNT=0;\n        #end\n        #if NAPE_TIMES var pt=flash.Lib.getTimer();\n        #end\n        prestep(deltaTime);\n        #if NAPE_TIMES Debug.PRE+=flash.Lib.getTimer()-pt;\n        #end\n        #if NAPE_TIMES var pt=flash.Lib.getTimer();\n        #end\n        if(sortcontacts){\n            {\n                var xxlist=c_arbiters_false;\n                if(!xxlist.empty()&&xxlist.begin().next!=null){\n                    var head:ZNPNode_ZPP_ColArbiter=xxlist.begin();\n                    var tail:ZNPNode_ZPP_ColArbiter=null;\n                    var left:ZNPNode_ZPP_ColArbiter=null;\n                    var right:ZNPNode_ZPP_ColArbiter=null;\n                    var nxt:ZNPNode_ZPP_ColArbiter=null;\n                    var listSize=1;\n                    var numMerges:Int,leftSize:Int,rightSize:Int;\n                    do{\n                        numMerges=0;\n                        left=head;\n                        tail=head=null;\n                        while(left!=null){\n                            numMerges++;\n                            right=left;\n                            leftSize=0;\n                            rightSize=listSize;\n                            while(right!=null&&leftSize<listSize){\n                                leftSize++;\n                                right=right.next;\n                            }\n                            while(leftSize>0||(rightSize>0&&right!=null)){\n                                if(leftSize==0){\n                                    nxt=right;\n                                    right=right.next;\n                                    rightSize--;\n                                }\n                                else if(rightSize==0||right==null){\n                                    nxt=left;\n                                    left=left.next;\n                                    leftSize--;\n                                }\n                                else if({\n                                    if(left.elem().active&&right.elem().active)left.elem().oc1.dist<right.elem().oc1.dist else true;\n                                }){\n                                    nxt=left;\n                                    left=left.next;\n                                    leftSize--;\n                                }\n                                else{\n                                    nxt=right;\n                                    right=right.next;\n                                    rightSize--;\n                                }\n                                if(tail!=null)tail.next=nxt;\n                                else head=nxt;\n                                tail=nxt;\n                            }\n                            left=right;\n                        }\n                        tail.next=null;\n                        listSize<<=1;\n                    }\n                    while(numMerges>1);\n                    xxlist.setbegin(head);\n                }\n            };\n        }\n        #if NAPE_TIMES Debug.SORT+=flash.Lib.getTimer()-pt;\n        #end\n        updateVel(deltaTime);\n        warmStart();\n        #if NAPE_TIMES var pt=flash.Lib.getTimer();\n        #end\n        iterateVel(velocityIterations);\n        #if NAPE_TIMES Debug.VEL+=flash.Lib.getTimer()-pt;\n        #end\n        {\n            {\n                var cx_ite=kinematics.begin();\n                while(cx_ite!=null){\n                    var cur=cx_ite.elem();\n                    {\n                        {\n                            cur.pre_posx=cur.posx;\n                            cur.pre_posy=cur.posy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cur.pre_posx!=cur.pre_posx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cur.pre_posx)\"+\") :: \"+(\"vec_set(in n: \"+\"cur.pre_pos\"+\",in x: \"+\"cur.posx\"+\",in y: \"+\"cur.posy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cur.pre_posy!=cur.pre_posy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cur.pre_posy)\"+\") :: \"+(\"vec_set(in n: \"+\"cur.pre_pos\"+\",in x: \"+\"cur.posx\"+\",in y: \"+\"cur.posy\"+\")\");\n                                #end\n                            };\n                        };\n                        cur.pre_rot=cur.rot;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        {\n            {\n                var cx_ite=live.begin();\n                while(cx_ite!=null){\n                    var cur=cx_ite.elem();\n                    {\n                        {\n                            cur.pre_posx=cur.posx;\n                            cur.pre_posy=cur.posy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cur.pre_posx!=cur.pre_posx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cur.pre_posx)\"+\") :: \"+(\"vec_set(in n: \"+\"cur.pre_pos\"+\",in x: \"+\"cur.posx\"+\",in y: \"+\"cur.posy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cur.pre_posy!=cur.pre_posy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cur.pre_posy)\"+\") :: \"+(\"vec_set(in n: \"+\"cur.pre_pos\"+\",in x: \"+\"cur.posx\"+\",in y: \"+\"cur.posy\"+\")\");\n                                #end\n                            };\n                        };\n                        cur.pre_rot=cur.rot;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        updatePos(deltaTime);\n        continuous=true;\n        continuousCollisions(deltaTime);\n        continuous=false;\n        #if NAPE_TIMES var pt=flash.Lib.getTimer();\n        #end\n        iteratePos(positionIterations);\n        #if NAPE_TIMES Debug.POS+=flash.Lib.getTimer()-pt;\n        #end\n        {\n            {\n                var cx_ite=kinematics.begin();\n                while(cx_ite!=null){\n                    var cur=cx_ite.elem();\n                    {\n                        var upos=!(cur.posx==cur.pre_posx&&cur.posy==cur.pre_posy);\n                        var urot=cur.pre_rot!=cur.rot;\n                        if(upos)cur.invalidate_pos();\n                        if(urot)cur.invalidate_rot();\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        {\n            {\n                var cx_ite=live.begin();\n                while(cx_ite!=null){\n                    var cur=cx_ite.elem();\n                    {\n                        var upos=!(cur.posx==cur.pre_posx&&cur.posy==cur.pre_posy);\n                        var urot=cur.pre_rot!=cur.rot;\n                        if(upos)cur.invalidate_pos();\n                        if(urot)cur.invalidate_rot();\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        var pre=null;\n        {\n            var cx_ite=staticsleep.begin();\n            while(cx_ite!=null){\n                var b=cx_ite.elem();\n                {\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            !b.isDynamic();\n                        };\n                        if(!res)throw \"assert(\"+\"!b.isDynamic()\"+\") :: \"+(\"step :: swef static/kinematics\");\n                        #end\n                    };\n                    if(!b.isKinematic()||(b.velx==0&&b.vely==0&&b.angvel==0)){\n                        if(b.kinematicDelaySleep){\n                            b.kinematicDelaySleep=false;\n                            {\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                        }\n                        b.component.sleeping=true;\n                        cx_ite=staticsleep.inlined_erase(pre);\n                        continue;\n                    }\n                    pre=cx_ite;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        #if NAPE_TIMES var pt=flash.Lib.getTimer();\n        #end\n        doForests(deltaTime);\n        sleepArbiters();\n        #if NAPE_TIMES Debug.FOR+=flash.Lib.getTimer()-pt;\n        #end\n        midstep=false;\n        var pre=null;\n        {\n            var cx_ite=callbackset_list.begin();\n            while(cx_ite!=null){\n                var set=cx_ite.elem();\n                {\n                    if(set.really_empty()){\n                        cx_ite=callbackset_list.inlined_erase(pre);\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !set.int1.cbsets.has(set);\n                            };\n                            if(!res)throw \"assert(\"+\"!set.int1.cbsets.has(set)\"+\") :: \"+(\"freeing set that wasn't lazy del'ed \"+set.int1.id+\" \"+set.int2.id);\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                !set.int2.cbsets.has(set);\n                            };\n                            if(!res)throw \"assert(\"+\"!set.int2.cbsets.has(set)\"+\") :: \"+(\"freeing set that wasn't lazy del'ed \"+set.int1.id+\" \"+set.int2.id);\n                            #end\n                        };\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                set.lazydel;\n                            };\n                            if(!res)throw \"assert(\"+\"set.lazydel\"+\") :: \"+(\"freeing set not with lazydel true\");\n                            #end\n                        };\n                        {\n                            var o=set;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    o!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_CallbackSet\"+\", in obj: \"+\"set\"+\")\");\n                                #end\n                            };\n                            o.free();\n                            o.next=ZPP_CallbackSet.zpp_pool;\n                            ZPP_CallbackSet.zpp_pool=o;\n                            #if NAPE_POOL_STATS ZPP_CallbackSet.POOL_CNT++;\n                            ZPP_CallbackSet.POOL_SUB++;\n                            #end\n                        };\n                        continue;\n                    }\n                    var sleeping=set.sleeping();\n                    ZPP_CbSet.find_all(set.int1.cbSet,set.int2.cbSet,ZPP_Flags.id_CbEvent_ONGOING,function(x:ZPP_InteractionListener){\n                        if((!sleeping||x.allowSleepingCallbacks)&&!set.empty_arb(x.itype)){\n                            var cb=push_callback(x);\n                            cb.event=ZPP_Flags.id_CbEvent_ONGOING;\n                            ZPP_Interactor.int_callback(set,x,cb);\n                            cb.set=set;\n                        }\n                    });\n                    pre=cx_ite;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        while(!callbacks.empty()){\n            var cb=callbacks.pop();\n            if(cb.listener.type==ZPP_Flags.id_ListenerType_BODY){\n                var o=cb.listener.body;\n                o.handler(cb.wrapper_body());\n            }\n            else if(cb.listener.type==ZPP_Flags.id_ListenerType_CONSTRAINT){\n                var o=cb.listener.constraint;\n                o.handler(cb.wrapper_con());\n            }\n            else if(cb.listener.type==ZPP_Flags.id_ListenerType_INTERACTION){\n                var o=cb.listener.interaction;\n                o.handleri(cb.wrapper_int());\n            }\n            {\n                var o=cb;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Callback\"+\", in obj: \"+\"cb\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_Callback.zpp_pool;\n                ZPP_Callback.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_Callback.POOL_CNT++;\n                ZPP_Callback.POOL_SUB++;\n                #end\n            };\n        }\n    }\n    public var toiEvents:ZNPList_ZPP_ToiEvent=null;\n    public function continuousCollisions(deltaTime:Float){\n        var MAX_VEL=2*Math.PI/deltaTime;\n        bphase.broadphase(this,false);\n        var curTimeAlpha=0.0;\n        while(curTimeAlpha<1&&!toiEvents.empty()){\n            var minTOI:ZPP_ToiEvent=null;\n            var minTime=2.0;\n            var minKinematic=false;\n            var preMin:ZNPNode_ZPP_ToiEvent=null;\n            var pre:ZNPNode_ZPP_ToiEvent=null;\n            {\n                var cx_ite=toiEvents.begin();\n                while(cx_ite!=null){\n                    var toi=cx_ite.elem();\n                    {\n                        var b1=toi.s1.body;\n                        var b2=toi.s2.body;\n                        if(b1.sweepFrozen&&b2.sweepFrozen){\n                            if(toi.toi!=0&&ZPP_Collide.testCollide_safe(toi.s1,toi.s2)){\n                                toi.toi=0;\n                            }\n                            else{\n                                cx_ite=toiEvents.erase(pre);\n                                {\n                                    var o=toi;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o!=null;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ToiEvent\"+\", in obj: \"+\"toi\"+\")\");\n                                        #end\n                                    };\n                                    o.free();\n                                    o.next=ZPP_ToiEvent.zpp_pool;\n                                    ZPP_ToiEvent.zpp_pool=o;\n                                    #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT++;\n                                    ZPP_ToiEvent.POOL_SUB++;\n                                    #end\n                                };\n                                continue;\n                            }\n                        }\n                        if((toi.frozen1!=b1.sweepFrozen||toi.frozen2!=b2.sweepFrozen)){\n                            if(!toi.kinematic){\n                                toi.frozen1=b1.sweepFrozen;\n                                toi.frozen2=b2.sweepFrozen;\n                                if(toi.frozen1){\n                                    var tmp=toi.s1;\n                                    toi.s1=toi.s2;\n                                    toi.s2=tmp;\n                                    toi.frozen1=false;\n                                    toi.frozen2=true;\n                                }\n                                ZPP_SweepDistance.staticSweep(toi,deltaTime,0,Config.collisionSlopCCD);\n                                if(toi.toi<0){\n                                    cx_ite=toiEvents.erase(pre);\n                                    {\n                                        var o=toi;\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ToiEvent\"+\", in obj: \"+\"toi\"+\")\");\n                                            #end\n                                        };\n                                        o.free();\n                                        o.next=ZPP_ToiEvent.zpp_pool;\n                                        ZPP_ToiEvent.zpp_pool=o;\n                                        #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT++;\n                                        ZPP_ToiEvent.POOL_SUB++;\n                                        #end\n                                    };\n                                    continue;\n                                }\n                            }\n                            else{\n                                cx_ite=toiEvents.erase(pre);\n                                {\n                                    var o=toi;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o!=null;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ToiEvent\"+\", in obj: \"+\"toi\"+\")\");\n                                        #end\n                                    };\n                                    o.free();\n                                    o.next=ZPP_ToiEvent.zpp_pool;\n                                    ZPP_ToiEvent.zpp_pool=o;\n                                    #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT++;\n                                    ZPP_ToiEvent.POOL_SUB++;\n                                    #end\n                                };\n                                continue;\n                            }\n                        }\n                        if(toi.toi>=0&&(toi.toi<minTime||(!minKinematic&&toi.kinematic))){\n                            minTOI=toi;\n                            minTime=toi.toi;\n                            minKinematic=toi.kinematic;\n                            preMin=pre;\n                        }\n                        pre=cx_ite;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            if(minTOI==null){\n                break;\n            }\n            toiEvents.erase(preMin);\n            curTimeAlpha=minTOI.toi;\n            var b1=minTOI.s1.body;\n            var b2=minTOI.s2.body;\n            if(!b1.sweepFrozen){\n                b1.sweepIntegrate(curTimeAlpha*deltaTime);\n                b1.sweepValidate(minTOI.s1);\n            }\n            if(!b2.sweepFrozen){\n                b2.sweepIntegrate(curTimeAlpha*deltaTime);\n                b2.sweepValidate(minTOI.s2);\n            }\n            var wasnull=minTOI.arbiter==null;\n            var arb=narrowPhase(minTOI.s1,minTOI.s2,true,minTOI.arbiter,true);\n            if(arb==null){\n                if(minTOI.arbiter!=null&&minTOI.arbiter.pair!=null){\n                    minTOI.arbiter.pair.arb=null;\n                    minTOI.arbiter.pair=null;\n                }\n            }\n            else{\n                if(!presteparb(arb,deltaTime,true)){\n                    if(arb.type==ZPP_Arbiter.COL&&arb.acting()){\n                        arb.colarb.warmStart();\n                        arb.colarb.applyImpulseVel();\n                        arb.colarb.applyImpulseVel();\n                        arb.colarb.applyImpulseVel();\n                        arb.colarb.applyImpulseVel();\n                        b1.sweep_angvel=(b1.angvel)%MAX_VEL;\n                        b2.sweep_angvel=(b2.angvel)%MAX_VEL;\n                    }\n                }\n            }\n            if(arb!=null&&arb.acting()&&arb.type==ZPP_Arbiter.COL){\n                if(!b1.sweepFrozen&&!b1.isKinematic()){\n                    b1.sweepFrozen=true;\n                    if(minTOI.failed)b1.angvel=b1.sweep_angvel=0;\n                    else if(minTOI.slipped)b1.angvel=(b1.sweep_angvel*=Config.angularCCDSlipScale);\n                    else b1.angvel=b1.sweep_angvel;\n                }\n                if(!b2.sweepFrozen&&!b2.isKinematic()){\n                    b2.sweepFrozen=true;\n                    if(minTOI.failed)b2.angvel=b2.sweep_angvel=0;\n                    else if(minTOI.slipped)b2.angvel=(b2.sweep_angvel*=Config.angularCCDSlipScale);\n                    else b2.angvel=b2.sweep_angvel;\n                }\n            }\n            {\n                var o=minTOI;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ToiEvent\"+\", in obj: \"+\"minTOI\"+\")\");\n                    #end\n                };\n                o.free();\n                o.next=ZPP_ToiEvent.zpp_pool;\n                ZPP_ToiEvent.zpp_pool=o;\n                #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT++;\n                ZPP_ToiEvent.POOL_SUB++;\n                #end\n            };\n        }\n        {\n            while(!toiEvents.empty()){\n                var toi=toiEvents.pop_unsafe();\n                {\n                    {\n                        var o=toi;\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                o!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ToiEvent\"+\", in obj: \"+\"toi\"+\")\");\n                            #end\n                        };\n                        o.free();\n                        o.next=ZPP_ToiEvent.zpp_pool;\n                        ZPP_ToiEvent.zpp_pool=o;\n                        #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT++;\n                        ZPP_ToiEvent.POOL_SUB++;\n                        #end\n                    };\n                };\n            }\n        };\n        {\n            var cx_ite=kinematics.begin();\n            while(cx_ite!=null){\n                var cur=cx_ite.elem();\n                {\n                    cur.sweepIntegrate(deltaTime);\n                    cur.sweepTime=0;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=live.begin();\n            while(cx_ite!=null){\n                var cur=cx_ite.elem();\n                {\n                    if(!cur.sweepFrozen){\n                        cur.sweepIntegrate(deltaTime);\n                    }\n                    cur.sweepTime=0;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function continuousEvent(s1:ZPP_Shape,s2:ZPP_Shape,stat:Bool,in_arb:ZPP_Arbiter,_:Bool){\n        if(s1.body.sweepFrozen&&s2.body.sweepFrozen)return in_arb;\n        if(s1.body.disableCCD||s2.body.disableCCD)return in_arb;\n        if((in_arb!=null&&in_arb.colarb==null)||interactionType(s1,s2,s1.body,s2.body)<=0){\n            return in_arb;\n        }\n        var b1=s1.body;\n        var b2=s2.body;\n        if(stat||b1.bullet||b2.bullet){\n            var toi;\n            {\n                if(ZPP_ToiEvent.zpp_pool==null){\n                    toi=new ZPP_ToiEvent();\n                    #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_TOT++;\n                    ZPP_ToiEvent.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    toi=ZPP_ToiEvent.zpp_pool;\n                    ZPP_ToiEvent.zpp_pool=toi.next;\n                    toi.next=null;\n                    #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT--;\n                    ZPP_ToiEvent.POOL_ADD++;\n                    #end\n                }\n                toi.alloc();\n            };\n            var kin=(b1.isKinematic()||b2.isKinematic());\n            if(stat&&!kin){\n                if(!s1.body.isDynamic()){\n                    toi.s2=s1;\n                    toi.s1=s2;\n                }\n                else{\n                    toi.s1=s1;\n                    toi.s2=s2;\n                }\n                toi.kinematic=false;\n                ZPP_SweepDistance.staticSweep(toi,pre_dt,0,Config.collisionSlopCCD);\n            }\n            else{\n                toi.s1=s1;\n                toi.s2=s2;\n                toi.kinematic=kin;\n                if(toi.s1.body.sweepFrozen||toi.s2.body.sweepFrozen){\n                    if(toi.s1.body.sweepFrozen){\n                        var tmp=toi.s1;\n                        toi.s1=toi.s2;\n                        toi.s2=tmp;\n                        toi.frozen1=false;\n                        toi.frozen2=true;\n                    }\n                    ZPP_SweepDistance.staticSweep(toi,pre_dt,0,Config.collisionSlopCCD);\n                }\n                else{\n                    ZPP_SweepDistance.dynamicSweep(toi,pre_dt,0,Config.collisionSlopCCD);\n                }\n            }\n            if((stat&&toi.toi<0)||toi.failed){\n                {\n                    var o=toi;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ToiEvent\"+\", in obj: \"+\"toi\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_ToiEvent.zpp_pool;\n                    ZPP_ToiEvent.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_ToiEvent.POOL_CNT++;\n                    ZPP_ToiEvent.POOL_SUB++;\n                    #end\n                };\n            }\n            else{\n                toiEvents.add(toi);\n                toi.frozen1=toi.s1.body.sweepFrozen;\n                toi.frozen2=toi.s2.body.sweepFrozen;\n                toi.arbiter=(in_arb!=null)?in_arb.colarb:null;\n            }\n        }\n        return in_arb;\n    }\n    public function bodyCbWake(b:ZPP_Body){\n        if(b.isDynamic()&&b.cbSet!=null){\n            if(midstep){\n                {\n                    var cx_ite=b.cbSet.bodylisteners.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        {\n                            if(i.event!=ZPP_Flags.id_CbEvent_WAKE){\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                            var cb=push_callback(i);\n                            cb.event=ZPP_Flags.id_CbEvent_WAKE;\n                            cb.body=b;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else b.component.woken=true;\n        }\n    }\n    public function bodyCbSleep(b:ZPP_Body){\n        if(b.isDynamic()&&b.cbSet!=null){\n            {\n                var cx_ite=b.cbSet.bodylisteners.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    {\n                        if(i.event!=ZPP_Flags.id_CbEvent_SLEEP){\n                            cx_ite=cx_ite.next;\n                            continue;\n                        };\n                        var cb=push_callback(i);\n                        cb.event=ZPP_Flags.id_CbEvent_SLEEP;\n                        cb.body=b;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n    }\n    public function constraintCbWake(con:ZPP_Constraint){\n        if(con.cbSet!=null){\n            if(midstep){\n                {\n                    var cx_ite=con.cbSet.conlisteners.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        {\n                            if(i.event!=ZPP_Flags.id_CbEvent_WAKE){\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                            var cb=push_callback(i);\n                            cb.event=ZPP_Flags.id_CbEvent_WAKE;\n                            cb.constraint=con;\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else con.component.woken=true;\n        }\n    }\n    public function constraintCbSleep(con:ZPP_Constraint){\n        if(con.cbSet!=null){\n            {\n                var cx_ite=con.cbSet.conlisteners.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    {\n                        if(i.event!=ZPP_Flags.id_CbEvent_SLEEP){\n                            cx_ite=cx_ite.next;\n                            continue;\n                        };\n                        var cb=push_callback(i);\n                        cb.event=ZPP_Flags.id_CbEvent_SLEEP;\n                        cb.constraint=con;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n    }\n    public function constraintCbBreak(con:ZPP_Constraint){\n        if(con.cbSet!=null){\n            {\n                var cx_ite=con.cbSet.conlisteners.begin();\n                while(cx_ite!=null){\n                    var i=cx_ite.elem();\n                    {\n                        if(i.event!=ZPP_Flags.id_CbEvent_BREAK){\n                            cx_ite=cx_ite.next;\n                            continue;\n                        };\n                        var cb=push_callback(i);\n                        cb.event=ZPP_Flags.id_CbEvent_BREAK;\n                        cb.constraint=con;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n    }\n    public function nullListenerType(cb1:ZPP_CbSet,cb2:ZPP_CbSet){\n        var stack=new ZNPList_ZPP_Interactor();\n        {\n            var cx_ite=cb1.interactors.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                stack.add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(cb1!=cb2){\n            var cx_ite=cb2.interactors.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                stack.add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        while(!stack.empty()){\n            var intx=stack.pop_unsafe();\n            if(intx.isCompound()){\n                var comp=intx.icompound;\n                {\n                    var cx_ite=comp.bodies.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        stack.add(i);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                {\n                    var cx_ite=comp.compounds.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        stack.add(i);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else{\n                var xbody=if(intx.isBody())intx.ibody else intx.ishape.body;\n                var xshp=if(intx.isShape())intx.ishape else null;\n                {\n                    var cx_ite=xbody.arbiters.begin();\n                    while(cx_ite!=null){\n                        var xarb=cx_ite.elem();\n                        {\n                            if(xarb.present==0){\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                            if(xshp!=null&&!(xarb.ws1==xshp||xarb.ws2==xshp)){\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                            MRCA_chains(xarb.ws1,xarb.ws2);\n                            {\n                                var cx_ite=mrca1.begin();\n                                while(cx_ite!=null){\n                                    var i1=cx_ite.elem();\n                                    {\n                                        if(i1.cbSet!=cb1&&i1.cbSet!=cb2){\n                                            cx_ite=cx_ite.next;\n                                            continue;\n                                        };\n                                        {\n                                            var cx_ite=mrca2.begin();\n                                            while(cx_ite!=null){\n                                                var i2=cx_ite.elem();\n                                                {\n                                                    if((i1.cbSet==cb1&&i2.cbSet!=cb2)||(i1.cbSet==cb2&&i2.cbSet!=cb1)){\n                                                        cx_ite=cx_ite.next;\n                                                        continue;\n                                                    };\n                                                    var callbackset=ZPP_Interactor.get(i1,i2);\n                                                    if(callbackset!=null){\n                                                        {\n                                                            while(!callbackset.arbiters.empty()){\n                                                                var arb=callbackset.arbiters.pop_unsafe();\n                                                                {\n                                                                    arb.present--;\n                                                                    {\n                                                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                                        var res={\n                                                                            arb.present>=0;\n                                                                        };\n                                                                        if(!res)throw \"assert(\"+\"arb.present>=0\"+\") :: \"+(\"xarb present <0 ?\");\n                                                                        #end\n                                                                    };\n                                                                };\n                                                            }\n                                                        };\n                                                        remove_callbackset(callbackset);\n                                                    }\n                                                };\n                                                cx_ite=cx_ite.next;\n                                            }\n                                        };\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        }\n    }\n    public function nullInteractorType(intx:ZPP_Interactor,me:ZPP_Interactor=null){\n        if(me==null)me=intx;\n        if(intx.isCompound()){\n            var comp=intx.icompound;\n            {\n                var cx_ite=comp.bodies.begin();\n                while(cx_ite!=null){\n                    var body=cx_ite.elem();\n                    nullInteractorType(body,me);\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var cx_ite=comp.compounds.begin();\n                while(cx_ite!=null){\n                    var comp=cx_ite.elem();\n                    nullInteractorType(comp,me);\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n        else{\n            var xbody=if(intx.isBody())intx.ibody else intx.ishape.body;\n            var xshp=if(intx.isShape())intx.ishape else null;\n            {\n                var cx_ite=xbody.arbiters.begin();\n                while(cx_ite!=null){\n                    var xarb=cx_ite.elem();\n                    {\n                        if(xarb.present==0){\n                            cx_ite=cx_ite.next;\n                            continue;\n                        };\n                        if(xshp!=null&&!(xarb.ws1==xshp||xarb.ws2==xshp)){\n                            cx_ite=cx_ite.next;\n                            continue;\n                        };\n                        MRCA_chains(xarb.ws1,xarb.ws2);\n                        {\n                            var cx_ite=mrca1.begin();\n                            while(cx_ite!=null){\n                                var i1=cx_ite.elem();\n                                {\n                                    {\n                                        var cx_ite=mrca2.begin();\n                                        while(cx_ite!=null){\n                                            var i2=cx_ite.elem();\n                                            {\n                                                if(i1!=me&&i2!=me){\n                                                    cx_ite=cx_ite.next;\n                                                    continue;\n                                                };\n                                                var callbackset=ZPP_Interactor.get(i1,i2);\n                                                if(callbackset!=null){\n                                                    xarb.present--;\n                                                    {\n                                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                        var res={\n                                                            xarb.present>=0;\n                                                        };\n                                                        if(!res)throw \"assert(\"+\"xarb.present>=0\"+\") :: \"+(\"xarb present <0?\");\n                                                        #end\n                                                    };\n                                                    callbackset.remove_arb(xarb);\n                                                    if(callbackset.really_empty()){\n                                                        remove_callbackset(callbackset);\n                                                    }\n                                                }\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n    }\n    public function freshListenerType(cb1:ZPP_CbSet,cb2:ZPP_CbSet){\n        var stack=new ZNPList_ZPP_Interactor();\n        {\n            var cx_ite=cb1.interactors.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                stack.add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        if(cb1!=cb2){\n            var cx_ite=cb2.interactors.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                stack.add(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        while(!stack.empty()){\n            var intx=stack.pop_unsafe();\n            if(intx.isCompound()){\n                var comp=intx.icompound;\n                {\n                    var cx_ite=comp.bodies.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        stack.add(i);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                {\n                    var cx_ite=comp.compounds.begin();\n                    while(cx_ite!=null){\n                        var i=cx_ite.elem();\n                        stack.add(i);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else{\n                var xbody=if(intx.isBody())intx.ibody else intx.ishape.body;\n                var xshp=if(intx.isShape())intx.ishape else null;\n                {\n                    var cx_ite=xbody.arbiters.begin();\n                    while(cx_ite!=null){\n                        var xarb=cx_ite.elem();\n                        {\n                            if(!xarb.presentable){\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                            if(xshp!=null&&!(xarb.ws1==xshp||xarb.ws2==xshp)){\n                                cx_ite=cx_ite.next;\n                                continue;\n                            };\n                            MRCA_chains(xarb.ws1,xarb.ws2);\n                            {\n                                var cx_ite=mrca1.begin();\n                                while(cx_ite!=null){\n                                    var i1=cx_ite.elem();\n                                    {\n                                        if(i1.cbSet!=cb1&&i1.cbSet!=cb2){\n                                            cx_ite=cx_ite.next;\n                                            continue;\n                                        };\n                                        {\n                                            var cx_ite=mrca2.begin();\n                                            while(cx_ite!=null){\n                                                var i2=cx_ite.elem();\n                                                {\n                                                    if((i1.cbSet==cb1&&i2.cbSet!=cb2)||(i1.cbSet==cb2&&i2.cbSet!=cb1)){\n                                                        cx_ite=cx_ite.next;\n                                                        continue;\n                                                    };\n                                                    var callbackset=ZPP_Interactor.get(i1,i2);\n                                                    if(callbackset==null){\n                                                        callbackset=ZPP_CallbackSet.get(i1,i2);\n                                                        add_callbackset(callbackset);\n                                                    }\n                                                    if(callbackset.add_arb(xarb)){\n                                                        xarb.present++;\n                                                    }\n                                                };\n                                                cx_ite=cx_ite.next;\n                                            }\n                                        };\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n        }\n    }\n    public function freshInteractorType(intx:ZPP_Interactor,me:ZPP_Interactor=null){\n        if(me==null)me=intx;\n        if(intx.isCompound()){\n            var comp=intx.icompound;\n            {\n                var cx_ite=comp.bodies.begin();\n                while(cx_ite!=null){\n                    var body=cx_ite.elem();\n                    freshInteractorType(body,me);\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var cx_ite=comp.compounds.begin();\n                while(cx_ite!=null){\n                    var comp=cx_ite.elem();\n                    freshInteractorType(comp,me);\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n        else{\n            var xbody=if(intx.isBody())intx.ibody else intx.ishape.body;\n            var xshp=if(intx.isShape())intx.ishape else null;\n            {\n                var cx_ite=xbody.arbiters.begin();\n                while(cx_ite!=null){\n                    var xarb=cx_ite.elem();\n                    {\n                        if(!xarb.presentable){\n                            cx_ite=cx_ite.next;\n                            continue;\n                        };\n                        if(xshp!=null&&!(xarb.ws1==xshp||xarb.ws2==xshp)){\n                            cx_ite=cx_ite.next;\n                            continue;\n                        };\n                        MRCA_chains(xarb.ws1,xarb.ws2);\n                        {\n                            var cx_ite=mrca1.begin();\n                            while(cx_ite!=null){\n                                var i1=cx_ite.elem();\n                                {\n                                    {\n                                        var cx_ite=mrca2.begin();\n                                        while(cx_ite!=null){\n                                            var i2=cx_ite.elem();\n                                            {\n                                                if(i1!=me&&i2!=me){\n                                                    cx_ite=cx_ite.next;\n                                                    continue;\n                                                };\n                                                var cb1=i1.cbSet;\n                                                var cb2=i2.cbSet;\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        cb1!=null&&cb2!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"cb1!=null&&cb2!=null\"+\") :: \"+(\"null cbset from MRCA_chain?\");\n                                                    #end\n                                                };\n                                                cb1.validate();\n                                                cb2.validate();\n                                                if(!ZPP_CbSet.empty_intersection(cb1,cb2)){\n                                                    var callbackset=ZPP_Interactor.get(i1,i2);\n                                                    if(callbackset==null){\n                                                        callbackset=ZPP_CallbackSet.get(i1,i2);\n                                                        add_callbackset(callbackset);\n                                                    }\n                                                    if(callbackset.add_arb(xarb)){\n                                                        xarb.present++;\n                                                    }\n                                                }\n                                            };\n                                            cx_ite=cx_ite.next;\n                                        }\n                                    };\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n    }\n    public function wakeCompound(x:ZPP_Compound){\n        {\n            var cx_ite=x.bodies.begin();\n            while(cx_ite!=null){\n                var y=cx_ite.elem();\n                {\n                    var o=y;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o.space==this;\n                        };\n                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                        #end\n                    };\n                    if(!o.world){\n                        {\n                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                            var res={\n                                o.component!=null;\n                            };\n                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                            #end\n                        };\n                        o.component.waket=stamp+(midstep?0:1);\n                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                        if(o.component.sleeping){\n                            really_wake(o,false);\n                        }\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=x.constraints.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                wake_constraint(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=x.compounds.begin();\n            while(cx_ite!=null){\n                var i=cx_ite.elem();\n                wakeCompound(i);\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function wakeIsland(i:ZPP_Island){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                i.sleep;\n            };\n            if(!res)throw \"assert(\"+\"i.sleep\"+\") :: \"+(\"this island is not sleeping but referenced? wtf\");\n            #end\n        };\n        while(!i.comps.empty()){\n            var c=i.comps.pop_unsafe();\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    c.sleeping;\n                };\n                if(!res)throw \"assert(\"+\"c.sleeping\"+\") :: \"+(\"???\");\n                #end\n            };\n            c.waket=stamp+(midstep?0:1);\n            if(c.isBody){\n                var b=c.body;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        b.space==this;\n                    };\n                    if(!res)throw \"assert(\"+\"b.space==this\"+\") :: \"+(\"wakeIsland:: body is not actually IN this space??\");\n                    #end\n                };\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        b.isDynamic();\n                    };\n                    if(!res)throw \"assert(\"+\"b.isDynamic()\"+\") :: \"+(\"din din\");\n                    #end\n                };\n                live.add(b);\n                {\n                    var cx_ite=b.arbiters.begin();\n                    while(cx_ite!=null){\n                        var arb=cx_ite.elem();\n                        {\n                            if(arb.sleeping){\n                                arb.sleeping=false;\n                                arb.up_stamp+=stamp-arb.sleep_stamp;\n                                if(arb.type==ZPP_Arbiter.COL){\n                                    var carb=arb.colarb;\n                                    if(carb.stat)c_arbiters_true.inlined_add(carb);\n                                    else c_arbiters_false.inlined_add(carb);\n                                }\n                                else if(arb.type==ZPP_Arbiter.FLUID)f_arbiters.inlined_add(arb.fluidarb);\n                                else s_arbiters.inlined_add(arb.sensorarb);\n                            }\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n                bodyCbWake(b);\n                c.reset();\n                if(!b.isStatic()){\n                    var cx_ite=b.shapes.begin();\n                    while(cx_ite!=null){\n                        var shape=cx_ite.elem();\n                        if(shape.node!=null)bphase.sync(shape);\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else{\n                var con=c.constraint;\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        con.space==this;\n                    };\n                    if(!res)throw \"assert(\"+\"con.space==this\"+\") :: \"+(\"wakeIsland:: constraint is not actually IN this space??\");\n                    #end\n                };\n                live_constraints.inlined_add(con);\n                constraintCbWake(con);\n                c.reset();\n            }\n        }\n        {\n            var o=i;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Island\"+\", in obj: \"+\"i\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Island.zpp_pool;\n            ZPP_Island.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Island.POOL_CNT++;\n            ZPP_Island.POOL_SUB++;\n            #end\n        };\n    }\n    public function non_inlined_wake(o:ZPP_Body,fst=false){\n        {\n            var o=o;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o.space==this;\n                };\n                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                #end\n            };\n            if(!o.world){\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        o.component!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                    #end\n                };\n                o.component.waket=stamp+(midstep?0:1);\n                if(o.isKinematic())o.kinematicDelaySleep=true;\n                if(o.component.sleeping){\n                    really_wake(o,fst);\n                }\n            }\n        };\n    }\n    public function really_wake(o:ZPP_Body,fst=false){\n        if(o.component.island==null){\n            o.component.sleeping=false;\n            if(o.isKinematic()||o.isStatic())staticsleep.inlined_add(o);\n            else live.inlined_add(o);\n            {\n                var cx_ite=o.constraints.begin();\n                while(cx_ite!=null){\n                    var con=cx_ite.elem();\n                    if(con.space==this)wake_constraint(con);\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var cx_ite=o.arbiters.begin();\n                while(cx_ite!=null){\n                    var arb=cx_ite.elem();\n                    {\n                        if(arb.sleeping){\n                            arb.sleeping=false;\n                            arb.up_stamp+=stamp+(midstep?0:1)-arb.sleep_stamp;\n                            if(arb.type==ZPP_Arbiter.COL){\n                                var carb=arb.colarb;\n                                if(carb.stat)c_arbiters_true.inlined_add(carb);\n                                else c_arbiters_false.inlined_add(carb);\n                            }\n                            else if(arb.type==ZPP_Arbiter.FLUID)f_arbiters.inlined_add(arb.fluidarb);\n                            else s_arbiters.inlined_add(arb.sensorarb);\n                        }\n                        if(arb.type!=ZPP_Arbiter.SENSOR&&!arb.cleared&&arb.up_stamp>=stamp&&((arb.immState&ZPP_Flags.id_ImmState_ACCEPT)!=0)){\n                            if(arb.b1.isDynamic()&&arb.b1.component.sleeping){\n                                var o=arb.b1;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        o.space==this;\n                                    };\n                                    if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                    #end\n                                };\n                                if(!o.world){\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o.component!=null;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                        #end\n                                    };\n                                    o.component.waket=stamp+(midstep?0:1);\n                                    if(o.isKinematic())o.kinematicDelaySleep=true;\n                                    if(o.component.sleeping){\n                                        really_wake(o,false);\n                                    }\n                                }\n                            };\n                            if(arb.b2.isDynamic()&&arb.b2.component.sleeping){\n                                var o=arb.b2;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        o.space==this;\n                                    };\n                                    if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                    #end\n                                };\n                                if(!o.world){\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o.component!=null;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                        #end\n                                    };\n                                    o.component.waket=stamp+(midstep?0:1);\n                                    if(o.isKinematic())o.kinematicDelaySleep=true;\n                                    if(o.component.sleeping){\n                                        really_wake(o,false);\n                                    }\n                                }\n                            };\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            if(!fst&&o.isDynamic())bodyCbWake(o);\n            if(!fst&&!bphase.is_sweep&&!o.isStatic()){\n                var cx_ite=o.shapes.begin();\n                while(cx_ite!=null){\n                    var shape=cx_ite.elem();\n                    if(shape.node!=null)bphase.sync(shape);\n                    cx_ite=cx_ite.next;\n                }\n            };\n        }\n        else{\n            wakeIsland(o.component.island);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                o.component.island==null;\n            };\n            if(!res)throw \"assert(\"+\"o.component.island==null\"+\") :: \"+(\"woken, but island non-null?\");\n            #end\n        };\n    }\n    public function wake_constraint(con:ZPP_Constraint,fst=false){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                con.space==this;\n            };\n            if(!res)throw \"assert(\"+\"con.space==this\"+\") :: \"+(\"constraint woken, but not actually IN the space!\");\n            #end\n        };\n        if(con.active){\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    con.component!=null;\n                };\n                if(!res)throw \"assert(\"+\"con.component!=null\"+\") :: \"+(\"constraint woken but no component exists?\");\n                #end\n            };\n            con.component.waket=stamp+(midstep?0:1);\n            if(con.component.sleeping){\n                if(con.component.island==null){\n                    con.component.sleeping=false;\n                    live_constraints.inlined_add(con);\n                    con.wake_connected();\n                    if(!fst)constraintCbWake(con);\n                }\n                else{\n                    wakeIsland(con.component.island);\n                }\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        con.component.island==null;\n                    };\n                    if(!res)throw \"assert(\"+\"con.component.island==null\"+\") :: \"+(\"woken (con), but island non-null?\");\n                    #end\n                };\n                return true;\n            }\n            else return false;\n        }\n        else return false;\n    }\n    public function doForests(dt:Float){\n        {\n            var cx_ite=c_arbiters_false.begin();\n            while(cx_ite!=null){\n                var arb=cx_ite.elem();\n                {\n                    if(!arb.cleared&&arb.up_stamp==stamp&&((arb.immState&ZPP_Flags.id_ImmState_ACCEPT)!=0)){\n                        if(arb.b1.isDynamic()&&arb.b2.isDynamic()){\n                            var xr=({\n                                if(arb.b1.component==arb.b1.component.parent)arb.b1.component;\n                                else{\n                                    var obj=arb.b1.component;\n                                    var stack=null;\n                                    while(obj!=obj.parent){\n                                        var nxt=obj.parent;\n                                        obj.parent=stack;\n                                        stack=obj;\n                                        obj=nxt;\n                                    }\n                                    while(stack!=null){\n                                        var nxt=stack.parent;\n                                        stack.parent=obj;\n                                        stack=nxt;\n                                    }\n                                    obj;\n                                }\n                            });\n                            var yr=({\n                                if(arb.b2.component==arb.b2.component.parent)arb.b2.component;\n                                else{\n                                    var obj=arb.b2.component;\n                                    var stack=null;\n                                    while(obj!=obj.parent){\n                                        var nxt=obj.parent;\n                                        obj.parent=stack;\n                                        stack=obj;\n                                        obj=nxt;\n                                    }\n                                    while(stack!=null){\n                                        var nxt=stack.parent;\n                                        stack.parent=obj;\n                                        stack=nxt;\n                                    }\n                                    obj;\n                                }\n                            });\n                            if(xr!=yr){\n                                if(xr.rank<yr.rank)xr.parent=yr;\n                                else if(xr.rank>yr.rank)yr.parent=xr;\n                                else{\n                                    yr.parent=xr;\n                                    xr.rank++;\n                                }\n                            }\n                        }\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=f_arbiters.begin();\n            while(cx_ite!=null){\n                var arb=cx_ite.elem();\n                {\n                    if(!arb.cleared&&arb.up_stamp==stamp&&((arb.immState&ZPP_Flags.id_ImmState_ACCEPT)!=0)){\n                        if(arb.b1.isDynamic()&&arb.b2.isDynamic()){\n                            var xr=({\n                                if(arb.b1.component==arb.b1.component.parent)arb.b1.component;\n                                else{\n                                    var obj=arb.b1.component;\n                                    var stack=null;\n                                    while(obj!=obj.parent){\n                                        var nxt=obj.parent;\n                                        obj.parent=stack;\n                                        stack=obj;\n                                        obj=nxt;\n                                    }\n                                    while(stack!=null){\n                                        var nxt=stack.parent;\n                                        stack.parent=obj;\n                                        stack=nxt;\n                                    }\n                                    obj;\n                                }\n                            });\n                            var yr=({\n                                if(arb.b2.component==arb.b2.component.parent)arb.b2.component;\n                                else{\n                                    var obj=arb.b2.component;\n                                    var stack=null;\n                                    while(obj!=obj.parent){\n                                        var nxt=obj.parent;\n                                        obj.parent=stack;\n                                        stack=obj;\n                                        obj=nxt;\n                                    }\n                                    while(stack!=null){\n                                        var nxt=stack.parent;\n                                        stack.parent=obj;\n                                        stack=nxt;\n                                    }\n                                    obj;\n                                }\n                            });\n                            if(xr!=yr){\n                                if(xr.rank<yr.rank)xr.parent=yr;\n                                else if(xr.rank>yr.rank)yr.parent=xr;\n                                else{\n                                    yr.parent=xr;\n                                    xr.rank++;\n                                }\n                            }\n                        }\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var cx_ite=live_constraints.begin();\n            while(cx_ite!=null){\n                var con=cx_ite.elem();\n                con.forest();\n                cx_ite=cx_ite.next;\n            }\n        };\n        while(!live.empty()){\n            var o=live.inlined_pop_unsafe();\n            var oc=o.component;\n            var root=({\n                if(oc==oc.parent)oc;\n                else{\n                    var obj=oc;\n                    var stack=null;\n                    while(obj!=obj.parent){\n                        var nxt=obj.parent;\n                        obj.parent=stack;\n                        stack=obj;\n                        obj=nxt;\n                    }\n                    while(stack!=null){\n                        var nxt=stack.parent;\n                        stack.parent=obj;\n                        stack=nxt;\n                    }\n                    obj;\n                }\n            });\n            if(root.island==null){\n                {\n                    if(ZPP_Island.zpp_pool==null){\n                        root.island=new ZPP_Island();\n                        #if NAPE_POOL_STATS ZPP_Island.POOL_TOT++;\n                        ZPP_Island.POOL_ADDNEW++;\n                        #end\n                    }\n                    else{\n                        root.island=ZPP_Island.zpp_pool;\n                        ZPP_Island.zpp_pool=root.island.next;\n                        root.island.next=null;\n                        #if NAPE_POOL_STATS ZPP_Island.POOL_CNT--;\n                        ZPP_Island.POOL_ADD++;\n                        #end\n                    }\n                    root.island.alloc();\n                };\n                islands.inlined_add(root.island);\n                root.island.sleep=true;\n            }\n            oc.island=root.island;\n            oc.island.comps.inlined_add(oc);\n            var rest=o.atRest(dt);\n            oc.island.sleep=oc.island.sleep&&rest;\n            if(oc.waket>oc.island.waket)oc.island.waket=oc.waket;\n        }\n        while(!live_constraints.empty()){\n            var o=live_constraints.inlined_pop_unsafe();\n            var oc=o.component;\n            var root=({\n                if(oc==oc.parent)oc;\n                else{\n                    var obj=oc;\n                    var stack=null;\n                    while(obj!=obj.parent){\n                        var nxt=obj.parent;\n                        obj.parent=stack;\n                        stack=obj;\n                        obj=nxt;\n                    }\n                    while(stack!=null){\n                        var nxt=stack.parent;\n                        stack.parent=obj;\n                        stack=nxt;\n                    }\n                    obj;\n                }\n            });\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    root.island!=null;\n                };\n                if(!res)throw \"assert(\"+\"root.island!=null\"+\") :: \"+(\"constraint without bodies?\");\n                #end\n            };\n            oc.island=root.island;\n            oc.island.comps.inlined_add(oc);\n            if(oc.waket>oc.island.waket)oc.island.waket=oc.waket;\n        }\n        while(!islands.empty()){\n            var i=islands.inlined_pop_unsafe();\n            if(i.sleep){\n                {\n                    var cx_ite=i.comps.begin();\n                    while(cx_ite!=null){\n                        var c=cx_ite.elem();\n                        {\n                            if(c.isBody){\n                                var b=c.body;\n                                {\n                                    b.velx=0;\n                                    b.vely=0;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((b.velx!=b.velx));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(b.velx)\"+\") :: \"+(\"vec_set(in n: \"+\"b.vel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            !((b.vely!=b.vely));\n                                        };\n                                        if(!res)throw \"assert(\"+\"!assert_isNaN(b.vely)\"+\") :: \"+(\"vec_set(in n: \"+\"b.vel\"+\",in x: \"+\"0\"+\",in y: \"+\"0\"+\")\");\n                                        #end\n                                    };\n                                };\n                                b.angvel=0;\n                                c.sleeping=true;\n                                {\n                                    var cx_ite=b.shapes.begin();\n                                    while(cx_ite!=null){\n                                        var shape=cx_ite.elem();\n                                        bphase.sync(shape);\n                                        cx_ite=cx_ite.next;\n                                    }\n                                }\n                                bodyCbSleep(b);\n                            }\n                            else{\n                                var con=c.constraint;\n                                constraintCbSleep(con);\n                                c.sleeping=true;\n                            }\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            else{\n                while(!i.comps.empty()){\n                    var c=i.comps.inlined_pop_unsafe();\n                    c.waket=i.waket;\n                    if(c.isBody)live.inlined_add(c.body);\n                    else live_constraints.inlined_add(c.constraint);\n                    c.reset();\n                }\n                {\n                    var o=i;\n                    {\n                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                        var res={\n                            o!=null;\n                        };\n                        if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Island\"+\", in obj: \"+\"i\"+\")\");\n                        #end\n                    };\n                    o.free();\n                    o.next=ZPP_Island.zpp_pool;\n                    ZPP_Island.zpp_pool=o;\n                    #if NAPE_POOL_STATS ZPP_Island.POOL_CNT++;\n                    ZPP_Island.POOL_SUB++;\n                    #end\n                };\n            }\n        }\n    }\n    public function sleepArbiters(){\n        {\n            var pre=null;\n            var arbs=c_arbiters_true;\n            var arbite=arbs.begin();\n            var fst=c_arbiters_false!=null;\n            {\n                if(fst&&arbite==null){\n                    fst=false;\n                    arbite=c_arbiters_false.begin();\n                    arbs=c_arbiters_false;\n                    pre=null;\n                }\n            };\n            while(arbite!=null){\n                var arb=arbite.elem();\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !arb.cleared;\n                    };\n                    if(!res)throw \"assert(\"+\"!arb.cleared\"+\") :: \"+(\"arb cleared in sleepArbiters\");\n                    #end\n                };\n                if(arb.b1.component.sleeping&&arb.b2.component.sleeping){\n                    arb.sleep_stamp=stamp;\n                    arb.sleeping=true;\n                    arbite=arbs.inlined_erase(pre);\n                    {\n                        if(fst&&arbite==null){\n                            fst=false;\n                            arbite=c_arbiters_false.begin();\n                            arbs=c_arbiters_false;\n                            pre=null;\n                        }\n                    };\n                    continue;\n                }\n                pre=arbite;\n                arbite=arbite.next;\n                {\n                    if(fst&&arbite==null){\n                        fst=false;\n                        arbite=c_arbiters_false.begin();\n                        arbs=c_arbiters_false;\n                        pre=null;\n                    }\n                };\n            }\n        };\n        {\n            var pre=null;\n            var arbs=f_arbiters;\n            var arbite=arbs.begin();\n            var fst=null!=null;\n            {\n                if(fst&&arbite==null){\n                    fst=false;\n/*silly null. issues*/\n                    arbs=null;\n                    pre=null;\n                }\n            };\n            while(arbite!=null){\n                var arb=arbite.elem();\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !arb.cleared;\n                    };\n                    if(!res)throw \"assert(\"+\"!arb.cleared\"+\") :: \"+(\"arb cleared in sleepArbiters\");\n                    #end\n                };\n                if(arb.b1.component.sleeping&&arb.b2.component.sleeping){\n                    arb.sleep_stamp=stamp;\n                    arb.sleeping=true;\n                    arbite=arbs.inlined_erase(pre);\n                    {\n                        if(fst&&arbite==null){\n                            fst=false;\n/*silly null. issues*/\n                            arbs=null;\n                            pre=null;\n                        }\n                    };\n                    continue;\n                }\n                pre=arbite;\n                arbite=arbite.next;\n                {\n                    if(fst&&arbite==null){\n                        fst=false;\n/*silly null. issues*/\n                        arbs=null;\n                        pre=null;\n                    }\n                };\n            }\n        };\n        {\n            var pre=null;\n            var arbs=s_arbiters;\n            var arbite=arbs.begin();\n            var fst=null!=null;\n            {\n                if(fst&&arbite==null){\n                    fst=false;\n/*silly null. issues*/\n                    arbs=null;\n                    pre=null;\n                }\n            };\n            while(arbite!=null){\n                var arb=arbite.elem();\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        !arb.cleared;\n                    };\n                    if(!res)throw \"assert(\"+\"!arb.cleared\"+\") :: \"+(\"arb cleared in sleepArbiters\");\n                    #end\n                };\n                if(arb.b1.component.sleeping&&arb.b2.component.sleeping){\n                    arb.sleep_stamp=stamp;\n                    arb.sleeping=true;\n                    arbite=arbs.inlined_erase(pre);\n                    {\n                        if(fst&&arbite==null){\n                            fst=false;\n/*silly null. issues*/\n                            arbs=null;\n                            pre=null;\n                        }\n                    };\n                    continue;\n                }\n                pre=arbite;\n                arbite=arbite.next;\n                {\n                    if(fst&&arbite==null){\n                        fst=false;\n/*silly null. issues*/\n                        arbs=null;\n                        pre=null;\n                    }\n                };\n            }\n        };\n    }\n    public function static_validation(body:ZPP_Body){\n        if(!body.shapes.empty()){\n            body.validate_aabb();\n        }\n        body.validate_mass();\n        body.validate_inertia();\n        #if(!NAPE_RELEASE_BUILD)\n        if(body.velx!=0||body.vely!=0||body.angvel!=0)throw \"Error: Static body cannot have any real velocity, only kinematic or surface velocities\";\n        #end\n        {\n            var cx_ite=body.shapes.begin();\n            while(cx_ite!=null){\n                var s=cx_ite.elem();\n                {\n                    if(s.isPolygon()){\n                        s.polygon.splice_collinear();\n                        #if(!NAPE_RELEASE_BUILD)\n                        var res=s.polygon.valid();\n                        if(res!=ValidationResult.VALID){\n                            throw \"Error: Cannot simulate with an invalid Polygon : \"+s.polygon.outer.toString()+\" is invalid : \"+res.toString();\n                        }\n                        #end\n                        s.polygon.validate_gaxi();\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        body.sweepFrozen=true;\n    }\n    public function validation(){\n        cbsets.validate();\n        {\n            {\n                var cx_ite=live.begin();\n                while(cx_ite!=null){\n                    var cur=cx_ite.elem();\n                    {\n                        cur.sweepRadius=0;\n                        {\n                            var cx_ite=cur.shapes.begin();\n                            while(cx_ite!=null){\n                                var s=cx_ite.elem();\n                                {\n                                    if(s.isPolygon()){\n                                        s.polygon.splice_collinear();\n                                        #if(!NAPE_RELEASE_BUILD)\n                                        var res=s.polygon.valid();\n                                        if(res!=ValidationResult.VALID){\n                                            throw \"Error: Cannot simulate with an invalid Polygon : \"+s.polygon.outer.toString()+\" is invalid : \"+res.toString();\n                                        }\n                                        #end\n                                        s.polygon.validate_gaxi();\n                                    }\n                                    s.validate_sweepRadius();\n                                    if(s.sweepRadius>cur.sweepRadius)cur.sweepRadius=s.sweepRadius;\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                        cur.validate_mass();\n                        cur.validate_inertia();\n                        if(!cur.shapes.empty()){\n                            cur.validate_aabb();\n                            cur.validate_worldCOM();\n                        }\n                        cur.validate_gravMass();\n                        cur.validate_axis();\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(!cur.nomove&&cur.isDynamic()&&cur.mass==0){\n                            throw \"Error: Dynamic Body cannot be simulated with 0 mass unless allowMovement is false\";\n                        }\n                        if(!cur.norotate&&cur.isDynamic()&&cur.inertia==0){\n                            throw \"Error: Dynamic Body cannot be simulated with 0 inertia unless allowRotation is false\";\n                        }\n                        #end\n                        if(!false){\n                            if(cur.component.woken&&cur.cbSet!=null){\n                                {\n                                    var cx_ite=cur.cbSet.bodylisteners.begin();\n                                    while(cx_ite!=null){\n                                        var i=cx_ite.elem();\n                                        {\n                                            if(i.event!=ZPP_Flags.id_CbEvent_WAKE){\n                                                cx_ite=cx_ite.next;\n                                                continue;\n                                            };\n                                            var cb=push_callback(i);\n                                            cb.event=ZPP_Flags.id_CbEvent_WAKE;\n                                            cb.body=cur;\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                }\n                            }\n                            cur.component.woken=false;\n                        }\n                        {\n                            var cx_ite=cur.shapes.begin();\n                            while(cx_ite!=null){\n                                var shape=cx_ite.elem();\n                                bphase.sync(shape);\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        {\n            {\n                var cx_ite=kinematics.begin();\n                while(cx_ite!=null){\n                    var cur=cx_ite.elem();\n                    {\n                        cur.sweepRadius=0;\n                        {\n                            var cx_ite=cur.shapes.begin();\n                            while(cx_ite!=null){\n                                var s=cx_ite.elem();\n                                {\n                                    if(s.isPolygon()){\n                                        s.polygon.splice_collinear();\n                                        #if(!NAPE_RELEASE_BUILD)\n                                        var res=s.polygon.valid();\n                                        if(res!=ValidationResult.VALID){\n                                            throw \"Error: Cannot simulate with an invalid Polygon : \"+s.polygon.outer.toString()+\" is invalid : \"+res.toString();\n                                        }\n                                        #end\n                                        s.polygon.validate_gaxi();\n                                    }\n                                    s.validate_sweepRadius();\n                                    if(s.sweepRadius>cur.sweepRadius)cur.sweepRadius=s.sweepRadius;\n                                };\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                        cur.validate_mass();\n                        cur.validate_inertia();\n                        if(!cur.shapes.empty()){\n                            cur.validate_aabb();\n                            cur.validate_worldCOM();\n                        }\n                        cur.validate_gravMass();\n                        cur.validate_axis();\n                        #if(!NAPE_RELEASE_BUILD)\n                        if(!cur.nomove&&cur.isDynamic()&&cur.mass==0){\n                            throw \"Error: Dynamic Body cannot be simulated with 0 mass unless allowMovement is false\";\n                        }\n                        if(!cur.norotate&&cur.isDynamic()&&cur.inertia==0){\n                            throw \"Error: Dynamic Body cannot be simulated with 0 inertia unless allowRotation is false\";\n                        }\n                        #end\n                        if(!true){\n                            if(cur.component.woken&&cur.cbSet!=null){\n                                {\n                                    var cx_ite=cur.cbSet.bodylisteners.begin();\n                                    while(cx_ite!=null){\n                                        var i=cx_ite.elem();\n                                        {\n                                            if(i.event!=ZPP_Flags.id_CbEvent_WAKE){\n                                                cx_ite=cx_ite.next;\n                                                continue;\n                                            };\n                                            var cb=push_callback(i);\n                                            cb.event=ZPP_Flags.id_CbEvent_WAKE;\n                                            cb.body=cur;\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                }\n                            }\n                            cur.component.woken=false;\n                        }\n                        {\n                            var cx_ite=cur.shapes.begin();\n                            while(cx_ite!=null){\n                                var shape=cx_ite.elem();\n                                bphase.sync(shape);\n                                cx_ite=cx_ite.next;\n                            }\n                        };\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        {\n            var cx_ite=live_constraints.begin();\n            while(cx_ite!=null){\n                var con=cx_ite.elem();\n                {\n                    if(con.active){\n                        #if(!NAPE_RELEASE_BUILD)\n                        con.validate();\n                        #end\n                        if(con.component.woken&&con.cbSet!=null){\n                            {\n                                var cx_ite=con.cbSet.conlisteners.begin();\n                                while(cx_ite!=null){\n                                    var i=cx_ite.elem();\n                                    {\n                                        if(i.event!=ZPP_Flags.id_CbEvent_WAKE){\n                                            cx_ite=cx_ite.next;\n                                            continue;\n                                        };\n                                        var cb=push_callback(i);\n                                        cb.event=ZPP_Flags.id_CbEvent_WAKE;\n                                        cb.constraint=con;\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                        }\n                        con.component.woken=false;\n                    }\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function updateVel(dt:Float){\n        var pre=null;\n        var linDrag=1-(dt*global_lin_drag);\n        var angDrag=1-(dt*global_ang_drag);\n        {\n            var cx_ite=live.begin();\n            while(cx_ite!=null){\n                var cur=cx_ite.elem();\n                {\n                    if(cur.smass!=0.0){\n                        var time=dt*cur.imass;\n                        cur.velx=(linDrag*cur.velx)+(cur.forcex+gravityx*cur.gravMass)*time;\n                        cur.vely=(linDrag*cur.vely)+(cur.forcey+gravityy*cur.gravMass)*time;\n                    }\n                    if(cur.sinertia!=0.0){\n                        var dpx:Float=0.0;\n                        var dpy:Float=0.0;\n                        {\n                            dpx=cur.worldCOMx-cur.posx;\n                            dpy=cur.worldCOMy-cur.posy;\n                        };\n                        var torque=cur.torque+((gravityy*dpx-gravityx*dpy)*cur.gravMass);\n                        cur.angvel=(angDrag*cur.angvel)+(torque*dt*cur.iinertia);\n                    }\n                    pre=cx_ite;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function updatePos(dt:Float){\n        var MAX_VEL=2*Math.PI/dt;\n        {\n            {\n                var cx_ite=live.begin();\n                while(cx_ite!=null){\n                    var cur=cx_ite.elem();\n                    {\n                        {\n                            cur.pre_posx=cur.posx;\n                            cur.pre_posy=cur.posy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cur.pre_posx!=cur.pre_posx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cur.pre_posx)\"+\") :: \"+(\"vec_set(in n: \"+\"cur.pre_pos\"+\",in x: \"+\"cur.posx\"+\",in y: \"+\"cur.posy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cur.pre_posy!=cur.pre_posy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cur.pre_posy)\"+\") :: \"+(\"vec_set(in n: \"+\"cur.pre_pos\"+\",in x: \"+\"cur.posx\"+\",in y: \"+\"cur.posy\"+\")\");\n                                #end\n                            };\n                        };\n                        cur.pre_rot=cur.rot;\n                        cur.sweepTime=0;\n                        cur.sweep_angvel=(cur.angvel)%MAX_VEL;\n                        cur.sweepIntegrate(dt);\n                        if(!cur.disableCCD){\n                            var linThreshold=Config.staticCCDLinearThreshold*cur.sweepRadius;\n                            var angThreshold=Config.staticCCDAngularThreshold;\n                            if((((cur.velx*cur.velx+cur.vely*cur.vely)*dt*dt)>(linThreshold*linThreshold)||(cur.angvel*cur.angvel*dt*dt)>(angThreshold*angThreshold))||cur.isKinematic()){\n                                var angvel=cur.sweep_angvel;\n                                if(angvel<0)angvel=-angvel;\n                                var iangvel=1/angvel;\n                                {\n                                    var cx_ite=cur.shapes.begin();\n                                    while(cx_ite!=null){\n                                        var s=cx_ite.elem();\n                                        {\n                                            var aabb=s.aabb;\n                                            var minx=aabb.minx;\n                                            var miny=aabb.miny;\n                                            var maxx=aabb.maxx;\n                                            var maxy=aabb.maxy;\n                                            var count:Int=(#if flash9 untyped __int__(angvel*dt*s.sweepCoef*(1/120))#else Std.int(angvel*dt*s.sweepCoef*(1/120))#end);\n                                            if(count>8)count=8;\n                                            var anginc=(angvel*dt)/count;\n                                            cur.sweepIntegrate(dt);\n                                            s.force_validate_aabb();\n                                            if(minx<aabb.minx)aabb.minx=minx else minx=aabb.minx;\n                                            if(miny<aabb.miny)aabb.miny=miny else miny=aabb.miny;\n                                            if(maxx>aabb.maxx)aabb.maxx=maxx else maxx=aabb.maxx;\n                                            if(maxy>aabb.maxy)aabb.maxy=maxy else maxy=aabb.maxy;\n                                            for(i in 1...count){\n                                                cur.sweepIntegrate(anginc*i*iangvel);\n                                                s.force_validate_aabb();\n                                                if(minx<aabb.minx)aabb.minx=minx else minx=aabb.minx;\n                                                if(miny<aabb.miny)aabb.miny=miny else miny=aabb.miny;\n                                                if(maxx>aabb.maxx)aabb.maxx=maxx else maxx=aabb.maxx;\n                                                if(maxy>aabb.maxy)aabb.maxy=maxy else maxy=aabb.maxy;\n                                            }\n                                            bphase.sync(s);\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                cur.sweepFrozen=false;\n                                if(cur.isDynamic()&&cur.bulletEnabled){\n                                    var linThreshold2=Config.bulletCCDLinearThreshold*cur.sweepRadius;\n                                    var angThreshold2=Config.bulletCCDAngularThreshold;\n                                    if((((cur.velx*cur.velx+cur.vely*cur.vely)*dt*dt)>(linThreshold2*linThreshold2)||(cur.angvel*cur.angvel*dt*dt)>(angThreshold2*angThreshold2))){\n                                        cur.bullet=true;\n                                    }\n                                }\n                            }\n                            else{\n                                cur.sweepFrozen=true;\n                                cur.bullet=false;\n                            }\n                        }\n                        else{\n                            cur.sweepFrozen=true;\n                            cur.bullet=false;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        {\n            {\n                var cx_ite=kinematics.begin();\n                while(cx_ite!=null){\n                    var cur=cx_ite.elem();\n                    {\n                        {\n                            cur.pre_posx=cur.posx;\n                            cur.pre_posy=cur.posy;\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cur.pre_posx!=cur.pre_posx));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cur.pre_posx)\"+\") :: \"+(\"vec_set(in n: \"+\"cur.pre_pos\"+\",in x: \"+\"cur.posx\"+\",in y: \"+\"cur.posy\"+\")\");\n                                #end\n                            };\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    !((cur.pre_posy!=cur.pre_posy));\n                                };\n                                if(!res)throw \"assert(\"+\"!assert_isNaN(cur.pre_posy)\"+\") :: \"+(\"vec_set(in n: \"+\"cur.pre_pos\"+\",in x: \"+\"cur.posx\"+\",in y: \"+\"cur.posy\"+\")\");\n                                #end\n                            };\n                        };\n                        cur.pre_rot=cur.rot;\n                        cur.sweepTime=0;\n                        cur.sweep_angvel=(cur.angvel)%MAX_VEL;\n                        cur.sweepIntegrate(dt);\n                        if(!cur.disableCCD){\n                            var linThreshold=Config.staticCCDLinearThreshold*cur.sweepRadius;\n                            var angThreshold=Config.staticCCDAngularThreshold;\n                            if((((cur.velx*cur.velx+cur.vely*cur.vely)*dt*dt)>(linThreshold*linThreshold)||(cur.angvel*cur.angvel*dt*dt)>(angThreshold*angThreshold))||cur.isKinematic()){\n                                var angvel=cur.sweep_angvel;\n                                if(angvel<0)angvel=-angvel;\n                                var iangvel=1/angvel;\n                                {\n                                    var cx_ite=cur.shapes.begin();\n                                    while(cx_ite!=null){\n                                        var s=cx_ite.elem();\n                                        {\n                                            var aabb=s.aabb;\n                                            var minx=aabb.minx;\n                                            var miny=aabb.miny;\n                                            var maxx=aabb.maxx;\n                                            var maxy=aabb.maxy;\n                                            var count:Int=(#if flash9 untyped __int__(angvel*dt*s.sweepCoef*(1/120))#else Std.int(angvel*dt*s.sweepCoef*(1/120))#end);\n                                            if(count>8)count=8;\n                                            var anginc=(angvel*dt)/count;\n                                            cur.sweepIntegrate(dt);\n                                            s.force_validate_aabb();\n                                            if(minx<aabb.minx)aabb.minx=minx else minx=aabb.minx;\n                                            if(miny<aabb.miny)aabb.miny=miny else miny=aabb.miny;\n                                            if(maxx>aabb.maxx)aabb.maxx=maxx else maxx=aabb.maxx;\n                                            if(maxy>aabb.maxy)aabb.maxy=maxy else maxy=aabb.maxy;\n                                            for(i in 1...count){\n                                                cur.sweepIntegrate(anginc*i*iangvel);\n                                                s.force_validate_aabb();\n                                                if(minx<aabb.minx)aabb.minx=minx else minx=aabb.minx;\n                                                if(miny<aabb.miny)aabb.miny=miny else miny=aabb.miny;\n                                                if(maxx>aabb.maxx)aabb.maxx=maxx else maxx=aabb.maxx;\n                                                if(maxy>aabb.maxy)aabb.maxy=maxy else maxy=aabb.maxy;\n                                            }\n                                            bphase.sync(s);\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                cur.sweepFrozen=false;\n                                if(cur.isDynamic()&&cur.bulletEnabled){\n                                    var linThreshold2=Config.bulletCCDLinearThreshold*cur.sweepRadius;\n                                    var angThreshold2=Config.bulletCCDAngularThreshold;\n                                    if((((cur.velx*cur.velx+cur.vely*cur.vely)*dt*dt)>(linThreshold2*linThreshold2)||(cur.angvel*cur.angvel*dt*dt)>(angThreshold2*angThreshold2))){\n                                        cur.bullet=true;\n                                    }\n                                }\n                            }\n                            else{\n                                cur.sweepFrozen=true;\n                                cur.bullet=false;\n                            }\n                        }\n                        else{\n                            cur.sweepFrozen=true;\n                            cur.bullet=false;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n    }\n    public var continuous:Bool=false;\n    public function presteparb(arb:ZPP_Arbiter,dt:Float,?cont=false){\n        if(!arb.cleared&&(arb.b1.component.sleeping&&arb.b2.component.sleeping)){\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    false;\n                };\n                if(!res)throw \"assert(\"+\"false\"+\") :: \"+(\"sleep in prestep (no longer should occur)\");\n                #end\n            };\n            arb.sleep_stamp=stamp;\n            arb.sleeping=true;\n            return true;\n        }\n        #if NAPE_TIMES Debug.ACNT++;\n        #end\n        if(!arb.cleared||arb.present!=0||arb.intchange){\n            var endcb=(!cont&&arb.up_stamp==stamp-1)&&!arb.cleared&&!arb.intchange;\n            var begcb=(arb.fresh)&&!arb.cleared&&!arb.intchange;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    !begcb||arb.up_stamp==stamp;\n                };\n                if(!res)throw \"assert(\"+\"!begcb||arb.up_stamp==stamp\"+\") :: \"+(\" fresh -> active=true hasn't held :(\"+begcb+\" \"+arb.up_stamp+\" \"+stamp);\n                #end\n            };\n            if(endcb){\n                arb.endGenerated=stamp;\n            }\n            if(begcb||endcb||arb.cleared||arb.intchange){\n                inlined_MRCA_chains(arb.ws1,arb.ws2);\n                {\n                    var cx_ite=mrca1.begin();\n                    while(cx_ite!=null){\n                        var i1=cx_ite.elem();\n                        {\n                            {\n                                var cx_ite=mrca2.begin();\n                                while(cx_ite!=null){\n                                    var i2=cx_ite.elem();\n                                    {\n                                        var cb1=i1.cbSet;\n                                        var cb2=i2.cbSet;\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                cb1!=null&&cb2!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"cb1!=null&&cb2!=null\"+\") :: \"+(\"null cb from MRCA_chains?\");\n                                            #end\n                                        };\n                                        if(ZPP_CbSet.empty_intersection(cb1,cb2)){\n                                            cx_ite=cx_ite.next;\n                                            continue;\n                                        };\n                                        var callbackset=ZPP_Interactor.get(i1,i2);\n                                        if(begcb||arb.intchange){\n                                            if(callbackset==null){\n                                                callbackset=ZPP_CallbackSet.get(i1,i2);\n                                                add_callbackset(callbackset);\n                                            }\n                                            ZPP_CbSet.find_all(cb1,cb2,ZPP_Flags.id_CbEvent_BEGIN,function(listener:ZPP_InteractionListener){\n                                                if((listener.itype&arb.type)!=0&&callbackset.empty_arb(listener.itype)){\n                                                    var cb=push_callback(listener);\n                                                    cb.event=ZPP_Flags.id_CbEvent_BEGIN;\n                                                    ZPP_Interactor.int_callback(callbackset,listener,cb);\n                                                    cb.set=callbackset;\n                                                }\n                                            });\n                                            if(callbackset.add_arb(arb))arb.present++;\n                                        }\n                                        else{\n                                            arb.present--;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    arb.present>=0;\n                                                };\n                                                if(!res)throw \"assert(\"+\"arb.present>=0\"+\") :: \"+(\"arb present < 0?\");\n                                                #end\n                                            };\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    callbackset!=null;\n                                                };\n                                                if(!res)throw \"assert(\"+\"callbackset!=null\"+\") :: \"+(\"end arbiter with no callbackset\");\n                                                #end\n                                            };\n                                            callbackset.remove_arb(arb);\n                                            ZPP_CbSet.find_all(cb1,cb2,ZPP_Flags.id_CbEvent_END,function(listener:ZPP_InteractionListener){\n                                                if((listener.itype&arb.type)!=0&&callbackset.empty_arb(listener.itype)){\n                                                    var cb=push_callback(listener);\n                                                    cb.event=ZPP_Flags.id_CbEvent_END;\n                                                    ZPP_Interactor.int_callback(callbackset,listener,cb);\n                                                    cb.set=callbackset;\n                                                }\n                                            });\n                                            if(callbackset.really_empty()){\n                                                remove_callbackset(callbackset);\n                                            }\n                                        }\n                                    };\n                                    cx_ite=cx_ite.next;\n                                }\n                            };\n                        };\n                        cx_ite=cx_ite.next;\n                    }\n                };\n            }\n            arb.fresh=false;\n            arb.intchange=false;\n        }\n        if(arb.cleared||arb.up_stamp+(arb.type==ZPP_Arbiter.COL?Config.arbiterExpirationDelay:0)<stamp){\n            if(arb.type==ZPP_Arbiter.SENSOR)arb.sensorarb.retire();\n            else if(arb.type==ZPP_Arbiter.FLUID)arb.fluidarb.retire();\n            else arb.colarb.retire();\n            return true;\n        }\n        var pact=arb.active;\n        arb.active=arb.presentable=arb.up_stamp==stamp;\n        if((arb.immState&ZPP_Flags.id_ImmState_ACCEPT)!=0){\n            if(arb.active&&arb.type!=ZPP_Arbiter.SENSOR){\n                if(arb.colarb!=null){\n                    if(arb.colarb.preStep(dt)){\n                        arb.active=false;\n                    }\n                }\n                else arb.fluidarb.preStep(this,dt);\n            }\n        }\n        else if(arb.colarb!=null){\n            if(arb.colarb.cleanupContacts())arb.active=false;\n        }\n        if(pact!=arb.active){\n            arb.b1.arbiters.modified=true;\n            arb.b2.arbiters.modified=true;\n            c_arbiters_true.modified=c_arbiters_false.modified=true;\n            s_arbiters.modified=f_arbiters.modified=true;\n        }\n        return false;\n    }\n    public function prestep(dt:Float){\n        var pre=null;\n        {\n            var cx_ite=live_constraints.begin();\n            while(cx_ite!=null){\n                var con=cx_ite.elem();\n                {\n                    if(con.preStep(dt)){\n                        cx_ite=live_constraints.erase(pre);\n                        con.broken();\n                        constraintCbBreak(con);\n                        if(con.removeOnBreak){\n                            con.component.sleeping=true;\n                            midstep=false;\n                            if(con.compound!=null)con.compound.wrap_constraints.remove(con.outer);\n                            else wrap_constraints.remove(con.outer);\n                            midstep=true;\n                        }\n                        else con.active=false;\n                        con.clearcache();\n                        continue;\n                    }\n                    pre=cx_ite;\n                };\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var pre=null;\n            var arbs=c_arbiters_true;\n            var arbite=arbs.begin();\n            var fst=c_arbiters_false!=null;\n            {\n                if(fst&&arbite==null){\n                    fst=false;\n                    arbite=c_arbiters_false.begin();\n                    arbs=c_arbiters_false;\n                    pre=null;\n                }\n            };\n            while(arbite!=null){\n                var arb=arbite.elem();\n                if(presteparb(arb,dt)){\n                    arbite=arbs.inlined_erase(pre);\n                    {\n                        if(fst&&arbite==null){\n                            fst=false;\n                            arbite=c_arbiters_false.begin();\n                            arbs=c_arbiters_false;\n                            pre=null;\n                        }\n                    };\n                    continue;\n                }\n                pre=arbite;\n                arbite=arbite.next;\n                {\n                    if(fst&&arbite==null){\n                        fst=false;\n                        arbite=c_arbiters_false.begin();\n                        arbs=c_arbiters_false;\n                        pre=null;\n                    }\n                };\n            }\n        };\n        {\n            var pre=null;\n            var arbs=f_arbiters;\n            var arbite=arbs.begin();\n            var fst=null!=null;\n            {\n                if(fst&&arbite==null){\n                    fst=false;\n/*silly null. issues*/\n                    arbs=null;\n                    pre=null;\n                }\n            };\n            while(arbite!=null){\n                var arb=arbite.elem();\n                if(presteparb(arb,dt)){\n                    arbite=arbs.inlined_erase(pre);\n                    {\n                        if(fst&&arbite==null){\n                            fst=false;\n/*silly null. issues*/\n                            arbs=null;\n                            pre=null;\n                        }\n                    };\n                    continue;\n                }\n                pre=arbite;\n                arbite=arbite.next;\n                {\n                    if(fst&&arbite==null){\n                        fst=false;\n/*silly null. issues*/\n                        arbs=null;\n                        pre=null;\n                    }\n                };\n            }\n        };\n        {\n            var pre=null;\n            var arbs=s_arbiters;\n            var arbite=arbs.begin();\n            var fst=null!=null;\n            {\n                if(fst&&arbite==null){\n                    fst=false;\n/*silly null. issues*/\n                    arbs=null;\n                    pre=null;\n                }\n            };\n            while(arbite!=null){\n                var arb=arbite.elem();\n                if(presteparb(arb,dt)){\n                    arbite=arbs.inlined_erase(pre);\n                    {\n                        if(fst&&arbite==null){\n                            fst=false;\n/*silly null. issues*/\n                            arbs=null;\n                            pre=null;\n                        }\n                    };\n                    continue;\n                }\n                pre=arbite;\n                arbite=arbite.next;\n                {\n                    if(fst&&arbite==null){\n                        fst=false;\n/*silly null. issues*/\n                        arbs=null;\n                        pre=null;\n                    }\n                };\n            }\n        };\n    }\n    public function warmStart(){\n        {\n            var cx_ite=f_arbiters.begin();\n            while(cx_ite!=null){\n                var arb=cx_ite.elem();\n                if(arb.acting())arb.warmStart();\n                cx_ite=cx_ite.next;\n            }\n        };\n        {\n            var arbi=c_arbiters_false.begin();\n            var fst=true;\n            if(arbi==null){\n                arbi=c_arbiters_true.begin();\n                fst=false;\n            }\n            while(arbi!=null){\n                var arb=arbi.elem();\n                {\n                    if(arb.acting())arb.warmStart();\n                }\n                arbi=arbi.next;\n                if(fst&&arbi==null){\n                    arbi=c_arbiters_true.begin();\n                    fst=false;\n                }\n            }\n        };\n        {\n            var cx_ite=live_constraints.begin();\n            while(cx_ite!=null){\n                var con=cx_ite.elem();\n                con.warmStart();\n                cx_ite=cx_ite.next;\n            }\n        };\n    }\n    public function iterateVel(times:Int){\n        for(i in 0...times){\n            {\n                var cx_ite=f_arbiters.begin();\n                while(cx_ite!=null){\n                    var arb=cx_ite.elem();\n                    if(arb.acting())arb.applyImpulseVel();\n                    cx_ite=cx_ite.next;\n                }\n            };\n            var pre=null;\n            {\n                var cx_ite=live_constraints.begin();\n                while(cx_ite!=null){\n                    var con=cx_ite.elem();\n                    {\n                        if(con.applyImpulseVel()){\n                            cx_ite=live_constraints.erase(pre);\n                            con.broken();\n                            constraintCbBreak(con);\n                            if(con.removeOnBreak){\n                                con.component.sleeping=true;\n                                midstep=false;\n                                if(con.compound!=null)con.compound.wrap_constraints.remove(con.outer);\n                                else wrap_constraints.remove(con.outer);\n                                midstep=true;\n                            }\n                            else con.active=false;\n                            con.clearcache();\n                            continue;\n                        }\n                        pre=cx_ite;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var arbi=c_arbiters_false.begin();\n                var fst=true;\n                if(arbi==null){\n                    arbi=c_arbiters_true.begin();\n                    fst=false;\n                }\n                while(arbi!=null){\n                    var arb=arbi.elem();\n                    {\n                        if(arb.acting())arb.applyImpulseVel();\n                    }\n                    arbi=arbi.next;\n                    if(fst&&arbi==null){\n                        arbi=c_arbiters_true.begin();\n                        fst=false;\n                    }\n                }\n            };\n        }\n    }\n    public function iteratePos(times:Int){\n        for(i in 0...times){\n            var pre=null;\n            {\n                var cx_ite=live_constraints.begin();\n                while(cx_ite!=null){\n                    var con=cx_ite.elem();\n                    {\n                        if(!con.__velocity&&con.stiff){\n                            if(con.applyImpulsePos()){\n                                cx_ite=live_constraints.erase(pre);\n                                con.broken();\n                                constraintCbBreak(con);\n                                if(con.removeOnBreak){\n                                    con.component.sleeping=true;\n                                    midstep=false;\n                                    if(con.compound!=null)con.compound.wrap_constraints.remove(con.outer);\n                                    else wrap_constraints.remove(con.outer);\n                                    midstep=true;\n                                }\n                                else con.active=false;\n                                con.clearcache();\n                                continue;\n                            }\n                        }\n                        pre=cx_ite;\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n            {\n                var arbi=c_arbiters_false.begin();\n                var fst=true;\n                if(arbi==null){\n                    arbi=c_arbiters_true.begin();\n                    fst=false;\n                }\n                while(arbi!=null){\n                    var arb=arbi.elem();\n                    {\n                        {\n                            if(arb.acting()){\n                                arb.applyImpulsePos();\n                            }\n                        };\n                    }\n                    arbi=arbi.next;\n                    if(fst&&arbi==null){\n                        arbi=c_arbiters_true.begin();\n                        fst=false;\n                    }\n                }\n            };\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function group_ignore(s1:ZPP_Shape,s2:ZPP_Shape){\n        var g1=s1.lookup_group();\n        if(g1==null)return false;\n        else{\n            var g2=s2.lookup_group();\n            if(g2==null)return false;\n            else{\n                var ret=false;\n                while(g1!=null&&g2!=null){\n                    if(g1==g2){\n                        ret=g1.ignore;\n                        break;\n                    }\n                    if(g1.depth<g2.depth)g2=g2.group;\n                    else g1=g1.group;\n                }\n                return ret;\n            }\n        }\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function interactionType(s1:ZPP_Shape,s2:ZPP_Shape,b1:ZPP_Body,b2:ZPP_Body){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !(b1==b2);\n            };\n            if(!res)throw \"assert(\"+\"!(b1==b2)\"+\") :: \"+(\"both shapes from same object?\");\n            #end\n        };\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !(b1.isStatic()&&b2.isStatic());\n            };\n            if(!res)throw \"assert(\"+\"!(b1.isStatic()&&b2.isStatic())\"+\") :: \"+(\"both objects static?\");\n            #end\n        };\n        var con_ignore;\n        {\n            con_ignore=false;\n            {\n                var cx_ite=b1.constraints.begin();\n                while(cx_ite!=null){\n                    var con=cx_ite.elem();\n                    {\n                        if(con.ignore&&con.pair_exists(b1.id,b2.id)){\n                            con_ignore=true;\n                            break;\n                        }\n                    };\n                    cx_ite=cx_ite.next;\n                }\n            };\n        };\n        if(!con_ignore&&!group_ignore(s1,s2)){\n            if((s1.sensorEnabled||s2.sensorEnabled)&&s1.filter.shouldSense(s2.filter)){\n                return 2;\n            }\n            else if((s1.fluidEnabled||s2.fluidEnabled)&&s1.filter.shouldFlow(s2.filter)&&!(b1.imass==0&&b2.imass==0&&b1.iinertia==0&&b2.iinertia==0)){\n                return 0;\n            }\n            else if(s1.filter.shouldCollide(s2.filter)&&!(b1.imass==0&&b2.imass==0&&b1.iinertia==0&&b2.iinertia==0)){\n                return 1;\n            }\n            else return-1;\n        }\n        else return-1;\n    }\n    var precb:PreCallback=null;\n    var prelisteners:ZNPList_ZPP_InteractionListener=null;\n    public function narrowPhase(s1:ZPP_Shape,s2:ZPP_Shape,stat:Bool,in_arb:ZPP_Arbiter,continuous:Bool){\n        #if NAPE_TIMES var pt=flash.Lib.getTimer();\n        #end\n        var ret:ZPP_Arbiter=null;\n        var b1=s1.body;\n        var b2=s2.body;\n        var itype=interactionType(s1,s2,b1,b2);\n        if(itype!=-1){\n            var sa,sb;\n            if(s1.type>s2.type){\n                sa=s2;\n                sb=s1;\n            }\n            else if(s1.type==s2.type){\n                if(s1.id<s2.id){\n                    sa=s1;\n                    sb=s2;\n                }\n                else{\n                    sb=s1;\n                    sa=s2;\n                }\n            }\n            else{\n                sa=s1;\n                sb=s2;\n            }\n            var reverse=sa==s2;\n            if(itype==0){\n                var xarb=if(in_arb==null)({\n                    var ret:ZPP_Arbiter=null;\n                    var b=if(b1.arbiters.length<b2.arbiters.length)b1 else b2;\n                    {\n                        var cx_ite=b.arbiters.begin();\n                        while(cx_ite!=null){\n                            var arb=cx_ite.elem();\n                            {\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !(arb.id==sb.id&&arb.di==sa.id);\n                                    };\n                                    if(!res)throw \"assert(\"+\"!(arb.id==sb.id&&arb.di==sa.id)\"+\") :: \"+(\"arbiter id order doesn't match s1/s2 order?>\");\n                                    #end\n                                };\n                                if(arb.id==sa.id&&arb.di==sb.id){\n                                    ret=arb;\n                                    break;\n                                }\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    ret;\n                })else in_arb;\n                var first=xarb==null;\n                var arb;\n                var swapped=false;\n                if(first){\n                    if(ZPP_FluidArbiter.zpp_pool==null){\n                        arb=new ZPP_FluidArbiter();\n                        #if NAPE_POOL_STATS ZPP_FluidArbiter.POOL_TOT++;\n                        ZPP_FluidArbiter.POOL_ADDNEW++;\n                        #end\n                    }\n                    else{\n                        arb=ZPP_FluidArbiter.zpp_pool;\n                        ZPP_FluidArbiter.zpp_pool=arb.next;\n                        arb.next=null;\n                        #if NAPE_POOL_STATS ZPP_FluidArbiter.POOL_CNT--;\n                        ZPP_FluidArbiter.POOL_ADD++;\n                        #end\n                    }\n                    arb.alloc();\n                }\n                else{\n                    if(xarb.fluidarb==null){\n                        xarb.lazyRetire(this,null);\n                        {\n                            if(ZPP_FluidArbiter.zpp_pool==null){\n                                arb=new ZPP_FluidArbiter();\n                                #if NAPE_POOL_STATS ZPP_FluidArbiter.POOL_TOT++;\n                                ZPP_FluidArbiter.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                arb=ZPP_FluidArbiter.zpp_pool;\n                                ZPP_FluidArbiter.zpp_pool=arb.next;\n                                arb.next=null;\n                                #if NAPE_POOL_STATS ZPP_FluidArbiter.POOL_CNT--;\n                                ZPP_FluidArbiter.POOL_ADD++;\n                                #end\n                            }\n                            arb.alloc();\n                        };\n                        arb.intchange=true;\n                        first=true;\n                        swapped=true;\n                    }\n                    else arb=xarb.fluidarb;\n                }\n                ret={\n                    var inttype=ZPP_Flags.id_InteractionType_FLUID;\n                    if(first||arb.stamp!=stamp||continuous){\n                        arb.stamp=stamp;\n                        if(ZPP_Collide.flowCollide(sa,sb,arb)){\n                            if(first){\n                                arb.assign(s1,s2,sa.id,sb.id);\n                                f_arbiters.inlined_add(arb);\n                                arb.fresh=!swapped;\n                            }\n                            else{\n                                arb.fresh=(arb.up_stamp<stamp-1||(arb.endGenerated==stamp&&continuous));\n                            }\n                            arb.up_stamp=arb.stamp;\n                            if(arb.fresh||(arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0){\n                                arb.immState=ZPP_Flags.id_ImmState_ACCEPT;\n                                var anyimpure=false;\n                                var arbs1=arb.ws1.id>arb.ws2.id?arb.ws2:arb.ws1;\n                                var arbs2=arb.ws1.id>arb.ws2.id?arb.ws1:arb.ws2;\n                                inlined_MRCA_chains(arbs1,arbs2);\n                                {\n                                    var cx_ite=mrca1.begin();\n                                    while(cx_ite!=null){\n                                        var i1=cx_ite.elem();\n                                        {\n                                            {\n                                                var cx_ite=mrca2.begin();\n                                                while(cx_ite!=null){\n                                                    var i2=cx_ite.elem();\n                                                    {\n                                                        var cb1=i1.cbSet;\n                                                        var cb2=i2.cbSet;\n                                                        {\n                                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                            var res={\n                                                                cb1!=null&&cb2!=null;\n                                                            };\n                                                            if(!res)throw \"assert(\"+\"cb1!=null&&cb2!=null\"+\") :: \"+(\"null cb from MRCA_chains?\");\n                                                            #end\n                                                        };\n                                                        if(ZPP_CbSet.empty_intersection(cb1,cb2)){\n                                                            cx_ite=cx_ite.next;\n                                                            continue;\n                                                        };\n                                                        var callbackset:ZPP_CallbackSet=null;\n                                                        var ncallbackset:ZPP_CallbackSet=null;\n                                                        prelisteners.inlined_clear();\n                                                        var lite:ZNPNode_ZPP_InteractionListener=null;\n                                                        ZPP_CbSet.find_all(cb1,cb2,ZPP_Flags.id_CbEvent_PRE,function(listener:ZPP_InteractionListener){\n                                                            if((listener.itype&inttype)!=0){\n                                                                lite=prelisteners.inlined_insert(lite,listener);\n                                                                anyimpure=anyimpure||!listener.pure;\n                                                            }\n                                                        });\n                                                        if(prelisteners.empty()){\n                                                            cx_ite=cx_ite.next;\n                                                            continue;\n                                                        };\n                                                        callbackset=ZPP_Interactor.get(i1,i2);\n                                                        if(callbackset==null){\n                                                            ncallbackset=ZPP_CallbackSet.get(i1,i2);\n                                                            add_callbackset(ncallbackset);\n                                                        }\n                                                        if(callbackset==null||((callbackset.FLUIDstamp!=stamp||continuous)&&(callbackset.FLUIDstate&ZPP_Flags.id_ImmState_ALWAYS==0))){\n                                                            if(ncallbackset!=null)callbackset=ncallbackset;\n                                                            if(callbackset!=null){\n                                                                {\n                                                                    var cx_ite=prelisteners.begin();\n                                                                    while(cx_ite!=null){\n                                                                        var listener=cx_ite.elem();\n                                                                        {\n                                                                            if(listener.itype==ZPP_Flags.id_InteractionType_ANY){\n                                                                                callbackset.COLLISIONstamp=stamp;\n                                                                                callbackset.SENSORstamp=stamp;\n                                                                                callbackset.FLUIDstamp=stamp;\n                                                                            }\n                                                                            else callbackset.FLUIDstamp=stamp;\n                                                                        };\n                                                                        cx_ite=cx_ite.next;\n                                                                    }\n                                                                };\n                                                            }\n                                                            #if(!NAPE_RELEASE_BUILD)\n                                                            arb.makemutable();\n                                                            #end\n                                                            var pact=arb.active;\n                                                            arb.active=true;\n                                                            var emptycontacts=false;\n                                                            #if false arb.cleanupContacts();\n                                                            #end\n                                                            precb.zpp_inner.pre_arbiter=arb;\n                                                            precb.zpp_inner.set=callbackset;\n                                                            {\n                                                                var cx_ite=prelisteners.begin();\n                                                                while(cx_ite!=null){\n                                                                    var listener=cx_ite.elem();\n                                                                    {\n                                                                        precb.zpp_inner.listener=listener;\n                                                                        #if NAPE_ASSERT if(callbackset.int1==null){\n                                                                            var err=\"\";\n                                                                            err+=\"OKAY WTF IS HAPPENING HERE\\n\";\n                                                                            err+=\"ncallbackset is null? \"+(ncallbackset==null?\"yes\":\"no\")+\"\\n\";\n                                                                            err+=\"assuming yes, let's find callbacksets on interactor\\n\";\n                                                                            err+=\"i1 (id=\"+i1.id+\"):\\n\";\n                                                                            {\n                                                                                var cx_ite=i1.cbsets.begin();\n                                                                                while(cx_ite!=null){\n                                                                                    var cbset=cx_ite.elem();\n                                                                                    err+=\"  (\"+cbset.id+\" \"+(cbset.int1==null?\"null\":\"\")+\",\"+cbset.di+\" \"+(cbset.int2==null?\"null\":\"\")+\") arbs size=\"+cbset.arbiters.size()+\" freed=\"+cbset.freed+\" lazydel=\"+cbset.lazydel+\"\\n\";\n                                                                                    cx_ite=cx_ite.next;\n                                                                                }\n                                                                            };\n                                                                            err+=\"i2 (id=\"+i2.id+\"):\\n\";\n                                                                            {\n                                                                                var cx_ite=i2.cbsets.begin();\n                                                                                while(cx_ite!=null){\n                                                                                    var cbset=cx_ite.elem();\n                                                                                    err+=\"  (\"+cbset.id+\" \"+(cbset.int1==null?\"null\":\"\")+\",\"+cbset.di+\" \"+(cbset.int2==null?\"null\":\"\")+\") arbs size=\"+cbset.arbiters.size()+\" freed=\"+cbset.freed+\" lazydel=\"+cbset.lazydel+\"\\n\";\n                                                                                    cx_ite=cx_ite.next;\n                                                                                }\n                                                                            };\n                                                                            throw err;\n                                                                        }\n                                                                        #end\n                                                                        ZPP_Interactor.int_callback(callbackset,listener,precb.zpp_inner);\n                                                                        precb.zpp_inner.pre_swapped=i1!=precb.zpp_inner.int1;\n                                                                        var ret=listener.handlerp(precb);\n                                                                        if(ret!=null){\n                                                                            arb.immState=if(ret==PreFlag.ACCEPT)ZPP_Flags.id_ImmState_ACCEPT|ZPP_Flags.id_ImmState_ALWAYS else if(ret==PreFlag.ACCEPT_ONCE)ZPP_Flags.id_ImmState_ACCEPT else if(ret==PreFlag.IGNORE)ZPP_Flags.id_ImmState_IGNORE|ZPP_Flags.id_ImmState_ALWAYS else ZPP_Flags.id_ImmState_IGNORE;\n                                                                        }\n                                                                    };\n                                                                    cx_ite=cx_ite.next;\n                                                                }\n                                                            };\n                                                            #if(!NAPE_RELEASE_BUILD)\n                                                            arb.makeimmutable();\n                                                            #end\n                                                            arb.active=pact;\n                                                            if(callbackset!=null){\n                                                                {\n                                                                    var cx_ite=prelisteners.begin();\n                                                                    while(cx_ite!=null){\n                                                                        var listener=cx_ite.elem();\n                                                                        {\n                                                                            if(listener.itype==ZPP_Flags.id_InteractionType_ANY){\n                                                                                callbackset.COLLISIONstate=arb.immState;\n                                                                                callbackset.SENSORstate=arb.immState;\n                                                                                callbackset.FLUIDstate=arb.immState;\n                                                                            }\n                                                                            else callbackset.FLUIDstate=arb.immState;\n                                                                        };\n                                                                        cx_ite=cx_ite.next;\n                                                                    }\n                                                                };\n                                                            }\n                                                        }\n                                                        else if(callbackset==null){\n                                                            if((arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0)arb.immState=ZPP_Flags.id_ImmState_ACCEPT;\n                                                        }\n                                                        else arb.immState=callbackset.FLUIDstate;\n                                                    };\n                                                    cx_ite=cx_ite.next;\n                                                }\n                                            };\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                if(anyimpure&&(arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0){\n                                    if(true){\n                                        if(arb.b1.isDynamic()){\n                                            var o=arb.b1;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                        if(arb.b1.isDynamic()){\n                                            var o=arb.b2;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                    }\n                                    else{\n                                        if(!arb.b1.isStatic()){\n                                            var o=arb.b1;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                        if(!arb.b2.isStatic()){\n                                            var o=arb.b2;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                    }\n                                }\n                            }\n                            if(true&&(arb.immState&ZPP_Flags.id_ImmState_ACCEPT)!=0){\n                                if(arb.b1.isDynamic()&&arb.b1.component.sleeping){\n                                    var o=arb.b1;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o.space==this;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                        #end\n                                    };\n                                    if(!o.world){\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o.component!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                            #end\n                                        };\n                                        o.component.waket=stamp+(midstep?0:1);\n                                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                                        if(o.component.sleeping){\n                                            really_wake(o,false);\n                                        }\n                                    }\n                                };\n                                if(arb.b2.isDynamic()&&arb.b2.component.sleeping){\n                                    var o=arb.b2;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o.space==this;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                        #end\n                                    };\n                                    if(!o.world){\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o.component!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                            #end\n                                        };\n                                        o.component.waket=stamp+(midstep?0:1);\n                                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                                        if(o.component.sleeping){\n                                            really_wake(o,false);\n                                        }\n                                    }\n                                };\n                            }\n                            if(arb.sleeping){\n                                arb.sleeping=false;\n                                f_arbiters.inlined_add(arb);\n                            }\n                            arb;\n                        }\n                        else if(first){\n                            {\n                                var o=arb;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        o!=null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_FluidArbiter\"+\", in obj: \"+\"arb\"+\")\");\n                                    #end\n                                };\n                                o.free();\n                                o.next=ZPP_FluidArbiter.zpp_pool;\n                                ZPP_FluidArbiter.zpp_pool=o;\n                                #if NAPE_POOL_STATS ZPP_FluidArbiter.POOL_CNT++;\n                                ZPP_FluidArbiter.POOL_SUB++;\n                                #end\n                            };\n                            null;\n                        }\n                        else arb;\n                    }\n                    else arb;\n                };\n            }\n            else if(itype==1){\n                var carbs=stat?c_arbiters_true:c_arbiters_false;\n                var xarb=if(in_arb==null)({\n                    var ret:ZPP_Arbiter=null;\n                    var b=if(b1.arbiters.length<b2.arbiters.length)b1 else b2;\n                    {\n                        var cx_ite=b.arbiters.begin();\n                        while(cx_ite!=null){\n                            var arb=cx_ite.elem();\n                            {\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !(arb.id==sb.id&&arb.di==sa.id);\n                                    };\n                                    if(!res)throw \"assert(\"+\"!(arb.id==sb.id&&arb.di==sa.id)\"+\") :: \"+(\"arbiter id order doesn't match s1/s2 order?>\");\n                                    #end\n                                };\n                                if(arb.id==sa.id&&arb.di==sb.id){\n                                    ret=arb;\n                                    break;\n                                }\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    ret;\n                })else in_arb;\n                var first=xarb==null;\n                var arb;\n                var swapped=false;\n                if(first){\n                    {\n                        if(ZPP_ColArbiter.zpp_pool==null){\n                            arb=new ZPP_ColArbiter();\n                            #if NAPE_POOL_STATS ZPP_ColArbiter.POOL_TOT++;\n                            ZPP_ColArbiter.POOL_ADDNEW++;\n                            #end\n                        }\n                        else{\n                            arb=ZPP_ColArbiter.zpp_pool;\n                            ZPP_ColArbiter.zpp_pool=arb.next;\n                            arb.next=null;\n                            #if NAPE_POOL_STATS ZPP_ColArbiter.POOL_CNT--;\n                            ZPP_ColArbiter.POOL_ADD++;\n                            #end\n                        }\n                        arb.alloc();\n                    };\n                    arb.stat=stat;\n                }\n                else{\n                    if(xarb.colarb==null){\n                        xarb.lazyRetire(this,null);\n                        {\n                            if(ZPP_ColArbiter.zpp_pool==null){\n                                arb=new ZPP_ColArbiter();\n                                #if NAPE_POOL_STATS ZPP_ColArbiter.POOL_TOT++;\n                                ZPP_ColArbiter.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                arb=ZPP_ColArbiter.zpp_pool;\n                                ZPP_ColArbiter.zpp_pool=arb.next;\n                                arb.next=null;\n                                #if NAPE_POOL_STATS ZPP_ColArbiter.POOL_CNT--;\n                                ZPP_ColArbiter.POOL_ADD++;\n                                #end\n                            }\n                            arb.alloc();\n                        };\n                        arb.intchange=true;\n                        arb.stat=stat;\n                        first=true;\n                        swapped=true;\n                    }\n                    else{\n                        arb=xarb.colarb;\n                        reverse=sa!=arb.s1;\n                        if(arb.stat!=stat){\n                            arb.stat=stat;\n                            if(!arb.sleeping){\n                                (if(stat)c_arbiters_false else c_arbiters_true).remove(arb);\n                                carbs.add(arb);\n                            }\n                        }\n                    }\n                }\n                ret={\n                    var inttype=ZPP_Flags.id_InteractionType_COLLISION;\n                    if(first||arb.stamp!=stamp||continuous){\n                        arb.stamp=stamp;\n                        if(ZPP_Collide.contactCollide(sa,sb,arb,reverse)){\n                            if(first){\n                                arb.assign(s1,s2,sa.id,sb.id);\n                                carbs.inlined_add(arb);\n                                arb.fresh=!swapped;\n                            }\n                            else{\n                                arb.fresh=(arb.up_stamp<stamp-1||(arb.endGenerated==stamp&&continuous));\n                            }\n                            arb.up_stamp=arb.stamp;\n                            if(arb.fresh||(arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0){\n                                arb.immState=ZPP_Flags.id_ImmState_ACCEPT;\n                                var anyimpure=false;\n                                var arbs1=arb.ws1.id>arb.ws2.id?arb.ws2:arb.ws1;\n                                var arbs2=arb.ws1.id>arb.ws2.id?arb.ws1:arb.ws2;\n                                inlined_MRCA_chains(arbs1,arbs2);\n                                {\n                                    var cx_ite=mrca1.begin();\n                                    while(cx_ite!=null){\n                                        var i1=cx_ite.elem();\n                                        {\n                                            {\n                                                var cx_ite=mrca2.begin();\n                                                while(cx_ite!=null){\n                                                    var i2=cx_ite.elem();\n                                                    {\n                                                        var cb1=i1.cbSet;\n                                                        var cb2=i2.cbSet;\n                                                        {\n                                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                            var res={\n                                                                cb1!=null&&cb2!=null;\n                                                            };\n                                                            if(!res)throw \"assert(\"+\"cb1!=null&&cb2!=null\"+\") :: \"+(\"null cb from MRCA_chains?\");\n                                                            #end\n                                                        };\n                                                        if(ZPP_CbSet.empty_intersection(cb1,cb2)){\n                                                            cx_ite=cx_ite.next;\n                                                            continue;\n                                                        };\n                                                        var callbackset:ZPP_CallbackSet=null;\n                                                        var ncallbackset:ZPP_CallbackSet=null;\n                                                        prelisteners.inlined_clear();\n                                                        var lite:ZNPNode_ZPP_InteractionListener=null;\n                                                        ZPP_CbSet.find_all(cb1,cb2,ZPP_Flags.id_CbEvent_PRE,function(listener:ZPP_InteractionListener){\n                                                            if((listener.itype&inttype)!=0){\n                                                                lite=prelisteners.inlined_insert(lite,listener);\n                                                                anyimpure=anyimpure||!listener.pure;\n                                                            }\n                                                        });\n                                                        if(prelisteners.empty()){\n                                                            cx_ite=cx_ite.next;\n                                                            continue;\n                                                        };\n                                                        callbackset=ZPP_Interactor.get(i1,i2);\n                                                        if(callbackset==null){\n                                                            ncallbackset=ZPP_CallbackSet.get(i1,i2);\n                                                            add_callbackset(ncallbackset);\n                                                        }\n                                                        if(callbackset==null||((callbackset.COLLISIONstamp!=stamp||continuous)&&(callbackset.COLLISIONstate&ZPP_Flags.id_ImmState_ALWAYS==0))){\n                                                            if(ncallbackset!=null)callbackset=ncallbackset;\n                                                            if(callbackset!=null){\n                                                                {\n                                                                    var cx_ite=prelisteners.begin();\n                                                                    while(cx_ite!=null){\n                                                                        var listener=cx_ite.elem();\n                                                                        {\n                                                                            if(listener.itype==ZPP_Flags.id_InteractionType_ANY){\n                                                                                callbackset.COLLISIONstamp=stamp;\n                                                                                callbackset.SENSORstamp=stamp;\n                                                                                callbackset.FLUIDstamp=stamp;\n                                                                            }\n                                                                            else callbackset.COLLISIONstamp=stamp;\n                                                                        };\n                                                                        cx_ite=cx_ite.next;\n                                                                    }\n                                                                };\n                                                            }\n                                                            #if(!NAPE_RELEASE_BUILD)\n                                                            arb.makemutable();\n                                                            #end\n                                                            var pact=arb.active;\n                                                            arb.active=true;\n                                                            var emptycontacts=false;\n                                                            #if true arb.cleanupContacts();\n                                                            #end\n                                                            precb.zpp_inner.pre_arbiter=arb;\n                                                            precb.zpp_inner.set=callbackset;\n                                                            {\n                                                                var cx_ite=prelisteners.begin();\n                                                                while(cx_ite!=null){\n                                                                    var listener=cx_ite.elem();\n                                                                    {\n                                                                        precb.zpp_inner.listener=listener;\n                                                                        #if NAPE_ASSERT if(callbackset.int1==null){\n                                                                            var err=\"\";\n                                                                            err+=\"OKAY WTF IS HAPPENING HERE\\n\";\n                                                                            err+=\"ncallbackset is null? \"+(ncallbackset==null?\"yes\":\"no\")+\"\\n\";\n                                                                            err+=\"assuming yes, let's find callbacksets on interactor\\n\";\n                                                                            err+=\"i1 (id=\"+i1.id+\"):\\n\";\n                                                                            {\n                                                                                var cx_ite=i1.cbsets.begin();\n                                                                                while(cx_ite!=null){\n                                                                                    var cbset=cx_ite.elem();\n                                                                                    err+=\"  (\"+cbset.id+\" \"+(cbset.int1==null?\"null\":\"\")+\",\"+cbset.di+\" \"+(cbset.int2==null?\"null\":\"\")+\") arbs size=\"+cbset.arbiters.size()+\" freed=\"+cbset.freed+\" lazydel=\"+cbset.lazydel+\"\\n\";\n                                                                                    cx_ite=cx_ite.next;\n                                                                                }\n                                                                            };\n                                                                            err+=\"i2 (id=\"+i2.id+\"):\\n\";\n                                                                            {\n                                                                                var cx_ite=i2.cbsets.begin();\n                                                                                while(cx_ite!=null){\n                                                                                    var cbset=cx_ite.elem();\n                                                                                    err+=\"  (\"+cbset.id+\" \"+(cbset.int1==null?\"null\":\"\")+\",\"+cbset.di+\" \"+(cbset.int2==null?\"null\":\"\")+\") arbs size=\"+cbset.arbiters.size()+\" freed=\"+cbset.freed+\" lazydel=\"+cbset.lazydel+\"\\n\";\n                                                                                    cx_ite=cx_ite.next;\n                                                                                }\n                                                                            };\n                                                                            throw err;\n                                                                        }\n                                                                        #end\n                                                                        ZPP_Interactor.int_callback(callbackset,listener,precb.zpp_inner);\n                                                                        precb.zpp_inner.pre_swapped=i1!=precb.zpp_inner.int1;\n                                                                        var ret=listener.handlerp(precb);\n                                                                        if(ret!=null){\n                                                                            arb.immState=if(ret==PreFlag.ACCEPT)ZPP_Flags.id_ImmState_ACCEPT|ZPP_Flags.id_ImmState_ALWAYS else if(ret==PreFlag.ACCEPT_ONCE)ZPP_Flags.id_ImmState_ACCEPT else if(ret==PreFlag.IGNORE)ZPP_Flags.id_ImmState_IGNORE|ZPP_Flags.id_ImmState_ALWAYS else ZPP_Flags.id_ImmState_IGNORE;\n                                                                        }\n                                                                    };\n                                                                    cx_ite=cx_ite.next;\n                                                                }\n                                                            };\n                                                            #if(!NAPE_RELEASE_BUILD)\n                                                            arb.makeimmutable();\n                                                            #end\n                                                            arb.active=pact;\n                                                            if(callbackset!=null){\n                                                                {\n                                                                    var cx_ite=prelisteners.begin();\n                                                                    while(cx_ite!=null){\n                                                                        var listener=cx_ite.elem();\n                                                                        {\n                                                                            if(listener.itype==ZPP_Flags.id_InteractionType_ANY){\n                                                                                callbackset.COLLISIONstate=arb.immState;\n                                                                                callbackset.SENSORstate=arb.immState;\n                                                                                callbackset.FLUIDstate=arb.immState;\n                                                                            }\n                                                                            else callbackset.COLLISIONstate=arb.immState;\n                                                                        };\n                                                                        cx_ite=cx_ite.next;\n                                                                    }\n                                                                };\n                                                            }\n                                                        }\n                                                        else if(callbackset==null){\n                                                            if((arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0)arb.immState=ZPP_Flags.id_ImmState_ACCEPT;\n                                                        }\n                                                        else arb.immState=callbackset.COLLISIONstate;\n                                                    };\n                                                    cx_ite=cx_ite.next;\n                                                }\n                                            };\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                if(anyimpure&&(arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0){\n                                    if(true){\n                                        if(arb.b1.isDynamic()){\n                                            var o=arb.b1;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                        if(arb.b1.isDynamic()){\n                                            var o=arb.b2;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                    }\n                                    else{\n                                        if(!arb.b1.isStatic()){\n                                            var o=arb.b1;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                        if(!arb.b2.isStatic()){\n                                            var o=arb.b2;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                    }\n                                }\n                            }\n                            if(true&&(arb.immState&ZPP_Flags.id_ImmState_ACCEPT)!=0){\n                                if(arb.b1.isDynamic()&&arb.b1.component.sleeping){\n                                    var o=arb.b1;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o.space==this;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                        #end\n                                    };\n                                    if(!o.world){\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o.component!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                            #end\n                                        };\n                                        o.component.waket=stamp+(midstep?0:1);\n                                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                                        if(o.component.sleeping){\n                                            really_wake(o,false);\n                                        }\n                                    }\n                                };\n                                if(arb.b2.isDynamic()&&arb.b2.component.sleeping){\n                                    var o=arb.b2;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o.space==this;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                        #end\n                                    };\n                                    if(!o.world){\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o.component!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                            #end\n                                        };\n                                        o.component.waket=stamp+(midstep?0:1);\n                                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                                        if(o.component.sleeping){\n                                            really_wake(o,false);\n                                        }\n                                    }\n                                };\n                            }\n                            if(arb.sleeping){\n                                arb.sleeping=false;\n                                carbs.inlined_add(arb);\n                            }\n                            arb;\n                        }\n                        else if(first){\n                            {\n                                var o=arb;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        o!=null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_ColArbiter\"+\", in obj: \"+\"arb\"+\")\");\n                                    #end\n                                };\n                                o.free();\n                                o.next=ZPP_ColArbiter.zpp_pool;\n                                ZPP_ColArbiter.zpp_pool=o;\n                                #if NAPE_POOL_STATS ZPP_ColArbiter.POOL_CNT++;\n                                ZPP_ColArbiter.POOL_SUB++;\n                                #end\n                            };\n                            null;\n                        }\n                        else arb;\n                    }\n                    else arb;\n                };\n            }\n            else{\n                var xarb=if(in_arb==null)({\n                    var ret:ZPP_Arbiter=null;\n                    var b=if(b1.arbiters.length<b2.arbiters.length)b1 else b2;\n                    {\n                        var cx_ite=b.arbiters.begin();\n                        while(cx_ite!=null){\n                            var arb=cx_ite.elem();\n                            {\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        !(arb.id==sb.id&&arb.di==sa.id);\n                                    };\n                                    if(!res)throw \"assert(\"+\"!(arb.id==sb.id&&arb.di==sa.id)\"+\") :: \"+(\"arbiter id order doesn't match s1/s2 order?>\");\n                                    #end\n                                };\n                                if(arb.id==sa.id&&arb.di==sb.id){\n                                    ret=arb;\n                                    break;\n                                }\n                            };\n                            cx_ite=cx_ite.next;\n                        }\n                    };\n                    ret;\n                })else in_arb;\n                var first=xarb==null;\n                var arb;\n                var swapped=false;\n                if(first){\n                    if(ZPP_SensorArbiter.zpp_pool==null){\n                        arb=new ZPP_SensorArbiter();\n                        #if NAPE_POOL_STATS ZPP_SensorArbiter.POOL_TOT++;\n                        ZPP_SensorArbiter.POOL_ADDNEW++;\n                        #end\n                    }\n                    else{\n                        arb=ZPP_SensorArbiter.zpp_pool;\n                        ZPP_SensorArbiter.zpp_pool=arb.next;\n                        arb.next=null;\n                        #if NAPE_POOL_STATS ZPP_SensorArbiter.POOL_CNT--;\n                        ZPP_SensorArbiter.POOL_ADD++;\n                        #end\n                    }\n                    arb.alloc();\n                }\n                else{\n                    if(xarb.sensorarb==null){\n                        xarb.lazyRetire(this,null);\n                        {\n                            if(ZPP_SensorArbiter.zpp_pool==null){\n                                arb=new ZPP_SensorArbiter();\n                                #if NAPE_POOL_STATS ZPP_SensorArbiter.POOL_TOT++;\n                                ZPP_SensorArbiter.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                arb=ZPP_SensorArbiter.zpp_pool;\n                                ZPP_SensorArbiter.zpp_pool=arb.next;\n                                arb.next=null;\n                                #if NAPE_POOL_STATS ZPP_SensorArbiter.POOL_CNT--;\n                                ZPP_SensorArbiter.POOL_ADD++;\n                                #end\n                            }\n                            arb.alloc();\n                        };\n                        arb.intchange=true;\n                        first=true;\n                        swapped=true;\n                    }\n                    else arb=xarb.sensorarb;\n                }\n                ret={\n                    var inttype=ZPP_Flags.id_InteractionType_SENSOR;\n                    if(first||arb.stamp!=stamp||continuous){\n                        arb.stamp=stamp;\n                        if(ZPP_Collide.testCollide(sa,sb)){\n                            if(first){\n                                arb.assign(s1,s2,sa.id,sb.id);\n                                s_arbiters.inlined_add(arb);\n                                arb.fresh=!swapped;\n                            }\n                            else{\n                                arb.fresh=(arb.up_stamp<stamp-1||(arb.endGenerated==stamp&&continuous));\n                            }\n                            arb.up_stamp=arb.stamp;\n                            if(arb.fresh||(arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0){\n                                arb.immState=ZPP_Flags.id_ImmState_ACCEPT;\n                                var anyimpure=false;\n                                var arbs1=arb.ws1.id>arb.ws2.id?arb.ws2:arb.ws1;\n                                var arbs2=arb.ws1.id>arb.ws2.id?arb.ws1:arb.ws2;\n                                inlined_MRCA_chains(arbs1,arbs2);\n                                {\n                                    var cx_ite=mrca1.begin();\n                                    while(cx_ite!=null){\n                                        var i1=cx_ite.elem();\n                                        {\n                                            {\n                                                var cx_ite=mrca2.begin();\n                                                while(cx_ite!=null){\n                                                    var i2=cx_ite.elem();\n                                                    {\n                                                        var cb1=i1.cbSet;\n                                                        var cb2=i2.cbSet;\n                                                        {\n                                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                            var res={\n                                                                cb1!=null&&cb2!=null;\n                                                            };\n                                                            if(!res)throw \"assert(\"+\"cb1!=null&&cb2!=null\"+\") :: \"+(\"null cb from MRCA_chains?\");\n                                                            #end\n                                                        };\n                                                        if(ZPP_CbSet.empty_intersection(cb1,cb2)){\n                                                            cx_ite=cx_ite.next;\n                                                            continue;\n                                                        };\n                                                        var callbackset:ZPP_CallbackSet=null;\n                                                        var ncallbackset:ZPP_CallbackSet=null;\n                                                        prelisteners.inlined_clear();\n                                                        var lite:ZNPNode_ZPP_InteractionListener=null;\n                                                        ZPP_CbSet.find_all(cb1,cb2,ZPP_Flags.id_CbEvent_PRE,function(listener:ZPP_InteractionListener){\n                                                            if((listener.itype&inttype)!=0){\n                                                                lite=prelisteners.inlined_insert(lite,listener);\n                                                                anyimpure=anyimpure||!listener.pure;\n                                                            }\n                                                        });\n                                                        if(prelisteners.empty()){\n                                                            cx_ite=cx_ite.next;\n                                                            continue;\n                                                        };\n                                                        callbackset=ZPP_Interactor.get(i1,i2);\n                                                        if(callbackset==null){\n                                                            ncallbackset=ZPP_CallbackSet.get(i1,i2);\n                                                            add_callbackset(ncallbackset);\n                                                        }\n                                                        if(callbackset==null||((callbackset.SENSORstamp!=stamp||continuous)&&(callbackset.SENSORstate&ZPP_Flags.id_ImmState_ALWAYS==0))){\n                                                            if(ncallbackset!=null)callbackset=ncallbackset;\n                                                            if(callbackset!=null){\n                                                                {\n                                                                    var cx_ite=prelisteners.begin();\n                                                                    while(cx_ite!=null){\n                                                                        var listener=cx_ite.elem();\n                                                                        {\n                                                                            if(listener.itype==ZPP_Flags.id_InteractionType_ANY){\n                                                                                callbackset.COLLISIONstamp=stamp;\n                                                                                callbackset.SENSORstamp=stamp;\n                                                                                callbackset.FLUIDstamp=stamp;\n                                                                            }\n                                                                            else callbackset.SENSORstamp=stamp;\n                                                                        };\n                                                                        cx_ite=cx_ite.next;\n                                                                    }\n                                                                };\n                                                            }\n                                                            #if(!NAPE_RELEASE_BUILD)\n                                                            arb.makemutable();\n                                                            #end\n                                                            var pact=arb.active;\n                                                            arb.active=true;\n                                                            var emptycontacts=false;\n                                                            #if false arb.cleanupContacts();\n                                                            #end\n                                                            precb.zpp_inner.pre_arbiter=arb;\n                                                            precb.zpp_inner.set=callbackset;\n                                                            {\n                                                                var cx_ite=prelisteners.begin();\n                                                                while(cx_ite!=null){\n                                                                    var listener=cx_ite.elem();\n                                                                    {\n                                                                        precb.zpp_inner.listener=listener;\n                                                                        #if NAPE_ASSERT if(callbackset.int1==null){\n                                                                            var err=\"\";\n                                                                            err+=\"OKAY WTF IS HAPPENING HERE\\n\";\n                                                                            err+=\"ncallbackset is null? \"+(ncallbackset==null?\"yes\":\"no\")+\"\\n\";\n                                                                            err+=\"assuming yes, let's find callbacksets on interactor\\n\";\n                                                                            err+=\"i1 (id=\"+i1.id+\"):\\n\";\n                                                                            {\n                                                                                var cx_ite=i1.cbsets.begin();\n                                                                                while(cx_ite!=null){\n                                                                                    var cbset=cx_ite.elem();\n                                                                                    err+=\"  (\"+cbset.id+\" \"+(cbset.int1==null?\"null\":\"\")+\",\"+cbset.di+\" \"+(cbset.int2==null?\"null\":\"\")+\") arbs size=\"+cbset.arbiters.size()+\" freed=\"+cbset.freed+\" lazydel=\"+cbset.lazydel+\"\\n\";\n                                                                                    cx_ite=cx_ite.next;\n                                                                                }\n                                                                            };\n                                                                            err+=\"i2 (id=\"+i2.id+\"):\\n\";\n                                                                            {\n                                                                                var cx_ite=i2.cbsets.begin();\n                                                                                while(cx_ite!=null){\n                                                                                    var cbset=cx_ite.elem();\n                                                                                    err+=\"  (\"+cbset.id+\" \"+(cbset.int1==null?\"null\":\"\")+\",\"+cbset.di+\" \"+(cbset.int2==null?\"null\":\"\")+\") arbs size=\"+cbset.arbiters.size()+\" freed=\"+cbset.freed+\" lazydel=\"+cbset.lazydel+\"\\n\";\n                                                                                    cx_ite=cx_ite.next;\n                                                                                }\n                                                                            };\n                                                                            throw err;\n                                                                        }\n                                                                        #end\n                                                                        ZPP_Interactor.int_callback(callbackset,listener,precb.zpp_inner);\n                                                                        precb.zpp_inner.pre_swapped=i1!=precb.zpp_inner.int1;\n                                                                        var ret=listener.handlerp(precb);\n                                                                        if(ret!=null){\n                                                                            arb.immState=if(ret==PreFlag.ACCEPT)ZPP_Flags.id_ImmState_ACCEPT|ZPP_Flags.id_ImmState_ALWAYS else if(ret==PreFlag.ACCEPT_ONCE)ZPP_Flags.id_ImmState_ACCEPT else if(ret==PreFlag.IGNORE)ZPP_Flags.id_ImmState_IGNORE|ZPP_Flags.id_ImmState_ALWAYS else ZPP_Flags.id_ImmState_IGNORE;\n                                                                        }\n                                                                    };\n                                                                    cx_ite=cx_ite.next;\n                                                                }\n                                                            };\n                                                            #if(!NAPE_RELEASE_BUILD)\n                                                            arb.makeimmutable();\n                                                            #end\n                                                            arb.active=pact;\n                                                            if(callbackset!=null){\n                                                                {\n                                                                    var cx_ite=prelisteners.begin();\n                                                                    while(cx_ite!=null){\n                                                                        var listener=cx_ite.elem();\n                                                                        {\n                                                                            if(listener.itype==ZPP_Flags.id_InteractionType_ANY){\n                                                                                callbackset.COLLISIONstate=arb.immState;\n                                                                                callbackset.SENSORstate=arb.immState;\n                                                                                callbackset.FLUIDstate=arb.immState;\n                                                                            }\n                                                                            else callbackset.SENSORstate=arb.immState;\n                                                                        };\n                                                                        cx_ite=cx_ite.next;\n                                                                    }\n                                                                };\n                                                            }\n                                                        }\n                                                        else if(callbackset==null){\n                                                            if((arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0)arb.immState=ZPP_Flags.id_ImmState_ACCEPT;\n                                                        }\n                                                        else arb.immState=callbackset.SENSORstate;\n                                                    };\n                                                    cx_ite=cx_ite.next;\n                                                }\n                                            };\n                                        };\n                                        cx_ite=cx_ite.next;\n                                    }\n                                };\n                                if(anyimpure&&(arb.immState&ZPP_Flags.id_ImmState_ALWAYS)==0){\n                                    if(false){\n                                        if(arb.b1.isDynamic()){\n                                            var o=arb.b1;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                        if(arb.b1.isDynamic()){\n                                            var o=arb.b2;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                    }\n                                    else{\n                                        if(!arb.b1.isStatic()){\n                                            var o=arb.b1;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                        if(!arb.b2.isStatic()){\n                                            var o=arb.b2;\n                                            {\n                                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                var res={\n                                                    o.space==this;\n                                                };\n                                                if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                                #end\n                                            };\n                                            if(!o.world){\n                                                {\n                                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                                    var res={\n                                                        o.component!=null;\n                                                    };\n                                                    if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                                    #end\n                                                };\n                                                o.component.waket=stamp+(midstep?0:1);\n                                                if(o.isKinematic())o.kinematicDelaySleep=true;\n                                                if(o.component.sleeping){\n                                                    really_wake(o,false);\n                                                }\n                                            }\n                                        };\n                                    }\n                                }\n                            }\n                            if(false&&(arb.immState&ZPP_Flags.id_ImmState_ACCEPT)!=0){\n                                if(arb.b1.isDynamic()&&arb.b1.component.sleeping){\n                                    var o=arb.b1;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o.space==this;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                        #end\n                                    };\n                                    if(!o.world){\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o.component!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                            #end\n                                        };\n                                        o.component.waket=stamp+(midstep?0:1);\n                                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                                        if(o.component.sleeping){\n                                            really_wake(o,false);\n                                        }\n                                    }\n                                };\n                                if(arb.b2.isDynamic()&&arb.b2.component.sleeping){\n                                    var o=arb.b2;\n                                    {\n                                        #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                        var res={\n                                            o.space==this;\n                                        };\n                                        if(!res)throw \"assert(\"+\"o.space==this\"+\") :: \"+(\"object being woken in the space... is not actually in the space!\");\n                                        #end\n                                    };\n                                    if(!o.world){\n                                        {\n                                            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                            var res={\n                                                o.component!=null;\n                                            };\n                                            if(!res)throw \"assert(\"+\"o.component!=null\"+\") :: \"+(\"body woken, but no component exists?\");\n                                            #end\n                                        };\n                                        o.component.waket=stamp+(midstep?0:1);\n                                        if(o.isKinematic())o.kinematicDelaySleep=true;\n                                        if(o.component.sleeping){\n                                            really_wake(o,false);\n                                        }\n                                    }\n                                };\n                            }\n                            if(arb.sleeping){\n                                arb.sleeping=false;\n                                s_arbiters.inlined_add(arb);\n                            }\n                            arb;\n                        }\n                        else if(first){\n                            {\n                                var o=arb;\n                                {\n                                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                    var res={\n                                        o!=null;\n                                    };\n                                    if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_SensorArbiter\"+\", in obj: \"+\"arb\"+\")\");\n                                    #end\n                                };\n                                o.free();\n                                o.next=ZPP_SensorArbiter.zpp_pool;\n                                ZPP_SensorArbiter.zpp_pool=o;\n                                #if NAPE_POOL_STATS ZPP_SensorArbiter.POOL_CNT++;\n                                ZPP_SensorArbiter.POOL_SUB++;\n                                #end\n                            };\n                            null;\n                        }\n                        else arb;\n                    }\n                    else arb;\n                };\n            }\n        }\n        #if NAPE_TIMES Debug.NARROW+=flash.Lib.getTimer()-pt;\n        #end\n        return ret;\n    }\n    public var mrca1:ZNPList_ZPP_Interactor;\n    public var mrca2:ZNPList_ZPP_Interactor;\n    public function MRCA_chains(s1:ZPP_Shape,s2:ZPP_Shape){\n        inlined_MRCA_chains(s1,s2);\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function inlined_MRCA_chains(s1:ZPP_Shape,s2:ZPP_Shape){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                s1!=s2&&s1.body!=s2.body;\n            };\n            if(!res)throw \"assert(\"+\"s1!=s2&&s1.body!=s2.body\"+\") :: \"+(\"MRCA chain for equal shapes, or shapes of the same body?\");\n            #end\n        };\n        mrca1.inlined_clear();\n        mrca2.inlined_clear();\n        if(s1.cbSet!=null)mrca1.inlined_add(s1);\n        if(s1.body.cbSet!=null)mrca1.inlined_add(s1.body);\n        if(s2.cbSet!=null)mrca2.inlined_add(s2);\n        if(s2.body.cbSet!=null)mrca2.inlined_add(s2.body);\n        var c1=s1.body.compound;\n        var c2=s2.body.compound;\n        while(c1!=c2){\n            var d1=if(c1==null)0 else c1.depth;\n            var d2=if(c2==null)0 else c2.depth;\n            if(d1<d2){\n                if(c2.cbSet!=null)mrca2.inlined_add(c2);\n                c2=c2.compound;\n            }\n            else{\n                if(c1.cbSet!=null)mrca1.inlined_add(c1);\n                c1=c1.compound;\n            }\n        }\n    }\n}\n","package zpp_nape.space;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_SweepData{\n    public var next:ZPP_SweepData=null;\n    static public var zpp_pool:ZPP_SweepData=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    public var prev:ZPP_SweepData=null;\n    public var shape:ZPP_Shape=null;\n    public var aabb:ZPP_AABB=null;\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        prev=null;\n        shape=null;\n        aabb=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public function new(){}\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function gt(x:ZPP_SweepData){\n        return aabb.minx>x.aabb.minx;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_SweepPhase extends ZPP_Broadphase{\n    public var list:ZPP_SweepData=null;\n    public function new(space:ZPP_Space){\n        this.space=space;\n        is_sweep=true;\n        sweep=this;\n    }\n    public function __insert(shape:ZPP_Shape){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                shape.sweep==null;\n            };\n            if(!res)throw \"assert(\"+\"shape.sweep==null\"+\") :: \"+(\"SweepPhase::insert\");\n            #end\n        };\n        var dat;\n        {\n            if(ZPP_SweepData.zpp_pool==null){\n                dat=new ZPP_SweepData();\n                #if NAPE_POOL_STATS ZPP_SweepData.POOL_TOT++;\n                ZPP_SweepData.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                dat=ZPP_SweepData.zpp_pool;\n                ZPP_SweepData.zpp_pool=dat.next;\n                dat.next=null;\n                #if NAPE_POOL_STATS ZPP_SweepData.POOL_CNT--;\n                ZPP_SweepData.POOL_ADD++;\n                #end\n            }\n            dat.alloc();\n        };\n        shape.sweep=dat;\n        dat.shape=shape;\n        dat.aabb=shape.aabb;\n        dat.next=list;\n        if(list!=null)list.prev=dat;\n        list=dat;\n    }\n    public function __remove(shape:ZPP_Shape){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                shape.sweep!=null;\n            };\n            if(!res)throw \"assert(\"+\"shape.sweep!=null\"+\") :: \"+(\"SweepPhase::remove\");\n            #end\n        };\n        var dat=shape.sweep;\n        if(dat.prev==null)list=dat.next;\n        else dat.prev.next=dat.next;\n        if(dat.next!=null)dat.next.prev=dat.prev;\n        shape.sweep=null;\n        {\n            var o=dat;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_SweepData\"+\", in obj: \"+\"dat\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_SweepData.zpp_pool;\n            ZPP_SweepData.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_SweepData.POOL_CNT++;\n            ZPP_SweepData.POOL_SUB++;\n            #end\n        };\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function __sync(shape:ZPP_Shape){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !shape.body.isStatic();\n            };\n            if(!res)throw \"assert(\"+\"!shape.body.isStatic()\"+\") :: \"+(\"static shape being synced?\");\n            #end\n        };\n        if(!space.continuous)shape.validate_aabb();\n    }\n    public function sync_broadphase(){\n        space.validation();\n        if(list!=null)sync_broadphase_fast();\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function sync_broadphase_fast(){\n        var a=list.next;\n        while(a!=null){\n            #if NAPE_TIMES Debug.BROADTOTAL++;\n            #end\n            var n=a.next;\n            var b=a.prev;\n            if(a.gt(b)){\n                a=n;\n                continue;\n            }\n            #if NAPE_TIMES Debug.BROADCLASH++;\n            #end\n            while(b.prev!=null&&b.prev.gt(a))b=b.prev;\n            var prev=a.prev;\n            prev.next=a.next;\n            if(a.next!=null)a.next.prev=prev;\n            if(b.prev==null){\n                a.prev=null;\n                list=a;\n                a.next=b;\n                b.prev=a;\n            }\n            else{\n                a.prev=b.prev;\n                b.prev=a;\n                a.prev.next=a;\n                a.next=b;\n            }\n            a=n;\n        }\n    }\n    public override function broadphase(space:ZPP_Space,discrete:Bool){\n        if(list!=null){\n            sync_broadphase_fast();\n            var d1=list;\n            while(d1!=null){\n                var d2=d1.next;\n                var s1=d1.shape;\n                var b1=s1.body;\n                var bottom=d1.aabb.maxx;\n                while(d2!=null){\n                    if(d2.aabb.minx>bottom)break;\n                    var s2=d2.shape;\n                    var b2=s2.body;\n                    if(b2==b1){\n                        d2=d2.next;\n                        continue;\n                    }\n                    if(b1.isStatic()&&b2.isStatic()){\n                        d2=d2.next;\n                        continue;\n                    }\n                    if(b1.component.sleeping&&b2.component.sleeping){\n                        d2=d2.next;\n                        continue;\n                    }\n                    if(s1.aabb.intersectY(s2.aabb)){\n                        if(discrete){\n                            space.narrowPhase(s1,s2,!b1.isDynamic()||!b2.isDynamic(),null,false);\n                        }\n                        else{\n                            space.continuousEvent(s1,s2,!b1.isDynamic()||!b2.isDynamic(),null,false);\n                        }\n                    }\n                    d2=d2.next;\n                }\n                d1=d1.next;\n            }\n        }\n    }\n    public override function clear(){\n        while(list!=null){\n            list.shape.removedFromSpace();\n            __remove(list.shape);\n        }\n    }\n    public override function shapesUnderPoint(x:Float,y:Float,filter:ZPP_InteractionFilter,output:ShapeList){\n        sync_broadphase();\n        var v=ZPP_Vec2.get(x,y);\n        var ret=(output==null?new ShapeList():output);\n        var a=list;\n        while(a!=null&&a.aabb.minx>x)a=a.next;\n        while(a!=null&&a.aabb.minx<=x){\n            if(a.aabb.maxx>=x&&a.aabb.miny<=y&&a.aabb.maxy>=y){\n                var shape=a.shape;\n                if(filter==null||shape.filter.shouldCollide(filter)){\n                    if(shape.isCircle()){\n                        if(ZPP_Collide.circleContains(shape.circle,v))ret.push(shape.outer);\n                    }\n                    else{\n                        if(ZPP_Collide.polyContains(shape.polygon,v))ret.push(shape.outer);\n                    }\n                }\n            }\n            a=a.next;\n        }\n        {\n            var o=v;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"v\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public override function bodiesUnderPoint(x:Float,y:Float,filter:ZPP_InteractionFilter,output:BodyList){\n        sync_broadphase();\n        var v=ZPP_Vec2.get(x,y);\n        var ret=(output==null?new BodyList():output);\n        var a=list;\n        while(a!=null&&a.aabb.minx>x)a=a.next;\n        while(a!=null&&a.aabb.minx<=x){\n            if(a.aabb.maxx>=x&&a.aabb.miny<=y&&a.aabb.maxy>=y){\n                var shape=a.shape;\n                var body=shape.body.outer;\n                if(!ret.has(body)){\n                    if(filter==null||shape.filter.shouldCollide(filter)){\n                        if(shape.isCircle()){\n                            if(ZPP_Collide.circleContains(shape.circle,v))ret.push(body);\n                        }\n                        else{\n                            if(ZPP_Collide.polyContains(shape.polygon,v))ret.push(body);\n                        }\n                    }\n                }\n            }\n            a=a.next;\n        }\n        {\n            var o=v;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Vec2\"+\", in obj: \"+\"v\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Vec2.zpp_pool;\n            ZPP_Vec2.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Vec2.POOL_CNT++;\n            ZPP_Vec2.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public override function shapesInAABB(aabb:ZPP_AABB,strict:Bool,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        sync_broadphase();\n        updateAABBShape(aabb);\n        var ab=aabbShape.zpp_inner.aabb;\n        var ret=(output==null?new ShapeList():output);\n        var a=list;\n        while(a!=null&&a.aabb.maxx<ab.minx)a=a.next;\n        while(a!=null&&a.aabb.minx<=ab.maxx){\n            var shape=a.shape;\n            if(filter==null||shape.filter.shouldCollide(filter)){\n                if(strict){\n                    if(containment){\n                        if(ZPP_Collide.containTest(aabbShape.zpp_inner,shape))ret.push(shape.outer);\n                    }\n                    else{\n                        if(ab.contains(a.aabb))ret.push(shape.outer);\n                        else if(a.aabb.intersect(ab)){\n                            if(ZPP_Collide.testCollide_safe(shape,aabbShape.zpp_inner))ret.push(shape.outer);\n                        }\n                    }\n                }\n                else if(containment?ab.contains(a.aabb):a.aabb.intersect(ab))ret.push(shape.outer);\n            }\n            a=a.next;\n        }\n        return ret;\n    }\n    public var failed:BodyList=null;\n    public override function bodiesInAABB(aabb:ZPP_AABB,strict:Bool,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        sync_broadphase();\n        updateAABBShape(aabb);\n        var ab=aabbShape.zpp_inner.aabb;\n        var ret=(output==null?new BodyList():output);\n        if(failed==null)failed=new BodyList();\n        var a=list;\n        while(a!=null&&a.aabb.maxx<ab.minx)a=a.next;\n        while(a!=null&&a.aabb.minx<=ab.maxx){\n            var shape=a.shape;\n            var body=shape.body.outer;\n            if(a.aabb.intersect(ab)){\n                if(filter==null||shape.filter.shouldCollide(filter)){\n                    if(strict){\n                        if(containment){\n                            if(!failed.has(body)){\n                                var col=ZPP_Collide.containTest(aabbShape.zpp_inner,shape);\n                                if(!ret.has(body)&&col)ret.push(body);\n                                else if(!col){\n                                    ret.remove(body);\n                                    failed.push(body);\n                                }\n                            }\n                        }\n                        else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(shape,aabbShape.zpp_inner)){\n                            ret.push(body);\n                        }\n                    }\n                    else{\n                        if(containment){\n                            if(!failed.has(body)){\n                                var col=ab.contains(shape.aabb);\n                                if(!ret.has(body)&&col)ret.push(body);\n                                else if(!col){\n                                    ret.remove(body);\n                                    failed.push(body);\n                                }\n                            }\n                        }\n                        else if(!ret.has(body)&&ab.contains(shape.aabb)){\n                            ret.push(body);\n                        }\n                    }\n                }\n            }\n            a=a.next;\n        }\n        failed.clear();\n        return ret;\n    }\n    public override function shapesInCircle(x:Float,y:Float,r:Float,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        sync_broadphase();\n        updateCircShape(x,y,r);\n        var ab=circShape.zpp_inner.aabb;\n        var ret=(output==null?new ShapeList():output);\n        var a=list;\n        while(a!=null&&a.aabb.maxx<ab.minx)a=a.next;\n        while(a!=null&&a.aabb.minx<=ab.maxx){\n            if(a.aabb.intersect(ab)){\n                var shape=a.shape;\n                if(filter==null||shape.filter.shouldCollide(filter)){\n                    if(containment){\n                        if(ZPP_Collide.containTest(circShape.zpp_inner,shape))ret.push(shape.outer);\n                    }\n                    else if(ZPP_Collide.testCollide_safe(shape,circShape.zpp_inner))ret.push(shape.outer);\n                }\n            }\n            a=a.next;\n        }\n        return ret;\n    }\n    public override function bodiesInCircle(x:Float,y:Float,r:Float,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        sync_broadphase();\n        updateCircShape(x,y,r);\n        var ab=circShape.zpp_inner.aabb;\n        var ret=(output==null?new BodyList():output);\n        if(failed==null)failed=new BodyList();\n        var a=list;\n        while(a!=null&&a.aabb.maxx<ab.minx)a=a.next;\n        while(a!=null&&a.aabb.minx<=ab.maxx){\n            if(a.aabb.intersect(ab)){\n                var shape=a.shape;\n                var body=shape.body.outer;\n                if(filter==null||shape.filter.shouldCollide(filter)){\n                    if(containment){\n                        if(!failed.has(body)){\n                            var col=ZPP_Collide.containTest(circShape.zpp_inner,shape);\n                            if(!ret.has(body)&&col)ret.push(body);\n                            else if(!col){\n                                ret.remove(body);\n                                failed.push(body);\n                            }\n                        }\n                    }\n                    else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(shape,circShape.zpp_inner)){\n                        ret.push(body);\n                    }\n                }\n            }\n            a=a.next;\n        }\n        failed.clear();\n        return ret;\n    }\n    public override function shapesInShape(shape:ZPP_Shape,containment:Bool,filter:ZPP_InteractionFilter,output:ShapeList){\n        sync_broadphase();\n        validateShape(shape);\n        var ab=shape.aabb;\n        var ret=(output==null?new ShapeList():output);\n        var a=list;\n        while(a!=null&&a.aabb.maxx<ab.minx)a=a.next;\n        while(a!=null&&a.aabb.minx<=ab.maxx){\n            if(a.aabb.intersect(ab)){\n                var shape2=a.shape;\n                if(filter==null||shape2.filter.shouldCollide(filter)){\n                    if(containment){\n                        if(ZPP_Collide.containTest(shape,shape2))ret.push(shape2.outer);\n                    }\n                    else if(ZPP_Collide.testCollide_safe(shape2,shape))ret.push(shape2.outer);\n                }\n            }\n            a=a.next;\n        }\n        return ret;\n    }\n    public override function bodiesInShape(shape:ZPP_Shape,containment:Bool,filter:ZPP_InteractionFilter,output:BodyList){\n        sync_broadphase();\n        validateShape(shape);\n        var ab=shape.aabb;\n        var ret=(output==null?new BodyList():output);\n        if(failed==null)failed=new BodyList();\n        var a=list;\n        while(a!=null&&a.aabb.maxx<ab.minx)a=a.next;\n        while(a!=null&&a.aabb.minx<=ab.maxx){\n            if(a.aabb.intersect(ab)){\n                var shape2=a.shape;\n                var body=shape2.body.outer;\n                if(filter==null||shape2.filter.shouldCollide(filter)){\n                    if(containment){\n                        if(!failed.has(body)){\n                            var col=ZPP_Collide.containTest(shape,shape2);\n                            if(!ret.has(body)&&col)ret.push(body);\n                            else if(!col){\n                                ret.remove(body);\n                                failed.push(body);\n                            }\n                        }\n                    }\n                    else if(!ret.has(body)&&ZPP_Collide.testCollide_safe(shape,shape2)){\n                        ret.push(body);\n                    }\n                }\n            }\n            a=a.next;\n        }\n        failed.clear();\n        return ret;\n    }\n    public override function rayCast(ray:ZPP_Ray,inner:Bool,filter:ZPP_InteractionFilter){\n        sync_broadphase();\n        ray.validate_dir();\n        var rayab=ray.rayAABB();\n        var mint=ray.maxdist;\n        var minres:RayResult=null;\n        if(ray.dirx==0){\n            var a=list;\n            while(a!=null&&a.aabb.minx<=rayab.minx){\n                if(a.aabb.intersect(rayab)&&(filter==null||a.shape.filter.shouldCollide(filter))){\n                    var t=ray.aabbsect(a.aabb);\n                    if(t>=0&&t<mint){\n                        var result=if(a.shape.isCircle())ray.circlesect(a.shape.circle,inner,mint)else ray.polysect(a.shape.polygon,inner,mint);\n                        if(result!=null){\n                            mint=result.distance;\n                            if(minres!=null){\n                                minres.dispose();\n                            }\n                            minres=result;\n                        }\n                    }\n                }\n                a=a.next;\n            }\n        }\n        else if(ray.dirx<0){\n            var a=list;\n            var b=null;\n            while(a!=null&&a.aabb.minx<=rayab.maxx){\n                b=a;\n                a=a.next;\n            }\n            a=b;\n            while(a!=null){\n                if(a.aabb.intersect(rayab)&&(filter==null||a.shape.filter.shouldCollide(filter))){\n                    var t=ray.aabbsect(a.aabb);\n                    if(t>=0&&t<mint){\n                        var result=if(a.shape.isCircle())ray.circlesect(a.shape.circle,inner,mint)else ray.polysect(a.shape.polygon,inner,mint);\n                        if(result!=null){\n                            mint=result.distance;\n                            if(minres!=null){\n                                minres.dispose();\n                            }\n                            minres=result;\n                        }\n                    }\n                }\n                a=a.prev;\n            }\n        }\n        else{\n            var a=list;\n            while(a!=null&&a.aabb.minx<=rayab.maxx&&a.aabb.minx<ray.originx+ray.dirx*mint){\n                if(a.aabb.intersect(rayab)&&(filter==null||a.shape.filter.shouldCollide(filter))){\n                    var t=ray.aabbsect(a.aabb);\n                    if(t>=0&&t<mint){\n                        var result=if(a.shape.isCircle())ray.circlesect(a.shape.circle,inner,mint)else ray.polysect(a.shape.polygon,inner,mint);\n                        if(result!=null){\n                            mint=result.distance;\n                            if(minres!=null){\n                                minres.dispose();\n                            }\n                            minres=result;\n                        }\n                    }\n                }\n                a=a.next;\n            }\n        }\n        {\n            var o=rayab;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABB\"+\", in obj: \"+\"rayab\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_AABB.zpp_pool;\n            ZPP_AABB.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT++;\n            ZPP_AABB.POOL_SUB++;\n            #end\n        };\n        return minres;\n    }\n    public override function rayMultiCast(ray:ZPP_Ray,inner:Bool,filter:ZPP_InteractionFilter,output:RayResultList){\n        sync_broadphase();\n        ray.validate_dir();\n        var rayab=ray.rayAABB();\n        var ret=(output==null?new RayResultList():output);\n        if(ray.dirx==0){\n            var a=list;\n            while(a!=null&&a.aabb.minx<=rayab.minx){\n                if(a.aabb.intersect(rayab)&&(filter==null||a.shape.filter.shouldCollide(filter))){\n                    var t=ray.aabbsect(a.aabb);\n                    if(t>=0){\n                        if(a.shape.isCircle())ray.circlesect2(a.shape.circle,inner,ret);\n                        else ray.polysect2(a.shape.polygon,inner,ret);\n                    }\n                }\n                a=a.next;\n            }\n        }\n        else if(ray.dirx<0){\n            var a=list;\n            var b=null;\n            while(a!=null&&a.aabb.minx<=rayab.maxx){\n                b=a;\n                a=a.next;\n            }\n            a=b;\n            while(a!=null){\n                if(a.aabb.intersect(rayab)&&(filter==null||a.shape.filter.shouldCollide(filter))){\n                    var t=ray.aabbsect(a.aabb);\n                    if(t>=0){\n                        if(a.shape.isCircle())ray.circlesect2(a.shape.circle,inner,ret);\n                        else ray.polysect2(a.shape.polygon,inner,ret);\n                    }\n                }\n                a=a.prev;\n            }\n        }\n        else{\n            var a=list;\n            while(a!=null&&a.aabb.minx<=rayab.maxx){\n                if(a.aabb.intersect(rayab)&&(filter==null||a.shape.filter.shouldCollide(filter))){\n                    var t=ray.aabbsect(a.aabb);\n                    if(t>=0){\n                        if(a.shape.isCircle())ray.circlesect2(a.shape.circle,inner,ret);\n                        else ray.polysect2(a.shape.polygon,inner,ret);\n                    }\n                }\n                a=a.next;\n            }\n        }\n        {\n            var o=rayab;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_AABB\"+\", in obj: \"+\"rayab\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_AABB.zpp_pool;\n            ZPP_AABB.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_AABB.POOL_CNT++;\n            ZPP_AABB.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n}\n","package zpp_nape.util;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if flash10 import flash.Memory;\nimport flash.utils.ByteArray;\n#end\n#if nape_swc@:keep #end\nclass ZPP_Math{\n     public static#if NAPE_NO_INLINE#else inline #end\n    function sqrt(x:Float){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((x!=x));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(x)\"+\") :: \"+(\"PR(Math).sqrt\");\n            #end\n        };\n        #if flash10 return if(x==0.0)0.0 else 1/invsqrt(x);\n        #else return Math.sqrt(x);\n        #end\n    }\n     public static#if NAPE_NO_INLINE#else inline #end\n    function invsqrt(x:Float){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((x!=x))&&x!=0.0;\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(x)&&x!=0.0\"+\") :: \"+(\"PR(Math).invsqrt\");\n            #end\n        };\n        #if flash10 Memory.setFloat(0,x);\n        Memory.setI32(0,0x5f3759df-(Memory.getI32(0)>>1));\n        var x2=Memory.getFloat(0);\n        return x2*(1.5-0.5*x*x2*x2);\n        #else return 1.0/sqrt(x);\n        #end\n    }\n     public#if NAPE_NO_INLINE#else inline #end\n    static function sqr(x:Float){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((x!=x));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(x)\"+\") :: \"+(\"PR(Math).sqr\");\n            #end\n        };\n        return x*x;\n    }\n     public#if NAPE_NO_INLINE#else inline #end\n    static function clamp2(x:Float,a:Float){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((x!=x))&&!((a!=a));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(x)&&!assert_isNaN(a)\"+\") :: \"+(\"PR(Math).clamp2 -> \"+x+\" -> \"+a);\n            #end\n        };\n        return clamp(x,-a,a);\n    }\n     public static#if NAPE_NO_INLINE#else inline #end\n    function clamp(x:Float,a:Float,b:Float){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !((x!=x))&&!((a!=a))&&!((b!=b));\n            };\n            if(!res)throw \"assert(\"+\"!assert_isNaN(x)&&!assert_isNaN(a)&&!assert_isNaN(b)\"+\") :: \"+(\"PR(Math).clamp2 -> \"+x+\" -> \"+a+\" -> \"+b);\n            #end\n        };\n        return if(x<a)a else if(x>b)b else x;\n    }\n}\n","package zpp_nape.util;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Flags;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n\n#if nape_swc@:keep #end\nclass ZPP_Set_ZPP_Body{\n    static public var zpp_pool:ZPP_Set_ZPP_Body=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        data=null;\n        lt=null;\n        swapped=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var lt:ZPP_Body->ZPP_Body->Bool=null;\n    public var swapped:ZPP_Body->ZPP_Body->Void=null;\n    public var data:ZPP_Body=null;\n    public var prev:ZPP_Set_ZPP_Body=null;\n    public var next:ZPP_Set_ZPP_Body=null;\n    public var parent:ZPP_Set_ZPP_Body=null;\n    public var colour:Int=0;\n    public function new(){}\n    public function verify(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    {\n                        var prei=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    this!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                                #end\n                            };\n                            if(!this.empty()){\n                                var set_ite=this.parent;\n                                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                while(set_ite!=null){\n                                    var j=set_ite.data;\n                                    {\n                                        if(!prei){\n                                            if(!lt(i,j)&&lt(j,i))return false;\n                                        }\n                                        else if(i==j)prei=false;\n                                        else{\n                                            if(!lt(j,i)&&lt(i,j))return false;\n                                        }\n                                    };\n                                    if(set_ite.next!=null){\n                                        set_ite=set_ite.next;\n                                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                    }\n                                    else{\n                                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                                        set_ite=set_ite.parent;\n                                    }\n                                }\n                            }\n                        };\n                    };\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return true;\n    }\n    public function empty(){\n        return parent==null;\n    }\n    public function singular(){\n        return parent!=null&&parent.prev==null&&parent.next==null;\n    }\n    public function size(){\n        var ret=0;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    ret++;\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return ret;\n    }\n    public function has(obj:ZPP_Body){\n        return find(obj)!=null;\n    }\n    public function find(obj:ZPP_Body){\n        var cur=parent;\n        while(cur!=null&&cur.data!=obj){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else cur=cur.next;\n        }\n        return cur;\n    }\n    public function has_weak(obj:ZPP_Body){\n        return find_weak(obj)!=null;\n    }\n    public function find_weak(obj:ZPP_Body){\n        var cur=parent;\n        while(cur!=null){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else if(lt(cur.data,obj))cur=cur.next;\n            else break;\n        }\n        return cur;\n    }\n    public function lower_bound(obj:ZPP_Body){\n        return{\n            var ret=null;\n            {\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        this!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                    #end\n                };\n                if(!this.empty()){\n                    var set_ite=this.parent;\n                    while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    while(set_ite!=null){\n                        var elt=set_ite.data;\n                        {\n                            if(!lt(elt,obj)){\n                                ret=elt;\n                                break;\n                            }\n                        };\n                        if(set_ite.next!=null){\n                            set_ite=set_ite.next;\n                            while(set_ite.prev!=null)set_ite=set_ite.prev;\n                        }\n                        else{\n                            while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                            set_ite=set_ite.parent;\n                        }\n                    }\n                }\n            };\n            ret;\n        };\n    }\n    public function first(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"first in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        return cur.data;\n    }\n    public function pop_front(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"pop_front in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        var ret=cur.data;\n        remove_node(cur);\n        return ret;\n    }\n    public function remove(obj:ZPP_Body){\n        var node=find(obj);\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"object not in tree\");\n            #end\n        };\n        remove_node(node);\n    }\n    public function successor_node(cur:ZPP_Set_ZPP_Body){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null){\n            cur=cur.next;\n            while(cur.prev!=null)cur=cur.prev;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.prev!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function predecessor_node(cur:ZPP_Set_ZPP_Body){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.prev!=null){\n            cur=cur.prev;\n            while(cur.next!=null)cur=cur.next;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.next!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function successor(obj:ZPP_Body){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=successor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function predecessor(obj:ZPP_Body){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=predecessor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function remove_node(cur:ZPP_Set_ZPP_Body){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null&&cur.prev!=null){\n            var sm=cur.next;\n            while(sm.prev!=null)sm=sm.prev;\n            {\n                var t=cur.data;\n                cur.data=sm.data;\n                sm.data=t;\n            };\n            if(swapped!=null)swapped(cur.data,sm.data);\n            cur=sm;\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur.next==null||cur.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"cur.next==null||cur.prev==null\"+\") :: \"+(\"node still has two children??\");\n            #end\n        };\n        var child=if(cur.prev==null)cur.next else cur.prev;\n        if(cur.colour==1){\n            if(cur.prev!=null||cur.next!=null)child.colour=1;\n            else if(cur.parent!=null){\n                var parent=cur.parent;\n                while(true){\n                    parent.colour++;\n                    parent.prev.colour--;\n                    parent.next.colour--;\n                    {\n                        var child=parent.prev;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    {\n                        var child=parent.next;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(parent.colour==2){\n                        if(parent.parent==null){\n                            parent.colour=1;\n                        }\n                        else{\n                            parent=parent.parent;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        {\n            var par=cur.parent;\n            if(par==null){\n                parent=child;\n            }\n            else if(par.prev==cur)par.prev=child;\n            else par.next=child;\n            if(child!=null)child.parent=par;\n        };\n        cur.parent=cur.prev=cur.next=null;\n        {\n            var o=cur;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_Body\"+\", in obj: \"+\"cur\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_Body.zpp_pool;\n            ZPP_Set_ZPP_Body.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT++;\n            ZPP_Set_ZPP_Body.POOL_SUB++;\n            #end\n        };\n    }\n    public function clear(){\n        clear_with(function(_){});\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function clear_with(lambda:ZPP_Body->Void){\n        if(parent==null)return;\n        else{\n            var cur=parent;\n            while(cur!=null)cur=if(cur.prev!=null)cur.prev else if(cur.next!=null)cur.next else clear_node(cur,lambda);\n            parent=null;\n        }\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    function clear_node(node:ZPP_Set_ZPP_Body,lambda:ZPP_Body->Void){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node.next==null&&node.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"node.next==null&&node.prev==null\"+\") :: \"+(\"clear_node :: node not a leaf\");\n            #end\n        };\n        lambda(node.data);\n        var ret=node.parent;\n        if(ret!=null){\n            if(node==ret.prev)ret.prev=null;\n            else ret.next=null;\n            node.parent=null;\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_Body\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_Body.zpp_pool;\n            ZPP_Set_ZPP_Body.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT++;\n            ZPP_Set_ZPP_Body.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function __fix_neg_red(negred:ZPP_Set_ZPP_Body){\n        var parent=negred.parent;\n        var child=if(parent.prev==negred){\n            var nl=negred.prev;\n            var nr=negred.next;\n            var trl=nr.prev;\n            var trr=nr.next;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.next=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.prev=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.next=parent.next;\n                if(parent.next!=null)parent.next.parent=nr;\n            };\n            {\n                parent.next=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        else{\n            var nl=negred.next;\n            var nr=negred.prev;\n            var trl=nr.next;\n            var trr=nr.prev;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.prev=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.next=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.prev=parent.prev;\n                if(parent.prev!=null)parent.prev.parent=nr;\n            };\n            {\n                parent.prev=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        if(child.prev!=null&&child.prev.colour==0)__fix_dbl_red(child.prev);\n        else if(child.next!=null&&child.next.colour==0)__fix_dbl_red(child.next);\n    }\n    public function __fix_dbl_red(x:ZPP_Set_ZPP_Body){\n        while(true){\n            var par=x.parent;\n            var g=par.parent;\n            if(g==null){\n                par.colour=1;\n                break;\n            }\n            var n1:ZPP_Set_ZPP_Body,n2:ZPP_Set_ZPP_Body,n3:ZPP_Set_ZPP_Body,t1:ZPP_Set_ZPP_Body,t2:ZPP_Set_ZPP_Body,t3:ZPP_Set_ZPP_Body,t4:ZPP_Set_ZPP_Body;\n            if(par==g.prev){\n                n3=g;\n                t4=g.next;\n                if(x==par.prev){\n                    n1=x;\n                    n2=par;\n                    t1=x.prev;\n                    t2=x.next;\n                    t3=par.next;\n                }\n                else{\n                    n1=par;\n                    n2=x;\n                    t1=par.prev;\n                    t2=x.prev;\n                    t3=x.next;\n                }\n            }\n            else{\n                n1=g;\n                t1=g.prev;\n                if(x==par.prev){\n                    n2=x;\n                    n3=par;\n                    t2=x.prev;\n                    t3=x.next;\n                    t4=par.next;\n                }\n                else{\n                    n2=par;\n                    n3=x;\n                    t2=par.prev;\n                    t3=x.prev;\n                    t4=x.next;\n                }\n            }\n            {\n                var par=g.parent;\n                if(par==null){\n                    parent=n2;\n                }\n                else if(par.prev==g)par.prev=n2;\n                else par.next=n2;\n                if(n2!=null)n2.parent=par;\n            };\n            {\n                n1.prev=t1;\n                if(t1!=null)t1.parent=n1;\n            };\n            {\n                n1.next=t2;\n                if(t2!=null)t2.parent=n1;\n            };\n            {\n                n2.prev=n1;\n                if(n1!=null)n1.parent=n2;\n            };\n            {\n                n2.next=n3;\n                if(n3!=null)n3.parent=n2;\n            };\n            {\n                n3.prev=t3;\n                if(t3!=null)t3.parent=n3;\n            };\n            {\n                n3.next=t4;\n                if(t4!=null)t4.parent=n3;\n            };\n            n2.colour=g.colour-1;\n            n1.colour=1;\n            n3.colour=1;\n            if(n2==parent)parent.colour=1;\n            else if(n2.colour==0&&n2.parent.colour==0){\n                x=n2;\n                continue;\n            }\n            break;\n        }\n    }\n    public function try_insert_bool(obj:ZPP_Body){\n        var x:ZPP_Set_ZPP_Body=null;\n        var cur:ZPP_Set_ZPP_Body=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_Body.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_Body();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_TOT++;\n                    ZPP_Set_ZPP_Body.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_Body.zpp_pool;\n                    ZPP_Set_ZPP_Body.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT--;\n                    ZPP_Set_ZPP_Body.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_Body.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_Body();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_TOT++;\n                                ZPP_Set_ZPP_Body.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_Body.zpp_pool;\n                                ZPP_Set_ZPP_Body.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT--;\n                                ZPP_Set_ZPP_Body.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_Body.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_Body();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_TOT++;\n                                ZPP_Set_ZPP_Body.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_Body.zpp_pool;\n                                ZPP_Set_ZPP_Body.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT--;\n                                ZPP_Set_ZPP_Body.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return false;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return true;\n        }\n    }\n    public function try_insert(obj:ZPP_Body){\n        var x:ZPP_Set_ZPP_Body=null;\n        var cur:ZPP_Set_ZPP_Body=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_Body.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_Body();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_TOT++;\n                    ZPP_Set_ZPP_Body.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_Body.zpp_pool;\n                    ZPP_Set_ZPP_Body.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT--;\n                    ZPP_Set_ZPP_Body.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_Body.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_Body();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_TOT++;\n                                ZPP_Set_ZPP_Body.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_Body.zpp_pool;\n                                ZPP_Set_ZPP_Body.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT--;\n                                ZPP_Set_ZPP_Body.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_Body.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_Body();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_TOT++;\n                                ZPP_Set_ZPP_Body.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_Body.zpp_pool;\n                                ZPP_Set_ZPP_Body.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT--;\n                                ZPP_Set_ZPP_Body.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return cur;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return x;\n        }\n    }\n    public function insert(obj:ZPP_Body){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !has(obj);\n            };\n            if(!res)throw \"assert(\"+\"!has(obj)\"+\") :: \"+(\"object already in set\");\n            #end\n        };\n        var x;\n        {\n            if(ZPP_Set_ZPP_Body.zpp_pool==null){\n                x=new ZPP_Set_ZPP_Body();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_TOT++;\n                ZPP_Set_ZPP_Body.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                x=ZPP_Set_ZPP_Body.zpp_pool;\n                ZPP_Set_ZPP_Body.zpp_pool=x.next;\n                x.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_Body.POOL_CNT--;\n                ZPP_Set_ZPP_Body.POOL_ADD++;\n                #end\n            }\n            x.alloc();\n        };\n        x.data=obj;\n        if(parent==null)parent=x;\n        else{\n            var cur=parent;\n            while(true){\n                if(lt(x.data,cur.data)){\n                    if(cur.prev==null){\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else{\n                    if(cur.next==null){\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n            }\n        }\n        if(x.parent==null)x.colour=1;\n        else{\n            x.colour=0;\n            if(x.parent.colour==0)__fix_dbl_red(x);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x.data==obj;\n            };\n            if(!res)throw \"assert(\"+\"x.data==obj\"+\") :: \"+(\"...wtf?\");\n            #end\n        };\n        return x;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Set_ZPP_CbSetPair{\n    static public var zpp_pool:ZPP_Set_ZPP_CbSetPair=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        data=null;\n        lt=null;\n        swapped=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var lt:ZPP_CbSetPair->ZPP_CbSetPair->Bool=null;\n    public var swapped:ZPP_CbSetPair->ZPP_CbSetPair->Void=null;\n    public var data:ZPP_CbSetPair=null;\n    public var prev:ZPP_Set_ZPP_CbSetPair=null;\n    public var next:ZPP_Set_ZPP_CbSetPair=null;\n    public var parent:ZPP_Set_ZPP_CbSetPair=null;\n    public var colour:Int=0;\n    public function new(){}\n    public function verify(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    {\n                        var prei=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    this!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                                #end\n                            };\n                            if(!this.empty()){\n                                var set_ite=this.parent;\n                                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                while(set_ite!=null){\n                                    var j=set_ite.data;\n                                    {\n                                        if(!prei){\n                                            if(!lt(i,j)&&lt(j,i))return false;\n                                        }\n                                        else if(i==j)prei=false;\n                                        else{\n                                            if(!lt(j,i)&&lt(i,j))return false;\n                                        }\n                                    };\n                                    if(set_ite.next!=null){\n                                        set_ite=set_ite.next;\n                                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                    }\n                                    else{\n                                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                                        set_ite=set_ite.parent;\n                                    }\n                                }\n                            }\n                        };\n                    };\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return true;\n    }\n    public function empty(){\n        return parent==null;\n    }\n    public function singular(){\n        return parent!=null&&parent.prev==null&&parent.next==null;\n    }\n    public function size(){\n        var ret=0;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    ret++;\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return ret;\n    }\n    public function has(obj:ZPP_CbSetPair){\n        return find(obj)!=null;\n    }\n    public function find(obj:ZPP_CbSetPair){\n        var cur=parent;\n        while(cur!=null&&cur.data!=obj){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else cur=cur.next;\n        }\n        return cur;\n    }\n    public function has_weak(obj:ZPP_CbSetPair){\n        return find_weak(obj)!=null;\n    }\n    public function find_weak(obj:ZPP_CbSetPair){\n        var cur=parent;\n        while(cur!=null){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else if(lt(cur.data,obj))cur=cur.next;\n            else break;\n        }\n        return cur;\n    }\n    public function lower_bound(obj:ZPP_CbSetPair){\n        return{\n            var ret=null;\n            {\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        this!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                    #end\n                };\n                if(!this.empty()){\n                    var set_ite=this.parent;\n                    while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    while(set_ite!=null){\n                        var elt=set_ite.data;\n                        {\n                            if(!lt(elt,obj)){\n                                ret=elt;\n                                break;\n                            }\n                        };\n                        if(set_ite.next!=null){\n                            set_ite=set_ite.next;\n                            while(set_ite.prev!=null)set_ite=set_ite.prev;\n                        }\n                        else{\n                            while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                            set_ite=set_ite.parent;\n                        }\n                    }\n                }\n            };\n            ret;\n        };\n    }\n    public function first(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"first in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        return cur.data;\n    }\n    public function pop_front(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"pop_front in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        var ret=cur.data;\n        remove_node(cur);\n        return ret;\n    }\n    public function remove(obj:ZPP_CbSetPair){\n        var node=find(obj);\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"object not in tree\");\n            #end\n        };\n        remove_node(node);\n    }\n    public function successor_node(cur:ZPP_Set_ZPP_CbSetPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null){\n            cur=cur.next;\n            while(cur.prev!=null)cur=cur.prev;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.prev!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function predecessor_node(cur:ZPP_Set_ZPP_CbSetPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.prev!=null){\n            cur=cur.prev;\n            while(cur.next!=null)cur=cur.next;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.next!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function successor(obj:ZPP_CbSetPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=successor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function predecessor(obj:ZPP_CbSetPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=predecessor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function remove_node(cur:ZPP_Set_ZPP_CbSetPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null&&cur.prev!=null){\n            var sm=cur.next;\n            while(sm.prev!=null)sm=sm.prev;\n            {\n                var t=cur.data;\n                cur.data=sm.data;\n                sm.data=t;\n            };\n            if(swapped!=null)swapped(cur.data,sm.data);\n            cur=sm;\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur.next==null||cur.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"cur.next==null||cur.prev==null\"+\") :: \"+(\"node still has two children??\");\n            #end\n        };\n        var child=if(cur.prev==null)cur.next else cur.prev;\n        if(cur.colour==1){\n            if(cur.prev!=null||cur.next!=null)child.colour=1;\n            else if(cur.parent!=null){\n                var parent=cur.parent;\n                while(true){\n                    parent.colour++;\n                    parent.prev.colour--;\n                    parent.next.colour--;\n                    {\n                        var child=parent.prev;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    {\n                        var child=parent.next;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(parent.colour==2){\n                        if(parent.parent==null){\n                            parent.colour=1;\n                        }\n                        else{\n                            parent=parent.parent;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        {\n            var par=cur.parent;\n            if(par==null){\n                parent=child;\n            }\n            else if(par.prev==cur)par.prev=child;\n            else par.next=child;\n            if(child!=null)child.parent=par;\n        };\n        cur.parent=cur.prev=cur.next=null;\n        {\n            var o=cur;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_CbSetPair\"+\", in obj: \"+\"cur\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n            ZPP_Set_ZPP_CbSetPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT++;\n            ZPP_Set_ZPP_CbSetPair.POOL_SUB++;\n            #end\n        };\n    }\n    public function clear(){\n        clear_with(function(_){});\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function clear_with(lambda:ZPP_CbSetPair->Void){\n        if(parent==null)return;\n        else{\n            var cur=parent;\n            while(cur!=null)cur=if(cur.prev!=null)cur.prev else if(cur.next!=null)cur.next else clear_node(cur,lambda);\n            parent=null;\n        }\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    function clear_node(node:ZPP_Set_ZPP_CbSetPair,lambda:ZPP_CbSetPair->Void){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node.next==null&&node.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"node.next==null&&node.prev==null\"+\") :: \"+(\"clear_node :: node not a leaf\");\n            #end\n        };\n        lambda(node.data);\n        var ret=node.parent;\n        if(ret!=null){\n            if(node==ret.prev)ret.prev=null;\n            else ret.next=null;\n            node.parent=null;\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_CbSetPair\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n            ZPP_Set_ZPP_CbSetPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT++;\n            ZPP_Set_ZPP_CbSetPair.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function __fix_neg_red(negred:ZPP_Set_ZPP_CbSetPair){\n        var parent=negred.parent;\n        var child=if(parent.prev==negred){\n            var nl=negred.prev;\n            var nr=negred.next;\n            var trl=nr.prev;\n            var trr=nr.next;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.next=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.prev=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.next=parent.next;\n                if(parent.next!=null)parent.next.parent=nr;\n            };\n            {\n                parent.next=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        else{\n            var nl=negred.next;\n            var nr=negred.prev;\n            var trl=nr.next;\n            var trr=nr.prev;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.prev=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.next=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.prev=parent.prev;\n                if(parent.prev!=null)parent.prev.parent=nr;\n            };\n            {\n                parent.prev=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        if(child.prev!=null&&child.prev.colour==0)__fix_dbl_red(child.prev);\n        else if(child.next!=null&&child.next.colour==0)__fix_dbl_red(child.next);\n    }\n    public function __fix_dbl_red(x:ZPP_Set_ZPP_CbSetPair){\n        while(true){\n            var par=x.parent;\n            var g=par.parent;\n            if(g==null){\n                par.colour=1;\n                break;\n            }\n            var n1:ZPP_Set_ZPP_CbSetPair,n2:ZPP_Set_ZPP_CbSetPair,n3:ZPP_Set_ZPP_CbSetPair,t1:ZPP_Set_ZPP_CbSetPair,t2:ZPP_Set_ZPP_CbSetPair,t3:ZPP_Set_ZPP_CbSetPair,t4:ZPP_Set_ZPP_CbSetPair;\n            if(par==g.prev){\n                n3=g;\n                t4=g.next;\n                if(x==par.prev){\n                    n1=x;\n                    n2=par;\n                    t1=x.prev;\n                    t2=x.next;\n                    t3=par.next;\n                }\n                else{\n                    n1=par;\n                    n2=x;\n                    t1=par.prev;\n                    t2=x.prev;\n                    t3=x.next;\n                }\n            }\n            else{\n                n1=g;\n                t1=g.prev;\n                if(x==par.prev){\n                    n2=x;\n                    n3=par;\n                    t2=x.prev;\n                    t3=x.next;\n                    t4=par.next;\n                }\n                else{\n                    n2=par;\n                    n3=x;\n                    t2=par.prev;\n                    t3=x.prev;\n                    t4=x.next;\n                }\n            }\n            {\n                var par=g.parent;\n                if(par==null){\n                    parent=n2;\n                }\n                else if(par.prev==g)par.prev=n2;\n                else par.next=n2;\n                if(n2!=null)n2.parent=par;\n            };\n            {\n                n1.prev=t1;\n                if(t1!=null)t1.parent=n1;\n            };\n            {\n                n1.next=t2;\n                if(t2!=null)t2.parent=n1;\n            };\n            {\n                n2.prev=n1;\n                if(n1!=null)n1.parent=n2;\n            };\n            {\n                n2.next=n3;\n                if(n3!=null)n3.parent=n2;\n            };\n            {\n                n3.prev=t3;\n                if(t3!=null)t3.parent=n3;\n            };\n            {\n                n3.next=t4;\n                if(t4!=null)t4.parent=n3;\n            };\n            n2.colour=g.colour-1;\n            n1.colour=1;\n            n3.colour=1;\n            if(n2==parent)parent.colour=1;\n            else if(n2.colour==0&&n2.parent.colour==0){\n                x=n2;\n                continue;\n            }\n            break;\n        }\n    }\n    public function try_insert_bool(obj:ZPP_CbSetPair){\n        var x:ZPP_Set_ZPP_CbSetPair=null;\n        var cur:ZPP_Set_ZPP_CbSetPair=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_CbSetPair.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_CbSetPair();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_TOT++;\n                    ZPP_Set_ZPP_CbSetPair.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n                    ZPP_Set_ZPP_CbSetPair.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT--;\n                    ZPP_Set_ZPP_CbSetPair.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_CbSetPair.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_CbSetPair();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_TOT++;\n                                ZPP_Set_ZPP_CbSetPair.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n                                ZPP_Set_ZPP_CbSetPair.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT--;\n                                ZPP_Set_ZPP_CbSetPair.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_CbSetPair.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_CbSetPair();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_TOT++;\n                                ZPP_Set_ZPP_CbSetPair.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n                                ZPP_Set_ZPP_CbSetPair.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT--;\n                                ZPP_Set_ZPP_CbSetPair.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return false;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return true;\n        }\n    }\n    public function try_insert(obj:ZPP_CbSetPair){\n        var x:ZPP_Set_ZPP_CbSetPair=null;\n        var cur:ZPP_Set_ZPP_CbSetPair=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_CbSetPair.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_CbSetPair();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_TOT++;\n                    ZPP_Set_ZPP_CbSetPair.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n                    ZPP_Set_ZPP_CbSetPair.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT--;\n                    ZPP_Set_ZPP_CbSetPair.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_CbSetPair.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_CbSetPair();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_TOT++;\n                                ZPP_Set_ZPP_CbSetPair.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n                                ZPP_Set_ZPP_CbSetPair.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT--;\n                                ZPP_Set_ZPP_CbSetPair.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_CbSetPair.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_CbSetPair();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_TOT++;\n                                ZPP_Set_ZPP_CbSetPair.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n                                ZPP_Set_ZPP_CbSetPair.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT--;\n                                ZPP_Set_ZPP_CbSetPair.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return cur;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return x;\n        }\n    }\n    public function insert(obj:ZPP_CbSetPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !has(obj);\n            };\n            if(!res)throw \"assert(\"+\"!has(obj)\"+\") :: \"+(\"object already in set\");\n            #end\n        };\n        var x;\n        {\n            if(ZPP_Set_ZPP_CbSetPair.zpp_pool==null){\n                x=new ZPP_Set_ZPP_CbSetPair();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_TOT++;\n                ZPP_Set_ZPP_CbSetPair.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                x=ZPP_Set_ZPP_CbSetPair.zpp_pool;\n                ZPP_Set_ZPP_CbSetPair.zpp_pool=x.next;\n                x.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSetPair.POOL_CNT--;\n                ZPP_Set_ZPP_CbSetPair.POOL_ADD++;\n                #end\n            }\n            x.alloc();\n        };\n        x.data=obj;\n        if(parent==null)parent=x;\n        else{\n            var cur=parent;\n            while(true){\n                if(lt(x.data,cur.data)){\n                    if(cur.prev==null){\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else{\n                    if(cur.next==null){\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n            }\n        }\n        if(x.parent==null)x.colour=1;\n        else{\n            x.colour=0;\n            if(x.parent.colour==0)__fix_dbl_red(x);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x.data==obj;\n            };\n            if(!res)throw \"assert(\"+\"x.data==obj\"+\") :: \"+(\"...wtf?\");\n            #end\n        };\n        return x;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Set_ZPP_PartitionVertex{\n    static public var zpp_pool:ZPP_Set_ZPP_PartitionVertex=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        data=null;\n        lt=null;\n        swapped=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var lt:ZPP_PartitionVertex->ZPP_PartitionVertex->Bool=null;\n    public var swapped:ZPP_PartitionVertex->ZPP_PartitionVertex->Void=null;\n    public var data:ZPP_PartitionVertex=null;\n    public var prev:ZPP_Set_ZPP_PartitionVertex=null;\n    public var next:ZPP_Set_ZPP_PartitionVertex=null;\n    public var parent:ZPP_Set_ZPP_PartitionVertex=null;\n    public var colour:Int=0;\n    public function new(){}\n    public function verify(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    {\n                        var prei=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    this!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                                #end\n                            };\n                            if(!this.empty()){\n                                var set_ite=this.parent;\n                                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                while(set_ite!=null){\n                                    var j=set_ite.data;\n                                    {\n                                        if(!prei){\n                                            if(!lt(i,j)&&lt(j,i))return false;\n                                        }\n                                        else if(i==j)prei=false;\n                                        else{\n                                            if(!lt(j,i)&&lt(i,j))return false;\n                                        }\n                                    };\n                                    if(set_ite.next!=null){\n                                        set_ite=set_ite.next;\n                                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                    }\n                                    else{\n                                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                                        set_ite=set_ite.parent;\n                                    }\n                                }\n                            }\n                        };\n                    };\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return true;\n    }\n    public function empty(){\n        return parent==null;\n    }\n    public function singular(){\n        return parent!=null&&parent.prev==null&&parent.next==null;\n    }\n    public function size(){\n        var ret=0;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    ret++;\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return ret;\n    }\n    public function has(obj:ZPP_PartitionVertex){\n        return find(obj)!=null;\n    }\n    public function find(obj:ZPP_PartitionVertex){\n        var cur=parent;\n        while(cur!=null&&cur.data!=obj){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else cur=cur.next;\n        }\n        return cur;\n    }\n    public function has_weak(obj:ZPP_PartitionVertex){\n        return find_weak(obj)!=null;\n    }\n    public function find_weak(obj:ZPP_PartitionVertex){\n        var cur=parent;\n        while(cur!=null){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else if(lt(cur.data,obj))cur=cur.next;\n            else break;\n        }\n        return cur;\n    }\n    public function lower_bound(obj:ZPP_PartitionVertex){\n        return{\n            var ret=null;\n            {\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        this!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                    #end\n                };\n                if(!this.empty()){\n                    var set_ite=this.parent;\n                    while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    while(set_ite!=null){\n                        var elt=set_ite.data;\n                        {\n                            if(!lt(elt,obj)){\n                                ret=elt;\n                                break;\n                            }\n                        };\n                        if(set_ite.next!=null){\n                            set_ite=set_ite.next;\n                            while(set_ite.prev!=null)set_ite=set_ite.prev;\n                        }\n                        else{\n                            while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                            set_ite=set_ite.parent;\n                        }\n                    }\n                }\n            };\n            ret;\n        };\n    }\n    public function first(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"first in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        return cur.data;\n    }\n    public function pop_front(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"pop_front in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        var ret=cur.data;\n        remove_node(cur);\n        return ret;\n    }\n    public function remove(obj:ZPP_PartitionVertex){\n        var node=find(obj);\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"object not in tree\");\n            #end\n        };\n        remove_node(node);\n    }\n    public function successor_node(cur:ZPP_Set_ZPP_PartitionVertex){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null){\n            cur=cur.next;\n            while(cur.prev!=null)cur=cur.prev;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.prev!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function predecessor_node(cur:ZPP_Set_ZPP_PartitionVertex){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.prev!=null){\n            cur=cur.prev;\n            while(cur.next!=null)cur=cur.next;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.next!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function successor(obj:ZPP_PartitionVertex){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=successor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function predecessor(obj:ZPP_PartitionVertex){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=predecessor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function remove_node(cur:ZPP_Set_ZPP_PartitionVertex){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null&&cur.prev!=null){\n            var sm=cur.next;\n            while(sm.prev!=null)sm=sm.prev;\n            {\n                var t=cur.data;\n                cur.data=sm.data;\n                sm.data=t;\n            };\n            if(swapped!=null)swapped(cur.data,sm.data);\n            cur=sm;\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur.next==null||cur.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"cur.next==null||cur.prev==null\"+\") :: \"+(\"node still has two children??\");\n            #end\n        };\n        var child=if(cur.prev==null)cur.next else cur.prev;\n        if(cur.colour==1){\n            if(cur.prev!=null||cur.next!=null)child.colour=1;\n            else if(cur.parent!=null){\n                var parent=cur.parent;\n                while(true){\n                    parent.colour++;\n                    parent.prev.colour--;\n                    parent.next.colour--;\n                    {\n                        var child=parent.prev;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    {\n                        var child=parent.next;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(parent.colour==2){\n                        if(parent.parent==null){\n                            parent.colour=1;\n                        }\n                        else{\n                            parent=parent.parent;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        {\n            var par=cur.parent;\n            if(par==null){\n                parent=child;\n            }\n            else if(par.prev==cur)par.prev=child;\n            else par.next=child;\n            if(child!=null)child.parent=par;\n        };\n        cur.parent=cur.prev=cur.next=null;\n        {\n            var o=cur;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_PartitionVertex\"+\", in obj: \"+\"cur\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n            ZPP_Set_ZPP_PartitionVertex.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT++;\n            ZPP_Set_ZPP_PartitionVertex.POOL_SUB++;\n            #end\n        };\n    }\n    public function clear(){\n        clear_with(function(_){});\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function clear_with(lambda:ZPP_PartitionVertex->Void){\n        if(parent==null)return;\n        else{\n            var cur=parent;\n            while(cur!=null)cur=if(cur.prev!=null)cur.prev else if(cur.next!=null)cur.next else clear_node(cur,lambda);\n            parent=null;\n        }\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    function clear_node(node:ZPP_Set_ZPP_PartitionVertex,lambda:ZPP_PartitionVertex->Void){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node.next==null&&node.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"node.next==null&&node.prev==null\"+\") :: \"+(\"clear_node :: node not a leaf\");\n            #end\n        };\n        lambda(node.data);\n        var ret=node.parent;\n        if(ret!=null){\n            if(node==ret.prev)ret.prev=null;\n            else ret.next=null;\n            node.parent=null;\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_PartitionVertex\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n            ZPP_Set_ZPP_PartitionVertex.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT++;\n            ZPP_Set_ZPP_PartitionVertex.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function __fix_neg_red(negred:ZPP_Set_ZPP_PartitionVertex){\n        var parent=negred.parent;\n        var child=if(parent.prev==negred){\n            var nl=negred.prev;\n            var nr=negred.next;\n            var trl=nr.prev;\n            var trr=nr.next;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.next=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.prev=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.next=parent.next;\n                if(parent.next!=null)parent.next.parent=nr;\n            };\n            {\n                parent.next=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        else{\n            var nl=negred.next;\n            var nr=negred.prev;\n            var trl=nr.next;\n            var trr=nr.prev;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.prev=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.next=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.prev=parent.prev;\n                if(parent.prev!=null)parent.prev.parent=nr;\n            };\n            {\n                parent.prev=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        if(child.prev!=null&&child.prev.colour==0)__fix_dbl_red(child.prev);\n        else if(child.next!=null&&child.next.colour==0)__fix_dbl_red(child.next);\n    }\n    public function __fix_dbl_red(x:ZPP_Set_ZPP_PartitionVertex){\n        while(true){\n            var par=x.parent;\n            var g=par.parent;\n            if(g==null){\n                par.colour=1;\n                break;\n            }\n            var n1:ZPP_Set_ZPP_PartitionVertex,n2:ZPP_Set_ZPP_PartitionVertex,n3:ZPP_Set_ZPP_PartitionVertex,t1:ZPP_Set_ZPP_PartitionVertex,t2:ZPP_Set_ZPP_PartitionVertex,t3:ZPP_Set_ZPP_PartitionVertex,t4:ZPP_Set_ZPP_PartitionVertex;\n            if(par==g.prev){\n                n3=g;\n                t4=g.next;\n                if(x==par.prev){\n                    n1=x;\n                    n2=par;\n                    t1=x.prev;\n                    t2=x.next;\n                    t3=par.next;\n                }\n                else{\n                    n1=par;\n                    n2=x;\n                    t1=par.prev;\n                    t2=x.prev;\n                    t3=x.next;\n                }\n            }\n            else{\n                n1=g;\n                t1=g.prev;\n                if(x==par.prev){\n                    n2=x;\n                    n3=par;\n                    t2=x.prev;\n                    t3=x.next;\n                    t4=par.next;\n                }\n                else{\n                    n2=par;\n                    n3=x;\n                    t2=par.prev;\n                    t3=x.prev;\n                    t4=x.next;\n                }\n            }\n            {\n                var par=g.parent;\n                if(par==null){\n                    parent=n2;\n                }\n                else if(par.prev==g)par.prev=n2;\n                else par.next=n2;\n                if(n2!=null)n2.parent=par;\n            };\n            {\n                n1.prev=t1;\n                if(t1!=null)t1.parent=n1;\n            };\n            {\n                n1.next=t2;\n                if(t2!=null)t2.parent=n1;\n            };\n            {\n                n2.prev=n1;\n                if(n1!=null)n1.parent=n2;\n            };\n            {\n                n2.next=n3;\n                if(n3!=null)n3.parent=n2;\n            };\n            {\n                n3.prev=t3;\n                if(t3!=null)t3.parent=n3;\n            };\n            {\n                n3.next=t4;\n                if(t4!=null)t4.parent=n3;\n            };\n            n2.colour=g.colour-1;\n            n1.colour=1;\n            n3.colour=1;\n            if(n2==parent)parent.colour=1;\n            else if(n2.colour==0&&n2.parent.colour==0){\n                x=n2;\n                continue;\n            }\n            break;\n        }\n    }\n    public function try_insert_bool(obj:ZPP_PartitionVertex){\n        var x:ZPP_Set_ZPP_PartitionVertex=null;\n        var cur:ZPP_Set_ZPP_PartitionVertex=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_PartitionVertex.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_PartitionVertex();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_TOT++;\n                    ZPP_Set_ZPP_PartitionVertex.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n                    ZPP_Set_ZPP_PartitionVertex.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT--;\n                    ZPP_Set_ZPP_PartitionVertex.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_PartitionVertex.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_PartitionVertex();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_TOT++;\n                                ZPP_Set_ZPP_PartitionVertex.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n                                ZPP_Set_ZPP_PartitionVertex.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT--;\n                                ZPP_Set_ZPP_PartitionVertex.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_PartitionVertex.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_PartitionVertex();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_TOT++;\n                                ZPP_Set_ZPP_PartitionVertex.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n                                ZPP_Set_ZPP_PartitionVertex.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT--;\n                                ZPP_Set_ZPP_PartitionVertex.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return false;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return true;\n        }\n    }\n    public function try_insert(obj:ZPP_PartitionVertex){\n        var x:ZPP_Set_ZPP_PartitionVertex=null;\n        var cur:ZPP_Set_ZPP_PartitionVertex=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_PartitionVertex.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_PartitionVertex();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_TOT++;\n                    ZPP_Set_ZPP_PartitionVertex.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n                    ZPP_Set_ZPP_PartitionVertex.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT--;\n                    ZPP_Set_ZPP_PartitionVertex.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_PartitionVertex.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_PartitionVertex();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_TOT++;\n                                ZPP_Set_ZPP_PartitionVertex.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n                                ZPP_Set_ZPP_PartitionVertex.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT--;\n                                ZPP_Set_ZPP_PartitionVertex.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_PartitionVertex.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_PartitionVertex();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_TOT++;\n                                ZPP_Set_ZPP_PartitionVertex.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n                                ZPP_Set_ZPP_PartitionVertex.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT--;\n                                ZPP_Set_ZPP_PartitionVertex.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return cur;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return x;\n        }\n    }\n    public function insert(obj:ZPP_PartitionVertex){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !has(obj);\n            };\n            if(!res)throw \"assert(\"+\"!has(obj)\"+\") :: \"+(\"object already in set\");\n            #end\n        };\n        var x;\n        {\n            if(ZPP_Set_ZPP_PartitionVertex.zpp_pool==null){\n                x=new ZPP_Set_ZPP_PartitionVertex();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_TOT++;\n                ZPP_Set_ZPP_PartitionVertex.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                x=ZPP_Set_ZPP_PartitionVertex.zpp_pool;\n                ZPP_Set_ZPP_PartitionVertex.zpp_pool=x.next;\n                x.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionVertex.POOL_CNT--;\n                ZPP_Set_ZPP_PartitionVertex.POOL_ADD++;\n                #end\n            }\n            x.alloc();\n        };\n        x.data=obj;\n        if(parent==null)parent=x;\n        else{\n            var cur=parent;\n            while(true){\n                if(lt(x.data,cur.data)){\n                    if(cur.prev==null){\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else{\n                    if(cur.next==null){\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n            }\n        }\n        if(x.parent==null)x.colour=1;\n        else{\n            x.colour=0;\n            if(x.parent.colour==0)__fix_dbl_red(x);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x.data==obj;\n            };\n            if(!res)throw \"assert(\"+\"x.data==obj\"+\") :: \"+(\"...wtf?\");\n            #end\n        };\n        return x;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Set_ZPP_PartitionPair{\n    static public var zpp_pool:ZPP_Set_ZPP_PartitionPair=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        data=null;\n        lt=null;\n        swapped=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var lt:ZPP_PartitionPair->ZPP_PartitionPair->Bool=null;\n    public var swapped:ZPP_PartitionPair->ZPP_PartitionPair->Void=null;\n    public var data:ZPP_PartitionPair=null;\n    public var prev:ZPP_Set_ZPP_PartitionPair=null;\n    public var next:ZPP_Set_ZPP_PartitionPair=null;\n    public var parent:ZPP_Set_ZPP_PartitionPair=null;\n    public var colour:Int=0;\n    public function new(){}\n    public function verify(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    {\n                        var prei=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    this!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                                #end\n                            };\n                            if(!this.empty()){\n                                var set_ite=this.parent;\n                                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                while(set_ite!=null){\n                                    var j=set_ite.data;\n                                    {\n                                        if(!prei){\n                                            if(!lt(i,j)&&lt(j,i))return false;\n                                        }\n                                        else if(i==j)prei=false;\n                                        else{\n                                            if(!lt(j,i)&&lt(i,j))return false;\n                                        }\n                                    };\n                                    if(set_ite.next!=null){\n                                        set_ite=set_ite.next;\n                                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                    }\n                                    else{\n                                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                                        set_ite=set_ite.parent;\n                                    }\n                                }\n                            }\n                        };\n                    };\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return true;\n    }\n    public function empty(){\n        return parent==null;\n    }\n    public function singular(){\n        return parent!=null&&parent.prev==null&&parent.next==null;\n    }\n    public function size(){\n        var ret=0;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    ret++;\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return ret;\n    }\n    public function has(obj:ZPP_PartitionPair){\n        return find(obj)!=null;\n    }\n    public function find(obj:ZPP_PartitionPair){\n        var cur=parent;\n        while(cur!=null&&cur.data!=obj){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else cur=cur.next;\n        }\n        return cur;\n    }\n    public function has_weak(obj:ZPP_PartitionPair){\n        return find_weak(obj)!=null;\n    }\n    public function find_weak(obj:ZPP_PartitionPair){\n        var cur=parent;\n        while(cur!=null){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else if(lt(cur.data,obj))cur=cur.next;\n            else break;\n        }\n        return cur;\n    }\n    public function lower_bound(obj:ZPP_PartitionPair){\n        return{\n            var ret=null;\n            {\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        this!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                    #end\n                };\n                if(!this.empty()){\n                    var set_ite=this.parent;\n                    while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    while(set_ite!=null){\n                        var elt=set_ite.data;\n                        {\n                            if(!lt(elt,obj)){\n                                ret=elt;\n                                break;\n                            }\n                        };\n                        if(set_ite.next!=null){\n                            set_ite=set_ite.next;\n                            while(set_ite.prev!=null)set_ite=set_ite.prev;\n                        }\n                        else{\n                            while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                            set_ite=set_ite.parent;\n                        }\n                    }\n                }\n            };\n            ret;\n        };\n    }\n    public function first(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"first in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        return cur.data;\n    }\n    public function pop_front(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"pop_front in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        var ret=cur.data;\n        remove_node(cur);\n        return ret;\n    }\n    public function remove(obj:ZPP_PartitionPair){\n        var node=find(obj);\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"object not in tree\");\n            #end\n        };\n        remove_node(node);\n    }\n    public function successor_node(cur:ZPP_Set_ZPP_PartitionPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null){\n            cur=cur.next;\n            while(cur.prev!=null)cur=cur.prev;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.prev!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function predecessor_node(cur:ZPP_Set_ZPP_PartitionPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.prev!=null){\n            cur=cur.prev;\n            while(cur.next!=null)cur=cur.next;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.next!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function successor(obj:ZPP_PartitionPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=successor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function predecessor(obj:ZPP_PartitionPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=predecessor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function remove_node(cur:ZPP_Set_ZPP_PartitionPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null&&cur.prev!=null){\n            var sm=cur.next;\n            while(sm.prev!=null)sm=sm.prev;\n            {\n                var t=cur.data;\n                cur.data=sm.data;\n                sm.data=t;\n            };\n            if(swapped!=null)swapped(cur.data,sm.data);\n            cur=sm;\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur.next==null||cur.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"cur.next==null||cur.prev==null\"+\") :: \"+(\"node still has two children??\");\n            #end\n        };\n        var child=if(cur.prev==null)cur.next else cur.prev;\n        if(cur.colour==1){\n            if(cur.prev!=null||cur.next!=null)child.colour=1;\n            else if(cur.parent!=null){\n                var parent=cur.parent;\n                while(true){\n                    parent.colour++;\n                    parent.prev.colour--;\n                    parent.next.colour--;\n                    {\n                        var child=parent.prev;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    {\n                        var child=parent.next;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(parent.colour==2){\n                        if(parent.parent==null){\n                            parent.colour=1;\n                        }\n                        else{\n                            parent=parent.parent;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        {\n            var par=cur.parent;\n            if(par==null){\n                parent=child;\n            }\n            else if(par.prev==cur)par.prev=child;\n            else par.next=child;\n            if(child!=null)child.parent=par;\n        };\n        cur.parent=cur.prev=cur.next=null;\n        {\n            var o=cur;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_PartitionPair\"+\", in obj: \"+\"cur\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n            ZPP_Set_ZPP_PartitionPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT++;\n            ZPP_Set_ZPP_PartitionPair.POOL_SUB++;\n            #end\n        };\n    }\n    public function clear(){\n        clear_with(function(_){});\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function clear_with(lambda:ZPP_PartitionPair->Void){\n        if(parent==null)return;\n        else{\n            var cur=parent;\n            while(cur!=null)cur=if(cur.prev!=null)cur.prev else if(cur.next!=null)cur.next else clear_node(cur,lambda);\n            parent=null;\n        }\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    function clear_node(node:ZPP_Set_ZPP_PartitionPair,lambda:ZPP_PartitionPair->Void){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node.next==null&&node.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"node.next==null&&node.prev==null\"+\") :: \"+(\"clear_node :: node not a leaf\");\n            #end\n        };\n        lambda(node.data);\n        var ret=node.parent;\n        if(ret!=null){\n            if(node==ret.prev)ret.prev=null;\n            else ret.next=null;\n            node.parent=null;\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_PartitionPair\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n            ZPP_Set_ZPP_PartitionPair.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT++;\n            ZPP_Set_ZPP_PartitionPair.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function __fix_neg_red(negred:ZPP_Set_ZPP_PartitionPair){\n        var parent=negred.parent;\n        var child=if(parent.prev==negred){\n            var nl=negred.prev;\n            var nr=negred.next;\n            var trl=nr.prev;\n            var trr=nr.next;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.next=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.prev=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.next=parent.next;\n                if(parent.next!=null)parent.next.parent=nr;\n            };\n            {\n                parent.next=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        else{\n            var nl=negred.next;\n            var nr=negred.prev;\n            var trl=nr.next;\n            var trr=nr.prev;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.prev=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.next=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.prev=parent.prev;\n                if(parent.prev!=null)parent.prev.parent=nr;\n            };\n            {\n                parent.prev=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        if(child.prev!=null&&child.prev.colour==0)__fix_dbl_red(child.prev);\n        else if(child.next!=null&&child.next.colour==0)__fix_dbl_red(child.next);\n    }\n    public function __fix_dbl_red(x:ZPP_Set_ZPP_PartitionPair){\n        while(true){\n            var par=x.parent;\n            var g=par.parent;\n            if(g==null){\n                par.colour=1;\n                break;\n            }\n            var n1:ZPP_Set_ZPP_PartitionPair,n2:ZPP_Set_ZPP_PartitionPair,n3:ZPP_Set_ZPP_PartitionPair,t1:ZPP_Set_ZPP_PartitionPair,t2:ZPP_Set_ZPP_PartitionPair,t3:ZPP_Set_ZPP_PartitionPair,t4:ZPP_Set_ZPP_PartitionPair;\n            if(par==g.prev){\n                n3=g;\n                t4=g.next;\n                if(x==par.prev){\n                    n1=x;\n                    n2=par;\n                    t1=x.prev;\n                    t2=x.next;\n                    t3=par.next;\n                }\n                else{\n                    n1=par;\n                    n2=x;\n                    t1=par.prev;\n                    t2=x.prev;\n                    t3=x.next;\n                }\n            }\n            else{\n                n1=g;\n                t1=g.prev;\n                if(x==par.prev){\n                    n2=x;\n                    n3=par;\n                    t2=x.prev;\n                    t3=x.next;\n                    t4=par.next;\n                }\n                else{\n                    n2=par;\n                    n3=x;\n                    t2=par.prev;\n                    t3=x.prev;\n                    t4=x.next;\n                }\n            }\n            {\n                var par=g.parent;\n                if(par==null){\n                    parent=n2;\n                }\n                else if(par.prev==g)par.prev=n2;\n                else par.next=n2;\n                if(n2!=null)n2.parent=par;\n            };\n            {\n                n1.prev=t1;\n                if(t1!=null)t1.parent=n1;\n            };\n            {\n                n1.next=t2;\n                if(t2!=null)t2.parent=n1;\n            };\n            {\n                n2.prev=n1;\n                if(n1!=null)n1.parent=n2;\n            };\n            {\n                n2.next=n3;\n                if(n3!=null)n3.parent=n2;\n            };\n            {\n                n3.prev=t3;\n                if(t3!=null)t3.parent=n3;\n            };\n            {\n                n3.next=t4;\n                if(t4!=null)t4.parent=n3;\n            };\n            n2.colour=g.colour-1;\n            n1.colour=1;\n            n3.colour=1;\n            if(n2==parent)parent.colour=1;\n            else if(n2.colour==0&&n2.parent.colour==0){\n                x=n2;\n                continue;\n            }\n            break;\n        }\n    }\n    public function try_insert_bool(obj:ZPP_PartitionPair){\n        var x:ZPP_Set_ZPP_PartitionPair=null;\n        var cur:ZPP_Set_ZPP_PartitionPair=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_PartitionPair.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_PartitionPair();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_TOT++;\n                    ZPP_Set_ZPP_PartitionPair.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n                    ZPP_Set_ZPP_PartitionPair.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT--;\n                    ZPP_Set_ZPP_PartitionPair.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_PartitionPair.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_PartitionPair();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_TOT++;\n                                ZPP_Set_ZPP_PartitionPair.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n                                ZPP_Set_ZPP_PartitionPair.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT--;\n                                ZPP_Set_ZPP_PartitionPair.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_PartitionPair.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_PartitionPair();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_TOT++;\n                                ZPP_Set_ZPP_PartitionPair.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n                                ZPP_Set_ZPP_PartitionPair.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT--;\n                                ZPP_Set_ZPP_PartitionPair.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return false;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return true;\n        }\n    }\n    public function try_insert(obj:ZPP_PartitionPair){\n        var x:ZPP_Set_ZPP_PartitionPair=null;\n        var cur:ZPP_Set_ZPP_PartitionPair=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_PartitionPair.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_PartitionPair();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_TOT++;\n                    ZPP_Set_ZPP_PartitionPair.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n                    ZPP_Set_ZPP_PartitionPair.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT--;\n                    ZPP_Set_ZPP_PartitionPair.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_PartitionPair.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_PartitionPair();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_TOT++;\n                                ZPP_Set_ZPP_PartitionPair.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n                                ZPP_Set_ZPP_PartitionPair.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT--;\n                                ZPP_Set_ZPP_PartitionPair.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_PartitionPair.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_PartitionPair();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_TOT++;\n                                ZPP_Set_ZPP_PartitionPair.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n                                ZPP_Set_ZPP_PartitionPair.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT--;\n                                ZPP_Set_ZPP_PartitionPair.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return cur;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return x;\n        }\n    }\n    public function insert(obj:ZPP_PartitionPair){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !has(obj);\n            };\n            if(!res)throw \"assert(\"+\"!has(obj)\"+\") :: \"+(\"object already in set\");\n            #end\n        };\n        var x;\n        {\n            if(ZPP_Set_ZPP_PartitionPair.zpp_pool==null){\n                x=new ZPP_Set_ZPP_PartitionPair();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_TOT++;\n                ZPP_Set_ZPP_PartitionPair.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                x=ZPP_Set_ZPP_PartitionPair.zpp_pool;\n                ZPP_Set_ZPP_PartitionPair.zpp_pool=x.next;\n                x.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_PartitionPair.POOL_CNT--;\n                ZPP_Set_ZPP_PartitionPair.POOL_ADD++;\n                #end\n            }\n            x.alloc();\n        };\n        x.data=obj;\n        if(parent==null)parent=x;\n        else{\n            var cur=parent;\n            while(true){\n                if(lt(x.data,cur.data)){\n                    if(cur.prev==null){\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else{\n                    if(cur.next==null){\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n            }\n        }\n        if(x.parent==null)x.colour=1;\n        else{\n            x.colour=0;\n            if(x.parent.colour==0)__fix_dbl_red(x);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x.data==obj;\n            };\n            if(!res)throw \"assert(\"+\"x.data==obj\"+\") :: \"+(\"...wtf?\");\n            #end\n        };\n        return x;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Set_ZPP_SimpleVert{\n    static public var zpp_pool:ZPP_Set_ZPP_SimpleVert=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        data=null;\n        lt=null;\n        swapped=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var lt:ZPP_SimpleVert->ZPP_SimpleVert->Bool=null;\n    public var swapped:ZPP_SimpleVert->ZPP_SimpleVert->Void=null;\n    public var data:ZPP_SimpleVert=null;\n    public var prev:ZPP_Set_ZPP_SimpleVert=null;\n    public var next:ZPP_Set_ZPP_SimpleVert=null;\n    public var parent:ZPP_Set_ZPP_SimpleVert=null;\n    public var colour:Int=0;\n    public function new(){}\n    public function verify(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    {\n                        var prei=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    this!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                                #end\n                            };\n                            if(!this.empty()){\n                                var set_ite=this.parent;\n                                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                while(set_ite!=null){\n                                    var j=set_ite.data;\n                                    {\n                                        if(!prei){\n                                            if(!lt(i,j)&&lt(j,i))return false;\n                                        }\n                                        else if(i==j)prei=false;\n                                        else{\n                                            if(!lt(j,i)&&lt(i,j))return false;\n                                        }\n                                    };\n                                    if(set_ite.next!=null){\n                                        set_ite=set_ite.next;\n                                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                    }\n                                    else{\n                                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                                        set_ite=set_ite.parent;\n                                    }\n                                }\n                            }\n                        };\n                    };\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return true;\n    }\n    public function empty(){\n        return parent==null;\n    }\n    public function singular(){\n        return parent!=null&&parent.prev==null&&parent.next==null;\n    }\n    public function size(){\n        var ret=0;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    ret++;\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return ret;\n    }\n    public function has(obj:ZPP_SimpleVert){\n        return find(obj)!=null;\n    }\n    public function find(obj:ZPP_SimpleVert){\n        var cur=parent;\n        while(cur!=null&&cur.data!=obj){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else cur=cur.next;\n        }\n        return cur;\n    }\n    public function has_weak(obj:ZPP_SimpleVert){\n        return find_weak(obj)!=null;\n    }\n    public function find_weak(obj:ZPP_SimpleVert){\n        var cur=parent;\n        while(cur!=null){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else if(lt(cur.data,obj))cur=cur.next;\n            else break;\n        }\n        return cur;\n    }\n    public function lower_bound(obj:ZPP_SimpleVert){\n        return{\n            var ret=null;\n            {\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        this!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                    #end\n                };\n                if(!this.empty()){\n                    var set_ite=this.parent;\n                    while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    while(set_ite!=null){\n                        var elt=set_ite.data;\n                        {\n                            if(!lt(elt,obj)){\n                                ret=elt;\n                                break;\n                            }\n                        };\n                        if(set_ite.next!=null){\n                            set_ite=set_ite.next;\n                            while(set_ite.prev!=null)set_ite=set_ite.prev;\n                        }\n                        else{\n                            while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                            set_ite=set_ite.parent;\n                        }\n                    }\n                }\n            };\n            ret;\n        };\n    }\n    public function first(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"first in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        return cur.data;\n    }\n    public function pop_front(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"pop_front in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        var ret=cur.data;\n        remove_node(cur);\n        return ret;\n    }\n    public function remove(obj:ZPP_SimpleVert){\n        var node=find(obj);\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"object not in tree\");\n            #end\n        };\n        remove_node(node);\n    }\n    public function successor_node(cur:ZPP_Set_ZPP_SimpleVert){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null){\n            cur=cur.next;\n            while(cur.prev!=null)cur=cur.prev;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.prev!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function predecessor_node(cur:ZPP_Set_ZPP_SimpleVert){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.prev!=null){\n            cur=cur.prev;\n            while(cur.next!=null)cur=cur.next;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.next!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function successor(obj:ZPP_SimpleVert){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=successor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function predecessor(obj:ZPP_SimpleVert){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=predecessor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function remove_node(cur:ZPP_Set_ZPP_SimpleVert){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null&&cur.prev!=null){\n            var sm=cur.next;\n            while(sm.prev!=null)sm=sm.prev;\n            {\n                var t=cur.data;\n                cur.data=sm.data;\n                sm.data=t;\n            };\n            if(swapped!=null)swapped(cur.data,sm.data);\n            cur=sm;\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur.next==null||cur.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"cur.next==null||cur.prev==null\"+\") :: \"+(\"node still has two children??\");\n            #end\n        };\n        var child=if(cur.prev==null)cur.next else cur.prev;\n        if(cur.colour==1){\n            if(cur.prev!=null||cur.next!=null)child.colour=1;\n            else if(cur.parent!=null){\n                var parent=cur.parent;\n                while(true){\n                    parent.colour++;\n                    parent.prev.colour--;\n                    parent.next.colour--;\n                    {\n                        var child=parent.prev;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    {\n                        var child=parent.next;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(parent.colour==2){\n                        if(parent.parent==null){\n                            parent.colour=1;\n                        }\n                        else{\n                            parent=parent.parent;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        {\n            var par=cur.parent;\n            if(par==null){\n                parent=child;\n            }\n            else if(par.prev==cur)par.prev=child;\n            else par.next=child;\n            if(child!=null)child.parent=par;\n        };\n        cur.parent=cur.prev=cur.next=null;\n        {\n            var o=cur;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_SimpleVert\"+\", in obj: \"+\"cur\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n            ZPP_Set_ZPP_SimpleVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT++;\n            ZPP_Set_ZPP_SimpleVert.POOL_SUB++;\n            #end\n        };\n    }\n    public function clear(){\n        clear_with(function(_){});\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function clear_with(lambda:ZPP_SimpleVert->Void){\n        if(parent==null)return;\n        else{\n            var cur=parent;\n            while(cur!=null)cur=if(cur.prev!=null)cur.prev else if(cur.next!=null)cur.next else clear_node(cur,lambda);\n            parent=null;\n        }\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    function clear_node(node:ZPP_Set_ZPP_SimpleVert,lambda:ZPP_SimpleVert->Void){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node.next==null&&node.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"node.next==null&&node.prev==null\"+\") :: \"+(\"clear_node :: node not a leaf\");\n            #end\n        };\n        lambda(node.data);\n        var ret=node.parent;\n        if(ret!=null){\n            if(node==ret.prev)ret.prev=null;\n            else ret.next=null;\n            node.parent=null;\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_SimpleVert\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n            ZPP_Set_ZPP_SimpleVert.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT++;\n            ZPP_Set_ZPP_SimpleVert.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function __fix_neg_red(negred:ZPP_Set_ZPP_SimpleVert){\n        var parent=negred.parent;\n        var child=if(parent.prev==negred){\n            var nl=negred.prev;\n            var nr=negred.next;\n            var trl=nr.prev;\n            var trr=nr.next;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.next=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.prev=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.next=parent.next;\n                if(parent.next!=null)parent.next.parent=nr;\n            };\n            {\n                parent.next=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        else{\n            var nl=negred.next;\n            var nr=negred.prev;\n            var trl=nr.next;\n            var trr=nr.prev;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.prev=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.next=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.prev=parent.prev;\n                if(parent.prev!=null)parent.prev.parent=nr;\n            };\n            {\n                parent.prev=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        if(child.prev!=null&&child.prev.colour==0)__fix_dbl_red(child.prev);\n        else if(child.next!=null&&child.next.colour==0)__fix_dbl_red(child.next);\n    }\n    public function __fix_dbl_red(x:ZPP_Set_ZPP_SimpleVert){\n        while(true){\n            var par=x.parent;\n            var g=par.parent;\n            if(g==null){\n                par.colour=1;\n                break;\n            }\n            var n1:ZPP_Set_ZPP_SimpleVert,n2:ZPP_Set_ZPP_SimpleVert,n3:ZPP_Set_ZPP_SimpleVert,t1:ZPP_Set_ZPP_SimpleVert,t2:ZPP_Set_ZPP_SimpleVert,t3:ZPP_Set_ZPP_SimpleVert,t4:ZPP_Set_ZPP_SimpleVert;\n            if(par==g.prev){\n                n3=g;\n                t4=g.next;\n                if(x==par.prev){\n                    n1=x;\n                    n2=par;\n                    t1=x.prev;\n                    t2=x.next;\n                    t3=par.next;\n                }\n                else{\n                    n1=par;\n                    n2=x;\n                    t1=par.prev;\n                    t2=x.prev;\n                    t3=x.next;\n                }\n            }\n            else{\n                n1=g;\n                t1=g.prev;\n                if(x==par.prev){\n                    n2=x;\n                    n3=par;\n                    t2=x.prev;\n                    t3=x.next;\n                    t4=par.next;\n                }\n                else{\n                    n2=par;\n                    n3=x;\n                    t2=par.prev;\n                    t3=x.prev;\n                    t4=x.next;\n                }\n            }\n            {\n                var par=g.parent;\n                if(par==null){\n                    parent=n2;\n                }\n                else if(par.prev==g)par.prev=n2;\n                else par.next=n2;\n                if(n2!=null)n2.parent=par;\n            };\n            {\n                n1.prev=t1;\n                if(t1!=null)t1.parent=n1;\n            };\n            {\n                n1.next=t2;\n                if(t2!=null)t2.parent=n1;\n            };\n            {\n                n2.prev=n1;\n                if(n1!=null)n1.parent=n2;\n            };\n            {\n                n2.next=n3;\n                if(n3!=null)n3.parent=n2;\n            };\n            {\n                n3.prev=t3;\n                if(t3!=null)t3.parent=n3;\n            };\n            {\n                n3.next=t4;\n                if(t4!=null)t4.parent=n3;\n            };\n            n2.colour=g.colour-1;\n            n1.colour=1;\n            n3.colour=1;\n            if(n2==parent)parent.colour=1;\n            else if(n2.colour==0&&n2.parent.colour==0){\n                x=n2;\n                continue;\n            }\n            break;\n        }\n    }\n    public function try_insert_bool(obj:ZPP_SimpleVert){\n        var x:ZPP_Set_ZPP_SimpleVert=null;\n        var cur:ZPP_Set_ZPP_SimpleVert=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_SimpleVert.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_SimpleVert();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_TOT++;\n                    ZPP_Set_ZPP_SimpleVert.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n                    ZPP_Set_ZPP_SimpleVert.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT--;\n                    ZPP_Set_ZPP_SimpleVert.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleVert.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleVert();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleVert.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n                                ZPP_Set_ZPP_SimpleVert.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleVert.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleVert.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleVert();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleVert.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n                                ZPP_Set_ZPP_SimpleVert.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleVert.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return false;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return true;\n        }\n    }\n    public function try_insert(obj:ZPP_SimpleVert){\n        var x:ZPP_Set_ZPP_SimpleVert=null;\n        var cur:ZPP_Set_ZPP_SimpleVert=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_SimpleVert.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_SimpleVert();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_TOT++;\n                    ZPP_Set_ZPP_SimpleVert.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n                    ZPP_Set_ZPP_SimpleVert.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT--;\n                    ZPP_Set_ZPP_SimpleVert.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleVert.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleVert();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleVert.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n                                ZPP_Set_ZPP_SimpleVert.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleVert.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleVert.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleVert();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleVert.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n                                ZPP_Set_ZPP_SimpleVert.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleVert.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return cur;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return x;\n        }\n    }\n    public function insert(obj:ZPP_SimpleVert){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !has(obj);\n            };\n            if(!res)throw \"assert(\"+\"!has(obj)\"+\") :: \"+(\"object already in set\");\n            #end\n        };\n        var x;\n        {\n            if(ZPP_Set_ZPP_SimpleVert.zpp_pool==null){\n                x=new ZPP_Set_ZPP_SimpleVert();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_TOT++;\n                ZPP_Set_ZPP_SimpleVert.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                x=ZPP_Set_ZPP_SimpleVert.zpp_pool;\n                ZPP_Set_ZPP_SimpleVert.zpp_pool=x.next;\n                x.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleVert.POOL_CNT--;\n                ZPP_Set_ZPP_SimpleVert.POOL_ADD++;\n                #end\n            }\n            x.alloc();\n        };\n        x.data=obj;\n        if(parent==null)parent=x;\n        else{\n            var cur=parent;\n            while(true){\n                if(lt(x.data,cur.data)){\n                    if(cur.prev==null){\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else{\n                    if(cur.next==null){\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n            }\n        }\n        if(x.parent==null)x.colour=1;\n        else{\n            x.colour=0;\n            if(x.parent.colour==0)__fix_dbl_red(x);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x.data==obj;\n            };\n            if(!res)throw \"assert(\"+\"x.data==obj\"+\") :: \"+(\"...wtf?\");\n            #end\n        };\n        return x;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Set_ZPP_SimpleSeg{\n    static public var zpp_pool:ZPP_Set_ZPP_SimpleSeg=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        data=null;\n        lt=null;\n        swapped=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var lt:ZPP_SimpleSeg->ZPP_SimpleSeg->Bool=null;\n    public var swapped:ZPP_SimpleSeg->ZPP_SimpleSeg->Void=null;\n    public var data:ZPP_SimpleSeg=null;\n    public var prev:ZPP_Set_ZPP_SimpleSeg=null;\n    public var next:ZPP_Set_ZPP_SimpleSeg=null;\n    public var parent:ZPP_Set_ZPP_SimpleSeg=null;\n    public var colour:Int=0;\n    public function new(){}\n    public function verify(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    {\n                        var prei=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    this!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                                #end\n                            };\n                            if(!this.empty()){\n                                var set_ite=this.parent;\n                                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                while(set_ite!=null){\n                                    var j=set_ite.data;\n                                    {\n                                        if(!prei){\n                                            if(!lt(i,j)&&lt(j,i))return false;\n                                        }\n                                        else if(i==j)prei=false;\n                                        else{\n                                            if(!lt(j,i)&&lt(i,j))return false;\n                                        }\n                                    };\n                                    if(set_ite.next!=null){\n                                        set_ite=set_ite.next;\n                                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                    }\n                                    else{\n                                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                                        set_ite=set_ite.parent;\n                                    }\n                                }\n                            }\n                        };\n                    };\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return true;\n    }\n    public function empty(){\n        return parent==null;\n    }\n    public function singular(){\n        return parent!=null&&parent.prev==null&&parent.next==null;\n    }\n    public function size(){\n        var ret=0;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    ret++;\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return ret;\n    }\n    public function has(obj:ZPP_SimpleSeg){\n        return find(obj)!=null;\n    }\n    public function find(obj:ZPP_SimpleSeg){\n        var cur=parent;\n        while(cur!=null&&cur.data!=obj){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else cur=cur.next;\n        }\n        return cur;\n    }\n    public function has_weak(obj:ZPP_SimpleSeg){\n        return find_weak(obj)!=null;\n    }\n    public function find_weak(obj:ZPP_SimpleSeg){\n        var cur=parent;\n        while(cur!=null){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else if(lt(cur.data,obj))cur=cur.next;\n            else break;\n        }\n        return cur;\n    }\n    public function lower_bound(obj:ZPP_SimpleSeg){\n        return{\n            var ret=null;\n            {\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        this!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                    #end\n                };\n                if(!this.empty()){\n                    var set_ite=this.parent;\n                    while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    while(set_ite!=null){\n                        var elt=set_ite.data;\n                        {\n                            if(!lt(elt,obj)){\n                                ret=elt;\n                                break;\n                            }\n                        };\n                        if(set_ite.next!=null){\n                            set_ite=set_ite.next;\n                            while(set_ite.prev!=null)set_ite=set_ite.prev;\n                        }\n                        else{\n                            while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                            set_ite=set_ite.parent;\n                        }\n                    }\n                }\n            };\n            ret;\n        };\n    }\n    public function first(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"first in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        return cur.data;\n    }\n    public function pop_front(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"pop_front in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        var ret=cur.data;\n        remove_node(cur);\n        return ret;\n    }\n    public function remove(obj:ZPP_SimpleSeg){\n        var node=find(obj);\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"object not in tree\");\n            #end\n        };\n        remove_node(node);\n    }\n    public function successor_node(cur:ZPP_Set_ZPP_SimpleSeg){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null){\n            cur=cur.next;\n            while(cur.prev!=null)cur=cur.prev;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.prev!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function predecessor_node(cur:ZPP_Set_ZPP_SimpleSeg){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.prev!=null){\n            cur=cur.prev;\n            while(cur.next!=null)cur=cur.next;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.next!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function successor(obj:ZPP_SimpleSeg){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=successor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function predecessor(obj:ZPP_SimpleSeg){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=predecessor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function remove_node(cur:ZPP_Set_ZPP_SimpleSeg){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null&&cur.prev!=null){\n            var sm=cur.next;\n            while(sm.prev!=null)sm=sm.prev;\n            {\n                var t=cur.data;\n                cur.data=sm.data;\n                sm.data=t;\n            };\n            if(swapped!=null)swapped(cur.data,sm.data);\n            cur=sm;\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur.next==null||cur.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"cur.next==null||cur.prev==null\"+\") :: \"+(\"node still has two children??\");\n            #end\n        };\n        var child=if(cur.prev==null)cur.next else cur.prev;\n        if(cur.colour==1){\n            if(cur.prev!=null||cur.next!=null)child.colour=1;\n            else if(cur.parent!=null){\n                var parent=cur.parent;\n                while(true){\n                    parent.colour++;\n                    parent.prev.colour--;\n                    parent.next.colour--;\n                    {\n                        var child=parent.prev;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    {\n                        var child=parent.next;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(parent.colour==2){\n                        if(parent.parent==null){\n                            parent.colour=1;\n                        }\n                        else{\n                            parent=parent.parent;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        {\n            var par=cur.parent;\n            if(par==null){\n                parent=child;\n            }\n            else if(par.prev==cur)par.prev=child;\n            else par.next=child;\n            if(child!=null)child.parent=par;\n        };\n        cur.parent=cur.prev=cur.next=null;\n        {\n            var o=cur;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_SimpleSeg\"+\", in obj: \"+\"cur\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n            ZPP_Set_ZPP_SimpleSeg.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT++;\n            ZPP_Set_ZPP_SimpleSeg.POOL_SUB++;\n            #end\n        };\n    }\n    public function clear(){\n        clear_with(function(_){});\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function clear_with(lambda:ZPP_SimpleSeg->Void){\n        if(parent==null)return;\n        else{\n            var cur=parent;\n            while(cur!=null)cur=if(cur.prev!=null)cur.prev else if(cur.next!=null)cur.next else clear_node(cur,lambda);\n            parent=null;\n        }\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    function clear_node(node:ZPP_Set_ZPP_SimpleSeg,lambda:ZPP_SimpleSeg->Void){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node.next==null&&node.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"node.next==null&&node.prev==null\"+\") :: \"+(\"clear_node :: node not a leaf\");\n            #end\n        };\n        lambda(node.data);\n        var ret=node.parent;\n        if(ret!=null){\n            if(node==ret.prev)ret.prev=null;\n            else ret.next=null;\n            node.parent=null;\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_SimpleSeg\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n            ZPP_Set_ZPP_SimpleSeg.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT++;\n            ZPP_Set_ZPP_SimpleSeg.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function __fix_neg_red(negred:ZPP_Set_ZPP_SimpleSeg){\n        var parent=negred.parent;\n        var child=if(parent.prev==negred){\n            var nl=negred.prev;\n            var nr=negred.next;\n            var trl=nr.prev;\n            var trr=nr.next;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.next=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.prev=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.next=parent.next;\n                if(parent.next!=null)parent.next.parent=nr;\n            };\n            {\n                parent.next=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        else{\n            var nl=negred.next;\n            var nr=negred.prev;\n            var trl=nr.next;\n            var trr=nr.prev;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.prev=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.next=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.prev=parent.prev;\n                if(parent.prev!=null)parent.prev.parent=nr;\n            };\n            {\n                parent.prev=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        if(child.prev!=null&&child.prev.colour==0)__fix_dbl_red(child.prev);\n        else if(child.next!=null&&child.next.colour==0)__fix_dbl_red(child.next);\n    }\n    public function __fix_dbl_red(x:ZPP_Set_ZPP_SimpleSeg){\n        while(true){\n            var par=x.parent;\n            var g=par.parent;\n            if(g==null){\n                par.colour=1;\n                break;\n            }\n            var n1:ZPP_Set_ZPP_SimpleSeg,n2:ZPP_Set_ZPP_SimpleSeg,n3:ZPP_Set_ZPP_SimpleSeg,t1:ZPP_Set_ZPP_SimpleSeg,t2:ZPP_Set_ZPP_SimpleSeg,t3:ZPP_Set_ZPP_SimpleSeg,t4:ZPP_Set_ZPP_SimpleSeg;\n            if(par==g.prev){\n                n3=g;\n                t4=g.next;\n                if(x==par.prev){\n                    n1=x;\n                    n2=par;\n                    t1=x.prev;\n                    t2=x.next;\n                    t3=par.next;\n                }\n                else{\n                    n1=par;\n                    n2=x;\n                    t1=par.prev;\n                    t2=x.prev;\n                    t3=x.next;\n                }\n            }\n            else{\n                n1=g;\n                t1=g.prev;\n                if(x==par.prev){\n                    n2=x;\n                    n3=par;\n                    t2=x.prev;\n                    t3=x.next;\n                    t4=par.next;\n                }\n                else{\n                    n2=par;\n                    n3=x;\n                    t2=par.prev;\n                    t3=x.prev;\n                    t4=x.next;\n                }\n            }\n            {\n                var par=g.parent;\n                if(par==null){\n                    parent=n2;\n                }\n                else if(par.prev==g)par.prev=n2;\n                else par.next=n2;\n                if(n2!=null)n2.parent=par;\n            };\n            {\n                n1.prev=t1;\n                if(t1!=null)t1.parent=n1;\n            };\n            {\n                n1.next=t2;\n                if(t2!=null)t2.parent=n1;\n            };\n            {\n                n2.prev=n1;\n                if(n1!=null)n1.parent=n2;\n            };\n            {\n                n2.next=n3;\n                if(n3!=null)n3.parent=n2;\n            };\n            {\n                n3.prev=t3;\n                if(t3!=null)t3.parent=n3;\n            };\n            {\n                n3.next=t4;\n                if(t4!=null)t4.parent=n3;\n            };\n            n2.colour=g.colour-1;\n            n1.colour=1;\n            n3.colour=1;\n            if(n2==parent)parent.colour=1;\n            else if(n2.colour==0&&n2.parent.colour==0){\n                x=n2;\n                continue;\n            }\n            break;\n        }\n    }\n    public function try_insert_bool(obj:ZPP_SimpleSeg){\n        var x:ZPP_Set_ZPP_SimpleSeg=null;\n        var cur:ZPP_Set_ZPP_SimpleSeg=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_SimpleSeg.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_SimpleSeg();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_TOT++;\n                    ZPP_Set_ZPP_SimpleSeg.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n                    ZPP_Set_ZPP_SimpleSeg.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT--;\n                    ZPP_Set_ZPP_SimpleSeg.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleSeg.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleSeg();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleSeg.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n                                ZPP_Set_ZPP_SimpleSeg.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleSeg.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleSeg.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleSeg();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleSeg.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n                                ZPP_Set_ZPP_SimpleSeg.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleSeg.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return false;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return true;\n        }\n    }\n    public function try_insert(obj:ZPP_SimpleSeg){\n        var x:ZPP_Set_ZPP_SimpleSeg=null;\n        var cur:ZPP_Set_ZPP_SimpleSeg=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_SimpleSeg.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_SimpleSeg();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_TOT++;\n                    ZPP_Set_ZPP_SimpleSeg.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n                    ZPP_Set_ZPP_SimpleSeg.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT--;\n                    ZPP_Set_ZPP_SimpleSeg.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleSeg.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleSeg();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleSeg.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n                                ZPP_Set_ZPP_SimpleSeg.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleSeg.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleSeg.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleSeg();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleSeg.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n                                ZPP_Set_ZPP_SimpleSeg.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleSeg.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return cur;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return x;\n        }\n    }\n    public function insert(obj:ZPP_SimpleSeg){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !has(obj);\n            };\n            if(!res)throw \"assert(\"+\"!has(obj)\"+\") :: \"+(\"object already in set\");\n            #end\n        };\n        var x;\n        {\n            if(ZPP_Set_ZPP_SimpleSeg.zpp_pool==null){\n                x=new ZPP_Set_ZPP_SimpleSeg();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_TOT++;\n                ZPP_Set_ZPP_SimpleSeg.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                x=ZPP_Set_ZPP_SimpleSeg.zpp_pool;\n                ZPP_Set_ZPP_SimpleSeg.zpp_pool=x.next;\n                x.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleSeg.POOL_CNT--;\n                ZPP_Set_ZPP_SimpleSeg.POOL_ADD++;\n                #end\n            }\n            x.alloc();\n        };\n        x.data=obj;\n        if(parent==null)parent=x;\n        else{\n            var cur=parent;\n            while(true){\n                if(lt(x.data,cur.data)){\n                    if(cur.prev==null){\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else{\n                    if(cur.next==null){\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n            }\n        }\n        if(x.parent==null)x.colour=1;\n        else{\n            x.colour=0;\n            if(x.parent.colour==0)__fix_dbl_red(x);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x.data==obj;\n            };\n            if(!res)throw \"assert(\"+\"x.data==obj\"+\") :: \"+(\"...wtf?\");\n            #end\n        };\n        return x;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Set_ZPP_SimpleEvent{\n    static public var zpp_pool:ZPP_Set_ZPP_SimpleEvent=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        data=null;\n        lt=null;\n        swapped=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var lt:ZPP_SimpleEvent->ZPP_SimpleEvent->Bool=null;\n    public var swapped:ZPP_SimpleEvent->ZPP_SimpleEvent->Void=null;\n    public var data:ZPP_SimpleEvent=null;\n    public var prev:ZPP_Set_ZPP_SimpleEvent=null;\n    public var next:ZPP_Set_ZPP_SimpleEvent=null;\n    public var parent:ZPP_Set_ZPP_SimpleEvent=null;\n    public var colour:Int=0;\n    public function new(){}\n    public function verify(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    {\n                        var prei=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    this!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                                #end\n                            };\n                            if(!this.empty()){\n                                var set_ite=this.parent;\n                                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                while(set_ite!=null){\n                                    var j=set_ite.data;\n                                    {\n                                        if(!prei){\n                                            if(!lt(i,j)&&lt(j,i))return false;\n                                        }\n                                        else if(i==j)prei=false;\n                                        else{\n                                            if(!lt(j,i)&&lt(i,j))return false;\n                                        }\n                                    };\n                                    if(set_ite.next!=null){\n                                        set_ite=set_ite.next;\n                                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                    }\n                                    else{\n                                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                                        set_ite=set_ite.parent;\n                                    }\n                                }\n                            }\n                        };\n                    };\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return true;\n    }\n    public function empty(){\n        return parent==null;\n    }\n    public function singular(){\n        return parent!=null&&parent.prev==null&&parent.next==null;\n    }\n    public function size(){\n        var ret=0;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    ret++;\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return ret;\n    }\n    public function has(obj:ZPP_SimpleEvent){\n        return find(obj)!=null;\n    }\n    public function find(obj:ZPP_SimpleEvent){\n        var cur=parent;\n        while(cur!=null&&cur.data!=obj){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else cur=cur.next;\n        }\n        return cur;\n    }\n    public function has_weak(obj:ZPP_SimpleEvent){\n        return find_weak(obj)!=null;\n    }\n    public function find_weak(obj:ZPP_SimpleEvent){\n        var cur=parent;\n        while(cur!=null){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else if(lt(cur.data,obj))cur=cur.next;\n            else break;\n        }\n        return cur;\n    }\n    public function lower_bound(obj:ZPP_SimpleEvent){\n        return{\n            var ret=null;\n            {\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        this!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                    #end\n                };\n                if(!this.empty()){\n                    var set_ite=this.parent;\n                    while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    while(set_ite!=null){\n                        var elt=set_ite.data;\n                        {\n                            if(!lt(elt,obj)){\n                                ret=elt;\n                                break;\n                            }\n                        };\n                        if(set_ite.next!=null){\n                            set_ite=set_ite.next;\n                            while(set_ite.prev!=null)set_ite=set_ite.prev;\n                        }\n                        else{\n                            while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                            set_ite=set_ite.parent;\n                        }\n                    }\n                }\n            };\n            ret;\n        };\n    }\n    public function first(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"first in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        return cur.data;\n    }\n    public function pop_front(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"pop_front in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        var ret=cur.data;\n        remove_node(cur);\n        return ret;\n    }\n    public function remove(obj:ZPP_SimpleEvent){\n        var node=find(obj);\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"object not in tree\");\n            #end\n        };\n        remove_node(node);\n    }\n    public function successor_node(cur:ZPP_Set_ZPP_SimpleEvent){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null){\n            cur=cur.next;\n            while(cur.prev!=null)cur=cur.prev;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.prev!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function predecessor_node(cur:ZPP_Set_ZPP_SimpleEvent){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.prev!=null){\n            cur=cur.prev;\n            while(cur.next!=null)cur=cur.next;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.next!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function successor(obj:ZPP_SimpleEvent){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=successor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function predecessor(obj:ZPP_SimpleEvent){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=predecessor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function remove_node(cur:ZPP_Set_ZPP_SimpleEvent){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null&&cur.prev!=null){\n            var sm=cur.next;\n            while(sm.prev!=null)sm=sm.prev;\n            {\n                var t=cur.data;\n                cur.data=sm.data;\n                sm.data=t;\n            };\n            if(swapped!=null)swapped(cur.data,sm.data);\n            cur=sm;\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur.next==null||cur.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"cur.next==null||cur.prev==null\"+\") :: \"+(\"node still has two children??\");\n            #end\n        };\n        var child=if(cur.prev==null)cur.next else cur.prev;\n        if(cur.colour==1){\n            if(cur.prev!=null||cur.next!=null)child.colour=1;\n            else if(cur.parent!=null){\n                var parent=cur.parent;\n                while(true){\n                    parent.colour++;\n                    parent.prev.colour--;\n                    parent.next.colour--;\n                    {\n                        var child=parent.prev;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    {\n                        var child=parent.next;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(parent.colour==2){\n                        if(parent.parent==null){\n                            parent.colour=1;\n                        }\n                        else{\n                            parent=parent.parent;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        {\n            var par=cur.parent;\n            if(par==null){\n                parent=child;\n            }\n            else if(par.prev==cur)par.prev=child;\n            else par.next=child;\n            if(child!=null)child.parent=par;\n        };\n        cur.parent=cur.prev=cur.next=null;\n        {\n            var o=cur;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_SimpleEvent\"+\", in obj: \"+\"cur\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n            ZPP_Set_ZPP_SimpleEvent.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT++;\n            ZPP_Set_ZPP_SimpleEvent.POOL_SUB++;\n            #end\n        };\n    }\n    public function clear(){\n        clear_with(function(_){});\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function clear_with(lambda:ZPP_SimpleEvent->Void){\n        if(parent==null)return;\n        else{\n            var cur=parent;\n            while(cur!=null)cur=if(cur.prev!=null)cur.prev else if(cur.next!=null)cur.next else clear_node(cur,lambda);\n            parent=null;\n        }\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    function clear_node(node:ZPP_Set_ZPP_SimpleEvent,lambda:ZPP_SimpleEvent->Void){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node.next==null&&node.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"node.next==null&&node.prev==null\"+\") :: \"+(\"clear_node :: node not a leaf\");\n            #end\n        };\n        lambda(node.data);\n        var ret=node.parent;\n        if(ret!=null){\n            if(node==ret.prev)ret.prev=null;\n            else ret.next=null;\n            node.parent=null;\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_SimpleEvent\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n            ZPP_Set_ZPP_SimpleEvent.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT++;\n            ZPP_Set_ZPP_SimpleEvent.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function __fix_neg_red(negred:ZPP_Set_ZPP_SimpleEvent){\n        var parent=negred.parent;\n        var child=if(parent.prev==negred){\n            var nl=negred.prev;\n            var nr=negred.next;\n            var trl=nr.prev;\n            var trr=nr.next;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.next=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.prev=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.next=parent.next;\n                if(parent.next!=null)parent.next.parent=nr;\n            };\n            {\n                parent.next=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        else{\n            var nl=negred.next;\n            var nr=negred.prev;\n            var trl=nr.next;\n            var trr=nr.prev;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.prev=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.next=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.prev=parent.prev;\n                if(parent.prev!=null)parent.prev.parent=nr;\n            };\n            {\n                parent.prev=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        if(child.prev!=null&&child.prev.colour==0)__fix_dbl_red(child.prev);\n        else if(child.next!=null&&child.next.colour==0)__fix_dbl_red(child.next);\n    }\n    public function __fix_dbl_red(x:ZPP_Set_ZPP_SimpleEvent){\n        while(true){\n            var par=x.parent;\n            var g=par.parent;\n            if(g==null){\n                par.colour=1;\n                break;\n            }\n            var n1:ZPP_Set_ZPP_SimpleEvent,n2:ZPP_Set_ZPP_SimpleEvent,n3:ZPP_Set_ZPP_SimpleEvent,t1:ZPP_Set_ZPP_SimpleEvent,t2:ZPP_Set_ZPP_SimpleEvent,t3:ZPP_Set_ZPP_SimpleEvent,t4:ZPP_Set_ZPP_SimpleEvent;\n            if(par==g.prev){\n                n3=g;\n                t4=g.next;\n                if(x==par.prev){\n                    n1=x;\n                    n2=par;\n                    t1=x.prev;\n                    t2=x.next;\n                    t3=par.next;\n                }\n                else{\n                    n1=par;\n                    n2=x;\n                    t1=par.prev;\n                    t2=x.prev;\n                    t3=x.next;\n                }\n            }\n            else{\n                n1=g;\n                t1=g.prev;\n                if(x==par.prev){\n                    n2=x;\n                    n3=par;\n                    t2=x.prev;\n                    t3=x.next;\n                    t4=par.next;\n                }\n                else{\n                    n2=par;\n                    n3=x;\n                    t2=par.prev;\n                    t3=x.prev;\n                    t4=x.next;\n                }\n            }\n            {\n                var par=g.parent;\n                if(par==null){\n                    parent=n2;\n                }\n                else if(par.prev==g)par.prev=n2;\n                else par.next=n2;\n                if(n2!=null)n2.parent=par;\n            };\n            {\n                n1.prev=t1;\n                if(t1!=null)t1.parent=n1;\n            };\n            {\n                n1.next=t2;\n                if(t2!=null)t2.parent=n1;\n            };\n            {\n                n2.prev=n1;\n                if(n1!=null)n1.parent=n2;\n            };\n            {\n                n2.next=n3;\n                if(n3!=null)n3.parent=n2;\n            };\n            {\n                n3.prev=t3;\n                if(t3!=null)t3.parent=n3;\n            };\n            {\n                n3.next=t4;\n                if(t4!=null)t4.parent=n3;\n            };\n            n2.colour=g.colour-1;\n            n1.colour=1;\n            n3.colour=1;\n            if(n2==parent)parent.colour=1;\n            else if(n2.colour==0&&n2.parent.colour==0){\n                x=n2;\n                continue;\n            }\n            break;\n        }\n    }\n    public function try_insert_bool(obj:ZPP_SimpleEvent){\n        var x:ZPP_Set_ZPP_SimpleEvent=null;\n        var cur:ZPP_Set_ZPP_SimpleEvent=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_SimpleEvent.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_SimpleEvent();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_TOT++;\n                    ZPP_Set_ZPP_SimpleEvent.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n                    ZPP_Set_ZPP_SimpleEvent.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT--;\n                    ZPP_Set_ZPP_SimpleEvent.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleEvent.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleEvent();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleEvent.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n                                ZPP_Set_ZPP_SimpleEvent.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleEvent.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleEvent.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleEvent();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleEvent.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n                                ZPP_Set_ZPP_SimpleEvent.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleEvent.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return false;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return true;\n        }\n    }\n    public function try_insert(obj:ZPP_SimpleEvent){\n        var x:ZPP_Set_ZPP_SimpleEvent=null;\n        var cur:ZPP_Set_ZPP_SimpleEvent=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_SimpleEvent.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_SimpleEvent();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_TOT++;\n                    ZPP_Set_ZPP_SimpleEvent.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n                    ZPP_Set_ZPP_SimpleEvent.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT--;\n                    ZPP_Set_ZPP_SimpleEvent.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleEvent.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleEvent();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleEvent.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n                                ZPP_Set_ZPP_SimpleEvent.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleEvent.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_SimpleEvent.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_SimpleEvent();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_TOT++;\n                                ZPP_Set_ZPP_SimpleEvent.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n                                ZPP_Set_ZPP_SimpleEvent.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT--;\n                                ZPP_Set_ZPP_SimpleEvent.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return cur;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return x;\n        }\n    }\n    public function insert(obj:ZPP_SimpleEvent){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !has(obj);\n            };\n            if(!res)throw \"assert(\"+\"!has(obj)\"+\") :: \"+(\"object already in set\");\n            #end\n        };\n        var x;\n        {\n            if(ZPP_Set_ZPP_SimpleEvent.zpp_pool==null){\n                x=new ZPP_Set_ZPP_SimpleEvent();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_TOT++;\n                ZPP_Set_ZPP_SimpleEvent.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                x=ZPP_Set_ZPP_SimpleEvent.zpp_pool;\n                ZPP_Set_ZPP_SimpleEvent.zpp_pool=x.next;\n                x.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_SimpleEvent.POOL_CNT--;\n                ZPP_Set_ZPP_SimpleEvent.POOL_ADD++;\n                #end\n            }\n            x.alloc();\n        };\n        x.data=obj;\n        if(parent==null)parent=x;\n        else{\n            var cur=parent;\n            while(true){\n                if(lt(x.data,cur.data)){\n                    if(cur.prev==null){\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else{\n                    if(cur.next==null){\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n            }\n        }\n        if(x.parent==null)x.colour=1;\n        else{\n            x.colour=0;\n            if(x.parent.colour==0)__fix_dbl_red(x);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x.data==obj;\n            };\n            if(!res)throw \"assert(\"+\"x.data==obj\"+\") :: \"+(\"...wtf?\");\n            #end\n        };\n        return x;\n    }\n}\n#if nape_swc@:keep #end\nclass ZPP_Set_ZPP_CbSet{\n    static public var zpp_pool:ZPP_Set_ZPP_CbSet=null;\n    #if NAPE_POOL_STATS \n    /**\n     * @private\n     */\n    static public var POOL_CNT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_TOT:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADD:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_ADDNEW:Int=0;\n    /**\n     * @private\n     */\n    static public var POOL_SUB:Int=0;\n    #end\n    \n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function free(){\n        data=null;\n        lt=null;\n        swapped=null;\n    }\n    #if NAPE_NO_INLINE#elseif(flash9&&flib)@:ns(\"flibdel\")#end\n    public#if NAPE_NO_INLINE#else inline #end\n    function alloc(){}\n    public var lt:ZPP_CbSet->ZPP_CbSet->Bool=null;\n    public var swapped:ZPP_CbSet->ZPP_CbSet->Void=null;\n    public var data:ZPP_CbSet=null;\n    public var prev:ZPP_Set_ZPP_CbSet=null;\n    public var next:ZPP_Set_ZPP_CbSet=null;\n    public var parent:ZPP_Set_ZPP_CbSet=null;\n    public var colour:Int=0;\n    public function new(){}\n    public function verify(){\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    {\n                        var prei=true;\n                        {\n                            {\n                                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                                var res={\n                                    this!=null;\n                                };\n                                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                                #end\n                            };\n                            if(!this.empty()){\n                                var set_ite=this.parent;\n                                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                while(set_ite!=null){\n                                    var j=set_ite.data;\n                                    {\n                                        if(!prei){\n                                            if(!lt(i,j)&&lt(j,i))return false;\n                                        }\n                                        else if(i==j)prei=false;\n                                        else{\n                                            if(!lt(j,i)&&lt(i,j))return false;\n                                        }\n                                    };\n                                    if(set_ite.next!=null){\n                                        set_ite=set_ite.next;\n                                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                                    }\n                                    else{\n                                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                                        set_ite=set_ite.parent;\n                                    }\n                                }\n                            }\n                        };\n                    };\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return true;\n    }\n    public function empty(){\n        return parent==null;\n    }\n    public function singular(){\n        return parent!=null&&parent.prev==null&&parent.next==null;\n    }\n    public function size(){\n        var ret=0;\n        {\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    this!=null;\n                };\n                if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                #end\n            };\n            if(!this.empty()){\n                var set_ite=this.parent;\n                while(set_ite.prev!=null)set_ite=set_ite.prev;\n                while(set_ite!=null){\n                    var i=set_ite.data;\n                    ret++;\n                    if(set_ite.next!=null){\n                        set_ite=set_ite.next;\n                        while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    }\n                    else{\n                        while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                        set_ite=set_ite.parent;\n                    }\n                }\n            }\n        };\n        return ret;\n    }\n    public function has(obj:ZPP_CbSet){\n        return find(obj)!=null;\n    }\n    public function find(obj:ZPP_CbSet){\n        var cur=parent;\n        while(cur!=null&&cur.data!=obj){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else cur=cur.next;\n        }\n        return cur;\n    }\n    public function has_weak(obj:ZPP_CbSet){\n        return find_weak(obj)!=null;\n    }\n    public function find_weak(obj:ZPP_CbSet){\n        var cur=parent;\n        while(cur!=null){\n            if(lt(obj,cur.data))cur=cur.prev;\n            else if(lt(cur.data,obj))cur=cur.next;\n            else break;\n        }\n        return cur;\n    }\n    public function lower_bound(obj:ZPP_CbSet){\n        return{\n            var ret=null;\n            {\n                {\n                    #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                    var res={\n                        this!=null;\n                    };\n                    if(!res)throw \"assert(\"+\"this!=null\"+\") :: \"+(\"Iterate  null set?\");\n                    #end\n                };\n                if(!this.empty()){\n                    var set_ite=this.parent;\n                    while(set_ite.prev!=null)set_ite=set_ite.prev;\n                    while(set_ite!=null){\n                        var elt=set_ite.data;\n                        {\n                            if(!lt(elt,obj)){\n                                ret=elt;\n                                break;\n                            }\n                        };\n                        if(set_ite.next!=null){\n                            set_ite=set_ite.next;\n                            while(set_ite.prev!=null)set_ite=set_ite.prev;\n                        }\n                        else{\n                            while(set_ite.parent!=null&&set_ite==set_ite.parent.next)set_ite=set_ite.parent;\n                            set_ite=set_ite.parent;\n                        }\n                    }\n                }\n            };\n            ret;\n        };\n    }\n    public function first(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"first in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        return cur.data;\n    }\n    public function pop_front(){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !empty();\n            };\n            if(!res)throw \"assert(\"+\"!empty()\"+\") :: \"+(\"pop_front in empty\");\n            #end\n        };\n        var cur=parent;\n        while(cur.prev!=null)cur=cur.prev;\n        var ret=cur.data;\n        remove_node(cur);\n        return ret;\n    }\n    public function remove(obj:ZPP_CbSet){\n        var node=find(obj);\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node!=null;\n            };\n            if(!res)throw \"assert(\"+\"node!=null\"+\") :: \"+(\"object not in tree\");\n            #end\n        };\n        remove_node(node);\n    }\n    public function successor_node(cur:ZPP_Set_ZPP_CbSet){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null){\n            cur=cur.next;\n            while(cur.prev!=null)cur=cur.prev;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.prev!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function predecessor_node(cur:ZPP_Set_ZPP_CbSet){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.prev!=null){\n            cur=cur.prev;\n            while(cur.next!=null)cur=cur.next;\n        }\n        else{\n            var pre=cur;\n            cur=cur.parent;\n            while(cur!=null&&cur.next!=pre){\n                pre=cur;\n                cur=cur.parent;\n            }\n        }\n        return cur;\n    }\n    public function successor(obj:ZPP_CbSet){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=successor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function predecessor(obj:ZPP_CbSet){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                has(obj);\n            };\n            if(!res)throw \"assert(\"+\"has(obj)\"+\") :: \"+(\"not in tree!\");\n            #end\n        };\n        var node=predecessor_node(find(obj));\n        return node==null?null:node.data;\n    }\n    public function remove_node(cur:ZPP_Set_ZPP_CbSet){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur!=null;\n            };\n            if(!res)throw \"assert(\"+\"cur!=null\"+\") :: \"+(\"null node\");\n            #end\n        };\n        if(cur.next!=null&&cur.prev!=null){\n            var sm=cur.next;\n            while(sm.prev!=null)sm=sm.prev;\n            {\n                var t=cur.data;\n                cur.data=sm.data;\n                sm.data=t;\n            };\n            if(swapped!=null)swapped(cur.data,sm.data);\n            cur=sm;\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                cur.next==null||cur.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"cur.next==null||cur.prev==null\"+\") :: \"+(\"node still has two children??\");\n            #end\n        };\n        var child=if(cur.prev==null)cur.next else cur.prev;\n        if(cur.colour==1){\n            if(cur.prev!=null||cur.next!=null)child.colour=1;\n            else if(cur.parent!=null){\n                var parent=cur.parent;\n                while(true){\n                    parent.colour++;\n                    parent.prev.colour--;\n                    parent.next.colour--;\n                    {\n                        var child=parent.prev;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    {\n                        var child=parent.next;\n                        if(child.colour==(-1)){\n                            __fix_neg_red(child);\n                            break;\n                        }\n                        else if(child.colour==0){\n                            {\n                                if(child.prev!=null&&child.prev.colour==0){\n                                    __fix_dbl_red(child.prev);\n                                    break;\n                                }\n                            }\n                            {\n                                if(child.next!=null&&child.next.colour==0){\n                                    __fix_dbl_red(child.next);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if(parent.colour==2){\n                        if(parent.parent==null){\n                            parent.colour=1;\n                        }\n                        else{\n                            parent=parent.parent;\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        {\n            var par=cur.parent;\n            if(par==null){\n                parent=child;\n            }\n            else if(par.prev==cur)par.prev=child;\n            else par.next=child;\n            if(child!=null)child.parent=par;\n        };\n        cur.parent=cur.prev=cur.next=null;\n        {\n            var o=cur;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_CbSet\"+\", in obj: \"+\"cur\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_CbSet.zpp_pool;\n            ZPP_Set_ZPP_CbSet.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT++;\n            ZPP_Set_ZPP_CbSet.POOL_SUB++;\n            #end\n        };\n    }\n    public function clear(){\n        clear_with(function(_){});\n    }\n    public#if NAPE_NO_INLINE#else inline #end\n    function clear_with(lambda:ZPP_CbSet->Void){\n        if(parent==null)return;\n        else{\n            var cur=parent;\n            while(cur!=null)cur=if(cur.prev!=null)cur.prev else if(cur.next!=null)cur.next else clear_node(cur,lambda);\n            parent=null;\n        }\n    }\n    #if NAPE_NO_INLINE#else inline #end\n    function clear_node(node:ZPP_Set_ZPP_CbSet,lambda:ZPP_CbSet->Void){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                node.next==null&&node.prev==null;\n            };\n            if(!res)throw \"assert(\"+\"node.next==null&&node.prev==null\"+\") :: \"+(\"clear_node :: node not a leaf\");\n            #end\n        };\n        lambda(node.data);\n        var ret=node.parent;\n        if(ret!=null){\n            if(node==ret.prev)ret.prev=null;\n            else ret.next=null;\n            node.parent=null;\n        }\n        {\n            var o=node;\n            {\n                #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n                var res={\n                    o!=null;\n                };\n                if(!res)throw \"assert(\"+\"o!=null\"+\") :: \"+(\"Free(in T: \"+\"ZPP_Set_ZPP_CbSet\"+\", in obj: \"+\"node\"+\")\");\n                #end\n            };\n            o.free();\n            o.next=ZPP_Set_ZPP_CbSet.zpp_pool;\n            ZPP_Set_ZPP_CbSet.zpp_pool=o;\n            #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT++;\n            ZPP_Set_ZPP_CbSet.POOL_SUB++;\n            #end\n        };\n        return ret;\n    }\n    public function __fix_neg_red(negred:ZPP_Set_ZPP_CbSet){\n        var parent=negred.parent;\n        var child=if(parent.prev==negred){\n            var nl=negred.prev;\n            var nr=negred.next;\n            var trl=nr.prev;\n            var trr=nr.next;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.next=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.prev=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.next=parent.next;\n                if(parent.next!=null)parent.next.parent=nr;\n            };\n            {\n                parent.next=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        else{\n            var nl=negred.next;\n            var nr=negred.prev;\n            var trl=nr.next;\n            var trr=nr.prev;\n            nl.colour=0;\n            negred.colour=parent.colour=1;\n            {\n                negred.prev=trl;\n                if(trl!=null)trl.parent=negred;\n            };\n            {\n                var t=parent.data;\n                parent.data=nr.data;\n                nr.data=t;\n            };\n            if(swapped!=null)swapped(parent.data,nr.data);\n            {\n                nr.next=trr;\n                if(trr!=null)trr.parent=nr;\n            };\n            {\n                nr.prev=parent.prev;\n                if(parent.prev!=null)parent.prev.parent=nr;\n            };\n            {\n                parent.prev=nr;\n                if(nr!=null)nr.parent=parent;\n            };\n            nl;\n        };\n        if(child.prev!=null&&child.prev.colour==0)__fix_dbl_red(child.prev);\n        else if(child.next!=null&&child.next.colour==0)__fix_dbl_red(child.next);\n    }\n    public function __fix_dbl_red(x:ZPP_Set_ZPP_CbSet){\n        while(true){\n            var par=x.parent;\n            var g=par.parent;\n            if(g==null){\n                par.colour=1;\n                break;\n            }\n            var n1:ZPP_Set_ZPP_CbSet,n2:ZPP_Set_ZPP_CbSet,n3:ZPP_Set_ZPP_CbSet,t1:ZPP_Set_ZPP_CbSet,t2:ZPP_Set_ZPP_CbSet,t3:ZPP_Set_ZPP_CbSet,t4:ZPP_Set_ZPP_CbSet;\n            if(par==g.prev){\n                n3=g;\n                t4=g.next;\n                if(x==par.prev){\n                    n1=x;\n                    n2=par;\n                    t1=x.prev;\n                    t2=x.next;\n                    t3=par.next;\n                }\n                else{\n                    n1=par;\n                    n2=x;\n                    t1=par.prev;\n                    t2=x.prev;\n                    t3=x.next;\n                }\n            }\n            else{\n                n1=g;\n                t1=g.prev;\n                if(x==par.prev){\n                    n2=x;\n                    n3=par;\n                    t2=x.prev;\n                    t3=x.next;\n                    t4=par.next;\n                }\n                else{\n                    n2=par;\n                    n3=x;\n                    t2=par.prev;\n                    t3=x.prev;\n                    t4=x.next;\n                }\n            }\n            {\n                var par=g.parent;\n                if(par==null){\n                    parent=n2;\n                }\n                else if(par.prev==g)par.prev=n2;\n                else par.next=n2;\n                if(n2!=null)n2.parent=par;\n            };\n            {\n                n1.prev=t1;\n                if(t1!=null)t1.parent=n1;\n            };\n            {\n                n1.next=t2;\n                if(t2!=null)t2.parent=n1;\n            };\n            {\n                n2.prev=n1;\n                if(n1!=null)n1.parent=n2;\n            };\n            {\n                n2.next=n3;\n                if(n3!=null)n3.parent=n2;\n            };\n            {\n                n3.prev=t3;\n                if(t3!=null)t3.parent=n3;\n            };\n            {\n                n3.next=t4;\n                if(t4!=null)t4.parent=n3;\n            };\n            n2.colour=g.colour-1;\n            n1.colour=1;\n            n3.colour=1;\n            if(n2==parent)parent.colour=1;\n            else if(n2.colour==0&&n2.parent.colour==0){\n                x=n2;\n                continue;\n            }\n            break;\n        }\n    }\n    public function try_insert_bool(obj:ZPP_CbSet){\n        var x:ZPP_Set_ZPP_CbSet=null;\n        var cur:ZPP_Set_ZPP_CbSet=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_CbSet.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_CbSet();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_TOT++;\n                    ZPP_Set_ZPP_CbSet.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_CbSet.zpp_pool;\n                    ZPP_Set_ZPP_CbSet.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT--;\n                    ZPP_Set_ZPP_CbSet.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_CbSet.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_CbSet();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_TOT++;\n                                ZPP_Set_ZPP_CbSet.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_CbSet.zpp_pool;\n                                ZPP_Set_ZPP_CbSet.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT--;\n                                ZPP_Set_ZPP_CbSet.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_CbSet.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_CbSet();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_TOT++;\n                                ZPP_Set_ZPP_CbSet.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_CbSet.zpp_pool;\n                                ZPP_Set_ZPP_CbSet.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT--;\n                                ZPP_Set_ZPP_CbSet.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return false;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return true;\n        }\n    }\n    public function try_insert(obj:ZPP_CbSet){\n        var x:ZPP_Set_ZPP_CbSet=null;\n        var cur:ZPP_Set_ZPP_CbSet=null;\n        if(parent==null){\n            {\n                if(ZPP_Set_ZPP_CbSet.zpp_pool==null){\n                    x=new ZPP_Set_ZPP_CbSet();\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_TOT++;\n                    ZPP_Set_ZPP_CbSet.POOL_ADDNEW++;\n                    #end\n                }\n                else{\n                    x=ZPP_Set_ZPP_CbSet.zpp_pool;\n                    ZPP_Set_ZPP_CbSet.zpp_pool=x.next;\n                    x.next=null;\n                    #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT--;\n                    ZPP_Set_ZPP_CbSet.POOL_ADD++;\n                    #end\n                }\n                x.alloc();\n            };\n            x.data=obj;\n            parent=x;\n        }\n        else{\n            cur=parent;\n            while(true){\n                if(lt(obj,cur.data)){\n                    if(cur.prev==null){\n                        {\n                            if(ZPP_Set_ZPP_CbSet.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_CbSet();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_TOT++;\n                                ZPP_Set_ZPP_CbSet.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_CbSet.zpp_pool;\n                                ZPP_Set_ZPP_CbSet.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT--;\n                                ZPP_Set_ZPP_CbSet.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else if(lt(cur.data,obj)){\n                    if(cur.next==null){\n                        {\n                            if(ZPP_Set_ZPP_CbSet.zpp_pool==null){\n                                x=new ZPP_Set_ZPP_CbSet();\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_TOT++;\n                                ZPP_Set_ZPP_CbSet.POOL_ADDNEW++;\n                                #end\n                            }\n                            else{\n                                x=ZPP_Set_ZPP_CbSet.zpp_pool;\n                                ZPP_Set_ZPP_CbSet.zpp_pool=x.next;\n                                x.next=null;\n                                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT--;\n                                ZPP_Set_ZPP_CbSet.POOL_ADD++;\n                                #end\n                            }\n                            x.alloc();\n                        };\n                        x.data=obj;\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n                else break;\n            }\n        }\n        if(x==null)return cur;\n        else{\n            if(x.parent==null)x.colour=1;\n            else{\n                x.colour=0;\n                if(x.parent.colour==0)__fix_dbl_red(x);\n            }\n            return x;\n        }\n    }\n    public function insert(obj:ZPP_CbSet){\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                !has(obj);\n            };\n            if(!res)throw \"assert(\"+\"!has(obj)\"+\") :: \"+(\"object already in set\");\n            #end\n        };\n        var x;\n        {\n            if(ZPP_Set_ZPP_CbSet.zpp_pool==null){\n                x=new ZPP_Set_ZPP_CbSet();\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_TOT++;\n                ZPP_Set_ZPP_CbSet.POOL_ADDNEW++;\n                #end\n            }\n            else{\n                x=ZPP_Set_ZPP_CbSet.zpp_pool;\n                ZPP_Set_ZPP_CbSet.zpp_pool=x.next;\n                x.next=null;\n                #if NAPE_POOL_STATS ZPP_Set_ZPP_CbSet.POOL_CNT--;\n                ZPP_Set_ZPP_CbSet.POOL_ADD++;\n                #end\n            }\n            x.alloc();\n        };\n        x.data=obj;\n        if(parent==null)parent=x;\n        else{\n            var cur=parent;\n            while(true){\n                if(lt(x.data,cur.data)){\n                    if(cur.prev==null){\n                        cur.prev=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.prev;\n                }\n                else{\n                    if(cur.next==null){\n                        cur.next=x;\n                        x.parent=cur;\n                        break;\n                    }\n                    else cur=cur.next;\n                }\n            }\n        }\n        if(x.parent==null)x.colour=1;\n        else{\n            x.colour=0;\n            if(x.parent.colour==0)__fix_dbl_red(x);\n        }\n        {\n            #if(NAPE_ASSERT&&!NAPE_RELEASE_BUILD)\n            var res={\n                x.data==obj;\n            };\n            if(!res)throw \"assert(\"+\"x.data==obj\"+\") :: \"+(\"...wtf?\");\n            #end\n        };\n        return x;\n    }\n}\n","package nape;\n/**\n * Configuration parameters for Nape\n */\n@:final class Config{\n    /**\n     * @private\n     */\n    function new(){}\n    /**\n     * Generic epsilon value for float comparisons\n     * <br/><br/>\n     * @default 1e-8\n     */\n    public static var epsilon:Float=1e-8;\n    /**\n     * Parameter used in computing shape fluid angular drag coeffecient.\n     * <br/><br/>\n     * Defines the contribution to the drag coeffecient due to Material dynamicFriction\n     * <br/><br/>\n     * This global value must be set as the very first thing to ensure all Shapes\n     * use your intended value.\n     * <br/><br/>\n     * This parameter has units kg/px\n     * @default 2.5 kg/px\n     */\n    public static var fluidAngularDragFriction:Float=2.5;\n    /**\n     * Parameter used in computing shape fluid angular drag coeffecient.\n     * <br/><br/>\n     * Defines the contribution to the drag coeffecient due to shape's surface\n     * area rotating into a fluid.\n     * <br/><br/>\n     * This global value must be set as the very first thing to ensure all Shapes\n     * use your intended value.\n     * <br/><br/>\n     * This parameter has units kg/px\n     * @default 100kg/px\n     */\n    public static var fluidAngularDrag:Float=100;\n    /**\n     * Parameter used in computing fluid drags.\n     * <br/><br/>\n     * Defines an added weight for scaling the contribution of forward drag due\n     * to leaving a vaccuum behind the shape pulling it back.\n     * <br/><br/>\n     * This global value must be set as the very first thing to ensure all Shapes\n     * use your intended value.\n     * <br/><br/>\n     * This parameter has no units.\n     * @default 0.5\n     */\n    public static var fluidVacuumDrag:Float=0.5;\n    /**\n     * Parameter used in computing shapes linear drag in fluid.\n     * <br/><br/>\n     * Used in determining the amount of linear drag for the shape based on forward profile.\n     * <br/><br/>\n     * This parameter has units kg/px\n     * @default 0.5kg/px\n     */\n    public static var fluidLinearDrag:Float=0.5;\n    /**\n     * Amount of overlap permitted between Shapes for collisions.\n     * <br/><br/>\n     * This parameter has units of pixels.\n     * @default 0.2px\n     */\n    public static var collisionSlop:Float=0.2;\n    /**\n     * Amount of overlap permitted between Shapes before CCD kicks in.\n     * <br/><br/>\n     * This parameter has units of pixels, and should always be larger\n     * than collisionSlop parameter.\n     * @default 0.5px\n     */\n    public static var collisionSlopCCD:Float=0.5;\n    /**\n     * Biased distance treshold for CCD collisions.\n     * <br/><br/>\n     * In CCD collision routines, two Shapes will be considered intersecting\n     * when the distance between them + collisionSlopCCD falls below this\n     * value.\n     * <br/><br/>\n     * This parameter has units of pixels, and should always be > 0\n     * @default 0.05px\n     */\n    public static var distanceThresholdCCD:Float=0.05;\n    /**\n     * Linear sweep threshold-ratio for static CCD collisions\n     * <br/><br/>\n     * In deciding what non-bullet objects should be collided continuously against\n     * static/kinematic objects, the linear speed of the body is considered.\n     * <code>\n     * ccdCollide if: bodyLinearSpeed * deltaTime > threshold * bodyRadius\n     * </code>\n     * Intuitively, a value of 0.5 would mean that a body, in the worst case scenario\n     * will be permitted to move half of its width in a single time step, before CCD\n     * is enabled for this reason.\n     * <br/><br/>\n     * This parameter has no units.\n     * @default 0.05\n     */\n    public static var staticCCDLinearThreshold:Float=0.05;\n    /**\n     * Angular sweep threshold for static CCD collisions\n     * <br><br/>\n     * In deciding what non-bullet objects should be collided continuously against\n     * static/kinematic objects, the angular speed of the body is considered.\n     * <code>\n     * ccdCollide if: bodyAngularSpeed * deltaTime > threshold\n     * </code>\n     * Intuitively, a value of 0.5 would mean that a body would have to rotate more than\n     * 0.5 radians in a single time step, before CCD is enabled for this reason. Noting that\n     * at 60fps physics, the body would need an angularVel greater than 30rad/s for this\n     * limit of 0.5 to be reached; the default is far smaller.\n     * <br/><br/>\n     * This parameter has units of rad.\n     * @default 0.005rad\n     */\n    public static var staticCCDAngularThreshold:Float=0.005;\n    /**\n     * Linear sweep threshold-ratio for bullet CCD collisions\n     * <br/><br/>\n     * A dynamic body marked as a bullet, will not necessarigly always be collided\n     * with continuously.\n     * <br/><br/>\n     * Should a body be moving, or rotating fast enough to pass the tests determined\n     * by staticCCD#Threshold parameters, and is marked as a bullet, it must then\n     * have its velocities checked against the equivalent bullet thresholds to actually\n     * be collided continuously against other dynamic bodies too.\n     * <br/><br/>\n     * This parameter has no units.\n     * @default 0.125\n     */\n    public static var bulletCCDLinearThreshold:Float=0.125;\n    /**\n     * Angular sweep threshold for bullet CCD collisions.\n     * <br/><br/>\n     * See description of bulletCCDLinearThreshold.\n     * <br/><br/>\n     * This parameter has units of rad.\n     * @default 0.0125rad\n     */\n    public static var bulletCCDAngularThreshold:Float=0.0125;\n    /**\n     * Relative linear threshold for dynamic-dynamic sweeps.\n     * <br/><br/>\n     * When performing dynamic-dynamic sweep of Body shapes during CCD collision phase,\n     * should the relative velocity of the bodies fall beneath this magnitude, they\n     * may be considered (based on angular velocities also) to be moving together, and\n     * this specific CCD test will be skipped.\n     * <br/><br/>\n     * This parameter has units of px/s\n     * @default 17px/s\n     */\n    public static var dynamicSweepLinearThreshold:Float=17;\n    /**\n     * Relative angular bias threshold for dynamic-dynamic sweeps.\n     * <br/><br/>\n     * When performing dynamic-dynamic sweep of Body shapes during CCD collision phase,\n     * should the relative angular velocity (weighted by the shape bias values) fall\n     * beneath this magnitude, they may be considered (based on linear velocities also) to\n     * be moving together, and this specific CCD test will be skipped.\n     * <br/><br/>\n     * The shape bias, is an internal value which indicates the 'amount of radius' of\n     * a shape about the centre of rotation that can be considered to change under rotations.\n     * eg: A circle at origin has a bias of 0 (Its rotation has no effect on sweeps)\n     * whilst A circle far from the origin may have a large bias.\n     * <br/><br/>\n     * This parameter has units of px.rad/s\n     * @default 0.6px.rad/s\n     */\n    public static var dynamicSweepAngularThreshold:Float=0.6;\n    /**\n     * Angular velocity scaling during CCD slips.\n     * <br/><br/>\n     * In rare cases, a Body can be moving in such a way that we fail to compute a perfect\n     * time of impact; generally when a thin box-like object is rotating very quickly. The\n     * time of impact solver in Nape attempts to avoid impacts which are seperating; so that\n     * we can catch true impact times; but in a 'slip' case we are unable to achieve this and\n     * to avoid a possible tunneling from the other side during later operations we will in\n     * these rare cases scale down the angular velocity of a Body by this parameter.\n     * <br/><br/>\n     * This parameter has no units.\n     * @default 0.75\n     */\n    public static var angularCCDSlipScale:Float=0.75;\n    /**\n     * Expiration delay length for collision arbiter destruction.\n     * <br/><br/>\n     * In unstable physics conditions, two colliding shapes may jitter such as to constantly\n     * seperate, and then come back together again. This parameter controls the number of time\n     * steps during which we will delay this destruction so that cached impulse values may\n     * persist and improve stability of strenuous simulations.\n     * <br/><br/>\n     * This parameter has units of 'steps' I suppose.\n     * @default 6steps\n     */\n    public static var arbiterExpirationDelay:Int=6;\n    /**\n     * Contact velocity threshold for static-dynamic friction\n     * <br/><br/>\n     * This is the threshold on projected contact velocities at which Nape will use\n     * dynamic friction Mateiral values, in place of static friction Material values.\n     * <br/><br/>\n     * This parameter has units of px/s\n     * @default 2px/s\n     */\n    public static var staticFrictionThreshold:Float=2;\n    /**\n     * Contact velocity threshold for elastic collisions\n     * <br/><br/>\n     * This is the threshold on weighted projected normal-contact velocities at which Nape will\n     * decide to stop using elastic collisions. Nape will take the normal velocities at contact\n     * and scale by the combined elasticity coeffecient for the Arbiter, if this value falls\n     * below the threshold, then elasticity is ignored for stability in stacking.\n     * <br/><br/>\n     * This parameter has units of px/s\n     * @default 20px/s\n     */\n    public static var elasticThreshold:Float=20;\n    /**\n     * Sleep delay for stationary bodies.\n     * <br/><br/>\n     * By default, Nape considers a body to be stationary even if it has a very small linear\n     * or angular velocity. This parameter controls how many steps such a Body will continue\n     * to be simulated for, before being put to sleep (Assuming everything else in the island\n     * is also stationary for a sufficiently long time).\n     * <br/><br/>\n     * This parameter has units of 'steps' I suppose.\n     * @default 60steps\n     */\n    public static var sleepDelay:Int=60;\n    /**\n     * Linear speed threshold for sleeping of Bodies.\n     * <br/><br/>\n     * A body in Nape will be considered stationary only if its linear velocity has magnitude\n     * under this threshold.\n     * <br/><br/>\n     * This parameter has units of px/s\n     * @default 0.2px/s\n     */\n    public static var linearSleepThreshold:Float=0.2;\n    /**\n     * Angular speed threshold for sleeping of Bodies.\n     * <br/><br/>\n     * A body in Nape will be considered stationary only if its angular velocity, multiplied\n     * by the body radius (never under-estimated) about the origin, falls below this threshold.\n     * <br/><br/>\n     * The body radius scaling, ensures that a very large body needs to be rotating more slowly\n     * to be considered stationary than a very small body. Intuitively we're designating this\n     * a threshold on the maximum tangentenial velocity of the body due to rotation.\n     * <br/><br/>\n     * This parameter has units of px.rad/s\n     * @default 0.4px.rad/s\n     */\n    public static var angularSleepThreshold:Float=0.4;\n    /**\n     * Fraction of contact slop resolved per-step for dynamic-dynamic discrete collisions.\n     * <br/><br/>\n     * This value determines, in the case of two non-continuously colliding dynamic objects\n     * the fraction of the contact overlap that will attempt to be resolved during positional\n     * iterations.\n     * <br/><br/>\n     * This parameter has units of 1/'step' I suppose.\n     * @default 0.3/step\n     */\n    public static var contactBiasCoef:Float=0.3;\n    /**\n     * Fraction of contact slop resolved per-step for static/kinematic discrete collisions.\n     * <br/><br/>\n     * See description of contactBiasCoef; this is the coeffecient for non-continuous collisions\n     * between a dynamic, and a static or kinematic object.\n     * <br/><br/>\n     * This parameter has units of 1/'step' I suppose.\n     * @default 0.6/step\n     */\n    public static var contactStaticBiasCoef:Float=0.6;\n    /**\n     * Fraction of contact slop resolved per-step for dynamic-dynamic continuous collisions.\n     * <br/><br/>\n     * See description of contactBiasCoef; this is the coeffecient for continuous collisions\n     * between two dynamic bodies.\n     * <br/><br/>\n     * This parameter has units of 1/'step' I suppose.\n     * @default 0.4/step\n     */\n    public static var contactContinuousBiasCoef:Float=0.4;\n    /**\n     * Fraction of contact slop resolved per-step for static/kinematic continuous collisions.\n     * <br/><br/>\n     * See description of contactBiasCoef; this is the coeffecient for continuous collisions\n     * between a dynamic, and a static or kinematic object.\n     * <br/><br/>\n     * This parameter has units of 1/'step' I suppose.\n     * @default 0.5/step\n     */\n    public static var contactContinuousStaticBiasCoef:Float=0.5;\n    /**\n     * Amount of linear slop permitted in constraints.\n     * <br/><br/>\n     * A constraint will be considered to be 'relaxed' during positional iterations\n     * only if the linear error falls below this threshold.\n     * <br/><br/>\n     * Assuming a 'sensible' constraint, this has units of px\n     * @default 0.1px\n     */\n    public static var constraintLinearSlop:Float=0.1;\n    /**\n     * Amount of angular slop permitted in constraints.\n     * <br/><br/>\n     * A constraint will be considered to be 'relaxed' during positional iterations\n     * only if the angular error falls below this threshold.\n     * <br/><br/>\n     * Assuming a 'sensible' constraint, this has units of rad\n     * @default 1e-3rad\n     */\n    public static var constraintAngularSlop:Float=1e-3;\n    /**\n     * Ill-conditioned threshold for 2-contact collision constraints.\n     * <br/><br/>\n     * This is a threshold on the measure of ill-conditioning of the effective-mass-matrix\n     * in a 2-contact collision at which the contact manifold will be forced into a 1-contact\n     * constraint. This can occur quite readily when two contact points are almost exactly equal\n     * or in certain other conditions where the mathematics quite simply breaks down when using\n     * a block solver.\n     * <br/><br/>\n     * This parameter has no units.\n     * @default 2e+8\n     */\n    public static var illConditionedThreshold:Float=2e+8;\n}\n","package zpp_nape.util;\nimport zpp_nape.Const;\nimport zpp_nape.ID;\nimport zpp_nape.constraint.PivotJoint;\nimport zpp_nape.constraint.Constraint;\nimport zpp_nape.constraint.WeldJoint;\nimport zpp_nape.constraint.DistanceJoint;\nimport zpp_nape.constraint.UserConstraint;\nimport zpp_nape.constraint.LineJoint;\nimport zpp_nape.constraint.LinearJoint;\nimport zpp_nape.constraint.MotorJoint;\nimport zpp_nape.constraint.AngleJoint;\nimport zpp_nape.phys.Interactor;\nimport zpp_nape.phys.FeatureMix;\nimport zpp_nape.phys.Material;\nimport zpp_nape.constraint.PulleyJoint;\nimport zpp_nape.phys.FluidProperties;\nimport zpp_nape.phys.Compound;\nimport zpp_nape.callbacks.OptionType;\nimport zpp_nape.callbacks.CbSetPair;\nimport zpp_nape.callbacks.CbType;\nimport zpp_nape.phys.Body;\nimport zpp_nape.callbacks.CbSet;\nimport zpp_nape.callbacks.Callback;\nimport zpp_nape.geom.GeomPoly;\nimport zpp_nape.callbacks.Listener;\nimport zpp_nape.geom.Mat23;\nimport zpp_nape.geom.ConvexRayResult;\nimport zpp_nape.geom.Cutter;\nimport zpp_nape.geom.Ray;\nimport zpp_nape.geom.Vec2;\nimport zpp_nape.geom.Convex;\nimport zpp_nape.geom.MatMath;\nimport zpp_nape.geom.PartitionedPoly;\nimport zpp_nape.geom.Triangular;\nimport zpp_nape.geom.Simplify;\nimport zpp_nape.geom.AABB;\nimport zpp_nape.geom.SweepDistance;\nimport zpp_nape.geom.Simple;\nimport zpp_nape.geom.Monotone;\nimport zpp_nape.geom.VecMath;\nimport zpp_nape.geom.Vec3;\nimport zpp_nape.geom.MatMN;\nimport zpp_nape.geom.PolyIter;\nimport zpp_nape.geom.MarchingSquares;\nimport zpp_nape.geom.Geom;\nimport zpp_nape.shape.Circle;\nimport zpp_nape.geom.Collide;\nimport zpp_nape.shape.Shape;\nimport zpp_nape.shape.Edge;\nimport zpp_nape.space.Broadphase;\nimport zpp_nape.shape.Polygon;\nimport zpp_nape.space.SweepPhase;\nimport zpp_nape.space.DynAABBPhase;\nimport zpp_nape.dynamics.Contact;\nimport zpp_nape.space.Space;\nimport zpp_nape.dynamics.InteractionGroup;\nimport zpp_nape.dynamics.InteractionFilter;\nimport zpp_nape.dynamics.SpaceArbiterList;\nimport zpp_nape.dynamics.Arbiter;\nimport zpp_nape.util.Array2;\nimport zpp_nape.util.Lists;\nimport zpp_nape.util.Queue;\nimport zpp_nape.util.Debug;\nimport zpp_nape.util.RBTree;\nimport zpp_nape.util.FastHash;\nimport zpp_nape.util.Pool;\nimport zpp_nape.util.Names;\nimport zpp_nape.util.Circular;\nimport zpp_nape.util.WrapLists;\nimport zpp_nape.util.UserData;\nimport zpp_nape.util.Math;\nimport nape.TArray;\nimport zpp_nape.util.DisjointSetForest;\nimport nape.Config;\nimport nape.constraint.PivotJoint;\nimport nape.constraint.WeldJoint;\nimport nape.constraint.Constraint;\nimport nape.constraint.UserConstraint;\nimport nape.constraint.DistanceJoint;\nimport nape.constraint.LineJoint;\nimport nape.constraint.LinearJoint;\nimport nape.constraint.ConstraintList;\nimport nape.constraint.AngleJoint;\nimport nape.constraint.MotorJoint;\nimport nape.constraint.ConstraintIterator;\nimport nape.phys.GravMassMode;\nimport nape.phys.BodyList;\nimport nape.phys.Interactor;\nimport nape.phys.InertiaMode;\nimport nape.phys.InteractorList;\nimport nape.constraint.PulleyJoint;\nimport nape.phys.MassMode;\nimport nape.phys.Material;\nimport nape.phys.InteractorIterator;\nimport nape.phys.FluidProperties;\nimport nape.phys.BodyIterator;\nimport nape.phys.Compound;\nimport nape.phys.CompoundList;\nimport nape.phys.BodyType;\nimport nape.phys.CompoundIterator;\nimport nape.callbacks.InteractionListener;\nimport nape.callbacks.OptionType;\nimport nape.callbacks.PreListener;\nimport nape.callbacks.BodyListener;\nimport nape.callbacks.ListenerIterator;\nimport nape.callbacks.CbType;\nimport nape.callbacks.ListenerType;\nimport nape.callbacks.PreFlag;\nimport nape.callbacks.CbEvent;\nimport nape.callbacks.InteractionType;\nimport nape.callbacks.PreCallback;\nimport nape.callbacks.InteractionCallback;\nimport nape.callbacks.ListenerList;\nimport nape.callbacks.ConstraintListener;\nimport nape.callbacks.BodyCallback;\nimport nape.callbacks.CbTypeList;\nimport nape.callbacks.Callback;\nimport nape.phys.Body;\nimport nape.callbacks.CbTypeIterator;\nimport nape.callbacks.ConstraintCallback;\nimport nape.callbacks.Listener;\nimport nape.geom.Mat23;\nimport nape.geom.ConvexResultIterator;\nimport nape.geom.Ray;\nimport nape.geom.GeomPoly;\nimport nape.geom.GeomPolyIterator;\nimport nape.geom.Vec2Iterator;\nimport nape.geom.RayResult;\nimport nape.geom.Winding;\nimport nape.geom.Vec2List;\nimport nape.geom.RayResultIterator;\nimport nape.geom.AABB;\nimport nape.geom.IsoFunction;\nimport nape.geom.GeomVertexIterator;\nimport nape.geom.ConvexResult;\nimport nape.geom.GeomPolyList;\nimport nape.geom.Vec2;\nimport nape.geom.RayResultList;\nimport nape.geom.Vec3;\nimport nape.geom.MatMN;\nimport nape.geom.ConvexResultList;\nimport nape.geom.MarchingSquares;\nimport nape.shape.Circle;\nimport nape.shape.ValidationResult;\nimport nape.geom.Geom;\nimport nape.shape.ShapeIterator;\nimport nape.shape.Polygon;\nimport nape.shape.Shape;\nimport nape.shape.Edge;\nimport nape.shape.EdgeList;\nimport nape.shape.ShapeList;\nimport nape.shape.EdgeIterator;\nimport nape.shape.ShapeType;\nimport nape.space.Broadphase;\nimport nape.dynamics.Contact;\nimport nape.dynamics.InteractionGroupList;\nimport nape.dynamics.Arbiter;\nimport nape.dynamics.InteractionGroup;\nimport nape.space.Space;\nimport nape.dynamics.ContactIterator;\nimport nape.dynamics.ArbiterList;\nimport nape.dynamics.InteractionFilter;\nimport nape.dynamics.ArbiterIterator;\nimport nape.dynamics.InteractionGroupIterator;\nimport nape.dynamics.FluidArbiter;\nimport nape.dynamics.ContactList;\nimport nape.dynamics.CollisionArbiter;\nimport nape.dynamics.ArbiterType;\nimport nape.util.Debug;\nimport nape.util.BitmapDebug;\nimport nape.util.ShapeDebug;\n#if nape_swc@:keep #end\nclass ZPP_Flags{\n    public static var internal:Bool=false;\n    \n    public static var id_ImmState_ACCEPT=1;\n    public static var id_ImmState_IGNORE=2;\n    public static var id_ImmState_ALWAYS=4;\n    public static var id_GravMassMode_DEFAULT=0;\n    public static var id_GravMassMode_FIXED=1;\n    public static var id_GravMassMode_SCALED=2;\n    public static var id_InertiaMode_DEFAULT=0;\n    public static var id_InertiaMode_FIXED=1;\n    public static var id_MassMode_DEFAULT=0;\n    public static var id_MassMode_FIXED=1;\n    public static var id_BodyType_STATIC=1;\n    public static var id_BodyType_DYNAMIC=2;\n    public static var id_BodyType_KINEMATIC=3;\n    public static var id_ListenerType_BODY=0;\n    public static var id_ListenerType_CONSTRAINT=1;\n    public static var id_PreFlag_ACCEPT=1;\n    public static var id_ListenerType_INTERACTION=2;\n    public static var id_PreFlag_IGNORE=2;\n    public static var id_ListenerType_PRE=3;\n    public static var id_PreFlag_ACCEPT_ONCE=3;\n    public static var id_PreFlag_IGNORE_ONCE=4;\n    public static var id_CbEvent_BEGIN=0;\n    public static var id_CbEvent_ONGOING=6;\n    public static var id_InteractionType_COLLISION=1;\n    public static var id_CbEvent_END=1;\n    public static var id_InteractionType_SENSOR=2;\n    public static var id_CbEvent_WAKE=2;\n    public static var id_InteractionType_FLUID=4;\n    public static var id_CbEvent_SLEEP=3;\n    public static var id_InteractionType_ANY=7;\n    public static var id_CbEvent_BREAK=4;\n    public static var id_CbEvent_PRE=5;\n    public static var id_Winding_UNDEFINED=0;\n    public static var id_Winding_CLOCKWISE=1;\n    public static var id_Winding_ANTICLOCKWISE=2;\n    public static var id_ValidationResult_VALID=0;\n    public static var id_ValidationResult_DEGENERATE=1;\n    public static var id_ValidationResult_CONCAVE=2;\n    public static var id_ValidationResult_SELF_INTERSECTING=3;\n    public static var id_ShapeType_CIRCLE=0;\n    public static var id_ShapeType_POLYGON=1;\n    public static var id_Broadphase_DYNAMIC_AABB_TREE=0;\n    public static var id_Broadphase_SWEEP_AND_PRUNE=1;\n    public static var id_ArbiterType_COLLISION=1;\n    public static var id_ArbiterType_SENSOR=2;\n    public static var id_ArbiterType_FLUID=4;\n    \n    public static var GravMassMode_DEFAULT:GravMassMode;\n    public static var GravMassMode_FIXED:GravMassMode;\n    public static var GravMassMode_SCALED:GravMassMode;\n    public static var InertiaMode_DEFAULT:InertiaMode;\n    public static var InertiaMode_FIXED:InertiaMode;\n    public static var MassMode_DEFAULT:MassMode;\n    public static var MassMode_FIXED:MassMode;\n    public static var BodyType_STATIC:BodyType;\n    public static var BodyType_DYNAMIC:BodyType;\n    public static var BodyType_KINEMATIC:BodyType;\n    public static var ListenerType_BODY:ListenerType;\n    public static var ListenerType_CONSTRAINT:ListenerType;\n    public static var PreFlag_ACCEPT:PreFlag;\n    public static var ListenerType_INTERACTION:ListenerType;\n    public static var PreFlag_IGNORE:PreFlag;\n    public static var ListenerType_PRE:ListenerType;\n    public static var PreFlag_ACCEPT_ONCE:PreFlag;\n    public static var PreFlag_IGNORE_ONCE:PreFlag;\n    public static var CbEvent_BEGIN:CbEvent;\n    public static var CbEvent_ONGOING:CbEvent;\n    public static var InteractionType_COLLISION:InteractionType;\n    public static var CbEvent_END:CbEvent;\n    public static var InteractionType_SENSOR:InteractionType;\n    public static var CbEvent_WAKE:CbEvent;\n    public static var InteractionType_FLUID:InteractionType;\n    public static var CbEvent_SLEEP:CbEvent;\n    public static var InteractionType_ANY:InteractionType;\n    public static var CbEvent_BREAK:CbEvent;\n    public static var CbEvent_PRE:CbEvent;\n    public static var Winding_UNDEFINED:Winding;\n    public static var Winding_CLOCKWISE:Winding;\n    public static var Winding_ANTICLOCKWISE:Winding;\n    public static var ValidationResult_VALID:ValidationResult;\n    public static var ValidationResult_DEGENERATE:ValidationResult;\n    public static var ValidationResult_CONCAVE:ValidationResult;\n    public static var ValidationResult_SELF_INTERSECTING:ValidationResult;\n    public static var ShapeType_CIRCLE:ShapeType;\n    public static var ShapeType_POLYGON:ShapeType;\n    public static var Broadphase_DYNAMIC_AABB_TREE:Broadphase;\n    public static var Broadphase_SWEEP_AND_PRUNE:Broadphase;\n    public static var ArbiterType_COLLISION:ArbiterType;\n    public static var ArbiterType_SENSOR:ArbiterType;\n    public static var ArbiterType_FLUID:ArbiterType;\n}\n"],
"names":[],
"mappings":"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"
}