<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/js/_std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="38" static="1">
			<f a=""><c path="Date"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="42" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="48" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" get="inline" set="null" line="34">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There is some extra functions available in the `DateTools` class.

	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/js/_std/EReg.hx">
		<r><c path="_EReg.HaxeRegExp"/></r>
		<match public="1" set="method" line="31">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<new public="1" set="method" line="26">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	http://haxe.org/manual/std-regex.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="js.RegExp" params="" file="/usr/lib/haxe/std/js/RegExp.hx" extern="1">
		<global public="1" set="null"><x path="Bool"/></global>
		<ignoreCase public="1" set="null"><x path="Bool"/></ignoreCase>
		<multiline public="1" set="null"><x path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<exec public="1" set="method"><f a="str">
	<c path="String"/>
	<t path="Null"><c path="js.RegExpMatch"/></t>
</f></exec>
		<test public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></test>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="pattern:?flags">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Native JavaScript regular expressions.

    For cross-platform regular expressions, use haxe `EReg` class or regexp literals.</haxe_doc>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<class path="_EReg.HaxeRegExp" params="" file="/usr/lib/haxe/std/js/_std/EReg.hx" private="1" module="EReg" extern="1">
		<extends path="js.RegExp"/>
		<m public="1"><c path="js.RegExpMatch"/></m>
		<s public="1"><c path="String"/></s>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"RegExp"</e></m>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta><m n=":deprecated"/></meta>
	</typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/js/_std/Math.hx" extern="1">
		<floor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<round public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/js/_std/Reflect.hx">
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<fields public="1" set="method" line="50" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="61" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compareMethods public="1" set="method" line="69" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="String" params="" file="/usr/lib/haxe/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, null is returned.

		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the string literal syntax "string value".

	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/js/_std/Std.hx">
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.

	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.

	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.

	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.

	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.

		This method is not required to check `hasNext` first. A call to this
		method while `hasNext` is false yields unspecified behavior.

		On the other hand iterators should not require a call to `hasNext`
		before the first call to `next` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.</haxe_doc></class>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned Int type is only defined for Flash and C#.
	Simulate it for other platforms.</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/usr/lib/haxe/std/UInt.hx" private="1" module="UInt"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="pixi.interaction.EventEmitter" params="" file="pixi/interaction/EventEmitter.hx" extern="1">
		<listeners public="1" set="method">
			<f a="event">
				<c path="String"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* Return a list of assigned event listeners.
	 *
	 * @param {String} eventName
	 * @returns {Array}</haxe_doc>
		</listeners>
		<emit public="1" set="method">
			<f a="event:?a1:?a2:?a3:?a4:?a5">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Emit an event to all registered event listeners.
     *
     * @alias dispatchEvent
     * @param eventName {String} The name of the event.
     * @return {Bool} Indication if we've emitted an event.</haxe_doc>
		</emit>
		<on public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
			<overloads>
				<on public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</on>
				<on public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</on>
			</overloads>
		</on>
		<once public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
			<overloads>
				<once public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</once>
				<once public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</once>
			</overloads>
		</once>
		<addListener public="1" set="method">
			<f a="event:fn:?context">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
			<overloads>
				<addListener public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</addListener>
				<addListener public="1" set="method">
					<f a="event:fn:?context">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<d/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {function} fn Callback function.
	 * @param {Mixed} context The context of the function.</haxe_doc>
				</addListener>
			</overloads>
		</addListener>
		<off public="1" set="method">
			<f a="event:fn:?once">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
			<overloads>
				<off public="1" set="method">
					<f a="event:fn:?once">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
				</off>
				<off public="1" set="method">
					<f a="event:fn:?once">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
				</off>
			</overloads>
		</off>
		<removeListener public="1" set="method">
			<f a="event:fn:?once">
				<c path="String"/>
				<f a="">
					<t path="pixi.interaction.EventTarget"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
			<overloads>
				<removeListener public="1" set="method">
					<f a="event:fn:?once">
						<c path="String"/>
						<f a=""><x path="Void"/></f>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
				</removeListener>
				<removeListener public="1" set="method">
					<f a="event:fn:?once">
						<c path="String"/>
						<f a="">
							<d/>
							<x path="Void"/>
						</f>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {function} fn The listener that we need to find.
	 * @param {Bool} once Only remove once listeners.</haxe_doc>
				</removeListener>
			</overloads>
		</removeListener>
		<removeAllListeners public="1" set="method">
			<f a="?event">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.</haxe_doc>
		</removeAllListeners>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor</haxe_doc>
		</new>
	</class>
	<class path="pixi.loaders.ResourceLoader" params="" file="pixi/loaders/ResourceLoader.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<baseUrl public="1">
			<c path="String"/>
			<haxe_doc>* The base url for all resources loaded by this loader.
     *
     * @member {String}</haxe_doc>
		</baseUrl>
		<progress public="1">
			<x path="Float"/>
			<haxe_doc>* The progress percent of the loader going through the queue.
     *
     * @member {Float}</haxe_doc>
		</progress>
		<loading public="1">
			<x path="Bool"/>
			<haxe_doc>* Loading state of the loader, true if it is currently loading resources.
     *
     * @member {Bool}</haxe_doc>
		</loading>
		<resources public="1">
			<d/>
			<haxe_doc><![CDATA[* All the resources for this loader keyed by name.
     *
     * @member {object<string, Resource>}]]></haxe_doc>
		</resources>
		<add public="1" set="method">
			<f a="name:url:?options:?callback">
				<c path="String"/>
				<c path="String"/>
				<t path="pixi.loaders.LoaderOptions"/>
				<f a="">
					<c path="pixi.loaders.Resource"/>
					<x path="Void"/>
				</f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
			<overloads>
				<add public="1" set="method">
					<f a="obj">
						<t path="pixi.loaders.ResourceObject"/>
						<c path="pixi.loaders.ResourceLoader"/>
					</f>
					<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
				</add>
				<add public="1" set="method">
					<f a="urls">
						<c path="Array"><t path="pixi.loaders.ResourceObject"/></c>
						<c path="pixi.loaders.ResourceLoader"/>
					</f>
					<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
				</add>
				<add public="1" set="method">
					<f a="urls">
						<c path="Array"><c path="String"/></c>
						<c path="pixi.loaders.ResourceLoader"/>
					</f>
					<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
				</add>
				<add public="1" set="method">
					<f a="url:?options:?callback">
						<c path="String"/>
						<t path="pixi.loaders.LoaderOptions"/>
						<f a="">
							<c path="pixi.loaders.Resource"/>
							<x path="Void"/>
						</f>
						<c path="pixi.loaders.ResourceLoader"/>
					</f>
					<haxe_doc>* Adds a resource (or multiple resources) to the loader queue.
	 *
	 * This function can take a wide variety of different parameters. The only thing that is always
	 * required the url to load. All the following will work:
	 *
	 * ```js
	 * loader
	 *     // normal param syntax
	 *     .add('key', 'http://...', 	function () {})
	 *     .add('http://...', 	function () {})
	 *     .add('http://...')
	 *
	 *     // object syntax
	 *     .add({
	 *         name: 'key2',
	 *         url: 'http://...'
	 *     }, 	function () {})
	 *     .add({
	 *         url: 'http://...'
	 *     }, function () {})
	 *     .add({
	 *         name: 'key3',
	 *         url: 'http://...'
	 *         onComplete: function () {}
	 *     })
	 *     .add({
	 *         url: 'https://...',
	 *         onComplete: function () {},
	 *         crossOrigin: true
	 *     })
	 *
	 *     // you can also pass an array of objects or urls or both
	 *     .add([
	 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
	 *         { url: 'http://...', onComplete: function () {} },
	 *         'http://...'
	 *     ]);
	 * ```
	 *
	 * @alias enqueue
	 * @param [name] {string} The name of the resource to load, if not passed the url is used.
	 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?
	 * @param [callback] {function} function to call when this specific resource completes loading.
	 * @return {Loader}</haxe_doc>
				</add>
			</overloads>
		</add>
		<after public="1" set="method">
			<f a="fn">
				<f a=":">
					<c path="pixi.loaders.Resource"/>
					<d/>
					<x path="Void"/>
				</f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Sets up a middleware function that will run *after* the
	 * resource is loaded.
	 *
	 * @alias use
	 * @param middleware {function} The middleware function to register.
	 * @return {Loader}</haxe_doc>
		</after>
		<before public="1" set="method">
			<f a="fn">
				<f a=":">
					<c path="pixi.loaders.Resource"/>
					<d/>
					<x path="Void"/>
				</f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Sets up a middleware function that will run *before* the
	 * resource is loaded.
	 *
	 * @alias pre
	 * @param middleware {function} The middleware function to register.
	 * @return {Loader}</haxe_doc>
		</before>
		<reset public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the queue of the loader to prepare for a new load.</haxe_doc>
		</reset>
		<load public="1" set="method">
			<f a="?cb">
				<f a=""><x path="Void"/></f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Starts loading the queued resources.
	 *
	 * @fires start
	 * @param [callback] {function} Optional callback that will be bound to the `complete` event.
	 * @return {Loader}</haxe_doc>
		</load>
		<loadResource public="1" set="method">
			<f a="resource:?cb">
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Loads a single resource.
	 *
	 * @fires progress</haxe_doc>
		</loadResource>
		<use public="1" set="method">
			<f a="fn">
				<f a=":">
					<c path="pixi.loaders.Resource"/>
					<d/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Middleware function to use
	 *
	 * @param {function} function to call</haxe_doc>
		</use>
		<pre public="1" set="method">
			<f a="fn">
				<f a=":">
					<c path="pixi.loaders.Resource"/>
					<d/>
					<x path="Void"/>
				</f>
				<c path="pixi.loaders.ResourceLoader"/>
			</f>
			<haxe_doc>* Middleware function
	 *
	 * @param {function} function to call</haxe_doc>
		</pre>
		<new public="1" set="method">
			<f a="?baseUrl:?concurrency">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Manages the state and loading of multiple resources to load.
	 *
	 * @class
	 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
	 * @param [concurrency=10] {number} The number of resources to load concurrently.</haxe_doc>
		</new>
	</class>
	<class path="pixi.loaders.Loader" params="" file="pixi/loaders/Loader.hx" extern="1">
		<extends path="pixi.loaders.ResourceLoader"/>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>*
	 * The new loader, extends Resource Loader by Chad Engler : https://github.com/englercj/resource-loader
	 *
	 * ```js
	 * 	var loader = new PIXI.loader();
	 *
	 * loader.add('spineboy',"data/spineboy.json");
	 *
	 * loader.once('complete',onAssetsLoaded);
	 *
	 * loader.load();
	 * ```
	 *
	 * @class
	 * @extends ResourceLoader
	 * @memberof PIXI.loaders</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.loaders.Loader"</e></m>
		</meta>
	</class>
	<class path="core.AssetLoader" params="" file="samples/core/AssetLoader.hx">
		<extends path="pixi.loaders.Loader"/>
		<pixelRatio public="1" get="null"><x path="Float"/></pixelRatio>
		<count public="1" set="null"><x path="Int"/></count>
		<_audioAssets><x path="Map">
	<c path="String"/>
	<c path="core.AudioAsset"/>
</x></_audioAssets>
		<start public="1" set="method" line="25"><f a="?onComplete:?onProgress">
	<f a=""><x path="Void"/></f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></start>
		<addAsset public="1" set="method" line="34"><f a="id:path:?usePixelRatio:?onAssetLoaded">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<f a="">
		<c path="pixi.loaders.Resource"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></addAsset>
		<getAudio public="1" set="method" line="75"><f a="id">
	<c path="String"/>
	<c path="core.AudioAsset"/>
</f></getAudio>
		<_getLoadtype set="method" line="106"><f a="asset">
	<c path="String"/>
	<x path="Int"/>
</f></_getLoadtype>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="core.AudioAsset" params="" file="samples/core/AudioAsset.hx">
		<mute public="1"><x path="Bool"/></mute>
		<loop public="1" set="accessor"><x path="Bool"/></loop>
		<_src><c path="js.html.Audio"/></_src>
		<play public="1" set="method" line="18"><f a=""><x path="Void"/></f></play>
		<stop public="1" set="method" line="22"><f a=""><x path="Void"/></f></stop>
		<set_loop set="method" line="26"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_loop>
		<new public="1" set="method" line="12"><f a="src">
	<c path="js.html.Audio"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="core.MultipackParser" params="" file="samples/core/MultipackParser.hx">
		<loader public="1" static="1"><c path="core.AssetLoader"/></loader>
		<parse public="1" set="method" line="12" static="1"><f a="resource:next">
	<c path="pixi.loaders.Resource"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></parse>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="core.MultipackSpriteSheet" params="" file="samples/core/MultipackParser.hx" module="core.MultipackParser"><a>
	<textures><c path="Array"><t path="core.MultipackTexture"/></c></textures>
	<multipack><x path="Bool"/></multipack>
</a></typedef>
	<typedef path="core.MultipackTexture" params="" file="samples/core/MultipackParser.hx" module="core.MultipackParser"><a>
	<meta><t path="core.MetaData"/></meta>
	<frames><c path="Array"><t path="core.FrameData"/></c></frames>
</a></typedef>
	<typedef path="core.FrameData" params="" file="samples/core/MultipackParser.hx" module="core.MultipackParser"><a>
	<trimmed><x path="Bool"/></trimmed>
	<spriteSourceSize><t path="core.SpriteSourceSize"/></spriteSourceSize>
	<sourceSize><t path="core.SourceSize"/></sourceSize>
	<rotated><x path="Bool"/></rotated>
	<frame><t path="core.Frame"/></frame>
	<format><c path="String"/></format>
</a></typedef>
	<typedef path="core.Frame" params="" file="samples/core/MultipackParser.hx" module="core.MultipackParser"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<w><x path="Float"/></w>
	<h><x path="Float"/></h>
</a></typedef>
	<typedef path="core.SpriteSourceSize" params="" file="samples/core/MultipackParser.hx" module="core.MultipackParser"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<w><x path="Float"/></w>
	<h><x path="Float"/></h>
</a></typedef>
	<typedef path="core.SourceSize" params="" file="samples/core/MultipackParser.hx" module="core.MultipackParser"><a>
	<w><x path="Float"/></w>
	<h><x path="Float"/></h>
</a></typedef>
	<typedef path="core.MetaData" params="" file="samples/core/MultipackParser.hx" module="core.MultipackParser"><a>
	<version><c path="String"/></version>
	<smartupdate><c path="String"/></smartupdate>
	<size><c path="String"/></size>
	<scale><c path="String"/></scale>
	<image><c path="String"/></image>
	<format><c path="String"/></format>
	<app><c path="String"/></app>
</a></typedef>
	<abstract path="haxe.Function" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/lib/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/usr/lib/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is null, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning true if
		matching succeeded and false otherwise.

		Example usage:

		```
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/js/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h><d/></h>
		<rh><d/></rh>
		<set public="1" get="inline" set="null" line="56">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="63">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<setReserved set="method" line="75"><f a="key:value">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
	<x path="Void"/>
</f></setReserved>
		<getReserved set="method" line="80"><f a="key">
	<c path="String"/>
	<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
</f></getReserved>
		<new public="1" get="inline" set="null" line="48">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/usr/lib/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</to>
		<haxe_doc>An abstract type allowing values to be either of `T1` or `T2` type.
    Supports implicit casts from/to either types.

    It is useful for interfacing with external code on dynamic platforms
    such as JavaScript or Python.

    Otherwise, use of this type is discouraged.</haxe_doc>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/usr/lib/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.Rest" params="T" file="/usr/lib/haxe/std/haxe/extern/Rest.hx">
		<this><c path="Array"><c path="haxe.extern.Rest.T"/></c></this>
		<haxe_doc>A special abstract type that represents "rest" function argument.

    Should be used as a type for the last argument of an extern method,
    representing that arbitrary number of arguments of given type can be
    passed to that method.</haxe_doc>
		<impl><class path="haxe.extern._Rest.Rest_Impl_" params="" file="/usr/lib/haxe/std/haxe/extern/Rest.hx" private="1" module="haxe.extern.Rest"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="js.Error" params="" file="/usr/lib/haxe/std/js/Error.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<stack public="1" set="null"><c path="String"/></stack>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="js._Boot.HaxeError" params="" file="/usr/lib/haxe/std/js/Boot.hx" private="1" module="js.Boot">
		<extends path="js.Error"/>
		<val><d/></val>
		<new public="1" set="method" line="28">
			<f a="val">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.EvalError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"EvalError"</e></m></meta>
	</class>
	<class path="js.RangeError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RangeError"</e></m></meta>
	</class>
	<class path="js.ReferenceError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"ReferenceError"</e></m></meta>
	</class>
	<class path="js.SyntaxError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"SyntaxError"</e></m></meta>
	</class>
	<class path="js.TypeError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"TypeError"</e></m></meta>
	</class>
	<class path="js.URIError" params="" file="/usr/lib/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"URIError"</e></m></meta>
	</class>
	<class path="js.Promise" params="T" file="/usr/lib/haxe/std/js/Promise.hx" extern="1">
		<resolve public="1" params="T" set="method" static="1">
			<f a="value">
				<c path="resolve.T"/>
				<c path="js.Promise"><c path="resolve.T"/></c>
			</f>
			<overloads>
				<resolve public="1" params="T" set="method"><f a="promise">
	<c path="js.Promise"><c path="resolve.T"/></c>
	<c path="js.Promise"><c path="resolve.T"/></c>
</f></resolve>
				<resolve public="1" params="T" set="method"><f a="thenable">
	<t path="js.Thenable"><c path="resolve.T"/></t>
	<c path="js.Promise"><c path="resolve.T"/></c>
</f></resolve>
			</overloads>
		</resolve>
		<reject public="1" params="T" set="method" static="1"><f a="?value">
	<d/>
	<c path="js.Promise"><c path="reject.T"/></c>
</f></reject>
		<all public="1" set="method" static="1"><f a="iterable">
	<c path="Array"><d/></c>
	<c path="js.Promise"><c path="Array"><d/></c></c>
</f></all>
		<race public="1" set="method" static="1"><f a="iterable">
	<c path="Array"><d/></c>
	<c path="js.Promise"><d/></c>
</f></race>
		<then public="1" params="TOut" set="method"><f a="?fulfillCallback:?rejectCallback">
	<t path="js.PromiseCallback">
		<c path="js.Promise.T"/>
		<c path="then.TOut"/>
	</t>
	<x path="haxe.extern.EitherType">
		<f a="">
			<d/>
			<x path="Void"/>
		</f>
		<t path="js.PromiseCallback">
			<d/>
			<c path="then.TOut"/>
		</t>
	</x>
	<c path="js.Promise"><c path="then.TOut"/></c>
</f></then>
		<catchError public="1" params="TOut" set="method">
			<f a="rejectCallback">
				<x path="haxe.extern.EitherType">
					<f a="">
						<d/>
						<x path="Void"/>
					</f>
					<t path="js.PromiseCallback">
						<d/>
						<c path="catchError.TOut"/>
					</t>
				</x>
				<c path="js.Promise"><c path="catchError.TOut"/></c>
			</f>
			<meta><m n=":native"><e>"catch"</e></m></meta>
		</catchError>
		<new public="1" set="method">
			<f a="init">
				<f a=":">
					<f a="">
						<c path="js.Promise.T"/>
						<x path="Void"/>
					</f>
					<f a="">
						<d/>
						<x path="Void"/>
					</f>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Promise"</e></m></meta>
	</class>
	<typedef path="js.PromiseCallback" params="T:TOut" file="/usr/lib/haxe/std/js/Promise.hx" module="js.Promise"><x path="haxe.extern.EitherType">
	<f a="">
		<c path="js.PromiseCallback.T"/>
		<c path="js.PromiseCallback.TOut"/>
	</f>
	<f a="">
		<c path="js.PromiseCallback.T"/>
		<c path="js.Promise"><c path="js.PromiseCallback.TOut"/></c>
	</f>
</x></typedef>
	<typedef path="js.Thenable" params="T" file="/usr/lib/haxe/std/js/Promise.hx" module="js.Promise"><a><then><x path="haxe.extern.EitherType">
	<f a=":">
		<f a="">
			<c path="js.Thenable.T"/>
			<x path="Void"/>
		</f>
		<f a="">
			<d/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
	<f a="">
		<f a="">
			<c path="js.Thenable.T"/>
			<x path="Void"/>
		</f>
		<x path="Void"/>
	</f>
</x></then></a></typedef>
	<class path="js.RegExpMatch" params="" file="/usr/lib/haxe/std/js/RegExp.hx" module="js.RegExp" extern="1">
		<extends path="Array"><c path="String"/></extends>
		<index public="1"><x path="Int"/></index>
		<input public="1"><c path="String"/></input>
	</class>
	<abstract path="js.html.AlignSetting" params="" file="/usr/lib/haxe/std/js/html/AlignSetting.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._AlignSetting.AlignSetting_Impl_" params="" file="/usr/lib/haxe/std/js/html/AlignSetting.hx" private="1" module="js.html.AlignSetting"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.EventTarget" params="" file="/usr/lib/haxe/std/js/html/EventTarget.hx" extern="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?capture" v="::false">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{capture:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><addEventListener public="1" set="method">
	<f a="type:listener:?capture:?wantsUntrusted" v="::false:">
		<c path="String"/>
		<c path="js.html.EventListener"/>
		<x path="Bool"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{capture:false}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</addEventListener></overloads>
		</addEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?capture" v="::false">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{capture:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><removeEventListener public="1" set="method">
	<f a="type:listener:?capture" v="::false">
		<c path="String"/>
		<c path="js.html.EventListener"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{capture:false}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</removeEventListener></overloads>
		</removeEventListener>
		<dispatchEvent public="1" set="method">
			<f a="event">
				<c path="js.html.Event"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</dispatchEvent>
		<meta><m n=":native"><e>"EventTarget"</e></m></meta>
	</class>
	<class path="js.html.Node" params="" file="/usr/lib/haxe/std/js/html/Node.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<ELEMENT_NODE public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ELEMENT_NODE>
		<ATTRIBUTE_NODE public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</ATTRIBUTE_NODE>
		<TEXT_NODE public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TEXT_NODE>
		<CDATA_SECTION_NODE public="1" get="inline" set="null" expr="4" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</CDATA_SECTION_NODE>
		<ENTITY_REFERENCE_NODE public="1" get="inline" set="null" expr="5" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ENTITY_REFERENCE_NODE>
		<ENTITY_NODE public="1" get="inline" set="null" expr="6" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</ENTITY_NODE>
		<PROCESSING_INSTRUCTION_NODE public="1" get="inline" set="null" expr="7" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</PROCESSING_INSTRUCTION_NODE>
		<COMMENT_NODE public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</COMMENT_NODE>
		<DOCUMENT_NODE public="1" get="inline" set="null" expr="9" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</DOCUMENT_NODE>
		<DOCUMENT_TYPE_NODE public="1" get="inline" set="null" expr="10" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</DOCUMENT_TYPE_NODE>
		<DOCUMENT_FRAGMENT_NODE public="1" get="inline" set="null" expr="11" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</DOCUMENT_FRAGMENT_NODE>
		<NOTATION_NODE public="1" get="inline" set="null" expr="12" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</NOTATION_NODE>
		<DOCUMENT_POSITION_DISCONNECTED public="1" get="inline" set="null" expr="1" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</DOCUMENT_POSITION_DISCONNECTED>
		<DOCUMENT_POSITION_PRECEDING public="1" get="inline" set="null" expr="2" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</DOCUMENT_POSITION_PRECEDING>
		<DOCUMENT_POSITION_FOLLOWING public="1" get="inline" set="null" expr="4" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DOCUMENT_POSITION_FOLLOWING>
		<DOCUMENT_POSITION_CONTAINS public="1" get="inline" set="null" expr="8" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</DOCUMENT_POSITION_CONTAINS>
		<DOCUMENT_POSITION_CONTAINED_BY public="1" get="inline" set="null" expr="16" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DOCUMENT_POSITION_CONTAINED_BY>
		<DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC public="1" get="inline" set="null" expr="32" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC>
		<nodeType public="1" set="null"><x path="Int"/></nodeType>
		<nodeName public="1" set="null"><c path="String"/></nodeName>
		<baseURI public="1" set="null"><c path="String"/></baseURI>
		<ownerDocument public="1" set="null"><c path="js.html.HTMLDocument"/></ownerDocument>
		<parentNode public="1" set="null"><c path="js.html.Node"/></parentNode>
		<parentElement public="1" set="null"><c path="js.html.Element"/></parentElement>
		<childNodes public="1" set="null"><c path="js.html.NodeList"/></childNodes>
		<firstChild public="1" set="null"><c path="js.html.Node"/></firstChild>
		<lastChild public="1" set="null"><c path="js.html.Node"/></lastChild>
		<previousSibling public="1" set="null"><c path="js.html.Node"/></previousSibling>
		<nextSibling public="1" set="null"><c path="js.html.Node"/></nextSibling>
		<nodeValue public="1"><c path="String"/></nodeValue>
		<textContent public="1"><c path="String"/></textContent>
		<namespaceURI public="1" set="null"><c path="String"/></namespaceURI>
		<prefix public="1" set="null"><c path="String"/></prefix>
		<localName public="1" set="null"><c path="String"/></localName>
		<hasChildNodes public="1" set="method"><f a=""><x path="Bool"/></f></hasChildNodes>
		<insertBefore public="1" set="method">
			<f a="node:child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertBefore>
		<appendChild public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendChild>
		<replaceChild public="1" set="method">
			<f a="node:child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceChild>
		<removeChild public="1" set="method">
			<f a="child">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeChild>
		<normalize public="1" set="method"><f a=""><x path="Void"/></f></normalize>
		<cloneNode public="1" set="method">
			<f a="?deep" v="false">
				<x path="Bool"/>
				<c path="js.html.Node"/>
			</f>
			<meta><m n=":value"><e>{deep:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cloneNode>
		<isEqualNode public="1" set="method"><f a="node">
	<c path="js.html.Node"/>
	<x path="Bool"/>
</f></isEqualNode>
		<compareDocumentPosition public="1" set="method"><f a="other">
	<c path="js.html.Node"/>
	<x path="Int"/>
</f></compareDocumentPosition>
		<contains public="1" set="method"><f a="other">
	<c path="js.html.Node"/>
	<x path="Bool"/>
</f></contains>
		<lookupPrefix public="1" set="method"><f a="namespace_">
	<c path="String"/>
	<c path="String"/>
</f></lookupPrefix>
		<lookupNamespaceURI public="1" set="method"><f a="prefix">
	<c path="String"/>
	<c path="String"/>
</f></lookupNamespaceURI>
		<isDefaultNamespace public="1" set="method"><f a="namespace_">
	<c path="String"/>
	<x path="Bool"/>
</f></isDefaultNamespace>
		<meta><m n=":native"><e>"Node"</e></m></meta>
	</class>
	<class path="js.html.DOMElement" params="" file="/usr/lib/haxe/std/js/html/DOMElement.hx" extern="1">
		<extends path="js.html.Node"/>
		<tagName public="1" set="null"><c path="String"/></tagName>
		<id public="1"><c path="String"/></id>
		<className public="1"><c path="String"/></className>
		<classList public="1" set="null"><c path="js.html.DOMTokenList"/></classList>
		<attributes public="1" set="null"><c path="js.html.NamedNodeMap"/></attributes>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<title public="1"><c path="String"/></title>
		<lang public="1"><c path="String"/></lang>
		<dir public="1"><c path="String"/></dir>
		<dataset public="1" set="null"><c path="js.html.DOMStringMap"/></dataset>
		<itemScope public="1"><x path="Bool"/></itemScope>
		<itemType public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemType>
		<itemId public="1"><c path="String"/></itemId>
		<itemRef public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemRef>
		<itemProp public="1" set="null"><c path="js.html.DOMSettableTokenList"/></itemProp>
		<properties public="1" set="null"><c path="js.html.HTMLPropertiesCollection"/></properties>
		<itemValue public="1"><d/></itemValue>
		<hidden public="1"><x path="Bool"/></hidden>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<accessKey public="1"><c path="String"/></accessKey>
		<accessKeyLabel public="1" set="null"><c path="String"/></accessKeyLabel>
		<draggable public="1"><x path="Bool"/></draggable>
		<contentEditable public="1"><c path="String"/></contentEditable>
		<isContentEditable public="1" set="null"><x path="Bool"/></isContentEditable>
		<contextMenu public="1" set="null"><c path="js.html.MenuElement"/></contextMenu>
		<spellcheck public="1"><x path="Bool"/></spellcheck>
		<style public="1" set="null"><c path="js.html.CSSStyleDeclaration"/></style>
		<oncopy public="1"><x path="haxe.Function"/></oncopy>
		<oncut public="1"><x path="haxe.Function"/></oncut>
		<onpaste public="1"><x path="haxe.Function"/></onpaste>
		<innerText public="1"><c path="String"/></innerText>
		<offsetParent public="1" set="null"><c path="js.html.Element"/></offsetParent>
		<offsetTop public="1" set="null"><x path="Int"/></offsetTop>
		<offsetLeft public="1" set="null"><x path="Int"/></offsetLeft>
		<offsetWidth public="1" set="null"><x path="Int"/></offsetWidth>
		<offsetHeight public="1" set="null"><x path="Int"/></offsetHeight>
		<scrollTop public="1"><x path="Int"/></scrollTop>
		<scrollLeft public="1"><x path="Int"/></scrollLeft>
		<scrollWidth public="1" set="null"><x path="Int"/></scrollWidth>
		<scrollHeight public="1" set="null"><x path="Int"/></scrollHeight>
		<clientTop public="1" set="null"><x path="Int"/></clientTop>
		<clientLeft public="1" set="null"><x path="Int"/></clientLeft>
		<clientWidth public="1" set="null"><x path="Int"/></clientWidth>
		<clientHeight public="1" set="null"><x path="Int"/></clientHeight>
		<scrollTopMax public="1" set="null"><x path="Int"/></scrollTopMax>
		<scrollLeftMax public="1" set="null"><x path="Int"/></scrollLeftMax>
		<innerHTML public="1"><c path="String"/></innerHTML>
		<outerHTML public="1"><c path="String"/></outerHTML>
		<shadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></shadowRoot>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<previousElementSibling public="1" set="null"><c path="js.html.Element"/></previousElementSibling>
		<nextElementSibling public="1" set="null"><c path="js.html.Element"/></nextElementSibling>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<getAttribute public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
		<getAttributeNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getAttributeNS>
		<setAttribute public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttribute>
		<setAttributeNS public="1" set="method">
			<f a="namespace_:name:value">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNS>
		<removeAttribute public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttribute>
		<removeAttributeNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttributeNS>
		<hasAttribute public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttribute>
		<hasAttributeNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttributeNS>
		<hasAttributes public="1" set="method"><f a=""><x path="Bool"/></f></hasAttributes>
		<closest public="1" set="method">
			<f a="selector">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</closest>
		<matches public="1" set="method">
			<f a="selector">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</matches>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.HTMLCollection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<setPointerCapture public="1" set="method">
			<f a="pointerId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setPointerCapture>
		<releasePointerCapture public="1" set="method">
			<f a="pointerId">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</releasePointerCapture>
		<setCapture public="1" set="method">
			<f a="?retargetToElement" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{retargetToElement:false}</e></m></meta>
		</setCapture>
		<releaseCapture public="1" set="method"><f a=""><x path="Void"/></f></releaseCapture>
		<requestPointerLock public="1" set="method"><f a=""><x path="Void"/></f></requestPointerLock>
		<getAttributeNode public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getAttributeNode>
		<setAttributeNode public="1" set="method">
			<f a="newAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNode>
		<removeAttributeNode public="1" set="method">
			<f a="oldAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAttributeNode>
		<getAttributeNodeNS public="1" set="method"><f a="namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getAttributeNodeNS>
		<setAttributeNodeNS public="1" set="method">
			<f a="newAttr">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setAttributeNodeNS>
		<requestFullscreen public="1" set="method"><f a=""><x path="Void"/></f></requestFullscreen>
		<click public="1" set="method"><f a=""><x path="Void"/></f></click>
		<focus public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</focus>
		<blur public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</blur>
		<getClientRects public="1" set="method"><f a=""><c path="js.html.DOMRectList"/></f></getClientRects>
		<getBoundingClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getBoundingClientRect>
		<scrollIntoView public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollIntoViewOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollIntoView public="1" set="method"><f a="top">
	<x path="Bool"/>
	<x path="Void"/>
</f></scrollIntoView></overloads>
		</scrollIntoView>
		<scroll public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scroll public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scroll></overloads>
		</scroll>
		<scrollTo public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollTo></overloads>
		</scrollTo>
		<scrollBy public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollBy public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollBy></overloads>
		</scrollBy>
		<insertAdjacentHTML public="1" set="method">
			<f a="position:text">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertAdjacentHTML>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<createShadowRoot public="1" set="method">
			<f a=""><c path="js.html.ShadowRoot"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createShadowRoot>
		<getDestinationInsertionPoints public="1" set="method"><f a=""><c path="js.html.NodeList"/></f></getDestinationInsertionPoints>
		<getAnimationPlayers public="1" set="method"><f a=""><c path="Array"><c path="js.html.AnimationPlayer"/></c></f></getAnimationPlayers>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<meta><m n=":native"><e>"Element"</e></m></meta>
	</class>
	<class path="js.html.Element" params="" file="/usr/lib/haxe/std/js/html/Element.hx" extern="1">
		<extends path="js.html.DOMElement"/>
		<meta><m n=":native"><e>"HTMLElement"</e></m></meta>
	</class>
	<class path="js.html.AnchorElement" params="" file="/usr/lib/haxe/std/js/html/AnchorElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<target public="1"><c path="String"/></target>
		<download public="1"><c path="String"/></download>
		<ping public="1"><c path="String"/></ping>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<hreflang public="1"><c path="String"/></hreflang>
		<type public="1"><c path="String"/></type>
		<text public="1"><c path="String"/></text>
		<coords public="1"><c path="String"/></coords>
		<charset public="1"><c path="String"/></charset>
		<name public="1"><c path="String"/></name>
		<rev public="1"><c path="String"/></rev>
		<shape public="1"><c path="String"/></shape>
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<searchParams public="1"><c path="js.html.URLSearchParams"/></searchParams>
		<meta><m n=":native"><e>"HTMLAnchorElement"</e></m></meta>
	</class>
	<class path="js.html.Animation" params="" file="/usr/lib/haxe/std/js/html/Animation.hx" extern="1">
		<effect public="1" set="null"><c path="js.html.AnimationEffect"/></effect>
		<target public="1" set="null"><c path="js.html.Element"/></target>
		<meta><m n=":native"><e>"Animation"</e></m></meta>
	</class>
	<class path="js.html.AnimationEffect" params="" file="/usr/lib/haxe/std/js/html/AnimationEffect.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<meta><m n=":native"><e>"AnimationEffect"</e></m></meta>
	</class>
	<abstract path="js.html.AnimationPlayState" params="" file="/usr/lib/haxe/std/js/html/AnimationPlayState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._AnimationPlayState.AnimationPlayState_Impl_" params="" file="/usr/lib/haxe/std/js/html/AnimationPlayState.hx" private="1" module="js.html.AnimationPlayState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.AnimationPlayer" params="" file="/usr/lib/haxe/std/js/html/AnimationPlayer.hx" extern="1">
		<source public="1" set="null"><c path="js.html.Animation"/></source>
		<timeline public="1" set="null"><c path="js.html.AnimationTimeline"/></timeline>
		<startTime public="1" set="null"><x path="Float"/></startTime>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<playState public="1" set="null"><x path="js.html.AnimationPlayState"/></playState>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<meta><m n=":native"><e>"AnimationPlayer"</e></m></meta>
	</class>
	<class path="js.html.AnimationTimeline" params="" file="/usr/lib/haxe/std/js/html/AnimationTimeline.hx" extern="1">
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<meta><m n=":native"><e>"AnimationTimeline"</e></m></meta>
	</class>
	<class path="js.html.AppletElement" params="" file="/usr/lib/haxe/std/js/html/AppletElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<alt public="1"><c path="String"/></alt>
		<archive public="1"><c path="String"/></archive>
		<code public="1"><c path="String"/></code>
		<codeBase public="1"><c path="String"/></codeBase>
		<height public="1"><c path="String"/></height>
		<hspace public="1"><x path="Int"/></hspace>
		<name public="1"><c path="String"/></name>
		<object public="1"><c path="String"/></object>
		<vspace public="1"><x path="Int"/></vspace>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLAppletElement"</e></m></meta>
	</class>
	<class path="js.html.ApplicationCache" params="" file="/usr/lib/haxe/std/js/html/ApplicationCache.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<UNCACHED public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNCACHED>
		<IDLE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</IDLE>
		<CHECKING public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CHECKING>
		<DOWNLOADING public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</DOWNLOADING>
		<UPDATEREADY public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</UPDATEREADY>
		<OBSOLETE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</OBSOLETE>
		<status public="1" set="null"><x path="Int"/></status>
		<onchecking public="1"><x path="haxe.Function"/></onchecking>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onnoupdate public="1"><x path="haxe.Function"/></onnoupdate>
		<ondownloading public="1"><x path="haxe.Function"/></ondownloading>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onupdateready public="1"><x path="haxe.Function"/></onupdateready>
		<oncached public="1"><x path="haxe.Function"/></oncached>
		<onobsolete public="1"><x path="haxe.Function"/></onobsolete>
		<update public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</update>
		<swapCache public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</swapCache>
		<meta><m n=":native"><e>"ApplicationCache"</e></m></meta>
	</class>
	<class path="js.html.AreaElement" params="" file="/usr/lib/haxe/std/js/html/AreaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<alt public="1"><c path="String"/></alt>
		<coords public="1"><c path="String"/></coords>
		<shape public="1"><c path="String"/></shape>
		<target public="1"><c path="String"/></target>
		<download public="1"><c path="String"/></download>
		<ping public="1"><c path="String"/></ping>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<noHref public="1"><x path="Bool"/></noHref>
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<searchParams public="1"><c path="js.html.URLSearchParams"/></searchParams>
		<meta><m n=":native"><e>"HTMLAreaElement"</e></m></meta>
	</class>
	<class path="js.html.ArrayBuffer" params="" file="/usr/lib/haxe/std/js/html/ArrayBuffer.hx" extern="1">
		<isView public="1" set="method" static="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></isView>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<slice public="1" set="method"><f a="begin:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBuffer"/>
</f></slice>
		<new public="1" set="method">
			<f a="length">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"ArrayBuffer"</e></m></meta>
	</class>
	<class path="js.html.ArrayBufferView" params="" file="/usr/lib/haxe/std/js/html/ArrayBufferView.hx" extern="1">
		<buffer public="1" set="null"><c path="js.html.ArrayBuffer"/></buffer>
		<byteOffset public="1" set="null"><x path="Int"/></byteOffset>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<meta><m n=":native"><e>"ArrayBufferView"</e></m></meta>
	</class>
	<class path="js.html.Attr" params="" file="/usr/lib/haxe/std/js/html/Attr.hx" extern="1">
		<extends path="js.html.Node"/>
		<value public="1"><c path="String"/></value>
		<name public="1" set="null"><c path="String"/></name>
		<specified public="1" set="null"><x path="Bool"/></specified>
		<ownerElement public="1" set="null"><c path="js.html.Element"/></ownerElement>
		<meta><m n=":native"><e>"Attr"</e></m></meta>
	</class>
	<class path="js.html.MediaElement" params="" file="/usr/lib/haxe/std/js/html/MediaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<NETWORK_EMPTY public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NETWORK_EMPTY>
		<NETWORK_IDLE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NETWORK_IDLE>
		<NETWORK_LOADING public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</NETWORK_LOADING>
		<NETWORK_NO_SOURCE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</NETWORK_NO_SOURCE>
		<HAVE_NOTHING public="1" get="inline" set="null" expr="0" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</HAVE_NOTHING>
		<HAVE_METADATA public="1" get="inline" set="null" expr="1" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</HAVE_METADATA>
		<HAVE_CURRENT_DATA public="1" get="inline" set="null" expr="2" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</HAVE_CURRENT_DATA>
		<HAVE_FUTURE_DATA public="1" get="inline" set="null" expr="3" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</HAVE_FUTURE_DATA>
		<HAVE_ENOUGH_DATA public="1" get="inline" set="null" expr="4" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</HAVE_ENOUGH_DATA>
		<error public="1" set="null"><c path="js.html.MediaError"/></error>
		<src public="1"><c path="String"/></src>
		<currentSrc public="1" set="null"><c path="String"/></currentSrc>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<networkState public="1" set="null"><x path="Int"/></networkState>
		<preload public="1"><c path="String"/></preload>
		<buffered public="1" set="null"><c path="js.html.TimeRanges"/></buffered>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<seeking public="1" set="null"><x path="Bool"/></seeking>
		<currentTime public="1"><x path="Float"/></currentTime>
		<duration public="1" set="null"><x path="Float"/></duration>
		<paused public="1" set="null"><x path="Bool"/></paused>
		<defaultPlaybackRate public="1"><x path="Float"/></defaultPlaybackRate>
		<playbackRate public="1"><x path="Float"/></playbackRate>
		<played public="1" set="null"><c path="js.html.TimeRanges"/></played>
		<seekable public="1" set="null"><c path="js.html.TimeRanges"/></seekable>
		<ended public="1" set="null"><x path="Bool"/></ended>
		<autoplay public="1"><x path="Bool"/></autoplay>
		<loop public="1"><x path="Bool"/></loop>
		<controls public="1"><x path="Bool"/></controls>
		<volume public="1"><x path="Float"/></volume>
		<muted public="1"><x path="Bool"/></muted>
		<defaultMuted public="1"><x path="Bool"/></defaultMuted>
		<audioTracks public="1" set="null"><c path="js.html.AudioTrackList"/></audioTracks>
		<videoTracks public="1" set="null"><c path="js.html.VideoTrackList"/></videoTracks>
		<textTracks public="1" set="null"><c path="js.html.TextTrackList"/></textTracks>
		<mediaKeys public="1" set="null"><c path="js.html.MediaKeys"/></mediaKeys>
		<onencrypted public="1"><x path="haxe.Function"/></onencrypted>
		<waitingFor public="1" set="null"><x path="js.html.MediaWaitingFor"/></waitingFor>
		<load public="1" set="method"><f a=""><x path="Void"/></f></load>
		<canPlayType public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="String"/>
</f></canPlayType>
		<fastSeek public="1" set="method">
			<f a="time">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</fastSeek>
		<play public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</play>
		<pause public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</pause>
		<addTextTrack public="1" set="method">
			<f a="kind:?label:?language" v=":&quot;&quot;:&quot;&quot;">
				<x path="js.html.TextTrackKind"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.TextTrack"/>
			</f>
			<meta><m n=":value"><e>{language:"",label:""}</e></m></meta>
		</addTextTrack>
		<setMediaKeys public="1" set="method"><f a="mediaKeys">
	<c path="js.html.MediaKeys"/>
	<c path="js.Promise"><x path="Void"/></c>
</f></setMediaKeys>
		<meta><m n=":native"><e>"HTMLMediaElement"</e></m></meta>
	</class>
	<class path="js.html.AudioElement" params="" file="/usr/lib/haxe/std/js/html/AudioElement.hx" extern="1">
		<extends path="js.html.MediaElement"/>
		<meta><m n=":native"><e>"HTMLAudioElement"</e></m></meta>
	</class>
	<class path="js.html.Audio" params="" file="/usr/lib/haxe/std/js/html/Audio.hx" extern="1">
		<extends path="js.html.AudioElement"/>
		<new public="1" set="method">
			<f a="?src">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Audio"</e></m></meta>
	</class>
	<class path="js.html.AudioTrack" params="" file="/usr/lib/haxe/std/js/html/AudioTrack.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<kind public="1" set="null"><c path="String"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<enabled public="1"><x path="Bool"/></enabled>
		<meta><m n=":native"><e>"AudioTrack"</e></m></meta>
	</class>
	<class path="js.html.AudioTrackList" params="" file="/usr/lib/haxe/std/js/html/AudioTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.AudioTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"AudioTrackList"</e></m></meta>
	</class>
	<class path="js.html.BRElement" params="" file="/usr/lib/haxe/std/js/html/BRElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<clear public="1"><c path="String"/></clear>
		<meta><m n=":native"><e>"HTMLBRElement"</e></m></meta>
	</class>
	<class path="js.html.BarProp" params="" file="/usr/lib/haxe/std/js/html/BarProp.hx" extern="1">
		<visible public="1"><x path="Bool"/></visible>
		<meta><m n=":native"><e>"BarProp"</e></m></meta>
	</class>
	<class path="js.html.BaseElement" params="" file="/usr/lib/haxe/std/js/html/BaseElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<href public="1"><c path="String"/></href>
		<target public="1"><c path="String"/></target>
		<meta><m n=":native"><e>"HTMLBaseElement"</e></m></meta>
	</class>
	<class path="js.html.BatteryManager" params="" file="/usr/lib/haxe/std/js/html/BatteryManager.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<charging public="1" set="null"><x path="Bool"/></charging>
		<chargingTime public="1" set="null"><x path="Float"/></chargingTime>
		<dischargingTime public="1" set="null"><x path="Float"/></dischargingTime>
		<level public="1" set="null"><x path="Float"/></level>
		<onchargingchange public="1"><x path="haxe.Function"/></onchargingchange>
		<onchargingtimechange public="1"><x path="haxe.Function"/></onchargingtimechange>
		<ondischargingtimechange public="1"><x path="haxe.Function"/></ondischargingtimechange>
		<onlevelchange public="1"><x path="haxe.Function"/></onlevelchange>
		<meta><m n=":native"><e>"BatteryManager"</e></m></meta>
	</class>
	<class path="js.html.Blob" params="" file="/usr/lib/haxe/std/js/html/Blob.hx" extern="1">
		<size public="1" set="null"><x path="Int"/></size>
		<type public="1" set="null"><c path="String"/></type>
		<slice public="1" set="method">
			<f a="?start:?end:?contentType" v="::&quot;&quot;">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="js.html.Blob"/>
			</f>
			<meta><m n=":value"><e>{contentType:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</slice>
		<new public="1" set="method">
			<f a="blobParts:?options">
				<c path="Array"><x path="haxe.extern.EitherType">
	<c path="js.html.ArrayBuffer"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<x path="haxe.extern.EitherType">
			<c path="js.html.Blob"/>
			<c path="String"/>
		</x>
	</x>
</x></c>
				<t path="js.html.BlobPropertyBag"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"Blob"</e></m></meta>
	</class>
	<typedef path="js.html.BlobPropertyBag" params="" file="/usr/lib/haxe/std/js/html/BlobPropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<endings>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</endings>
</a></typedef>
	<class path="js.html.BodyElement" params="" file="/usr/lib/haxe/std/js/html/BodyElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<text public="1"><c path="String"/></text>
		<link public="1"><c path="String"/></link>
		<vLink public="1"><c path="String"/></vLink>
		<aLink public="1"><c path="String"/></aLink>
		<bgColor public="1"><c path="String"/></bgColor>
		<background public="1"><c path="String"/></background>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<meta><m n=":native"><e>"HTMLBodyElement"</e></m></meta>
	</class>
	<class path="js.html.ButtonElement" params="" file="/usr/lib/haxe/std/js/html/ButtonElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<formAction public="1"><c path="String"/></formAction>
		<formEnctype public="1"><c path="String"/></formEnctype>
		<formMethod public="1"><c path="String"/></formMethod>
		<formNoValidate public="1"><x path="Bool"/></formNoValidate>
		<formTarget public="1"><c path="String"/></formTarget>
		<name public="1"><c path="String"/></name>
		<type public="1"><c path="String"/></type>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLButtonElement"</e></m></meta>
	</class>
	<class path="js.html.CharacterData" params="" file="/usr/lib/haxe/std/js/html/CharacterData.hx" extern="1">
		<extends path="js.html.Node"/>
		<data public="1"><c path="String"/></data>
		<length public="1" set="null"><x path="Int"/></length>
		<previousElementSibling public="1" set="null"><c path="js.html.Element"/></previousElementSibling>
		<nextElementSibling public="1" set="null"><c path="js.html.Element"/></nextElementSibling>
		<substringData public="1" set="method">
			<f a="offset:count">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</substringData>
		<appendData public="1" set="method">
			<f a="data">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendData>
		<insertData public="1" set="method">
			<f a="offset:data">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertData>
		<deleteData public="1" set="method">
			<f a="offset:count">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteData>
		<replaceData public="1" set="method">
			<f a="offset:count:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceData>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<meta><m n=":native"><e>"CharacterData"</e></m></meta>
	</class>
	<class path="js.html.Text" params="" file="/usr/lib/haxe/std/js/html/Text.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<wholeText public="1" set="null"><c path="String"/></wholeText>
		<splitText public="1" set="method">
			<f a="offset">
				<x path="Int"/>
				<c path="js.html.Text"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</splitText>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<new public="1" set="method">
			<f a="?data" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{data:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Text"</e></m></meta>
	</class>
	<class path="js.html.CDATASection" params="" file="/usr/lib/haxe/std/js/html/CDATASection.hx" extern="1">
		<extends path="js.html.Text"/>
		<meta><m n=":native"><e>"CDATASection"</e></m></meta>
	</class>
	<class path="js.html.CSSRule" params="" file="/usr/lib/haxe/std/js/html/CSSRule.hx" extern="1">
		<UNKNOWN_RULE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNKNOWN_RULE>
		<STYLE_RULE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</STYLE_RULE>
		<CHARSET_RULE public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CHARSET_RULE>
		<IMPORT_RULE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</IMPORT_RULE>
		<MEDIA_RULE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</MEDIA_RULE>
		<FONT_FACE_RULE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</FONT_FACE_RULE>
		<PAGE_RULE public="1" get="inline" set="null" expr="6" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</PAGE_RULE>
		<type public="1" set="null"><x path="Int"/></type>
		<cssText public="1"><c path="String"/></cssText>
		<parentStyleSheet public="1" set="null"><c path="js.html.CSSStyleSheet"/></parentStyleSheet>
		<parentRule public="1" set="null"><c path="js.html.CSSRule"/></parentRule>
		<meta><m n=":native"><e>"CSSRule"</e></m></meta>
	</class>
	<class path="js.html.CSSRuleList" params="" file="/usr/lib/haxe/std/js/html/CSSRuleList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.CSSRule"/>
</f></item>
		<meta><m n=":native"><e>"CSSRuleList"</e></m></meta>
	</class>
	<class path="js.html.CSSStyleDeclaration" params="" file="/usr/lib/haxe/std/js/html/CSSStyleDeclaration.hx" extern="1">
		<cssText public="1"><c path="String"/></cssText>
		<length public="1" set="null"><x path="Int"/></length>
		<parentRule public="1" set="null"><c path="js.html.CSSRule"/></parentRule>
		<alignContent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-content" CSS property.</haxe_doc>
		</alignContent>
		<alignItems public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-items" CSS property.</haxe_doc>
		</alignItems>
		<alignSelf public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "align-self" CSS property.</haxe_doc>
		</alignSelf>
		<alignmentAdjust public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "alignment-adjust" CSS property.</haxe_doc>
		</alignmentAdjust>
		<alignmentBaseline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "alignment-baseline" CSS property.</haxe_doc>
		</alignmentBaseline>
		<all public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "all" CSS property.</haxe_doc>
		</all>
		<anchorPoint public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "anchor-point" CSS property.</haxe_doc>
		</anchorPoint>
		<animation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation" CSS property.</haxe_doc>
		</animation>
		<animationDelay public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-delay" CSS property.</haxe_doc>
		</animationDelay>
		<animationDirection public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-direction" CSS property.</haxe_doc>
		</animationDirection>
		<animationDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-duration" CSS property.</haxe_doc>
		</animationDuration>
		<animationFillMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-fill-mode" CSS property.</haxe_doc>
		</animationFillMode>
		<animationIterationCount public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-iteration-count" CSS property.</haxe_doc>
		</animationIterationCount>
		<animationName public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-name" CSS property.</haxe_doc>
		</animationName>
		<animationPlayState public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-play-state" CSS property.</haxe_doc>
		</animationPlayState>
		<animationTimingFunction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "animation-timing-function" CSS property.</haxe_doc>
		</animationTimingFunction>
		<azimuth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "azimuth" CSS property.</haxe_doc>
		</azimuth>
		<backfaceVisibility public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "backface-visibility" CSS property.</haxe_doc>
		</backfaceVisibility>
		<background public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background" CSS property.</haxe_doc>
		</background>
		<backgroundAttachment public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-attachment" CSS property.</haxe_doc>
		</backgroundAttachment>
		<backgroundClip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-clip" CSS property.</haxe_doc>
		</backgroundClip>
		<backgroundColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-color" CSS property.</haxe_doc>
		</backgroundColor>
		<backgroundImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-image" CSS property.</haxe_doc>
		</backgroundImage>
		<backgroundOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-origin" CSS property.</haxe_doc>
		</backgroundOrigin>
		<backgroundPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-position" CSS property.</haxe_doc>
		</backgroundPosition>
		<backgroundRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-repeat" CSS property.</haxe_doc>
		</backgroundRepeat>
		<backgroundSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "background-size" CSS property.</haxe_doc>
		</backgroundSize>
		<baselineShift public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "baseline-shift" CSS property.</haxe_doc>
		</baselineShift>
		<binding public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "binding" CSS property.</haxe_doc>
		</binding>
		<bleed public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bleed" CSS property.</haxe_doc>
		</bleed>
		<bookmarkLabel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-label" CSS property.</haxe_doc>
		</bookmarkLabel>
		<bookmarkLevel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-level" CSS property.</haxe_doc>
		</bookmarkLevel>
		<bookmarkState public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bookmark-state" CSS property.</haxe_doc>
		</bookmarkState>
		<border public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border" CSS property.</haxe_doc>
		</border>
		<borderBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom" CSS property.</haxe_doc>
		</borderBottom>
		<borderBottomColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-color" CSS property.</haxe_doc>
		</borderBottomColor>
		<borderBottomLeftRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-left-radius" CSS property.</haxe_doc>
		</borderBottomLeftRadius>
		<borderBottomRightRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-right-radius" CSS property.</haxe_doc>
		</borderBottomRightRadius>
		<borderBottomStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-style" CSS property.</haxe_doc>
		</borderBottomStyle>
		<borderBottomWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-bottom-width" CSS property.</haxe_doc>
		</borderBottomWidth>
		<borderCollapse public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-collapse" CSS property.</haxe_doc>
		</borderCollapse>
		<borderColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-color" CSS property.</haxe_doc>
		</borderColor>
		<borderImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image" CSS property.</haxe_doc>
		</borderImage>
		<borderImageOutset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-outset" CSS property.</haxe_doc>
		</borderImageOutset>
		<borderImageRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-repeat" CSS property.</haxe_doc>
		</borderImageRepeat>
		<borderImageSlice public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-slice" CSS property.</haxe_doc>
		</borderImageSlice>
		<borderImageSource public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-source" CSS property.</haxe_doc>
		</borderImageSource>
		<borderImageWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-image-width" CSS property.</haxe_doc>
		</borderImageWidth>
		<borderLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left" CSS property.</haxe_doc>
		</borderLeft>
		<borderLeftColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-color" CSS property.</haxe_doc>
		</borderLeftColor>
		<borderLeftStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-style" CSS property.</haxe_doc>
		</borderLeftStyle>
		<borderLeftWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-left-width" CSS property.</haxe_doc>
		</borderLeftWidth>
		<borderRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-radius" CSS property.</haxe_doc>
		</borderRadius>
		<borderRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right" CSS property.</haxe_doc>
		</borderRight>
		<borderRightColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-color" CSS property.</haxe_doc>
		</borderRightColor>
		<borderRightStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-style" CSS property.</haxe_doc>
		</borderRightStyle>
		<borderRightWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-right-width" CSS property.</haxe_doc>
		</borderRightWidth>
		<borderSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-spacing" CSS property.</haxe_doc>
		</borderSpacing>
		<borderStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-style" CSS property.</haxe_doc>
		</borderStyle>
		<borderTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top" CSS property.</haxe_doc>
		</borderTop>
		<borderTopColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-color" CSS property.</haxe_doc>
		</borderTopColor>
		<borderTopLeftRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-left-radius" CSS property.</haxe_doc>
		</borderTopLeftRadius>
		<borderTopRightRadius public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-right-radius" CSS property.</haxe_doc>
		</borderTopRightRadius>
		<borderTopStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-style" CSS property.</haxe_doc>
		</borderTopStyle>
		<borderTopWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-top-width" CSS property.</haxe_doc>
		</borderTopWidth>
		<borderWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "border-width" CSS property.</haxe_doc>
		</borderWidth>
		<bottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "bottom" CSS property.</haxe_doc>
		</bottom>
		<boxDecorationBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-decoration-break" CSS property.</haxe_doc>
		</boxDecorationBreak>
		<boxShadow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-shadow" CSS property.</haxe_doc>
		</boxShadow>
		<boxSizing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-sizing" CSS property.</haxe_doc>
		</boxSizing>
		<boxSnap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-snap" CSS property.</haxe_doc>
		</boxSnap>
		<boxSuppress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "box-suppress" CSS property.</haxe_doc>
		</boxSuppress>
		<breakAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-after" CSS property.</haxe_doc>
		</breakAfter>
		<breakBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-before" CSS property.</haxe_doc>
		</breakBefore>
		<breakInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "break-inside" CSS property.</haxe_doc>
		</breakInside>
		<captionSide public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "caption-side" CSS property.</haxe_doc>
		</captionSide>
		<chains public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "chains" CSS property.</haxe_doc>
		</chains>
		<clear public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clear" CSS property.</haxe_doc>
		</clear>
		<clip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip" CSS property.</haxe_doc>
		</clip>
		<clipPath public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip-path" CSS property.</haxe_doc>
		</clipPath>
		<clipRule public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "clip-rule" CSS property.</haxe_doc>
		</clipRule>
		<color public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "color" CSS property.</haxe_doc>
		</color>
		<colorInterpolationFilters public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "color-interpolation-filters" CSS property.</haxe_doc>
		</colorInterpolationFilters>
		<columnCount public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-count" CSS property.</haxe_doc>
		</columnCount>
		<columnFill public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-fill" CSS property.</haxe_doc>
		</columnFill>
		<columnGap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-gap" CSS property.</haxe_doc>
		</columnGap>
		<columnRule public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule" CSS property.</haxe_doc>
		</columnRule>
		<columnRuleColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-color" CSS property.</haxe_doc>
		</columnRuleColor>
		<columnRuleStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-style" CSS property.</haxe_doc>
		</columnRuleStyle>
		<columnRuleWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-rule-width" CSS property.</haxe_doc>
		</columnRuleWidth>
		<columnSpan public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-span" CSS property.</haxe_doc>
		</columnSpan>
		<columnWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "column-width" CSS property.</haxe_doc>
		</columnWidth>
		<columns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "columns" CSS property.</haxe_doc>
		</columns>
		<contain public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "contain" CSS property.</haxe_doc>
		</contain>
		<content public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "content" CSS property.</haxe_doc>
		</content>
		<counterIncrement public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-increment" CSS property.</haxe_doc>
		</counterIncrement>
		<counterReset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-reset" CSS property.</haxe_doc>
		</counterReset>
		<counterSet public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "counter-set" CSS property.</haxe_doc>
		</counterSet>
		<crop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "crop" CSS property.</haxe_doc>
		</crop>
		<cue public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue" CSS property.</haxe_doc>
		</cue>
		<cueAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue-after" CSS property.</haxe_doc>
		</cueAfter>
		<cueBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cue-before" CSS property.</haxe_doc>
		</cueBefore>
		<cursor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "cursor" CSS property.</haxe_doc>
		</cursor>
		<direction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "direction" CSS property.</haxe_doc>
		</direction>
		<display public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display" CSS property.</haxe_doc>
		</display>
		<displayInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-inside" CSS property.</haxe_doc>
		</displayInside>
		<displayList public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-list" CSS property.</haxe_doc>
		</displayList>
		<displayOutside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "display-outside" CSS property.</haxe_doc>
		</displayOutside>
		<dominantBaseline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "dominant-baseline" CSS property.</haxe_doc>
		</dominantBaseline>
		<elevation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "elevation" CSS property.</haxe_doc>
		</elevation>
		<emptyCells public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "empty-cells" CSS property.</haxe_doc>
		</emptyCells>
		<filter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "filter" CSS property.</haxe_doc>
		</filter>
		<flex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex" CSS property.</haxe_doc>
		</flex>
		<flexBasis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-basis" CSS property.</haxe_doc>
		</flexBasis>
		<flexDirection public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-direction" CSS property.</haxe_doc>
		</flexDirection>
		<flexFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-flow" CSS property.</haxe_doc>
		</flexFlow>
		<flexGrow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-grow" CSS property.</haxe_doc>
		</flexGrow>
		<flexShrink public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-shrink" CSS property.</haxe_doc>
		</flexShrink>
		<flexWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flex-wrap" CSS property.</haxe_doc>
		</flexWrap>
		<float public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "float" CSS property.</haxe_doc>
		</float>
		<floatOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "float-offset" CSS property.</haxe_doc>
		</floatOffset>
		<floodColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flood-color" CSS property.</haxe_doc>
		</floodColor>
		<floodOpacity public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flood-opacity" CSS property.</haxe_doc>
		</floodOpacity>
		<flowFrom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flow-from" CSS property.</haxe_doc>
		</flowFrom>
		<flowInto public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "flow-into" CSS property.</haxe_doc>
		</flowInto>
		<font public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font" CSS property.</haxe_doc>
		</font>
		<fontFamily public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-family" CSS property.</haxe_doc>
		</fontFamily>
		<fontFeatureSettings public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-feature-settings" CSS property.</haxe_doc>
		</fontFeatureSettings>
		<fontKerning public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-kerning" CSS property.</haxe_doc>
		</fontKerning>
		<fontLanguageOverride public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-language-override" CSS property.</haxe_doc>
		</fontLanguageOverride>
		<fontSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-size" CSS property.</haxe_doc>
		</fontSize>
		<fontSizeAdjust public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-size-adjust" CSS property.</haxe_doc>
		</fontSizeAdjust>
		<fontStretch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-stretch" CSS property.</haxe_doc>
		</fontStretch>
		<fontStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-style" CSS property.</haxe_doc>
		</fontStyle>
		<fontSynthesis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-synthesis" CSS property.</haxe_doc>
		</fontSynthesis>
		<fontVariant public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant" CSS property.</haxe_doc>
		</fontVariant>
		<fontVariantAlternates public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-alternates" CSS property.</haxe_doc>
		</fontVariantAlternates>
		<fontVariantCaps public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-caps" CSS property.</haxe_doc>
		</fontVariantCaps>
		<fontVariantEastAsian public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-east-asian" CSS property.</haxe_doc>
		</fontVariantEastAsian>
		<fontVariantLigatures public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-ligatures" CSS property.</haxe_doc>
		</fontVariantLigatures>
		<fontVariantNumeric public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-numeric" CSS property.</haxe_doc>
		</fontVariantNumeric>
		<fontVariantPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-variant-position" CSS property.</haxe_doc>
		</fontVariantPosition>
		<fontWeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "font-weight" CSS property.</haxe_doc>
		</fontWeight>
		<grid public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid" CSS property.</haxe_doc>
		</grid>
		<gridArea public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-area" CSS property.</haxe_doc>
		</gridArea>
		<gridAutoColumns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-columns" CSS property.</haxe_doc>
		</gridAutoColumns>
		<gridAutoFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-flow" CSS property.</haxe_doc>
		</gridAutoFlow>
		<gridAutoRows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-auto-rows" CSS property.</haxe_doc>
		</gridAutoRows>
		<gridColumn public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column" CSS property.</haxe_doc>
		</gridColumn>
		<gridColumnEnd public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column-end" CSS property.</haxe_doc>
		</gridColumnEnd>
		<gridColumnStart public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-column-start" CSS property.</haxe_doc>
		</gridColumnStart>
		<gridRow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row" CSS property.</haxe_doc>
		</gridRow>
		<gridRowEnd public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row-end" CSS property.</haxe_doc>
		</gridRowEnd>
		<gridRowStart public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-row-start" CSS property.</haxe_doc>
		</gridRowStart>
		<gridTemplate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template" CSS property.</haxe_doc>
		</gridTemplate>
		<gridTemplateAreas public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-areas" CSS property.</haxe_doc>
		</gridTemplateAreas>
		<gridTemplateColumns public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-columns" CSS property.</haxe_doc>
		</gridTemplateColumns>
		<gridTemplateRows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "grid-template-rows" CSS property.</haxe_doc>
		</gridTemplateRows>
		<hangingPunctuation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "hanging-punctuation" CSS property.</haxe_doc>
		</hangingPunctuation>
		<height public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "height" CSS property.</haxe_doc>
		</height>
		<hyphens public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "hyphens" CSS property.</haxe_doc>
		</hyphens>
		<icon public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "icon" CSS property.</haxe_doc>
		</icon>
		<imageOrientation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "image-orientation" CSS property.</haxe_doc>
		</imageOrientation>
		<imageResolution public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "image-resolution" CSS property.</haxe_doc>
		</imageResolution>
		<imeMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ime-mode" CSS property.</haxe_doc>
		</imeMode>
		<initialLetters public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "initial-letters" CSS property.</haxe_doc>
		</initialLetters>
		<inlineBoxAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "inline-box-align" CSS property.</haxe_doc>
		</inlineBoxAlign>
		<justifyContent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-content" CSS property.</haxe_doc>
		</justifyContent>
		<justifyItems public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-items" CSS property.</haxe_doc>
		</justifyItems>
		<justifySelf public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "justify-self" CSS property.</haxe_doc>
		</justifySelf>
		<left public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "left" CSS property.</haxe_doc>
		</left>
		<letterSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "letter-spacing" CSS property.</haxe_doc>
		</letterSpacing>
		<lightingColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "lighting-color" CSS property.</haxe_doc>
		</lightingColor>
		<lineBoxContain public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-box-contain" CSS property.</haxe_doc>
		</lineBoxContain>
		<lineBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-break" CSS property.</haxe_doc>
		</lineBreak>
		<lineGrid public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-grid" CSS property.</haxe_doc>
		</lineGrid>
		<lineHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-height" CSS property.</haxe_doc>
		</lineHeight>
		<lineSnap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-snap" CSS property.</haxe_doc>
		</lineSnap>
		<lineStacking public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking" CSS property.</haxe_doc>
		</lineStacking>
		<lineStackingRuby public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-ruby" CSS property.</haxe_doc>
		</lineStackingRuby>
		<lineStackingShift public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-shift" CSS property.</haxe_doc>
		</lineStackingShift>
		<lineStackingStrategy public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "line-stacking-strategy" CSS property.</haxe_doc>
		</lineStackingStrategy>
		<listStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style" CSS property.</haxe_doc>
		</listStyle>
		<listStyleImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-image" CSS property.</haxe_doc>
		</listStyleImage>
		<listStylePosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-position" CSS property.</haxe_doc>
		</listStylePosition>
		<listStyleType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "list-style-type" CSS property.</haxe_doc>
		</listStyleType>
		<margin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin" CSS property.</haxe_doc>
		</margin>
		<marginBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-bottom" CSS property.</haxe_doc>
		</marginBottom>
		<marginLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-left" CSS property.</haxe_doc>
		</marginLeft>
		<marginRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-right" CSS property.</haxe_doc>
		</marginRight>
		<marginTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "margin-top" CSS property.</haxe_doc>
		</marginTop>
		<markerOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marker-offset" CSS property.</haxe_doc>
		</markerOffset>
		<markerSide public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marker-side" CSS property.</haxe_doc>
		</markerSide>
		<marks public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "marks" CSS property.</haxe_doc>
		</marks>
		<mask public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask" CSS property.</haxe_doc>
		</mask>
		<maskBox public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box" CSS property.</haxe_doc>
		</maskBox>
		<maskBoxOutset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-outset" CSS property.</haxe_doc>
		</maskBoxOutset>
		<maskBoxRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-repeat" CSS property.</haxe_doc>
		</maskBoxRepeat>
		<maskBoxSlice public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-slice" CSS property.</haxe_doc>
		</maskBoxSlice>
		<maskBoxSource public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-source" CSS property.</haxe_doc>
		</maskBoxSource>
		<maskBoxWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-box-width" CSS property.</haxe_doc>
		</maskBoxWidth>
		<maskClip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-clip" CSS property.</haxe_doc>
		</maskClip>
		<maskImage public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-image" CSS property.</haxe_doc>
		</maskImage>
		<maskOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-origin" CSS property.</haxe_doc>
		</maskOrigin>
		<maskPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-position" CSS property.</haxe_doc>
		</maskPosition>
		<maskRepeat public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-repeat" CSS property.</haxe_doc>
		</maskRepeat>
		<maskSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-size" CSS property.</haxe_doc>
		</maskSize>
		<maskSourceType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-source-type" CSS property.</haxe_doc>
		</maskSourceType>
		<maskType public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "mask-type" CSS property.</haxe_doc>
		</maskType>
		<maxHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-height" CSS property.</haxe_doc>
		</maxHeight>
		<maxLines public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-lines" CSS property.</haxe_doc>
		</maxLines>
		<maxWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "max-width" CSS property.</haxe_doc>
		</maxWidth>
		<minHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "min-height" CSS property.</haxe_doc>
		</minHeight>
		<minWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "min-width" CSS property.</haxe_doc>
		</minWidth>
		<moveTo public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "move-to" CSS property.</haxe_doc>
		</moveTo>
		<navDown public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-down" CSS property.</haxe_doc>
		</navDown>
		<navIndex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-index" CSS property.</haxe_doc>
		</navIndex>
		<navLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-left" CSS property.</haxe_doc>
		</navLeft>
		<navRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-right" CSS property.</haxe_doc>
		</navRight>
		<navUp public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "nav-up" CSS property.</haxe_doc>
		</navUp>
		<objectFit public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "object-fit" CSS property.</haxe_doc>
		</objectFit>
		<objectPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "object-position" CSS property.</haxe_doc>
		</objectPosition>
		<opacity public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "opacity" CSS property.</haxe_doc>
		</opacity>
		<order public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "order" CSS property.</haxe_doc>
		</order>
		<orphans public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "orphans" CSS property.</haxe_doc>
		</orphans>
		<outline public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline" CSS property.</haxe_doc>
		</outline>
		<outlineColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-color" CSS property.</haxe_doc>
		</outlineColor>
		<outlineOffset public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-offset" CSS property.</haxe_doc>
		</outlineOffset>
		<outlineStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-style" CSS property.</haxe_doc>
		</outlineStyle>
		<outlineWidth public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "outline-width" CSS property.</haxe_doc>
		</outlineWidth>
		<overflow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow" CSS property.</haxe_doc>
		</overflow>
		<overflowWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-wrap" CSS property.</haxe_doc>
		</overflowWrap>
		<overflowX public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-x" CSS property.</haxe_doc>
		</overflowX>
		<overflowY public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "overflow-y" CSS property.</haxe_doc>
		</overflowY>
		<padding public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding" CSS property.</haxe_doc>
		</padding>
		<paddingBottom public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-bottom" CSS property.</haxe_doc>
		</paddingBottom>
		<paddingLeft public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-left" CSS property.</haxe_doc>
		</paddingLeft>
		<paddingRight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-right" CSS property.</haxe_doc>
		</paddingRight>
		<paddingTop public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "padding-top" CSS property.</haxe_doc>
		</paddingTop>
		<page public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page" CSS property.</haxe_doc>
		</page>
		<pageBreakAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-after" CSS property.</haxe_doc>
		</pageBreakAfter>
		<pageBreakBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-before" CSS property.</haxe_doc>
		</pageBreakBefore>
		<pageBreakInside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-break-inside" CSS property.</haxe_doc>
		</pageBreakInside>
		<pagePolicy public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "page-policy" CSS property.</haxe_doc>
		</pagePolicy>
		<pause public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause" CSS property.</haxe_doc>
		</pause>
		<pauseAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause-after" CSS property.</haxe_doc>
		</pauseAfter>
		<pauseBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pause-before" CSS property.</haxe_doc>
		</pauseBefore>
		<perspective public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "perspective" CSS property.</haxe_doc>
		</perspective>
		<perspectiveOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "perspective-origin" CSS property.</haxe_doc>
		</perspectiveOrigin>
		<pitch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pitch" CSS property.</haxe_doc>
		</pitch>
		<pitchRange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "pitch-range" CSS property.</haxe_doc>
		</pitchRange>
		<playDuring public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "play-during" CSS property.</haxe_doc>
		</playDuring>
		<position public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "position" CSS property.</haxe_doc>
		</position>
		<presentationLevel public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "presentation-level" CSS property.</haxe_doc>
		</presentationLevel>
		<quotes public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "quotes" CSS property.</haxe_doc>
		</quotes>
		<regionFragment public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "region-fragment" CSS property.</haxe_doc>
		</regionFragment>
		<resize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "resize" CSS property.</haxe_doc>
		</resize>
		<rest public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest" CSS property.</haxe_doc>
		</rest>
		<restAfter public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest-after" CSS property.</haxe_doc>
		</restAfter>
		<restBefore public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rest-before" CSS property.</haxe_doc>
		</restBefore>
		<richness public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "richness" CSS property.</haxe_doc>
		</richness>
		<right public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "right" CSS property.</haxe_doc>
		</right>
		<rotation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rotation" CSS property.</haxe_doc>
		</rotation>
		<rotationPoint public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "rotation-point" CSS property.</haxe_doc>
		</rotationPoint>
		<rubyAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-align" CSS property.</haxe_doc>
		</rubyAlign>
		<rubyMerge public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-merge" CSS property.</haxe_doc>
		</rubyMerge>
		<rubyPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "ruby-position" CSS property.</haxe_doc>
		</rubyPosition>
		<shapeImageThreshold public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-image-threshold" CSS property.</haxe_doc>
		</shapeImageThreshold>
		<shapeOutside public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-outside" CSS property.</haxe_doc>
		</shapeOutside>
		<shapeMargin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "shape-margin" CSS property.</haxe_doc>
		</shapeMargin>
		<size public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "size" CSS property.</haxe_doc>
		</size>
		<speak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak" CSS property.</haxe_doc>
		</speak>
		<speakAs public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-as" CSS property.</haxe_doc>
		</speakAs>
		<speakHeader public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-header" CSS property.</haxe_doc>
		</speakHeader>
		<speakNumeral public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-numeral" CSS property.</haxe_doc>
		</speakNumeral>
		<speakPunctuation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speak-punctuation" CSS property.</haxe_doc>
		</speakPunctuation>
		<speechRate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "speech-rate" CSS property.</haxe_doc>
		</speechRate>
		<stress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "stress" CSS property.</haxe_doc>
		</stress>
		<stringSet public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "string-set" CSS property.</haxe_doc>
		</stringSet>
		<tabSize public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "tab-size" CSS property.</haxe_doc>
		</tabSize>
		<tableLayout public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "table-layout" CSS property.</haxe_doc>
		</tableLayout>
		<textAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-align" CSS property.</haxe_doc>
		</textAlign>
		<textAlignLast public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-align-last" CSS property.</haxe_doc>
		</textAlignLast>
		<textCombineUpright public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-combine-upright" CSS property.</haxe_doc>
		</textCombineUpright>
		<textDecoration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration" CSS property.</haxe_doc>
		</textDecoration>
		<textDecorationColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-color" CSS property.</haxe_doc>
		</textDecorationColor>
		<textDecorationLine public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-line" CSS property.</haxe_doc>
		</textDecorationLine>
		<textDecorationSkip public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-skip" CSS property.</haxe_doc>
		</textDecorationSkip>
		<textDecorationStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-decoration-style" CSS property.</haxe_doc>
		</textDecorationStyle>
		<textEmphasis public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis" CSS property.</haxe_doc>
		</textEmphasis>
		<textEmphasisColor public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-color" CSS property.</haxe_doc>
		</textEmphasisColor>
		<textEmphasisPosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-position" CSS property.</haxe_doc>
		</textEmphasisPosition>
		<textEmphasisStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-emphasis-style" CSS property.</haxe_doc>
		</textEmphasisStyle>
		<textHeight public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-height" CSS property.</haxe_doc>
		</textHeight>
		<textIndent public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-indent" CSS property.</haxe_doc>
		</textIndent>
		<textJustify public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-justify" CSS property.</haxe_doc>
		</textJustify>
		<textOrientation public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-orientation" CSS property.</haxe_doc>
		</textOrientation>
		<textOverflow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-overflow" CSS property.</haxe_doc>
		</textOverflow>
		<textShadow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-shadow" CSS property.</haxe_doc>
		</textShadow>
		<textSpaceCollapse public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-space-collapse" CSS property.</haxe_doc>
		</textSpaceCollapse>
		<textTransform public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-transform" CSS property.</haxe_doc>
		</textTransform>
		<textUnderlinePosition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-underline-position" CSS property.</haxe_doc>
		</textUnderlinePosition>
		<textWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "text-wrap" CSS property.</haxe_doc>
		</textWrap>
		<top public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "top" CSS property.</haxe_doc>
		</top>
		<transform public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform" CSS property.</haxe_doc>
		</transform>
		<transformOrigin public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform-origin" CSS property.</haxe_doc>
		</transformOrigin>
		<transformStyle public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transform-style" CSS property.</haxe_doc>
		</transformStyle>
		<transition public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition" CSS property.</haxe_doc>
		</transition>
		<transitionDelay public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-delay" CSS property.</haxe_doc>
		</transitionDelay>
		<transitionDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-duration" CSS property.</haxe_doc>
		</transitionDuration>
		<transitionProperty public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-property" CSS property.</haxe_doc>
		</transitionProperty>
		<transitionTimingFunction public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "transition-timing-function" CSS property.</haxe_doc>
		</transitionTimingFunction>
		<unicodeBidi public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "unicode-bidi" CSS property.</haxe_doc>
		</unicodeBidi>
		<verticalAlign public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "vertical-align" CSS property.</haxe_doc>
		</verticalAlign>
		<visibility public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "visibility" CSS property.</haxe_doc>
		</visibility>
		<voiceBalance public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-balance" CSS property.</haxe_doc>
		</voiceBalance>
		<voiceDuration public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-duration" CSS property.</haxe_doc>
		</voiceDuration>
		<voiceFamily public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-family" CSS property.</haxe_doc>
		</voiceFamily>
		<voicePitch public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-pitch" CSS property.</haxe_doc>
		</voicePitch>
		<voiceRange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-range" CSS property.</haxe_doc>
		</voiceRange>
		<voiceRate public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-rate" CSS property.</haxe_doc>
		</voiceRate>
		<voiceStress public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-stress" CSS property.</haxe_doc>
		</voiceStress>
		<voiceVolume public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "voice-volume" CSS property.</haxe_doc>
		</voiceVolume>
		<volume public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "volume" CSS property.</haxe_doc>
		</volume>
		<whiteSpace public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "white-space" CSS property.</haxe_doc>
		</whiteSpace>
		<widows public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "widows" CSS property.</haxe_doc>
		</widows>
		<width public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "width" CSS property.</haxe_doc>
		</width>
		<willChange public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "will-change" CSS property.</haxe_doc>
		</willChange>
		<wordBreak public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-break" CSS property.</haxe_doc>
		</wordBreak>
		<wordSpacing public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-spacing" CSS property.</haxe_doc>
		</wordSpacing>
		<wordWrap public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "word-wrap" CSS property.</haxe_doc>
		</wordWrap>
		<wrapFlow public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "wrap-flow" CSS property.</haxe_doc>
		</wrapFlow>
		<wrapThrough public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "wrap-through" CSS property.</haxe_doc>
		</wrapThrough>
		<writingMode public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "writing-mode" CSS property.</haxe_doc>
		</writingMode>
		<zIndex public="1">
			<c path="String"/>
			<haxe_doc>Shorthand for the "z-index" CSS property.</haxe_doc>
		</zIndex>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<getPropertyValue public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getPropertyValue>
		<getPropertyCSSValue public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="js.html.CSSValue"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getPropertyCSSValue>
		<getPropertyPriority public="1" set="method"><f a="property">
	<c path="String"/>
	<c path="String"/>
</f></getPropertyPriority>
		<setProperty public="1" set="method">
			<f a="property:value:?priority" v="::&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{priority:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setProperty>
		<removeProperty public="1" set="method">
			<f a="property">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeProperty>
		<meta><m n=":native"><e>"CSSStyleDeclaration"</e></m></meta>
	</class>
	<class path="js.html.StyleSheet" params="" file="/usr/lib/haxe/std/js/html/StyleSheet.hx" extern="1">
		<type public="1" set="null"><c path="String"/></type>
		<href public="1" set="null"><c path="String"/></href>
		<ownerNode public="1" set="null"><c path="js.html.Node"/></ownerNode>
		<parentStyleSheet public="1" set="null"><c path="js.html.StyleSheet"/></parentStyleSheet>
		<title public="1" set="null"><c path="String"/></title>
		<media public="1" set="null"><c path="js.html.MediaList"/></media>
		<disabled public="1"><x path="Bool"/></disabled>
		<meta><m n=":native"><e>"StyleSheet"</e></m></meta>
	</class>
	<class path="js.html.CSSStyleSheet" params="" file="/usr/lib/haxe/std/js/html/CSSStyleSheet.hx" extern="1">
		<extends path="js.html.StyleSheet"/>
		<ownerRule public="1" set="null"><c path="js.html.CSSRule"/></ownerRule>
		<cssRules public="1" set="null"><c path="js.html.CSSRuleList"/></cssRules>
		<insertRule public="1" set="method">
			<f a="rule:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRule>
		<deleteRule public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRule>
		<meta><m n=":native"><e>"CSSStyleSheet"</e></m></meta>
	</class>
	<class path="js.html.CSSValue" params="" file="/usr/lib/haxe/std/js/html/CSSValue.hx" extern="1">
		<CSS_INHERIT public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</CSS_INHERIT>
		<CSS_PRIMITIVE_VALUE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CSS_PRIMITIVE_VALUE>
		<CSS_VALUE_LIST public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CSS_VALUE_LIST>
		<CSS_CUSTOM public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CSS_CUSTOM>
		<cssText public="1"><c path="String"/></cssText>
		<cssValueType public="1" set="null"><x path="Int"/></cssValueType>
		<meta><m n=":native"><e>"CSSValue"</e></m></meta>
	</class>
	<class path="js.html.CanvasElement" params="" file="/usr/lib/haxe/std/js/html/CanvasElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<getContext public="1" set="method">
			<f a="contextId:?contextOptions">
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getContext>
		<toDataURL public="1" set="method">
			<f a="?type:?encoderOptions" v="&quot;&quot;:">
				<c path="String"/>
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{type:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toDataURL>
		<toBlob public="1" set="method">
			<f a="callback:?type:?encoderOptions" v=":&quot;&quot;:">
				<f a="">
					<c path="js.html.Blob"/>
					<x path="Void"/>
				</f>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{type:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toBlob>
		<getContext2d public="1" get="inline" set="null" line="41">
			<f a="?attribs">
				<a/>
				<c path="js.html.CanvasRenderingContext2D"/>
			</f>
			<haxe_doc>Shorthand for getting a CanvasRenderingContext2D.</haxe_doc>
		</getContext2d>
		<getContextWebGL public="1" get="inline" set="null" line="45">
			<f a="?attribs">
				<t path="js.html.webgl.ContextAttributes"/>
				<c path="js.html.webgl.RenderingContext"/>
			</f>
			<haxe_doc>Shorthand for getting a js.html.webgl.RenderingContext.</haxe_doc>
		</getContextWebGL>
		<meta><m n=":native"><e>"HTMLCanvasElement"</e></m></meta>
	</class>
	<class path="js.html.CanvasGradient" params="" file="/usr/lib/haxe/std/js/html/CanvasGradient.hx" extern="1">
		<addColorStop public="1" set="method">
			<f a="offset:color">
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addColorStop>
		<meta><m n=":native"><e>"CanvasGradient"</e></m></meta>
	</class>
	<class path="js.html.CanvasPattern" params="" file="/usr/lib/haxe/std/js/html/CanvasPattern.hx" extern="1">
		<setTransform public="1" set="method"><f a="matrix">
	<c path="js.html.svg.Matrix"/>
	<x path="Void"/>
</f></setTransform>
		<meta><m n=":native"><e>"CanvasPattern"</e></m></meta>
	</class>
	<class path="js.html.CanvasRenderingContext2D" params="" file="/usr/lib/haxe/std/js/html/CanvasRenderingContext2D.hx" extern="1">
		<canvas public="1" set="null"><c path="js.html.CanvasElement"/></canvas>
		<globalAlpha public="1"><x path="Float"/></globalAlpha>
		<globalCompositeOperation public="1"><c path="String"/></globalCompositeOperation>
		<strokeStyle public="1"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.CanvasGradient"/>
		<c path="js.html.CanvasPattern"/>
	</x>
</x></strokeStyle>
		<fillStyle public="1"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.CanvasGradient"/>
		<c path="js.html.CanvasPattern"/>
	</x>
</x></fillStyle>
		<shadowOffsetX public="1"><x path="Float"/></shadowOffsetX>
		<shadowOffsetY public="1"><x path="Float"/></shadowOffsetY>
		<shadowBlur public="1"><x path="Float"/></shadowBlur>
		<shadowColor public="1"><c path="String"/></shadowColor>
		<filter public="1"><c path="String"/></filter>
		<imageSmoothingEnabled public="1"><x path="Bool"/></imageSmoothingEnabled>
		<lineWidth public="1"><x path="Float"/></lineWidth>
		<lineCap public="1"><c path="String"/></lineCap>
		<lineJoin public="1"><c path="String"/></lineJoin>
		<miterLimit public="1"><x path="Float"/></miterLimit>
		<lineDashOffset public="1"><x path="Float"/></lineDashOffset>
		<font public="1"><c path="String"/></font>
		<textAlign public="1"><c path="String"/></textAlign>
		<textBaseline public="1"><c path="String"/></textBaseline>
		<save public="1" set="method"><f a=""><x path="Void"/></f></save>
		<restore public="1" set="method"><f a=""><x path="Void"/></f></restore>
		<scale public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</scale>
		<rotate public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</rotate>
		<translate public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</translate>
		<transform public="1" set="method">
			<f a="a:b:c:d:e:f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</transform>
		<setTransform public="1" set="method">
			<f a="a:b:c:d:e:f">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setTransform>
		<resetTransform public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resetTransform>
		<createLinearGradient public="1" set="method"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.CanvasGradient"/>
</f></createLinearGradient>
		<createRadialGradient public="1" set="method">
			<f a="x0:y0:r0:x1:y1:r1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.CanvasGradient"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createRadialGradient>
		<createPattern public="1" set="method">
			<f a="image:repetition">
				<x path="haxe.extern.EitherType">
					<c path="js.html.ImageElement"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.CanvasElement"/>
						<c path="js.html.VideoElement"/>
					</x>
				</x>
				<c path="String"/>
				<c path="js.html.CanvasPattern"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createPattern>
		<clearRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearRect>
		<fillRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<strokeRect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></strokeRect>
		<beginPath public="1" set="method"><f a=""><x path="Void"/></f></beginPath>
		<fill public="1" set="method">
			<f a="path:?winding" v=":&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><fill public="1" set="method">
	<f a="?winding" v="&quot;nonzero&quot;">
		<x path="js.html.CanvasWindingRule"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</fill></overloads>
		</fill>
		<stroke public="1" set="method">
			<f a="path">
				<c path="js.html.Path2D"/>
				<x path="Void"/>
			</f>
			<overloads><stroke public="1" set="method"><f a=""><x path="Void"/></f></stroke></overloads>
		</stroke>
		<drawFocusIfNeeded public="1" set="method"><f a="element">
	<c path="js.html.Element"/>
	<x path="Void"/>
</f></drawFocusIfNeeded>
		<drawCustomFocusRing public="1" set="method"><f a="element">
	<c path="js.html.Element"/>
	<x path="Bool"/>
</f></drawCustomFocusRing>
		<clip public="1" set="method">
			<f a="path:?winding" v=":&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><clip public="1" set="method">
	<f a="?winding" v="&quot;nonzero&quot;">
		<x path="js.html.CanvasWindingRule"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</clip></overloads>
		</clip>
		<isPointInPath public="1" set="method">
			<f a="path:x:y:?winding" v=":::&quot;nonzero&quot;">
				<c path="js.html.Path2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="js.html.CanvasWindingRule"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
			<overloads><isPointInPath public="1" set="method">
	<f a="x:y:?winding" v="::&quot;nonzero&quot;">
		<x path="Float"/>
		<x path="Float"/>
		<x path="js.html.CanvasWindingRule"/>
		<x path="Bool"/>
	</f>
	<meta><m n=":value"><e>{winding:"nonzero"}</e></m></meta>
</isPointInPath></overloads>
		</isPointInPath>
		<isPointInStroke public="1" set="method">
			<f a="path:x:y">
				<c path="js.html.Path2D"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<overloads><isPointInStroke public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isPointInStroke></overloads>
		</isPointInStroke>
		<fillText public="1" set="method">
			<f a="text:x:y:?maxWidth">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</fillText>
		<strokeText public="1" set="method">
			<f a="text:x:y:?maxWidth">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</strokeText>
		<measureText public="1" set="method">
			<f a="text">
				<c path="String"/>
				<c path="js.html.TextMetrics"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</measureText>
		<drawImage public="1" set="method">
			<f a="image:sx:sy:sw:sh:dx:dy:dw:dh">
				<x path="haxe.extern.EitherType">
					<c path="js.html.ImageElement"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.CanvasElement"/>
						<c path="js.html.VideoElement"/>
					</x>
				</x>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<drawImage public="1" set="method">
					<f a="image:dx:dy">
						<x path="haxe.extern.EitherType">
							<c path="js.html.ImageElement"/>
							<x path="haxe.extern.EitherType">
								<c path="js.html.CanvasElement"/>
								<c path="js.html.VideoElement"/>
							</x>
						</x>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</drawImage>
				<drawImage public="1" set="method">
					<f a="image:dx:dy:dw:dh">
						<x path="haxe.extern.EitherType">
							<c path="js.html.ImageElement"/>
							<x path="haxe.extern.EitherType">
								<c path="js.html.CanvasElement"/>
								<c path="js.html.VideoElement"/>
							</x>
						</x>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</drawImage>
			</overloads>
		</drawImage>
		<addHitRegion public="1" set="method">
			<f a="?options">
				<t path="js.html.HitRegionOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addHitRegion>
		<removeHitRegion public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></removeHitRegion>
		<clearHitRegions public="1" set="method"><f a=""><x path="Void"/></f></clearHitRegions>
		<createImageData public="1" set="method">
			<f a="imagedata">
				<c path="js.html.ImageData"/>
				<c path="js.html.ImageData"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createImageData public="1" set="method">
	<f a="sw:sh">
		<x path="Float"/>
		<x path="Float"/>
		<c path="js.html.ImageData"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createImageData></overloads>
		</createImageData>
		<getImageData public="1" set="method">
			<f a="sx:sy:sw:sh">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.ImageData"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getImageData>
		<putImageData public="1" set="method">
			<f a="imagedata:dx:dy:dirtyX:dirtyY:dirtyWidth:dirtyHeight">
				<c path="js.html.ImageData"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><putImageData public="1" set="method">
	<f a="imagedata:dx:dy">
		<c path="js.html.ImageData"/>
		<x path="Float"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</putImageData></overloads>
		</putImageData>
		<setLineDash public="1" set="method"><f a="segments">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setLineDash>
		<getLineDash public="1" set="method"><f a=""><c path="Array"><x path="Float"/></c></f></getLineDash>
		<closePath public="1" set="method"><f a=""><x path="Void"/></f></closePath>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadraticCurveTo public="1" set="method"><f a="cpx:cpy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<bezierCurveTo public="1" set="method"><f a="cp1x:cp1y:cp2x:cp2y:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bezierCurveTo>
		<arcTo public="1" set="method">
			<f a="x1:y1:x2:y2:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arcTo>
		<rect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rect>
		<arc public="1" set="method">
			<f a="x:y:radius:startAngle:endAngle:?anticlockwise" v=":::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{anticlockwise:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arc>
		<meta><m n=":native"><e>"CanvasRenderingContext2D"</e></m></meta>
	</class>
	<abstract path="js.html.CanvasWindingRule" params="" file="/usr/lib/haxe/std/js/html/CanvasWindingRule.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._CanvasWindingRule.CanvasWindingRule_Impl_" params="" file="/usr/lib/haxe/std/js/html/CanvasWindingRule.hx" private="1" module="js.html.CanvasWindingRule"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.CaretPosition" params="" file="/usr/lib/haxe/std/js/html/CaretPosition.hx" extern="1">
		<offsetNode public="1" set="null"><c path="js.html.Node"/></offsetNode>
		<offset public="1" set="null"><x path="Int"/></offset>
		<getClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getClientRect>
		<meta><m n=":native"><e>"CaretPosition"</e></m></meta>
	</class>
	<typedef path="js.html.ChromeFilePropertyBag" params="" file="/usr/lib/haxe/std/js/html/ChromeFilePropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<temporary>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</temporary>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<lastModified>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</lastModified>
</a></typedef>
	<class path="js.html.Comment" params="" file="/usr/lib/haxe/std/js/html/Comment.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<new public="1" set="method">
			<f a="?data" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{data:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Comment"</e></m></meta>
	</class>
	<class path="js.html.Console" params="" file="/usr/lib/haxe/std/js/html/Console.hx" extern="1">
		<log public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></log>
		<info public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></info>
		<warn public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></warn>
		<error public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></error>
		<exception public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></exception>
		<debug public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></debug>
		<table public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></table>
		<trace public="1" set="method"><f a=""><x path="Void"/></f></trace>
		<dir public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></dir>
		<group public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></group>
		<groupCollapsed public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></groupCollapsed>
		<groupEnd public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></groupEnd>
		<time public="1" set="method"><f a="?time">
	<d/>
	<x path="Void"/>
</f></time>
		<timeEnd public="1" set="method"><f a="?time">
	<d/>
	<x path="Void"/>
</f></timeEnd>
		<profile public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></profile>
		<profileEnd public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></profileEnd>
		<assert public="1" set="method"><f a="condition:data">
	<x path="Bool"/>
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></assert>
		<count public="1" set="method"><f a="data">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></count>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<meta><m n=":native"><e>"Console"</e></m></meta>
	</class>
	<class path="js.html.ContentElement" params="" file="/usr/lib/haxe/std/js/html/ContentElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<select public="1"><c path="String"/></select>
		<getDistributedNodes public="1" set="method"><f a=""><c path="js.html.NodeList"/></f></getDistributedNodes>
		<meta><m n=":native"><e>"HTMLContentElement"</e></m></meta>
	</class>
	<typedef path="js.html.ConvertCoordinateOptions" params="" file="/usr/lib/haxe/std/js/html/ConvertCoordinateOptions.hx"><a>
	<toBox>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</toBox>
	<fromBox>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</fromBox>
</a></typedef>
	<class path="js.html.Coordinates" params="" file="/usr/lib/haxe/std/js/html/Coordinates.hx" extern="1">
		<latitude public="1" set="null"><x path="Float"/></latitude>
		<longitude public="1" set="null"><x path="Float"/></longitude>
		<altitude public="1" set="null"><x path="Float"/></altitude>
		<accuracy public="1" set="null"><x path="Float"/></accuracy>
		<altitudeAccuracy public="1" set="null"><x path="Float"/></altitudeAccuracy>
		<heading public="1" set="null"><x path="Float"/></heading>
		<speed public="1" set="null"><x path="Float"/></speed>
		<meta><m n=":native"><e>"Coordinates"</e></m></meta>
	</class>
	<class path="js.html.DListElement" params="" file="/usr/lib/haxe/std/js/html/DListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLDListElement"</e></m></meta>
	</class>
	<class path="js.html.DOMError" params="" file="/usr/lib/haxe/std/js/html/DOMError.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<message public="1" set="null"><c path="String"/></message>
		<new public="1" set="method">
			<f a="name:?message" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"DOMError"</e></m></meta>
	</class>
	<class path="js.html.DOMImplementation" params="" file="/usr/lib/haxe/std/js/html/DOMImplementation.hx" extern="1">
		<hasFeature public="1" set="method"><f a="feature:version">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasFeature>
		<createDocumentType public="1" set="method">
			<f a="qualifiedName:publicId:systemId">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.DocumentType"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createDocumentType>
		<createDocument public="1" set="method">
			<f a="namespace_:qualifiedName:?doctype">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.DocumentType"/>
				<c path="js.html.HTMLDocument"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createDocument>
		<createHTMLDocument public="1" set="method">
			<f a="?title">
				<c path="String"/>
				<c path="js.html.HTMLDocument"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createHTMLDocument>
		<meta><m n=":native"><e>"DOMImplementation"</e></m></meta>
	</class>
	<class path="js.html.DOMPointReadOnly" params="" file="/usr/lib/haxe/std/js/html/DOMPointReadOnly.hx" extern="1">
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<z public="1" set="null"><x path="Float"/></z>
		<w public="1" set="null"><x path="Float"/></w>
		<meta><m n=":native"><e>"DOMPointReadOnly"</e></m></meta>
	</class>
	<class path="js.html.DOMPoint" params="" file="/usr/lib/haxe/std/js/html/DOMPoint.hx" extern="1">
		<extends path="js.html.DOMPointReadOnly"/>
		<new public="1" set="method">
			<f a="x:y:?z:?w" v="::0.0:1.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{w:1.0,z:0.0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?point">
		<t path="js.html.DOMPointInit"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMPoint"</e></m></meta>
	</class>
	<typedef path="js.html.DOMPointInit" params="" file="/usr/lib/haxe/std/js/html/DOMPointInit.hx"><a>
	<z>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</z>
	<y>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</y>
	<x>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</x>
	<w>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</w>
</a></typedef>
	<class path="js.html.DOMQuad" params="" file="/usr/lib/haxe/std/js/html/DOMQuad.hx" extern="1">
		<p1 public="1" set="null"><c path="js.html.DOMPoint"/></p1>
		<p2 public="1" set="null"><c path="js.html.DOMPoint"/></p2>
		<p3 public="1" set="null"><c path="js.html.DOMPoint"/></p3>
		<p4 public="1" set="null"><c path="js.html.DOMPoint"/></p4>
		<bounds public="1" set="null"><c path="js.html.DOMRectReadOnly"/></bounds>
		<new public="1" set="method">
			<f a="rect">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?p1:?p2:?p3:?p4">
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<t path="js.html.DOMPointInit"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMQuad"</e></m></meta>
	</class>
	<class path="js.html.DOMRectReadOnly" params="" file="/usr/lib/haxe/std/js/html/DOMRectReadOnly.hx" extern="1">
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<top public="1" set="null"><x path="Float"/></top>
		<right public="1" set="null"><x path="Float"/></right>
		<bottom public="1" set="null"><x path="Float"/></bottom>
		<left public="1" set="null"><x path="Float"/></left>
		<meta><m n=":native"><e>"DOMRectReadOnly"</e></m></meta>
	</class>
	<class path="js.html.DOMRect" params="" file="/usr/lib/haxe/std/js/html/DOMRect.hx" extern="1">
		<extends path="js.html.DOMRectReadOnly"/>
		<new public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"DOMRect"</e></m></meta>
	</class>
	<class path="js.html.DOMRectList" params="" file="/usr/lib/haxe/std/js/html/DOMRectList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.DOMRect"/>
</f></item>
		<meta><m n=":native"><e>"DOMRectList"</e></m></meta>
	</class>
	<class path="js.html.DOMTokenList" params="" file="/usr/lib/haxe/std/js/html/DOMTokenList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<contains public="1" set="method">
			<f a="token">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</contains>
		<add public="1" set="method">
			<f a="tokens">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<remove public="1" set="method">
			<f a="tokens">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</remove>
		<toggle public="1" set="method">
			<f a="token:?force">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</toggle>
		<meta><m n=":native"><e>"DOMTokenList"</e></m></meta>
	</class>
	<class path="js.html.DOMSettableTokenList" params="" file="/usr/lib/haxe/std/js/html/DOMSettableTokenList.hx" extern="1">
		<extends path="js.html.DOMTokenList"/>
		<value public="1"><c path="String"/></value>
		<meta><m n=":native"><e>"DOMSettableTokenList"</e></m></meta>
	</class>
	<class path="js.html.DOMStringList" params="" file="/usr/lib/haxe/std/js/html/DOMStringList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<contains public="1" set="method"><f a="string">
	<c path="String"/>
	<x path="Bool"/>
</f></contains>
		<meta><m n=":native"><e>"DOMStringList"</e></m></meta>
	</class>
	<class path="js.html.DOMStringMap" params="" file="/usr/lib/haxe/std/js/html/DOMStringMap.hx" extern="1">
		<meta><m n=":native"><e>"DOMStringMap"</e></m></meta>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="js.html.DataListElement" params="" file="/usr/lib/haxe/std/js/html/DataListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<options public="1" set="null"><c path="js.html.HTMLCollection"/></options>
		<meta><m n=":native"><e>"HTMLDataListElement"</e></m></meta>
	</class>
	<abstract path="js.html.DirectionSetting" params="" file="/usr/lib/haxe/std/js/html/DirectionSetting.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._DirectionSetting.DirectionSetting_Impl_" params="" file="/usr/lib/haxe/std/js/html/DirectionSetting.hx" private="1" module="js.html.DirectionSetting"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.DirectoryElement" params="" file="/usr/lib/haxe/std/js/html/DirectoryElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLDirectoryElement"</e></m></meta>
	</class>
	<class path="js.html.DivElement" params="" file="/usr/lib/haxe/std/js/html/DivElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLDivElement"</e></m></meta>
	</class>
	<class path="js.html.Document" params="" file="/usr/lib/haxe/std/js/html/Document.hx" extern="1">
		<extends path="js.html.Node"/>
		<implementation public="1" set="null"><c path="js.html.DOMImplementation"/></implementation>
		<URL public="1" set="null"><c path="String"/></URL>
		<documentURI public="1" set="null"><c path="String"/></documentURI>
		<compatMode public="1" set="null"><c path="String"/></compatMode>
		<characterSet public="1" set="null"><c path="String"/></characterSet>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<doctype public="1" set="null"><c path="js.html.DocumentType"/></doctype>
		<documentElement public="1" set="null"><c path="js.html.Element"/></documentElement>
		<inputEncoding public="1" set="null"><c path="String"/></inputEncoding>
		<fullscreenEnabled public="1" set="null"><x path="Bool"/></fullscreenEnabled>
		<fullscreenElement public="1" set="null"><c path="js.html.Element"/></fullscreenElement>
		<onfullscreenchange public="1"><x path="haxe.Function"/></onfullscreenchange>
		<onfullscreenerror public="1"><x path="haxe.Function"/></onfullscreenerror>
		<location public="1" set="null"><c path="js.html.Location"/></location>
		<referrer public="1" set="null"><c path="String"/></referrer>
		<lastModified public="1" set="null"><c path="String"/></lastModified>
		<readyState public="1" set="null"><c path="String"/></readyState>
		<title public="1"><c path="String"/></title>
		<dir public="1"><c path="String"/></dir>
		<defaultView public="1" set="null"><c path="js.html.Window"/></defaultView>
		<activeElement public="1" set="null"><c path="js.html.Element"/></activeElement>
		<onreadystatechange public="1"><x path="haxe.Function"/></onreadystatechange>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<oncopy public="1"><x path="haxe.Function"/></oncopy>
		<oncut public="1"><x path="haxe.Function"/></oncut>
		<onpaste public="1"><x path="haxe.Function"/></onpaste>
		<onbeforescriptexecute public="1"><x path="haxe.Function"/></onbeforescriptexecute>
		<onafterscriptexecute public="1"><x path="haxe.Function"/></onafterscriptexecute>
		<currentScript public="1" set="null"><c path="js.html.Element"/></currentScript>
		<pointerLockElement public="1" set="null"><c path="js.html.Element"/></pointerLockElement>
		<hidden public="1" set="null"><x path="Bool"/></hidden>
		<visibilityState public="1" set="null"><x path="js.html.VisibilityState"/></visibilityState>
		<styleSheets public="1" set="null"><c path="js.html.StyleSheetList"/></styleSheets>
		<selectedStyleSheetSet public="1"><c path="String"/></selectedStyleSheetSet>
		<lastStyleSheetSet public="1" set="null"><c path="String"/></lastStyleSheetSet>
		<preferredStyleSheetSet public="1" set="null"><c path="String"/></preferredStyleSheetSet>
		<styleSheetSets public="1" set="null"><c path="js.html.DOMStringList"/></styleSheetSets>
		<timeline public="1" set="null"><c path="js.html.AnimationTimeline"/></timeline>
		<fonts public="1" set="null"><c path="js.html.FontFaceSet"/></fonts>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method">
			<f a="namespace_:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.HTMLCollection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<getElementById public="1" set="method"><f a="elementId">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></getElementById>
		<createElement public="1" set="method">
			<f a="localName:typeExtension">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createElement public="1" set="method">
	<f a="localName">
		<c path="String"/>
		<c path="js.html.Element"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createElement></overloads>
		</createElement>
		<createElementNS public="1" set="method">
			<f a="namespace_:qualifiedName:typeExtension">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createElementNS public="1" set="method">
	<f a="namespace_:qualifiedName">
		<c path="String"/>
		<c path="String"/>
		<c path="js.html.Element"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createElementNS></overloads>
		</createElementNS>
		<createDocumentFragment public="1" set="method"><f a=""><c path="js.html.DocumentFragment"/></f></createDocumentFragment>
		<createTextNode public="1" set="method"><f a="data">
	<c path="String"/>
	<c path="js.html.Text"/>
</f></createTextNode>
		<createComment public="1" set="method"><f a="data">
	<c path="String"/>
	<c path="js.html.Comment"/>
</f></createComment>
		<createProcessingInstruction public="1" set="method">
			<f a="target:data">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.ProcessingInstruction"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createProcessingInstruction>
		<importNode public="1" set="method">
			<f a="node:?deep" v=":false">
				<c path="js.html.Node"/>
				<x path="Bool"/>
				<c path="js.html.Node"/>
			</f>
			<meta><m n=":value"><e>{deep:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</importNode>
		<adoptNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</adoptNode>
		<createEvent public="1" set="method">
			<f a="interface_">
				<c path="String"/>
				<c path="js.html.Event"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createEvent>
		<createRange public="1" set="method">
			<f a=""><c path="js.html.Range"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createRange>
		<createNodeIterator public="1" set="method">
			<f a="root:?whatToShow:?filter" v=":&apos;???&apos;:">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<c path="js.html.NodeFilter"/>
				<c path="js.html.NodeIterator"/>
			</f>
			<meta><m n=":value"><e>{whatToShow:'???'}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createNodeIterator>
		<createTreeWalker public="1" set="method">
			<f a="root:?whatToShow:?filter" v=":&apos;???&apos;:">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<c path="js.html.NodeFilter"/>
				<c path="js.html.TreeWalker"/>
			</f>
			<meta><m n=":value"><e>{whatToShow:'???'}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createTreeWalker>
		<createCDATASection public="1" set="method">
			<f a="data">
				<c path="String"/>
				<c path="js.html.CDATASection"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createCDATASection>
		<createAttribute public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createAttribute>
		<createAttributeNS public="1" set="method">
			<f a="namespace_:name">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createAttributeNS>
		<exitFullscreen public="1" set="method"><f a=""><x path="Void"/></f></exitFullscreen>
		<hasFocus public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</hasFocus>
		<releaseCapture public="1" set="method"><f a=""><x path="Void"/></f></releaseCapture>
		<exitPointerLock public="1" set="method"><f a=""><x path="Void"/></f></exitPointerLock>
		<registerElement public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.ElementRegistrationOptions"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerElement>
		<enableStyleSheetsForSet public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></enableStyleSheetsForSet>
		<elementFromPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.Element"/>
</f></elementFromPoint>
		<caretPositionFromPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.CaretPosition"/>
</f></caretPositionFromPoint>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<createTouch public="1" set="method">
			<f a="?view:?target:?identifier:?pageX:?pageY:?screenX:?screenY:?clientX:?clientY:?radiusX:?radiusY:?rotationAngle:?force" v="::0:0:0:0:0:0:0:0:0:0.0:0.0">
				<c path="js.html.Window"/>
				<c path="js.html.EventTarget"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.Touch"/>
			</f>
			<meta><m n=":value"><e>{force:0.0,rotationAngle:0.0,radiusY:0,radiusX:0,clientY:0,clientX:0,screenY:0,screenX:0,pageY:0,pageX:0,identifier:0}</e></m></meta>
		</createTouch>
		<createTouchList public="1" set="method">
			<f a="touches">
				<c path="Array"><c path="js.html.Touch"/></c>
				<c path="js.html.TouchList"/>
			</f>
			<overloads>
				<createTouchList public="1" set="method"><f a="touch:touches">
	<c path="js.html.Touch"/>
	<x path="haxe.extern.Rest"><c path="js.html.Touch"/></x>
	<c path="js.html.TouchList"/>
</f></createTouchList>
				<createTouchList public="1" set="method"><f a=""><c path="js.html.TouchList"/></f></createTouchList>
			</overloads>
		</createTouchList>
		<convertQuadFromNode public="1" set="method">
			<f a="quad:from:?options">
				<c path="js.html.DOMQuad"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertQuadFromNode>
		<convertRectFromNode public="1" set="method">
			<f a="rect:from:?options">
				<c path="js.html.DOMRectReadOnly"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMQuad"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertRectFromNode>
		<convertPointFromNode public="1" set="method">
			<f a="point:from:?options">
				<t path="js.html.DOMPointInit"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Text"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Element"/>
						<c path="js.html.HTMLDocument"/>
					</x>
				</x>
				<t path="js.html.ConvertCoordinateOptions"/>
				<c path="js.html.DOMPoint"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</convertPointFromNode>
		<createExpression public="1" set="method">
			<f a="expression:resolver">
				<c path="String"/>
				<c path="js.html.XPathNSResolver"/>
				<c path="js.html.XPathExpression"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createExpression>
		<createNSResolver public="1" set="method"><f a="nodeResolver">
	<c path="js.html.Node"/>
	<c path="js.html.Node"/>
</f></createNSResolver>
		<evaluate public="1" set="method">
			<f a="expression:contextNode:resolver:type:result">
				<c path="String"/>
				<c path="js.html.Node"/>
				<c path="js.html.XPathNSResolver"/>
				<x path="Int"/>
				<d/>
				<c path="js.html.XPathResult"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</evaluate>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Document"</e></m></meta>
	</class>
	<class path="js.html.DocumentFragment" params="" file="/usr/lib/haxe/std/js/html/DocumentFragment.hx" extern="1">
		<extends path="js.html.Node"/>
		<children public="1" set="null"><c path="js.html.HTMLCollection"/></children>
		<firstElementChild public="1" set="null"><c path="js.html.Element"/></firstElementChild>
		<lastElementChild public="1" set="null"><c path="js.html.Element"/></lastElementChild>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<getElementById public="1" set="method"><f a="elementId">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></getElementById>
		<querySelector public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.Element"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelector>
		<querySelectorAll public="1" set="method">
			<f a="selectors">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</querySelectorAll>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"DocumentFragment"</e></m></meta>
	</class>
	<class path="js.html.DocumentType" params="" file="/usr/lib/haxe/std/js/html/DocumentType.hx" extern="1">
		<extends path="js.html.Node"/>
		<name public="1" set="null"><c path="String"/></name>
		<publicId public="1" set="null"><c path="String"/></publicId>
		<systemId public="1" set="null"><c path="String"/></systemId>
		<internalSubset public="1" set="null"><c path="String"/></internalSubset>
		<remove public="1" set="method"><f a=""><x path="Void"/></f></remove>
		<meta><m n=":native"><e>"DocumentType"</e></m></meta>
	</class>
	<typedef path="js.html.ElementRegistrationOptions" params="" file="/usr/lib/haxe/std/js/html/ElementRegistrationOptions.hx"><a>
	<prototype>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</prototype>
	<extends_>
		<t path="Null"><c path="String"/></t>
		<meta>
			<m n=":native"><e>"extends"</e></m>
			<m n=":optional"/>
		</meta>
	</extends_>
</a></typedef>
	<class path="js.html.EmbedElement" params="" file="/usr/lib/haxe/std/js/html/EmbedElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<align public="1"><c path="String"/></align>
		<name public="1"><c path="String"/></name>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLEmbedElement"</e></m></meta>
	</class>
	<class path="js.html.Event" params="" file="/usr/lib/haxe/std/js/html/Event.hx" extern="1">
		<NONE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<CAPTURING_PHASE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CAPTURING_PHASE>
		<AT_TARGET public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</AT_TARGET>
		<BUBBLING_PHASE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</BUBBLING_PHASE>
		<ALT_MASK public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ALT_MASK>
		<CONTROL_MASK public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CONTROL_MASK>
		<SHIFT_MASK public="1" get="inline" set="null" expr="4" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</SHIFT_MASK>
		<META_MASK public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</META_MASK>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><c path="js.html.EventTarget"/></target>
		<currentTarget public="1" set="null"><c path="js.html.EventTarget"/></currentTarget>
		<eventPhase public="1" set="null"><x path="Int"/></eventPhase>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<defaultPrevented public="1" set="null"><x path="Bool"/></defaultPrevented>
		<isTrusted public="1" set="null"><x path="Bool"/></isTrusted>
		<timeStamp public="1" set="null"><x path="Float"/></timeStamp>
		<originalTarget public="1" set="null"><c path="js.html.EventTarget"/></originalTarget>
		<explicitOriginalTarget public="1" set="null"><c path="js.html.EventTarget"/></explicitOriginalTarget>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<initEvent public="1" set="method">
			<f a="type:bubbles:cancelable">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</initEvent>
		<getPreventDefault public="1" set="method"><f a=""><x path="Bool"/></f></getPreventDefault>
		<new public="1" set="method">
			<f a="type:?eventInitDict">
				<c path="String"/>
				<t path="js.html.EventInit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Event"</e></m></meta>
	</class>
	<typedef path="js.html.EventInit" params="" file="/usr/lib/haxe/std/js/html/EventInit.hx"><a>
	<cancelable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</cancelable>
	<bubbles>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</bubbles>
</a></typedef>
	<class path="js.html.EventListener" params="" file="/usr/lib/haxe/std/js/html/EventListener.hx" extern="1">
		<handleEvent public="1" set="method"><f a="event">
	<c path="js.html.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<meta><m n=":native"><e>"EventListener"</e></m></meta>
	</class>
	<class path="js.html.FieldSetElement" params="" file="/usr/lib/haxe/std/js/html/FieldSetElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<name public="1"><c path="String"/></name>
		<type public="1" set="null"><c path="String"/></type>
		<elements public="1" set="null"><c path="js.html.HTMLCollection"/></elements>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLFieldSetElement"</e></m></meta>
	</class>
	<class path="js.html.File" params="" file="/usr/lib/haxe/std/js/html/File.hx" extern="1">
		<extends path="js.html.Blob"/>
		<name public="1" set="null"><c path="String"/></name>
		<lastModified public="1" set="null"><x path="Int"/></lastModified>
		<lastModifiedDate public="1" set="null"><c path="Date"/></lastModifiedDate>
		<new public="1" set="method">
			<f a="fileBits:?options">
				<c path="String"/>
				<t path="js.html.ChromeFilePropertyBag"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="fileBits:fileName:?options">
						<c path="Array"><x path="haxe.extern.EitherType">
	<c path="js.html.ArrayBuffer"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<x path="haxe.extern.EitherType">
			<c path="js.html.Blob"/>
			<c path="String"/>
		</x>
	</x>
</x></c>
						<c path="String"/>
						<t path="js.html.FilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="fileBits:?options">
						<c path="js.html.Blob"/>
						<t path="js.html.ChromeFilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="fileBits:?options">
						<d/>
						<t path="js.html.ChromeFilePropertyBag"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"File"</e></m></meta>
	</class>
	<class path="js.html.FileList" params="" file="/usr/lib/haxe/std/js/html/FileList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.File"/>
</f></item>
		<meta><m n=":native"><e>"FileList"</e></m></meta>
	</class>
	<typedef path="js.html.FilePropertyBag" params="" file="/usr/lib/haxe/std/js/html/FilePropertyBag.hx"><a>
	<type>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<lastModified>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</lastModified>
</a></typedef>
	<class path="js.html.Float32Array" params="" file="/usr/lib/haxe/std/js/html/Float32Array.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Float32Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Float32Array"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Float"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Float32Array"</e></m></meta>
	</class>
	<class path="js.html.FontElement" params="" file="/usr/lib/haxe/std/js/html/FontElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<color public="1"><c path="String"/></color>
		<face public="1"><c path="String"/></face>
		<size public="1"><c path="String"/></size>
		<meta><m n=":native"><e>"HTMLFontElement"</e></m></meta>
	</class>
	<class path="js.html.FontFace" params="" file="/usr/lib/haxe/std/js/html/FontFace.hx" extern="1">
		<family public="1"><c path="String"/></family>
		<style public="1"><c path="String"/></style>
		<weight public="1"><c path="String"/></weight>
		<stretch public="1"><c path="String"/></stretch>
		<unicodeRange public="1"><c path="String"/></unicodeRange>
		<variant public="1"><c path="String"/></variant>
		<featureSettings public="1"><c path="String"/></featureSettings>
		<status public="1" set="null"><x path="js.html.FontFaceLoadStatus"/></status>
		<loaded public="1" set="null"><c path="js.Promise"><c path="js.html.FontFace"/></c></loaded>
		<load public="1" set="method">
			<f a=""><c path="js.Promise"><c path="js.html.FontFace"/></c></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</load>
		<new public="1" set="method">
			<f a="family:source:?descriptors">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.ArrayBuffer"/>
						<c path="js.html.ArrayBufferView"/>
					</x>
				</x>
				<t path="js.html.FontFaceDescriptors"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"FontFace"</e></m></meta>
	</class>
	<typedef path="js.html.FontFaceDescriptors" params="" file="/usr/lib/haxe/std/js/html/FontFaceDescriptors.hx"><a>
	<weight>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</weight>
	<variant>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</variant>
	<unicodeRange>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</unicodeRange>
	<style>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</style>
	<stretch>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</stretch>
	<featureSettings>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</featureSettings>
</a></typedef>
	<abstract path="js.html.FontFaceLoadStatus" params="" file="/usr/lib/haxe/std/js/html/FontFaceLoadStatus.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._FontFaceLoadStatus.FontFaceLoadStatus_Impl_" params="" file="/usr/lib/haxe/std/js/html/FontFaceLoadStatus.hx" private="1" module="js.html.FontFaceLoadStatus"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.FontFaceSet" params="" file="/usr/lib/haxe/std/js/html/FontFaceSet.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<onloading public="1"><x path="haxe.Function"/></onloading>
		<onloadingdone public="1"><x path="haxe.Function"/></onloadingdone>
		<onloadingerror public="1"><x path="haxe.Function"/></onloadingerror>
		<ready public="1" set="null"><c path="js.Promise"><x path="Void"/></c></ready>
		<status public="1" set="null"><x path="js.html.FontFaceSetLoadStatus"/></status>
		<length public="1" set="null"><x path="Int"/></length>
		<add public="1" set="method">
			<f a="font">
				<c path="js.html.FontFace"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<has public="1" set="method"><f a="font">
	<c path="js.html.FontFace"/>
	<x path="Bool"/>
</f></has>
		<delete_ public="1" set="method">
			<f a="font">
				<c path="js.html.FontFace"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<load public="1" set="method">
			<f a="font:?text" v=":&quot; &quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="js.Promise"><c path="Array"><c path="js.html.FontFace"/></c></c>
			</f>
			<meta><m n=":value"><e>{text:" "}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</load>
		<meta><m n=":native"><e>"FontFaceSet"</e></m></meta>
	</class>
	<abstract path="js.html.FontFaceSetLoadStatus" params="" file="/usr/lib/haxe/std/js/html/FontFaceSetLoadStatus.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._FontFaceSetLoadStatus.FontFaceSetLoadStatus_Impl_" params="" file="/usr/lib/haxe/std/js/html/FontFaceSetLoadStatus.hx" private="1" module="js.html.FontFaceSetLoadStatus"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.FormData" params="" file="/usr/lib/haxe/std/js/html/FormData.hx" extern="1">
		<append public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<overloads><append public="1" set="method"><f a="name:value:?filename">
	<c path="String"/>
	<c path="js.html.Blob"/>
	<c path="String"/>
	<x path="Void"/>
</f></append></overloads>
		</append>
		<new public="1" set="method">
			<f a="?form">
				<c path="js.html.FormElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"FormData"</e></m></meta>
	</class>
	<class path="js.html.FormElement" params="" file="/usr/lib/haxe/std/js/html/FormElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<acceptCharset public="1"><c path="String"/></acceptCharset>
		<action public="1"><c path="String"/></action>
		<autocomplete public="1"><c path="String"/></autocomplete>
		<enctype public="1"><c path="String"/></enctype>
		<encoding public="1"><c path="String"/></encoding>
		<method public="1"><c path="String"/></method>
		<name public="1"><c path="String"/></name>
		<noValidate public="1"><x path="Bool"/></noValidate>
		<target public="1"><c path="String"/></target>
		<elements public="1" set="null"><c path="js.html.HTMLCollection"/></elements>
		<length public="1" set="null"><x path="Int"/></length>
		<submit public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</submit>
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<meta><m n=":native"><e>"HTMLFormElement"</e></m></meta>
	</class>
	<class path="js.html.FrameElement" params="" file="/usr/lib/haxe/std/js/html/FrameElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<scrolling public="1"><c path="String"/></scrolling>
		<src public="1"><c path="String"/></src>
		<frameBorder public="1"><c path="String"/></frameBorder>
		<longDesc public="1"><c path="String"/></longDesc>
		<noResize public="1"><x path="Bool"/></noResize>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<marginHeight public="1"><c path="String"/></marginHeight>
		<marginWidth public="1"><c path="String"/></marginWidth>
		<meta><m n=":native"><e>"HTMLFrameElement"</e></m></meta>
	</class>
	<class path="js.html.FrameSetElement" params="" file="/usr/lib/haxe/std/js/html/FrameSetElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cols public="1"><c path="String"/></cols>
		<rows public="1"><c path="String"/></rows>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<meta><m n=":native"><e>"HTMLFrameSetElement"</e></m></meta>
	</class>
	<class path="js.html.Gamepad" params="" file="/usr/lib/haxe/std/js/html/Gamepad.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<index public="1" set="null"><x path="Int"/></index>
		<mapping public="1" set="null"><x path="js.html.GamepadMappingType"/></mapping>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<buttons public="1" set="null"><c path="Array"><c path="js.html.GamepadButton"/></c></buttons>
		<axes public="1" set="null"><c path="Array"><x path="Float"/></c></axes>
		<timestamp public="1" set="null"><x path="Float"/></timestamp>
		<meta><m n=":native"><e>"Gamepad"</e></m></meta>
	</class>
	<class path="js.html.GamepadButton" params="" file="/usr/lib/haxe/std/js/html/GamepadButton.hx" extern="1">
		<pressed public="1" set="null"><x path="Bool"/></pressed>
		<value public="1" set="null"><x path="Float"/></value>
		<meta><m n=":native"><e>"GamepadButton"</e></m></meta>
	</class>
	<abstract path="js.html.GamepadMappingType" params="" file="/usr/lib/haxe/std/js/html/GamepadMappingType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._GamepadMappingType.GamepadMappingType_Impl_" params="" file="/usr/lib/haxe/std/js/html/GamepadMappingType.hx" private="1" module="js.html.GamepadMappingType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.Geolocation" params="" file="/usr/lib/haxe/std/js/html/Geolocation.hx" extern="1">
		<getCurrentPosition public="1" set="method">
			<f a="successCallback:?errorCallback:?options">
				<f a="">
					<c path="js.html.Position"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="js.html.PositionError"/>
					<x path="Void"/>
				</f>
				<t path="js.html.PositionOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getCurrentPosition>
		<watchPosition public="1" set="method">
			<f a="successCallback:?errorCallback:?options">
				<f a="">
					<c path="js.html.Position"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="js.html.PositionError"/>
					<x path="Void"/>
				</f>
				<t path="js.html.PositionOptions"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</watchPosition>
		<clearWatch public="1" set="method"><f a="watchId">
	<x path="Int"/>
	<x path="Void"/>
</f></clearWatch>
		<meta><m n=":native"><e>"Geolocation"</e></m></meta>
	</class>
	<class path="js.html.HRElement" params="" file="/usr/lib/haxe/std/js/html/HRElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<color public="1"><c path="String"/></color>
		<noShade public="1"><x path="Bool"/></noShade>
		<size public="1"><c path="String"/></size>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLHRElement"</e></m></meta>
	</class>
	<class path="js.html.HTMLAllCollection" params="" file="/usr/lib/haxe/std/js/html/HTMLAllCollection.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Node"/>
					<c path="js.html.HTMLCollection"/>
				</x>
			</f>
			<overloads><item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Node"/>
</f></item></overloads>
		</item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.Node"/>
		<c path="js.html.HTMLCollection"/>
	</x>
</f></namedItem>
		<meta><m n=":native"><e>"HTMLAllCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLCollection" params="" file="/usr/lib/haxe/std/js/html/HTMLCollection.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Element"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Element"/>
</f></namedItem>
		<meta><m n=":native"><e>"HTMLCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLDocument" params="" file="/usr/lib/haxe/std/js/html/HTMLDocument.hx" extern="1">
		<extends path="js.html.Document"/>
		<domain public="1"><c path="String"/></domain>
		<cookie public="1"><c path="String"/></cookie>
		<body public="1"><c path="js.html.Element"/></body>
		<head public="1" set="null"><c path="js.html.HeadElement"/></head>
		<images public="1" set="null"><c path="js.html.HTMLCollection"/></images>
		<embeds public="1" set="null"><c path="js.html.HTMLCollection"/></embeds>
		<plugins public="1" set="null"><c path="js.html.HTMLCollection"/></plugins>
		<links public="1" set="null"><c path="js.html.HTMLCollection"/></links>
		<forms public="1" set="null"><c path="js.html.HTMLCollection"/></forms>
		<scripts public="1" set="null"><c path="js.html.HTMLCollection"/></scripts>
		<designMode public="1"><c path="String"/></designMode>
		<fgColor public="1"><c path="String"/></fgColor>
		<linkColor public="1"><c path="String"/></linkColor>
		<vlinkColor public="1"><c path="String"/></vlinkColor>
		<alinkColor public="1"><c path="String"/></alinkColor>
		<bgColor public="1"><c path="String"/></bgColor>
		<anchors public="1" set="null"><c path="js.html.HTMLCollection"/></anchors>
		<applets public="1" set="null"><c path="js.html.HTMLCollection"/></applets>
		<all public="1" set="null"><c path="js.html.HTMLAllCollection"/></all>
		<getElementsByName public="1" set="method"><f a="elementName">
	<c path="String"/>
	<c path="js.html.NodeList"/>
</f></getElementsByName>
		<getItems public="1" set="method">
			<f a="?typeNames" v="&quot;&quot;">
				<c path="String"/>
				<c path="js.html.NodeList"/>
			</f>
			<meta><m n=":value"><e>{typeNames:""}</e></m></meta>
		</getItems>
		<open public="1" set="method">
			<f a="url:name:features:?replace" v=":::false">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="js.html.Window"/>
			</f>
			<meta><m n=":value"><e>{replace:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="?type:?replace" v="&quot;text/html&quot;:&quot;&quot;">
		<c path="String"/>
		<c path="String"/>
		<c path="js.html.HTMLDocument"/>
	</f>
	<meta><m n=":value"><e>{replace:"",type:"text/html"}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</close>
		<write public="1" set="method">
			<f a="text">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</write>
		<writeln public="1" set="method">
			<f a="text">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</writeln>
		<execCommand public="1" set="method">
			<f a="commandId:?showUI:?value" v=":false:&quot;&quot;">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{value:"",showUI:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</execCommand>
		<queryCommandEnabled public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandEnabled>
		<queryCommandIndeterm public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandIndeterm>
		<queryCommandState public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandState>
		<queryCommandSupported public="1" set="method"><f a="commandId">
	<c path="String"/>
	<x path="Bool"/>
</f></queryCommandSupported>
		<queryCommandValue public="1" set="method">
			<f a="commandId">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</queryCommandValue>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<getSelection public="1" set="method">
			<f a=""><c path="js.html.Selection"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getSelection>
		<captureEvents public="1" set="method"><f a=""><x path="Void"/></f></captureEvents>
		<releaseEvents public="1" set="method"><f a=""><x path="Void"/></f></releaseEvents>
		<createTableCellElement public="1" get="inline" set="null" line="78">
			<f a=""><c path="js.html.TableCellElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <td> element.]]></haxe_doc>
		</createTableCellElement>
		<createHRElement public="1" get="inline" set="null" line="80">
			<f a=""><c path="js.html.HRElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <hr> element.]]></haxe_doc>
		</createHRElement>
		<createSelectElement public="1" get="inline" set="null" line="82">
			<f a=""><c path="js.html.SelectElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <select> element.]]></haxe_doc>
		</createSelectElement>
		<createMapElement public="1" get="inline" set="null" line="84">
			<f a=""><c path="js.html.MapElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <map> element.]]></haxe_doc>
		</createMapElement>
		<createFormElement public="1" get="inline" set="null" line="86">
			<f a=""><c path="js.html.FormElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <form> element.]]></haxe_doc>
		</createFormElement>
		<createOptionElement public="1" get="inline" set="null" line="88">
			<f a=""><c path="js.html.OptionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <option> element.]]></haxe_doc>
		</createOptionElement>
		<createLabelElement public="1" get="inline" set="null" line="90">
			<f a=""><c path="js.html.LabelElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <label> element.]]></haxe_doc>
		</createLabelElement>
		<createMetaElement public="1" get="inline" set="null" line="92">
			<f a=""><c path="js.html.MetaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <meta> element.]]></haxe_doc>
		</createMetaElement>
		<createImageElement public="1" get="inline" set="null" line="94">
			<f a=""><c path="js.html.ImageElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <img> element.]]></haxe_doc>
		</createImageElement>
		<createDListElement public="1" get="inline" set="null" line="96">
			<f a=""><c path="js.html.DListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <dl> element.]]></haxe_doc>
		</createDListElement>
		<createFrameElement public="1" get="inline" set="null" line="98">
			<f a=""><c path="js.html.FrameElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <frame> element.]]></haxe_doc>
		</createFrameElement>
		<createModElement public="1" get="inline" set="null" line="100">
			<f a=""><c path="js.html.ModElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <mod> element.]]></haxe_doc>
		</createModElement>
		<createUListElement public="1" get="inline" set="null" line="102">
			<f a=""><c path="js.html.UListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <ul> element.]]></haxe_doc>
		</createUListElement>
		<createOutputElement public="1" get="inline" set="null" line="104">
			<f a=""><c path="js.html.OutputElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <output> element.]]></haxe_doc>
		</createOutputElement>
		<createOListElement public="1" get="inline" set="null" line="106">
			<f a=""><c path="js.html.OListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <ol> element.]]></haxe_doc>
		</createOListElement>
		<createShadowElement public="1" get="inline" set="null" line="108">
			<f a=""><c path="js.html.ShadowElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <shadow> element.]]></haxe_doc>
		</createShadowElement>
		<createLIElement public="1" get="inline" set="null" line="110">
			<f a=""><c path="js.html.LIElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <li> element.]]></haxe_doc>
		</createLIElement>
		<createDataListElement public="1" get="inline" set="null" line="112">
			<f a=""><c path="js.html.DataListElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <datalist> element.]]></haxe_doc>
		</createDataListElement>
		<createParamElement public="1" get="inline" set="null" line="114">
			<f a=""><c path="js.html.ParamElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <param> element.]]></haxe_doc>
		</createParamElement>
		<createFontElement public="1" get="inline" set="null" line="116">
			<f a=""><c path="js.html.FontElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <font> element.]]></haxe_doc>
		</createFontElement>
		<createTrackElement public="1" get="inline" set="null" line="118">
			<f a=""><c path="js.html.TrackElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <track> element.]]></haxe_doc>
		</createTrackElement>
		<createAppletElement public="1" get="inline" set="null" line="120">
			<f a=""><c path="js.html.AppletElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <applet> element.]]></haxe_doc>
		</createAppletElement>
		<createAreaElement public="1" get="inline" set="null" line="122">
			<f a=""><c path="js.html.AreaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <area> element.]]></haxe_doc>
		</createAreaElement>
		<createLinkElement public="1" get="inline" set="null" line="124">
			<f a=""><c path="js.html.LinkElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <link> element.]]></haxe_doc>
		</createLinkElement>
		<createDivElement public="1" get="inline" set="null" line="126">
			<f a=""><c path="js.html.DivElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <div> element.]]></haxe_doc>
		</createDivElement>
		<createTitleElement public="1" get="inline" set="null" line="128">
			<f a=""><c path="js.html.TitleElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <title> element.]]></haxe_doc>
		</createTitleElement>
		<createStyleElement public="1" get="inline" set="null" line="130">
			<f a=""><c path="js.html.StyleElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <style> element.]]></haxe_doc>
		</createStyleElement>
		<createProgressElement public="1" get="inline" set="null" line="132">
			<f a=""><c path="js.html.ProgressElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <progress> element.]]></haxe_doc>
		</createProgressElement>
		<createButtonElement public="1" get="inline" set="null" line="134">
			<f a=""><c path="js.html.ButtonElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <button> element.]]></haxe_doc>
		</createButtonElement>
		<createFieldSetElement public="1" get="inline" set="null" line="136">
			<f a=""><c path="js.html.FieldSetElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <fieldset> element.]]></haxe_doc>
		</createFieldSetElement>
		<createAnchorElement public="1" get="inline" set="null" line="138">
			<f a=""><c path="js.html.AnchorElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <a> element.]]></haxe_doc>
		</createAnchorElement>
		<createIFrameElement public="1" get="inline" set="null" line="140">
			<f a=""><c path="js.html.IFrameElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <iframe> element.]]></haxe_doc>
		</createIFrameElement>
		<createSpanElement public="1" get="inline" set="null" line="142">
			<f a=""><c path="js.html.SpanElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <span> element.]]></haxe_doc>
		</createSpanElement>
		<createBodyElement public="1" get="inline" set="null" line="144">
			<f a=""><c path="js.html.BodyElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <body> element.]]></haxe_doc>
		</createBodyElement>
		<createInputElement public="1" get="inline" set="null" line="146">
			<f a=""><c path="js.html.InputElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <input> element.]]></haxe_doc>
		</createInputElement>
		<createEmbedElement public="1" get="inline" set="null" line="148">
			<f a=""><c path="js.html.EmbedElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <embed> element.]]></haxe_doc>
		</createEmbedElement>
		<createMeterElement public="1" get="inline" set="null" line="150">
			<f a=""><c path="js.html.MeterElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <meter> element.]]></haxe_doc>
		</createMeterElement>
		<createPictureElement public="1" get="inline" set="null" line="152">
			<f a=""><c path="js.html.PictureElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <picture> element.]]></haxe_doc>
		</createPictureElement>
		<createPreElement public="1" get="inline" set="null" line="154">
			<f a=""><c path="js.html.PreElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <pre> element.]]></haxe_doc>
		</createPreElement>
		<createTableSectionElement public="1" get="inline" set="null" line="156">
			<f a=""><c path="js.html.TableSectionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <thead> element.]]></haxe_doc>
		</createTableSectionElement>
		<createHeadElement public="1" get="inline" set="null" line="158">
			<f a=""><c path="js.html.HeadElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <head> element.]]></haxe_doc>
		</createHeadElement>
		<createBaseElement public="1" get="inline" set="null" line="160">
			<f a=""><c path="js.html.BaseElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <base> element.]]></haxe_doc>
		</createBaseElement>
		<createOptGroupElement public="1" get="inline" set="null" line="162">
			<f a=""><c path="js.html.OptGroupElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <optgroup> element.]]></haxe_doc>
		</createOptGroupElement>
		<createQuoteElement public="1" get="inline" set="null" line="164">
			<f a=""><c path="js.html.QuoteElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <quote> element.]]></haxe_doc>
		</createQuoteElement>
		<createAudioElement public="1" get="inline" set="null" line="166">
			<f a=""><c path="js.html.AudioElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <audio> element.]]></haxe_doc>
		</createAudioElement>
		<createVideoElement public="1" get="inline" set="null" line="168">
			<f a=""><c path="js.html.VideoElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <video> element.]]></haxe_doc>
		</createVideoElement>
		<createLegendElement public="1" get="inline" set="null" line="170">
			<f a=""><c path="js.html.LegendElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <legend> element.]]></haxe_doc>
		</createLegendElement>
		<createMenuElement public="1" get="inline" set="null" line="172">
			<f a=""><c path="js.html.MenuElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <menu> element.]]></haxe_doc>
		</createMenuElement>
		<createFrameSetElement public="1" get="inline" set="null" line="174">
			<f a=""><c path="js.html.FrameSetElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <frameset> element.]]></haxe_doc>
		</createFrameSetElement>
		<createCanvasElement public="1" get="inline" set="null" line="176">
			<f a=""><c path="js.html.CanvasElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <canvas> element.]]></haxe_doc>
		</createCanvasElement>
		<createParagraphElement public="1" get="inline" set="null" line="178">
			<f a=""><c path="js.html.ParagraphElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <p> element.]]></haxe_doc>
		</createParagraphElement>
		<createTableColElement public="1" get="inline" set="null" line="180">
			<f a=""><c path="js.html.TableColElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <col> element.]]></haxe_doc>
		</createTableColElement>
		<createDirectoryElement public="1" get="inline" set="null" line="182">
			<f a=""><c path="js.html.DirectoryElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <dir> element.]]></haxe_doc>
		</createDirectoryElement>
		<createTableElement public="1" get="inline" set="null" line="184">
			<f a=""><c path="js.html.TableElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <table> element.]]></haxe_doc>
		</createTableElement>
		<createTableRowElement public="1" get="inline" set="null" line="186">
			<f a=""><c path="js.html.TableRowElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <tr> element.]]></haxe_doc>
		</createTableRowElement>
		<createScriptElement public="1" get="inline" set="null" line="188">
			<f a=""><c path="js.html.ScriptElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <script> element.]]></haxe_doc>
		</createScriptElement>
		<createSourceElement public="1" get="inline" set="null" line="190">
			<f a=""><c path="js.html.SourceElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <source> element.]]></haxe_doc>
		</createSourceElement>
		<createContentElement public="1" get="inline" set="null" line="192">
			<f a=""><c path="js.html.ContentElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <content> element.]]></haxe_doc>
		</createContentElement>
		<createBRElement public="1" get="inline" set="null" line="194">
			<f a=""><c path="js.html.BRElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <br> element.]]></haxe_doc>
		</createBRElement>
		<createHtmlElement public="1" get="inline" set="null" line="196">
			<f a=""><c path="js.html.HtmlElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <html> element.]]></haxe_doc>
		</createHtmlElement>
		<createTextAreaElement public="1" get="inline" set="null" line="198">
			<f a=""><c path="js.html.TextAreaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <textarea> element.]]></haxe_doc>
		</createTextAreaElement>
		<createMediaElement public="1" get="inline" set="null" line="200">
			<f a=""><c path="js.html.MediaElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <media> element.]]></haxe_doc>
		</createMediaElement>
		<createObjectElement public="1" get="inline" set="null" line="202">
			<f a=""><c path="js.html.ObjectElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <object> element.]]></haxe_doc>
		</createObjectElement>
		<createTableCaptionElement public="1" get="inline" set="null" line="204">
			<f a=""><c path="js.html.TableCaptionElement"/></f>
			<haxe_doc><![CDATA[Shorthand for creating an HTML <caption> element.]]></haxe_doc>
		</createTableCaptionElement>
		<meta><m n=":native"><e>"HTMLDocument"</e></m></meta>
	</class>
	<class path="js.html.HTMLOptionsCollection" params="" file="/usr/lib/haxe/std/js/html/HTMLOptionsCollection.hx" extern="1">
		<extends path="js.html.HTMLCollection"/>
		<selectedIndex public="1"><x path="Int"/></selectedIndex>
		<add public="1" set="method">
			<f a="element:?before">
				<x path="haxe.extern.EitherType">
					<c path="js.html.OptionElement"/>
					<c path="js.html.OptGroupElement"/>
				</x>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Element"/>
					<x path="Int"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<remove public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</remove>
		<meta><m n=":native"><e>"HTMLOptionsCollection"</e></m></meta>
	</class>
	<class path="js.html.HTMLPropertiesCollection" params="" file="/usr/lib/haxe/std/js/html/HTMLPropertiesCollection.hx" extern="1">
		<extends path="js.html.HTMLCollection"/>
		<names public="1" set="null"><c path="js.html.DOMStringList"/></names>
		<meta><m n=":native"><e>"HTMLPropertiesCollection"</e></m></meta>
	</class>
	<class path="js.html.HeadElement" params="" file="/usr/lib/haxe/std/js/html/HeadElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLHeadElement"</e></m></meta>
	</class>
	<class path="js.html.History" params="" file="/usr/lib/haxe/std/js/html/History.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<state public="1" set="null"><d/></state>
		<go public="1" set="method">
			<f a="?delta" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{delta:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</go>
		<back public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</back>
		<forward public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</forward>
		<pushState public="1" set="method">
			<f a="data:title:?url">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</pushState>
		<replaceState public="1" set="method">
			<f a="data:title:?url">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replaceState>
		<meta><m n=":native"><e>"History"</e></m></meta>
	</class>
	<typedef path="js.html.HitRegionOptions" params="" file="/usr/lib/haxe/std/js/html/HitRegionOptions.hx"><a>
	<id>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</id>
	<control>
		<t path="Null"><c path="js.html.Element"/></t>
		<meta><m n=":optional"/></meta>
	</control>
</a></typedef>
	<class path="js.html.HtmlElement" params="" file="/usr/lib/haxe/std/js/html/HtmlElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<version public="1"><c path="String"/></version>
		<meta><m n=":native"><e>"HTMLHtmlElement"</e></m></meta>
	</class>
	<class path="js.html.IFrameElement" params="" file="/usr/lib/haxe/std/js/html/IFrameElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<srcdoc public="1"><c path="String"/></srcdoc>
		<name public="1"><c path="String"/></name>
		<sandbox public="1" set="null"><c path="js.html.DOMSettableTokenList"/></sandbox>
		<allowFullscreen public="1"><x path="Bool"/></allowFullscreen>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<align public="1"><c path="String"/></align>
		<scrolling public="1"><c path="String"/></scrolling>
		<frameBorder public="1"><c path="String"/></frameBorder>
		<longDesc public="1"><c path="String"/></longDesc>
		<marginHeight public="1"><c path="String"/></marginHeight>
		<marginWidth public="1"><c path="String"/></marginWidth>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLIFrameElement"</e></m></meta>
	</class>
	<class path="js.html.ImageElement" params="" file="/usr/lib/haxe/std/js/html/ImageElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<alt public="1"><c path="String"/></alt>
		<src public="1"><c path="String"/></src>
		<srcset public="1"><c path="String"/></srcset>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<useMap public="1"><c path="String"/></useMap>
		<isMap public="1"><x path="Bool"/></isMap>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<naturalWidth public="1" set="null"><x path="Int"/></naturalWidth>
		<naturalHeight public="1" set="null"><x path="Int"/></naturalHeight>
		<complete public="1" set="null"><x path="Bool"/></complete>
		<name public="1"><c path="String"/></name>
		<align public="1"><c path="String"/></align>
		<hspace public="1"><x path="Int"/></hspace>
		<vspace public="1"><x path="Int"/></vspace>
		<longDesc public="1"><c path="String"/></longDesc>
		<border public="1"><c path="String"/></border>
		<sizes public="1"><c path="String"/></sizes>
		<currentSrc public="1" set="null"><c path="String"/></currentSrc>
		<lowsrc public="1"><c path="String"/></lowsrc>
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<meta><m n=":native"><e>"HTMLImageElement"</e></m></meta>
	</class>
	<class path="js.html.Image" params="" file="/usr/lib/haxe/std/js/html/Image.hx" extern="1">
		<extends path="js.html.ImageElement"/>
		<new public="1" set="method">
			<f a="?width:?height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Image"</e></m></meta>
	</class>
	<class path="js.html.ImageData" params="" file="/usr/lib/haxe/std/js/html/ImageData.hx" extern="1">
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<data public="1" set="null"><c path="js.html.Uint8ClampedArray"/></data>
		<new public="1" set="method">
			<f a="data:sw:?sh">
				<c path="js.html.Uint8ClampedArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="sw:sh">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"ImageData"</e></m></meta>
	</class>
	<class path="js.html.InputElement" params="" file="/usr/lib/haxe/std/js/html/InputElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<accept public="1"><c path="String"/></accept>
		<alt public="1"><c path="String"/></alt>
		<autocomplete public="1"><c path="String"/></autocomplete>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<defaultChecked public="1"><x path="Bool"/></defaultChecked>
		<checked public="1"><x path="Bool"/></checked>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<files public="1" set="null"><c path="js.html.FileList"/></files>
		<formAction public="1"><c path="String"/></formAction>
		<formEnctype public="1"><c path="String"/></formEnctype>
		<formMethod public="1"><c path="String"/></formMethod>
		<formNoValidate public="1"><x path="Bool"/></formNoValidate>
		<formTarget public="1"><c path="String"/></formTarget>
		<height public="1"><x path="Int"/></height>
		<indeterminate public="1"><x path="Bool"/></indeterminate>
		<list public="1" set="null"><c path="js.html.Element"/></list>
		<max public="1"><c path="String"/></max>
		<maxLength public="1"><x path="Int"/></maxLength>
		<min public="1"><c path="String"/></min>
		<multiple public="1"><x path="Bool"/></multiple>
		<name public="1"><c path="String"/></name>
		<pattern public="1"><c path="String"/></pattern>
		<placeholder public="1"><c path="String"/></placeholder>
		<readOnly public="1"><x path="Bool"/></readOnly>
		<required public="1"><x path="Bool"/></required>
		<size public="1"><x path="Int"/></size>
		<src public="1"><c path="String"/></src>
		<step public="1"><c path="String"/></step>
		<type public="1"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<valueAsNumber public="1"><x path="Float"/></valueAsNumber>
		<width public="1"><x path="Int"/></width>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<selectionStart public="1"><x path="Int"/></selectionStart>
		<selectionEnd public="1"><x path="Int"/></selectionEnd>
		<selectionDirection public="1"><c path="String"/></selectionDirection>
		<align public="1"><c path="String"/></align>
		<useMap public="1"><c path="String"/></useMap>
		<textLength public="1" set="null"><x path="Int"/></textLength>
		<stepUp public="1" set="method">
			<f a="?n" v="1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{n:1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stepUp>
		<stepDown public="1" set="method">
			<f a="?n" v="1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{n:1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stepDown>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<select public="1" set="method"><f a=""><x path="Void"/></f></select>
		<setRangeText public="1" set="method">
			<f a="replacement:start:end:?selectionMode" v=":::&quot;preserve&quot;">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="js.html.SelectionMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{selectionMode:"preserve"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setRangeText public="1" set="method">
	<f a="replacement">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setRangeText></overloads>
		</setRangeText>
		<setSelectionRange public="1" set="method">
			<f a="start:end:?direction">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setSelectionRange>
		<meta><m n=":native"><e>"HTMLInputElement"</e></m></meta>
	</class>
	<class path="js.html.Int32Array" params="" file="/usr/lib/haxe/std/js/html/Int32Array.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Int32Array"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Int32Array"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Int32Array"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Int32Array"</e></m></meta>
	</class>
	<class path="js.html.LIElement" params="" file="/usr/lib/haxe/std/js/html/LIElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Int"/></value>
		<type public="1"><c path="String"/></type>
		<meta><m n=":native"><e>"HTMLLIElement"</e></m></meta>
	</class>
	<class path="js.html.LabelElement" params="" file="/usr/lib/haxe/std/js/html/LabelElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<htmlFor public="1"><c path="String"/></htmlFor>
		<control public="1" set="null"><c path="js.html.Element"/></control>
		<meta><m n=":native"><e>"HTMLLabelElement"</e></m></meta>
	</class>
	<class path="js.html.LegendElement" params="" file="/usr/lib/haxe/std/js/html/LegendElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLLegendElement"</e></m></meta>
	</class>
	<class path="js.html.LinkElement" params="" file="/usr/lib/haxe/std/js/html/LinkElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<href public="1"><c path="String"/></href>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<rel public="1"><c path="String"/></rel>
		<relList public="1" set="null"><c path="js.html.DOMTokenList"/></relList>
		<media public="1"><c path="String"/></media>
		<hreflang public="1"><c path="String"/></hreflang>
		<type public="1"><c path="String"/></type>
		<sizes public="1" set="null"><c path="js.html.DOMSettableTokenList"/></sizes>
		<charset public="1"><c path="String"/></charset>
		<rev public="1"><c path="String"/></rev>
		<target public="1"><c path="String"/></target>
		<import_ public="1" set="null">
			<c path="js.html.HTMLDocument"/>
			<meta><m n=":native"><e>"import"</e></m></meta>
		</import_>
		<sheet public="1" set="null"><c path="js.html.StyleSheet"/></sheet>
		<meta><m n=":native"><e>"HTMLLinkElement"</e></m></meta>
	</class>
	<class path="js.html.Location" params="" file="/usr/lib/haxe/std/js/html/Location.hx" extern="1">
		<href public="1"><c path="String"/></href>
		<origin public="1" set="null"><c path="String"/></origin>
		<protocol public="1"><c path="String"/></protocol>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<hostname public="1"><c path="String"/></hostname>
		<port public="1"><c path="String"/></port>
		<pathname public="1"><c path="String"/></pathname>
		<search public="1"><c path="String"/></search>
		<hash public="1"><c path="String"/></hash>
		<assign public="1" set="method">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</assign>
		<replace public="1" set="method">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</replace>
		<reload public="1" set="method">
			<f a="?forceget" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{forceget:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</reload>
		<meta><m n=":native"><e>"Location"</e></m></meta>
	</class>
	<class path="js.html.MapElement" params="" file="/usr/lib/haxe/std/js/html/MapElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<areas public="1" set="null"><c path="js.html.HTMLCollection"/></areas>
		<meta><m n=":native"><e>"HTMLMapElement"</e></m></meta>
	</class>
	<class path="js.html.MediaError" params="" file="/usr/lib/haxe/std/js/html/MediaError.hx" extern="1">
		<MEDIA_ERR_ABORTED public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</MEDIA_ERR_ABORTED>
		<MEDIA_ERR_NETWORK public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</MEDIA_ERR_NETWORK>
		<MEDIA_ERR_DECODE public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</MEDIA_ERR_DECODE>
		<MEDIA_ERR_SRC_NOT_SUPPORTED public="1" get="inline" set="null" expr="4" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</MEDIA_ERR_SRC_NOT_SUPPORTED>
		<code public="1" set="null"><x path="Int"/></code>
		<meta><m n=":native"><e>"MediaError"</e></m></meta>
	</class>
	<class path="js.html.MediaKeyError" params="" file="/usr/lib/haxe/std/js/html/MediaKeyError.hx" extern="1">
		<extends path="js.html.Event"/>
		<systemCode public="1" set="null"><x path="Int"/></systemCode>
		<meta><m n=":native"><e>"MediaKeyError"</e></m></meta>
	</class>
	<class path="js.html.MediaKeySession" params="" file="/usr/lib/haxe/std/js/html/MediaKeySession.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<error public="1" set="null"><c path="js.html.MediaKeyError"/></error>
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<sessionId public="1" set="null"><c path="String"/></sessionId>
		<expiration public="1" set="null"><x path="Float"/></expiration>
		<closed public="1" set="null"><c path="js.Promise"><x path="Void"/></c></closed>
		<generateRequest public="1" set="method"><f a="initDataType:initData">
	<c path="String"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></generateRequest>
		<load public="1" set="method"><f a="sessionId">
	<c path="String"/>
	<c path="js.Promise"><x path="Bool"/></c>
</f></load>
		<update public="1" set="method"><f a="response">
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></update>
		<close public="1" set="method"><f a=""><c path="js.Promise"><x path="Void"/></c></f></close>
		<remove public="1" set="method"><f a=""><c path="js.Promise"><x path="Void"/></c></f></remove>
		<getUsableKeyIds public="1" set="method"><f a=""><c path="js.Promise"><c path="Array"><c path="js.html.ArrayBuffer"/></c></c></f></getUsableKeyIds>
		<meta><m n=":native"><e>"MediaKeySession"</e></m></meta>
	</class>
	<class path="js.html.MediaKeySystemAccess" params="" file="/usr/lib/haxe/std/js/html/MediaKeySystemAccess.hx" extern="1">
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<createMediaKeys public="1" set="method"><f a=""><c path="js.Promise"><c path="js.html.MediaKeys"/></c></f></createMediaKeys>
		<meta><m n=":native"><e>"MediaKeySystemAccess"</e></m></meta>
	</class>
	<typedef path="js.html.MediaKeySystemOptions" params="" file="/usr/lib/haxe/std/js/html/MediaKeySystemOptions.hx"><a>
	<videoType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</videoType>
	<videoCapability>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</videoCapability>
	<uniqueidentifier>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</uniqueidentifier>
	<stateful>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</stateful>
	<initDataType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</initDataType>
	<audioType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</audioType>
	<audioCapability>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</audioCapability>
</a></typedef>
	<class path="js.html.MediaKeys" params="" file="/usr/lib/haxe/std/js/html/MediaKeys.hx" extern="1">
		<keySystem public="1" set="null"><c path="String"/></keySystem>
		<createSession public="1" set="method">
			<f a="?sessionType" v="&quot;temporary&quot;">
				<x path="js.html.SessionType"/>
				<c path="js.html.MediaKeySession"/>
			</f>
			<meta><m n=":value"><e>{sessionType:"temporary"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createSession>
		<setServerCertificate public="1" set="method"><f a="serverCertificate">
	<x path="haxe.extern.EitherType">
		<c path="js.html.ArrayBufferView"/>
		<c path="js.html.ArrayBuffer"/>
	</x>
	<c path="js.Promise"><x path="Void"/></c>
</f></setServerCertificate>
		<meta><m n=":native"><e>"MediaKeys"</e></m></meta>
	</class>
	<class path="js.html.MediaList" params="" file="/usr/lib/haxe/std/js/html/MediaList.hx" extern="1">
		<mediaText public="1"><c path="String"/></mediaText>
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></item>
		<deleteMedium public="1" set="method">
			<f a="oldMedium">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteMedium>
		<appendMedium public="1" set="method">
			<f a="newMedium">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</appendMedium>
		<meta><m n=":native"><e>"MediaList"</e></m></meta>
	</class>
	<class path="js.html.MediaQueryList" params="" file="/usr/lib/haxe/std/js/html/MediaQueryList.hx" extern="1">
		<media public="1" set="null"><c path="String"/></media>
		<matches public="1" set="null"><x path="Bool"/></matches>
		<addListener public="1" set="method"><f a="listener">
	<f a="">
		<c path="js.html.MediaQueryList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></addListener>
		<removeListener public="1" set="method"><f a="listener">
	<f a="">
		<c path="js.html.MediaQueryList"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></removeListener>
		<meta><m n=":native"><e>"MediaQueryList"</e></m></meta>
	</class>
	<abstract path="js.html.MediaWaitingFor" params="" file="/usr/lib/haxe/std/js/html/MediaWaitingFor.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._MediaWaitingFor.MediaWaitingFor_Impl_" params="" file="/usr/lib/haxe/std/js/html/MediaWaitingFor.hx" private="1" module="js.html.MediaWaitingFor"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.MenuElement" params="" file="/usr/lib/haxe/std/js/html/MenuElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<type public="1"><c path="String"/></type>
		<label public="1"><c path="String"/></label>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLMenuElement"</e></m></meta>
	</class>
	<class path="js.html.MetaElement" params="" file="/usr/lib/haxe/std/js/html/MetaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<httpEquiv public="1"><c path="String"/></httpEquiv>
		<content public="1"><c path="String"/></content>
		<scheme public="1"><c path="String"/></scheme>
		<meta><m n=":native"><e>"HTMLMetaElement"</e></m></meta>
	</class>
	<class path="js.html.MeterElement" params="" file="/usr/lib/haxe/std/js/html/MeterElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Float"/></value>
		<min public="1"><x path="Float"/></min>
		<max public="1"><x path="Float"/></max>
		<low public="1"><x path="Float"/></low>
		<high public="1"><x path="Float"/></high>
		<optimum public="1"><x path="Float"/></optimum>
		<meta><m n=":native"><e>"HTMLMeterElement"</e></m></meta>
	</class>
	<class path="js.html.MimeType" params="" file="/usr/lib/haxe/std/js/html/MimeType.hx" extern="1">
		<description public="1" set="null"><c path="String"/></description>
		<enabledPlugin public="1" set="null"><c path="js.html.Plugin"/></enabledPlugin>
		<suffixes public="1" set="null"><c path="String"/></suffixes>
		<type public="1" set="null"><c path="String"/></type>
		<meta><m n=":native"><e>"MimeType"</e></m></meta>
	</class>
	<class path="js.html.MimeTypeArray" params="" file="/usr/lib/haxe/std/js/html/MimeTypeArray.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.MimeType"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.MimeType"/>
</f></namedItem>
		<meta><m n=":native"><e>"MimeTypeArray"</e></m></meta>
	</class>
	<class path="js.html.ModElement" params="" file="/usr/lib/haxe/std/js/html/ModElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cite public="1"><c path="String"/></cite>
		<dateTime public="1"><c path="String"/></dateTime>
		<meta><m n=":native"><e>"HTMLModElement"</e></m></meta>
	</class>
	<class path="js.html.NamedNodeMap" params="" file="/usr/lib/haxe/std/js/html/NamedNodeMap.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getNamedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getNamedItem>
		<setNamedItem public="1" set="method">
			<f a="arg">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setNamedItem>
		<removeNamedItem public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeNamedItem>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Attr"/>
</f></item>
		<getNamedItemNS public="1" set="method"><f a="namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.Attr"/>
</f></getNamedItemNS>
		<setNamedItemNS public="1" set="method">
			<f a="arg">
				<c path="js.html.Attr"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setNamedItemNS>
		<removeNamedItemNS public="1" set="method">
			<f a="namespaceURI:localName">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Attr"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeNamedItemNS>
		<meta><m n=":native"><e>"NamedNodeMap"</e></m></meta>
	</class>
	<class path="js.html.Navigator" params="" file="/usr/lib/haxe/std/js/html/Navigator.hx" extern="1">
		<mimeTypes public="1" set="null"><c path="js.html.MimeTypeArray"/></mimeTypes>
		<plugins public="1" set="null"><c path="js.html.PluginArray"/></plugins>
		<doNotTrack public="1" set="null"><c path="String"/></doNotTrack>
		<maxTouchPoints public="1" set="null"><x path="Int"/></maxTouchPoints>
		<oscpu public="1" set="null"><c path="String"/></oscpu>
		<vendor public="1" set="null"><c path="String"/></vendor>
		<vendorSub public="1" set="null"><c path="String"/></vendorSub>
		<productSub public="1" set="null"><c path="String"/></productSub>
		<cookieEnabled public="1" set="null"><x path="Bool"/></cookieEnabled>
		<buildID public="1" set="null"><c path="String"/></buildID>
		<battery public="1" set="null"><c path="js.html.BatteryManager"/></battery>
		<geolocation public="1" set="null"><c path="js.html.Geolocation"/></geolocation>
		<appCodeName public="1" set="null"><c path="String"/></appCodeName>
		<appName public="1" set="null"><c path="String"/></appName>
		<appVersion public="1" set="null"><c path="String"/></appVersion>
		<platform public="1" set="null"><c path="String"/></platform>
		<userAgent public="1" set="null"><c path="String"/></userAgent>
		<product public="1" set="null"><c path="String"/></product>
		<language public="1" set="null"><c path="String"/></language>
		<languages public="1" set="null"><c path="Array"><c path="String"/></c></languages>
		<onLine public="1" set="null"><x path="Bool"/></onLine>
		<vibrate public="1" set="method">
			<f a="pattern">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<overloads><vibrate public="1" set="method"><f a="duration">
	<x path="Int"/>
	<x path="Bool"/>
</f></vibrate></overloads>
		</vibrate>
		<javaEnabled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</javaEnabled>
		<getGamepads public="1" set="method">
			<f a=""><c path="Array"><c path="js.html.Gamepad"/></c></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getGamepads>
		<sendBeacon public="1" set="method">
			<f a="url:?data">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="js.html.ArrayBufferView"/>
					<x path="haxe.extern.EitherType">
						<c path="js.html.Blob"/>
						<x path="haxe.extern.EitherType">
							<c path="String"/>
							<c path="js.html.FormData"/>
						</x>
					</x>
				</x>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sendBeacon>
		<requestMediaKeySystemAccess public="1" set="method"><f a="keySystem:?supportedConfigurations">
	<c path="String"/>
	<c path="Array"><t path="js.html.MediaKeySystemOptions"/></c>
	<c path="js.Promise"><c path="js.html.MediaKeySystemAccess"/></c>
</f></requestMediaKeySystemAccess>
		<registerProtocolHandler public="1" set="method">
			<f a="scheme:url:title">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerProtocolHandler>
		<registerContentHandler public="1" set="method">
			<f a="mimeType:url:title">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</registerContentHandler>
		<taintEnabled public="1" set="method"><f a=""><x path="Bool"/></f></taintEnabled>
		<meta><m n=":native"><e>"Navigator"</e></m></meta>
	</class>
	<class path="js.html.NodeFilter" params="" file="/usr/lib/haxe/std/js/html/NodeFilter.hx" extern="1">
		<FILTER_ACCEPT public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</FILTER_ACCEPT>
		<FILTER_REJECT public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</FILTER_REJECT>
		<FILTER_SKIP public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</FILTER_SKIP>
		<SHOW_ALL public="1" get="inline" set="null" expr="&apos;???&apos;" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>'???'</e></m></meta>
		</SHOW_ALL>
		<SHOW_ELEMENT public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</SHOW_ELEMENT>
		<SHOW_ATTRIBUTE public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</SHOW_ATTRIBUTE>
		<SHOW_TEXT public="1" get="inline" set="null" expr="4" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</SHOW_TEXT>
		<SHOW_CDATA_SECTION public="1" get="inline" set="null" expr="8" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</SHOW_CDATA_SECTION>
		<SHOW_ENTITY_REFERENCE public="1" get="inline" set="null" expr="16" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</SHOW_ENTITY_REFERENCE>
		<SHOW_ENTITY public="1" get="inline" set="null" expr="32" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</SHOW_ENTITY>
		<SHOW_PROCESSING_INSTRUCTION public="1" get="inline" set="null" expr="64" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</SHOW_PROCESSING_INSTRUCTION>
		<SHOW_COMMENT public="1" get="inline" set="null" expr="128" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</SHOW_COMMENT>
		<SHOW_DOCUMENT public="1" get="inline" set="null" expr="256" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</SHOW_DOCUMENT>
		<SHOW_DOCUMENT_TYPE public="1" get="inline" set="null" expr="512" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>512</e></m></meta>
		</SHOW_DOCUMENT_TYPE>
		<SHOW_DOCUMENT_FRAGMENT public="1" get="inline" set="null" expr="1024" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</SHOW_DOCUMENT_FRAGMENT>
		<SHOW_NOTATION public="1" get="inline" set="null" expr="2048" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2048</e></m></meta>
		</SHOW_NOTATION>
		<acceptNode public="1" set="method"><f a="node">
	<c path="js.html.Node"/>
	<x path="Int"/>
</f></acceptNode>
		<meta><m n=":native"><e>"NodeFilter"</e></m></meta>
	</class>
	<class path="js.html.NodeIterator" params="" file="/usr/lib/haxe/std/js/html/NodeIterator.hx" extern="1">
		<root public="1" set="null"><c path="js.html.Node"/></root>
		<referenceNode public="1" set="null"><c path="js.html.Node"/></referenceNode>
		<pointerBeforeReferenceNode public="1" set="null"><x path="Bool"/></pointerBeforeReferenceNode>
		<whatToShow public="1" set="null"><x path="Int"/></whatToShow>
		<filter public="1" set="null"><c path="js.html.NodeFilter"/></filter>
		<nextNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextNode>
		<previousNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousNode>
		<detach public="1" set="method"><f a=""><x path="Void"/></f></detach>
		<meta><m n=":native"><e>"NodeIterator"</e></m></meta>
	</class>
	<class path="js.html.NodeList" params="" file="/usr/lib/haxe/std/js/html/NodeList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Node"/>
</f></item>
		<meta><m n=":native"><e>"NodeList"</e></m></meta>
	</class>
	<class path="js.html.OListElement" params="" file="/usr/lib/haxe/std/js/html/OListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<reversed public="1"><x path="Bool"/></reversed>
		<start public="1"><x path="Int"/></start>
		<type public="1"><c path="String"/></type>
		<compact public="1"><x path="Bool"/></compact>
		<meta><m n=":native"><e>"HTMLOListElement"</e></m></meta>
	</class>
	<class path="js.html.ObjectElement" params="" file="/usr/lib/haxe/std/js/html/ObjectElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<data public="1"><c path="String"/></data>
		<type public="1"><c path="String"/></type>
		<typeMustMatch public="1"><x path="Bool"/></typeMustMatch>
		<name public="1"><c path="String"/></name>
		<useMap public="1"><c path="String"/></useMap>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<width public="1"><c path="String"/></width>
		<height public="1"><c path="String"/></height>
		<contentDocument public="1" set="null"><c path="js.html.HTMLDocument"/></contentDocument>
		<contentWindow public="1" set="null"><c path="js.html.Window"/></contentWindow>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<align public="1"><c path="String"/></align>
		<archive public="1"><c path="String"/></archive>
		<code public="1"><c path="String"/></code>
		<declare public="1"><x path="Bool"/></declare>
		<hspace public="1"><x path="Int"/></hspace>
		<standby public="1"><c path="String"/></standby>
		<vspace public="1"><x path="Int"/></vspace>
		<codeBase public="1"><c path="String"/></codeBase>
		<codeType public="1"><c path="String"/></codeType>
		<border public="1"><c path="String"/></border>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<getSVGDocument public="1" set="method"><f a=""><c path="js.html.HTMLDocument"/></f></getSVGDocument>
		<meta><m n=":native"><e>"HTMLObjectElement"</e></m></meta>
	</class>
	<class path="js.html.OptGroupElement" params="" file="/usr/lib/haxe/std/js/html/OptGroupElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<label public="1"><c path="String"/></label>
		<meta><m n=":native"><e>"HTMLOptGroupElement"</e></m></meta>
	</class>
	<class path="js.html.OptionElement" params="" file="/usr/lib/haxe/std/js/html/OptionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<label public="1"><c path="String"/></label>
		<defaultSelected public="1"><x path="Bool"/></defaultSelected>
		<selected public="1"><x path="Bool"/></selected>
		<value public="1"><c path="String"/></value>
		<text public="1"><c path="String"/></text>
		<index public="1" set="null"><x path="Int"/></index>
		<meta><m n=":native"><e>"HTMLOptionElement"</e></m></meta>
	</class>
	<class path="js.html.OutputElement" params="" file="/usr/lib/haxe/std/js/html/OutputElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<htmlFor public="1" set="null"><c path="js.html.DOMSettableTokenList"/></htmlFor>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<name public="1"><c path="String"/></name>
		<type public="1" set="null"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLOutputElement"</e></m></meta>
	</class>
	<class path="js.html.ParagraphElement" params="" file="/usr/lib/haxe/std/js/html/ParagraphElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLParagraphElement"</e></m></meta>
	</class>
	<class path="js.html.ParamElement" params="" file="/usr/lib/haxe/std/js/html/ParamElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<type public="1"><c path="String"/></type>
		<valueType public="1"><c path="String"/></valueType>
		<meta><m n=":native"><e>"HTMLParamElement"</e></m></meta>
	</class>
	<class path="js.html.Path2D" params="" file="/usr/lib/haxe/std/js/html/Path2D.hx" extern="1">
		<addPath public="1" set="method"><f a="path:?transformation">
	<c path="js.html.Path2D"/>
	<c path="js.html.svg.Matrix"/>
	<x path="Void"/>
</f></addPath>
		<closePath public="1" set="method"><f a=""><x path="Void"/></f></closePath>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<quadraticCurveTo public="1" set="method"><f a="cpx:cpy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<bezierCurveTo public="1" set="method"><f a="cp1x:cp1y:cp2x:cp2y:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bezierCurveTo>
		<arcTo public="1" set="method">
			<f a="x1:y1:x2:y2:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arcTo>
		<rect public="1" set="method"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rect>
		<arc public="1" set="method">
			<f a="x:y:radius:startAngle:endAngle:?anticlockwise" v=":::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{anticlockwise:false}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</arc>
		<new public="1" set="method">
			<f a="pathString">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a=""><x path="Void"/></f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="other">
						<c path="js.html.Path2D"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Path2D"</e></m></meta>
	</class>
	<class path="js.html.Performance" params="" file="/usr/lib/haxe/std/js/html/Performance.hx" extern="1">
		<timing public="1" set="null"><c path="js.html.PerformanceTiming"/></timing>
		<navigation public="1" set="null"><c path="js.html.PerformanceNavigation"/></navigation>
		<now public="1" set="method"><f a=""><x path="Float"/></f></now>
		<meta><m n=":native"><e>"Performance"</e></m></meta>
	</class>
	<class path="js.html.PerformanceNavigation" params="" file="/usr/lib/haxe/std/js/html/PerformanceNavigation.hx" extern="1">
		<TYPE_NAVIGATE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</TYPE_NAVIGATE>
		<TYPE_RELOAD public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TYPE_RELOAD>
		<TYPE_BACK_FORWARD public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</TYPE_BACK_FORWARD>
		<TYPE_RESERVED public="1" get="inline" set="null" expr="255" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>255</e></m></meta>
		</TYPE_RESERVED>
		<type public="1" set="null"><x path="Int"/></type>
		<redirectCount public="1" set="null"><x path="Int"/></redirectCount>
		<meta><m n=":native"><e>"PerformanceNavigation"</e></m></meta>
	</class>
	<class path="js.html.PerformanceTiming" params="" file="/usr/lib/haxe/std/js/html/PerformanceTiming.hx" extern="1">
		<navigationStart public="1" set="null"><x path="Int"/></navigationStart>
		<unloadEventStart public="1" set="null"><x path="Int"/></unloadEventStart>
		<unloadEventEnd public="1" set="null"><x path="Int"/></unloadEventEnd>
		<redirectStart public="1" set="null"><x path="Int"/></redirectStart>
		<redirectEnd public="1" set="null"><x path="Int"/></redirectEnd>
		<fetchStart public="1" set="null"><x path="Int"/></fetchStart>
		<domainLookupStart public="1" set="null"><x path="Int"/></domainLookupStart>
		<domainLookupEnd public="1" set="null"><x path="Int"/></domainLookupEnd>
		<connectStart public="1" set="null"><x path="Int"/></connectStart>
		<connectEnd public="1" set="null"><x path="Int"/></connectEnd>
		<requestStart public="1" set="null"><x path="Int"/></requestStart>
		<responseStart public="1" set="null"><x path="Int"/></responseStart>
		<responseEnd public="1" set="null"><x path="Int"/></responseEnd>
		<domLoading public="1" set="null"><x path="Int"/></domLoading>
		<domInteractive public="1" set="null"><x path="Int"/></domInteractive>
		<domContentLoadedEventStart public="1" set="null"><x path="Int"/></domContentLoadedEventStart>
		<domContentLoadedEventEnd public="1" set="null"><x path="Int"/></domContentLoadedEventEnd>
		<domComplete public="1" set="null"><x path="Int"/></domComplete>
		<loadEventStart public="1" set="null"><x path="Int"/></loadEventStart>
		<loadEventEnd public="1" set="null"><x path="Int"/></loadEventEnd>
		<meta><m n=":native"><e>"PerformanceTiming"</e></m></meta>
	</class>
	<class path="js.html.PictureElement" params="" file="/usr/lib/haxe/std/js/html/PictureElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLPictureElement"</e></m></meta>
	</class>
	<class path="js.html.Plugin" params="" file="/usr/lib/haxe/std/js/html/Plugin.hx" extern="1">
		<description public="1" set="null"><c path="String"/></description>
		<filename public="1" set="null"><c path="String"/></filename>
		<version public="1" set="null"><c path="String"/></version>
		<name public="1" set="null"><c path="String"/></name>
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.MimeType"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.MimeType"/>
</f></namedItem>
		<meta><m n=":native"><e>"Plugin"</e></m></meta>
	</class>
	<class path="js.html.PluginArray" params="" file="/usr/lib/haxe/std/js/html/PluginArray.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Plugin"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.Plugin"/>
</f></namedItem>
		<refresh public="1" set="method">
			<f a="?reloadDocuments" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{reloadDocuments:false}</e></m></meta>
		</refresh>
		<meta><m n=":native"><e>"PluginArray"</e></m></meta>
	</class>
	<class path="js.html.Position" params="" file="/usr/lib/haxe/std/js/html/Position.hx" extern="1">
		<coords public="1" set="null"><c path="js.html.Coordinates"/></coords>
		<timestamp public="1" set="null"><x path="Int"/></timestamp>
		<meta><m n=":native"><e>"Position"</e></m></meta>
	</class>
	<class path="js.html.PositionError" params="" file="/usr/lib/haxe/std/js/html/PositionError.hx" extern="1">
		<PERMISSION_DENIED public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</PERMISSION_DENIED>
		<POSITION_UNAVAILABLE public="1" get="inline" set="null" expr="2" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</POSITION_UNAVAILABLE>
		<TIMEOUT public="1" get="inline" set="null" expr="3" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TIMEOUT>
		<code public="1" set="null"><x path="Int"/></code>
		<message public="1" set="null"><c path="String"/></message>
		<meta><m n=":native"><e>"PositionError"</e></m></meta>
	</class>
	<typedef path="js.html.PositionOptions" params="" file="/usr/lib/haxe/std/js/html/PositionOptions.hx"><a>
	<timeout>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</timeout>
	<maximumAge>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</maximumAge>
	<enableHighAccuracy>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</enableHighAccuracy>
</a></typedef>
	<class path="js.html.PreElement" params="" file="/usr/lib/haxe/std/js/html/PreElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<width public="1"><x path="Int"/></width>
		<meta><m n=":native"><e>"HTMLPreElement"</e></m></meta>
	</class>
	<class path="js.html.ProcessingInstruction" params="" file="/usr/lib/haxe/std/js/html/ProcessingInstruction.hx" extern="1">
		<extends path="js.html.CharacterData"/>
		<target public="1" set="null"><c path="String"/></target>
		<meta><m n=":native"><e>"ProcessingInstruction"</e></m></meta>
	</class>
	<class path="js.html.ProgressElement" params="" file="/usr/lib/haxe/std/js/html/ProgressElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<value public="1"><x path="Float"/></value>
		<max public="1"><x path="Float"/></max>
		<position public="1" set="null"><x path="Float"/></position>
		<meta><m n=":native"><e>"HTMLProgressElement"</e></m></meta>
	</class>
	<class path="js.html.QuoteElement" params="" file="/usr/lib/haxe/std/js/html/QuoteElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<cite public="1"><c path="String"/></cite>
		<meta><m n=":native"><e>"HTMLQuoteElement"</e></m></meta>
	</class>
	<class path="js.html.Range" params="" file="/usr/lib/haxe/std/js/html/Range.hx" extern="1">
		<START_TO_START public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</START_TO_START>
		<START_TO_END public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</START_TO_END>
		<END_TO_END public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</END_TO_END>
		<END_TO_START public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</END_TO_START>
		<startContainer public="1" set="null"><c path="js.html.Node"/></startContainer>
		<startOffset public="1" set="null"><x path="Int"/></startOffset>
		<endContainer public="1" set="null"><c path="js.html.Node"/></endContainer>
		<endOffset public="1" set="null"><x path="Int"/></endOffset>
		<collapsed public="1" set="null"><x path="Bool"/></collapsed>
		<commonAncestorContainer public="1" set="null"><c path="js.html.Node"/></commonAncestorContainer>
		<setStart public="1" set="method">
			<f a="refNode:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStart>
		<setEnd public="1" set="method">
			<f a="refNode:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEnd>
		<setStartBefore public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStartBefore>
		<setStartAfter public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setStartAfter>
		<setEndBefore public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEndBefore>
		<setEndAfter public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setEndAfter>
		<collapse public="1" set="method">
			<f a="?toStart" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{toStart:false}</e></m></meta>
		</collapse>
		<selectNode public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectNode>
		<selectNodeContents public="1" set="method">
			<f a="refNode">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectNodeContents>
		<compareBoundaryPoints public="1" set="method">
			<f a="how:sourceRange">
				<x path="Int"/>
				<c path="js.html.Range"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</compareBoundaryPoints>
		<deleteContents public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteContents>
		<extractContents public="1" set="method">
			<f a=""><c path="js.html.DocumentFragment"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</extractContents>
		<cloneContents public="1" set="method">
			<f a=""><c path="js.html.DocumentFragment"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cloneContents>
		<insertNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertNode>
		<surroundContents public="1" set="method">
			<f a="newParent">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</surroundContents>
		<cloneRange public="1" set="method"><f a=""><c path="js.html.Range"/></f></cloneRange>
		<detach public="1" set="method"><f a=""><x path="Void"/></f></detach>
		<isPointInRange public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</isPointInRange>
		<comparePoint public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</comparePoint>
		<intersectsNode public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</intersectsNode>
		<createContextualFragment public="1" set="method">
			<f a="fragment">
				<c path="String"/>
				<c path="js.html.DocumentFragment"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createContextualFragment>
		<getClientRects public="1" set="method"><f a=""><c path="js.html.DOMRectList"/></f></getClientRects>
		<getBoundingClientRect public="1" set="method"><f a=""><c path="js.html.DOMRect"/></f></getBoundingClientRect>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Range"</e></m></meta>
	</class>
	<class path="js.html.Screen" params="" file="/usr/lib/haxe/std/js/html/Screen.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<availWidth public="1" set="null"><x path="Int"/></availWidth>
		<availHeight public="1" set="null"><x path="Int"/></availHeight>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<colorDepth public="1" set="null"><x path="Int"/></colorDepth>
		<pixelDepth public="1" set="null"><x path="Int"/></pixelDepth>
		<top public="1" set="null"><x path="Int"/></top>
		<left public="1" set="null"><x path="Int"/></left>
		<availTop public="1" set="null"><x path="Int"/></availTop>
		<availLeft public="1" set="null"><x path="Int"/></availLeft>
		<meta><m n=":native"><e>"Screen"</e></m></meta>
	</class>
	<class path="js.html.ScriptElement" params="" file="/usr/lib/haxe/std/js/html/ScriptElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<charset public="1"><c path="String"/></charset>
		<async public="1"><x path="Bool"/></async>
		<defer public="1"><x path="Bool"/></defer>
		<crossOrigin public="1"><c path="String"/></crossOrigin>
		<text public="1"><c path="String"/></text>
		<event public="1"><c path="String"/></event>
		<htmlFor public="1"><c path="String"/></htmlFor>
		<meta><m n=":native"><e>"HTMLScriptElement"</e></m></meta>
	</class>
	<typedef path="js.html.ScrollIntoViewOptions" params="" file="/usr/lib/haxe/std/js/html/ScrollIntoViewOptions.hx"><a>
	<block>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</block>
	<behavior>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</behavior>
</a></typedef>
	<typedef path="js.html.ScrollOptions" params="" file="/usr/lib/haxe/std/js/html/ScrollOptions.hx"><a><behavior>
	<t path="Null"><d/></t>
	<meta><m n=":optional"/></meta>
</behavior></a></typedef>
	<typedef path="js.html.ScrollToOptions" params="" file="/usr/lib/haxe/std/js/html/ScrollToOptions.hx"><a>
	<top>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</top>
	<left>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</left>
	<behavior>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</behavior>
</a></typedef>
	<class path="js.html.SelectElement" params="" file="/usr/lib/haxe/std/js/html/SelectElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<multiple public="1"><x path="Bool"/></multiple>
		<name public="1"><c path="String"/></name>
		<required public="1"><x path="Bool"/></required>
		<size public="1"><x path="Int"/></size>
		<type public="1" set="null"><c path="String"/></type>
		<options public="1" set="null"><c path="js.html.HTMLOptionsCollection"/></options>
		<length public="1"><x path="Int"/></length>
		<selectedOptions public="1" set="null"><c path="js.html.HTMLCollection"/></selectedOptions>
		<selectedIndex public="1"><x path="Int"/></selectedIndex>
		<value public="1"><c path="String"/></value>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Element"/>
</f></item>
		<namedItem public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="js.html.OptionElement"/>
</f></namedItem>
		<add public="1" set="method">
			<f a="element:?before">
				<x path="haxe.extern.EitherType">
					<c path="js.html.OptionElement"/>
					<c path="js.html.OptGroupElement"/>
				</x>
				<x path="haxe.extern.EitherType">
					<c path="js.html.Element"/>
					<x path="Int"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<meta><m n=":native"><e>"HTMLSelectElement"</e></m></meta>
	</class>
	<class path="js.html.Selection" params="" file="/usr/lib/haxe/std/js/html/Selection.hx" extern="1">
		<anchorNode public="1" set="null"><c path="js.html.Node"/></anchorNode>
		<anchorOffset public="1" set="null"><x path="Int"/></anchorOffset>
		<focusNode public="1" set="null"><c path="js.html.Node"/></focusNode>
		<focusOffset public="1" set="null"><x path="Int"/></focusOffset>
		<isCollapsed public="1" set="null"><x path="Bool"/></isCollapsed>
		<rangeCount public="1" set="null"><x path="Int"/></rangeCount>
		<collapse public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapse>
		<collapseToStart public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapseToStart>
		<collapseToEnd public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</collapseToEnd>
		<extend public="1" set="method">
			<f a="node:offset">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</extend>
		<selectAllChildren public="1" set="method">
			<f a="node">
				<c path="js.html.Node"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</selectAllChildren>
		<deleteFromDocument public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteFromDocument>
		<getRangeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="js.html.Range"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getRangeAt>
		<addRange public="1" set="method">
			<f a="range">
				<c path="js.html.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</addRange>
		<removeRange public="1" set="method">
			<f a="range">
				<c path="js.html.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeRange>
		<removeAllRanges public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeAllRanges>
		<containsNode public="1" set="method">
			<f a="node:allowPartialContainment">
				<c path="js.html.Node"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</containsNode>
		<modify public="1" set="method">
			<f a="alter:direction:granularity">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</modify>
		<meta><m n=":native"><e>"Selection"</e></m></meta>
	</class>
	<abstract path="js.html.SelectionMode" params="" file="/usr/lib/haxe/std/js/html/SelectionMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._SelectionMode.SelectionMode_Impl_" params="" file="/usr/lib/haxe/std/js/html/SelectionMode.hx" private="1" module="js.html.SelectionMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="js.html.SessionType" params="" file="/usr/lib/haxe/std/js/html/SessionType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._SessionType.SessionType_Impl_" params="" file="/usr/lib/haxe/std/js/html/SessionType.hx" private="1" module="js.html.SessionType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.ShadowElement" params="" file="/usr/lib/haxe/std/js/html/ShadowElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<olderShadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></olderShadowRoot>
		<meta><m n=":native"><e>"HTMLShadowElement"</e></m></meta>
	</class>
	<class path="js.html.ShadowRoot" params="" file="/usr/lib/haxe/std/js/html/ShadowRoot.hx" extern="1">
		<extends path="js.html.DocumentFragment"/>
		<innerHTML public="1"><c path="String"/></innerHTML>
		<host public="1" set="null"><c path="js.html.Element"/></host>
		<olderShadowRoot public="1" set="null"><c path="js.html.ShadowRoot"/></olderShadowRoot>
		<applyAuthorStyles public="1"><x path="Bool"/></applyAuthorStyles>
		<styleSheets public="1" set="null"><c path="js.html.StyleSheetList"/></styleSheets>
		<getElementsByTagName public="1" set="method"><f a="localName">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method"><f a="namespace_:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByTagNameNS>
		<getElementsByClassName public="1" set="method"><f a="classNames">
	<c path="String"/>
	<c path="js.html.HTMLCollection"/>
</f></getElementsByClassName>
		<meta><m n=":native"><e>"ShadowRoot"</e></m></meta>
	</class>
	<class path="js.html.SourceElement" params="" file="/usr/lib/haxe/std/js/html/SourceElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<src public="1"><c path="String"/></src>
		<type public="1"><c path="String"/></type>
		<srcset public="1"><c path="String"/></srcset>
		<sizes public="1"><c path="String"/></sizes>
		<media public="1"><c path="String"/></media>
		<meta><m n=":native"><e>"HTMLSourceElement"</e></m></meta>
	</class>
	<class path="js.html.SpanElement" params="" file="/usr/lib/haxe/std/js/html/SpanElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<meta><m n=":native"><e>"HTMLSpanElement"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesis" params="" file="/usr/lib/haxe/std/js/html/SpeechSynthesis.hx" extern="1">
		<pending public="1" set="null"><x path="Bool"/></pending>
		<speaking public="1" set="null"><x path="Bool"/></speaking>
		<paused public="1" set="null"><x path="Bool"/></paused>
		<speak public="1" set="method"><f a="utterance">
	<c path="js.html.SpeechSynthesisUtterance"/>
	<x path="Void"/>
</f></speak>
		<cancel public="1" set="method"><f a=""><x path="Void"/></f></cancel>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<getVoices public="1" set="method"><f a=""><c path="Array"><c path="js.html.SpeechSynthesisVoice"/></c></f></getVoices>
		<meta><m n=":native"><e>"SpeechSynthesis"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesisUtterance" params="" file="/usr/lib/haxe/std/js/html/SpeechSynthesisUtterance.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<text public="1"><c path="String"/></text>
		<lang public="1"><c path="String"/></lang>
		<voice public="1"><c path="js.html.SpeechSynthesisVoice"/></voice>
		<volume public="1"><x path="Float"/></volume>
		<rate public="1"><x path="Float"/></rate>
		<pitch public="1"><x path="Float"/></pitch>
		<onstart public="1"><x path="haxe.Function"/></onstart>
		<onend public="1"><x path="haxe.Function"/></onend>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onresume public="1"><x path="haxe.Function"/></onresume>
		<onmark public="1"><x path="haxe.Function"/></onmark>
		<onboundary public="1"><x path="haxe.Function"/></onboundary>
		<new public="1" set="method">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"SpeechSynthesisUtterance"</e></m></meta>
	</class>
	<class path="js.html.SpeechSynthesisVoice" params="" file="/usr/lib/haxe/std/js/html/SpeechSynthesisVoice.hx" extern="1">
		<voiceURI public="1" set="null"><c path="String"/></voiceURI>
		<name public="1" set="null"><c path="String"/></name>
		<lang public="1" set="null"><c path="String"/></lang>
		<localService public="1" set="null"><x path="Bool"/></localService>
		<default_ public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":native"><e>"default"</e></m></meta>
		</default_>
		<meta><m n=":native"><e>"SpeechSynthesisVoice"</e></m></meta>
	</class>
	<class path="js.html.Storage" params="" file="/usr/lib/haxe/std/js/html/Storage.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<key public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</key>
		<getItem public="1" set="method">
			<f a="key">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getItem>
		<setItem public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setItem>
		<removeItem public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeItem>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clear>
		<meta><m n=":native"><e>"Storage"</e></m></meta>
	</class>
	<class path="js.html.StyleElement" params="" file="/usr/lib/haxe/std/js/html/StyleElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<disabled public="1"><x path="Bool"/></disabled>
		<media public="1"><c path="String"/></media>
		<type public="1"><c path="String"/></type>
		<scoped public="1"><x path="Bool"/></scoped>
		<sheet public="1" set="null"><c path="js.html.StyleSheet"/></sheet>
		<meta><m n=":native"><e>"HTMLStyleElement"</e></m></meta>
	</class>
	<class path="js.html.StyleSheetList" params="" file="/usr/lib/haxe/std/js/html/StyleSheetList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.StyleSheet"/>
</f></item>
		<meta><m n=":native"><e>"StyleSheetList"</e></m></meta>
	</class>
	<class path="js.html.TableCaptionElement" params="" file="/usr/lib/haxe/std/js/html/TableCaptionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<align public="1"><c path="String"/></align>
		<meta><m n=":native"><e>"HTMLTableCaptionElement"</e></m></meta>
	</class>
	<class path="js.html.TableCellElement" params="" file="/usr/lib/haxe/std/js/html/TableCellElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<colSpan public="1"><x path="Int"/></colSpan>
		<rowSpan public="1"><x path="Int"/></rowSpan>
		<headers public="1"><c path="String"/></headers>
		<cellIndex public="1" set="null"><x path="Int"/></cellIndex>
		<abbr public="1"><c path="String"/></abbr>
		<scope public="1"><c path="String"/></scope>
		<align public="1"><c path="String"/></align>
		<axis public="1"><c path="String"/></axis>
		<height public="1"><c path="String"/></height>
		<width public="1"><c path="String"/></width>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<noWrap public="1"><x path="Bool"/></noWrap>
		<vAlign public="1"><c path="String"/></vAlign>
		<bgColor public="1"><c path="String"/></bgColor>
		<meta><m n=":native"><e>"HTMLTableCellElement"</e></m></meta>
	</class>
	<class path="js.html.TableColElement" params="" file="/usr/lib/haxe/std/js/html/TableColElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<span public="1"><x path="Int"/></span>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<width public="1"><c path="String"/></width>
		<meta><m n=":native"><e>"HTMLTableColElement"</e></m></meta>
	</class>
	<class path="js.html.TableElement" params="" file="/usr/lib/haxe/std/js/html/TableElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<caption public="1"><c path="js.html.TableCaptionElement"/></caption>
		<tHead public="1"><c path="js.html.TableSectionElement"/></tHead>
		<tFoot public="1"><c path="js.html.TableSectionElement"/></tFoot>
		<tBodies public="1" set="null"><c path="js.html.HTMLCollection"/></tBodies>
		<rows public="1" set="null"><c path="js.html.HTMLCollection"/></rows>
		<align public="1"><c path="String"/></align>
		<border public="1"><c path="String"/></border>
		<frame public="1"><c path="String"/></frame>
		<rules public="1"><c path="String"/></rules>
		<summary public="1"><c path="String"/></summary>
		<width public="1"><c path="String"/></width>
		<bgColor public="1"><c path="String"/></bgColor>
		<cellPadding public="1"><c path="String"/></cellPadding>
		<cellSpacing public="1"><c path="String"/></cellSpacing>
		<createCaption public="1" set="method"><f a=""><c path="js.html.Element"/></f></createCaption>
		<deleteCaption public="1" set="method"><f a=""><x path="Void"/></f></deleteCaption>
		<createTHead public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTHead>
		<deleteTHead public="1" set="method"><f a=""><x path="Void"/></f></deleteTHead>
		<createTFoot public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTFoot>
		<deleteTFoot public="1" set="method"><f a=""><x path="Void"/></f></deleteTFoot>
		<createTBody public="1" set="method"><f a=""><c path="js.html.Element"/></f></createTBody>
		<insertRow public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRow>
		<deleteRow public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRow>
		<meta><m n=":native"><e>"HTMLTableElement"</e></m></meta>
	</class>
	<class path="js.html.TableRowElement" params="" file="/usr/lib/haxe/std/js/html/TableRowElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<rowIndex public="1" set="null"><x path="Int"/></rowIndex>
		<sectionRowIndex public="1" set="null"><x path="Int"/></sectionRowIndex>
		<cells public="1" set="null"><c path="js.html.HTMLCollection"/></cells>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<bgColor public="1"><c path="String"/></bgColor>
		<insertCell public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertCell>
		<deleteCell public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteCell>
		<meta><m n=":native"><e>"HTMLTableRowElement"</e></m></meta>
	</class>
	<class path="js.html.TableSectionElement" params="" file="/usr/lib/haxe/std/js/html/TableSectionElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<rows public="1" set="null"><c path="js.html.HTMLCollection"/></rows>
		<align public="1"><c path="String"/></align>
		<ch public="1"><c path="String"/></ch>
		<chOff public="1"><c path="String"/></chOff>
		<vAlign public="1"><c path="String"/></vAlign>
		<insertRow public="1" set="method">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="js.html.Element"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</insertRow>
		<deleteRow public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteRow>
		<meta><m n=":native"><e>"HTMLTableSectionElement"</e></m></meta>
	</class>
	<class path="js.html.TextAreaElement" params="" file="/usr/lib/haxe/std/js/html/TextAreaElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<autofocus public="1"><x path="Bool"/></autofocus>
		<cols public="1"><x path="Int"/></cols>
		<disabled public="1"><x path="Bool"/></disabled>
		<form public="1" set="null"><c path="js.html.FormElement"/></form>
		<maxLength public="1"><x path="Int"/></maxLength>
		<name public="1"><c path="String"/></name>
		<placeholder public="1"><c path="String"/></placeholder>
		<readOnly public="1"><x path="Bool"/></readOnly>
		<required public="1"><x path="Bool"/></required>
		<rows public="1"><x path="Int"/></rows>
		<wrap public="1"><c path="String"/></wrap>
		<type public="1" set="null"><c path="String"/></type>
		<defaultValue public="1"><c path="String"/></defaultValue>
		<value public="1"><c path="String"/></value>
		<textLength public="1" set="null"><x path="Int"/></textLength>
		<willValidate public="1" set="null"><x path="Bool"/></willValidate>
		<validity public="1" set="null"><c path="js.html.ValidityState"/></validity>
		<validationMessage public="1" set="null"><c path="String"/></validationMessage>
		<selectionStart public="1"><x path="Int"/></selectionStart>
		<selectionEnd public="1"><x path="Int"/></selectionEnd>
		<selectionDirection public="1"><c path="String"/></selectionDirection>
		<checkValidity public="1" set="method"><f a=""><x path="Bool"/></f></checkValidity>
		<setCustomValidity public="1" set="method"><f a="error">
	<c path="String"/>
	<x path="Void"/>
</f></setCustomValidity>
		<select public="1" set="method"><f a=""><x path="Void"/></f></select>
		<setRangeText public="1" set="method">
			<f a="replacement:start:end:?selectionMode" v=":::&quot;preserve&quot;">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="js.html.SelectionMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{selectionMode:"preserve"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setRangeText public="1" set="method">
	<f a="replacement">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setRangeText></overloads>
		</setRangeText>
		<setSelectionRange public="1" set="method">
			<f a="start:end:?direction">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setSelectionRange>
		<meta><m n=":native"><e>"HTMLTextAreaElement"</e></m></meta>
	</class>
	<class path="js.html.TextMetrics" params="" file="/usr/lib/haxe/std/js/html/TextMetrics.hx" extern="1">
		<width public="1" set="null"><x path="Float"/></width>
		<meta><m n=":native"><e>"TextMetrics"</e></m></meta>
	</class>
	<class path="js.html.TextTrack" params="" file="/usr/lib/haxe/std/js/html/TextTrack.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<kind public="1" set="null"><x path="js.html.TextTrackKind"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<id public="1" set="null"><c path="String"/></id>
		<inBandMetadataTrackDispatchType public="1" set="null"><c path="String"/></inBandMetadataTrackDispatchType>
		<mode public="1"><x path="js.html.TextTrackMode"/></mode>
		<cues public="1" set="null"><c path="js.html.TextTrackCueList"/></cues>
		<activeCues public="1" set="null"><c path="js.html.TextTrackCueList"/></activeCues>
		<addCue public="1" set="method"><f a="cue">
	<c path="js.html.VTTCue"/>
	<x path="Void"/>
</f></addCue>
		<removeCue public="1" set="method">
			<f a="cue">
				<c path="js.html.VTTCue"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</removeCue>
		<meta><m n=":native"><e>"TextTrack"</e></m></meta>
	</class>
	<class path="js.html.TextTrackCueList" params="" file="/usr/lib/haxe/std/js/html/TextTrackCueList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getCueById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.VTTCue"/>
</f></getCueById>
		<meta><m n=":native"><e>"TextTrackCueList"</e></m></meta>
	</class>
	<abstract path="js.html.TextTrackKind" params="" file="/usr/lib/haxe/std/js/html/TextTrackKind.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._TextTrackKind.TextTrackKind_Impl_" params="" file="/usr/lib/haxe/std/js/html/TextTrackKind.hx" private="1" module="js.html.TextTrackKind"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.TextTrackList" params="" file="/usr/lib/haxe/std/js/html/TextTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.TextTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"TextTrackList"</e></m></meta>
	</class>
	<abstract path="js.html.TextTrackMode" params="" file="/usr/lib/haxe/std/js/html/TextTrackMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._TextTrackMode.TextTrackMode_Impl_" params="" file="/usr/lib/haxe/std/js/html/TextTrackMode.hx" private="1" module="js.html.TextTrackMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.TimeRanges" params="" file="/usr/lib/haxe/std/js/html/TimeRanges.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<start public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</start>
		<end public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</end>
		<meta><m n=":native"><e>"TimeRanges"</e></m></meta>
	</class>
	<class path="js.html.TitleElement" params="" file="/usr/lib/haxe/std/js/html/TitleElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<text public="1"><c path="String"/></text>
		<meta><m n=":native"><e>"HTMLTitleElement"</e></m></meta>
	</class>
	<class path="js.html.Touch" params="" file="/usr/lib/haxe/std/js/html/Touch.hx" extern="1">
		<identifier public="1" set="null"><x path="Int"/></identifier>
		<target public="1" set="null"><c path="js.html.EventTarget"/></target>
		<screenX public="1" set="null"><x path="Int"/></screenX>
		<screenY public="1" set="null"><x path="Int"/></screenY>
		<clientX public="1" set="null"><x path="Int"/></clientX>
		<clientY public="1" set="null"><x path="Int"/></clientY>
		<pageX public="1" set="null"><x path="Int"/></pageX>
		<pageY public="1" set="null"><x path="Int"/></pageY>
		<radiusX public="1" set="null"><x path="Int"/></radiusX>
		<radiusY public="1" set="null"><x path="Int"/></radiusY>
		<rotationAngle public="1" set="null"><x path="Float"/></rotationAngle>
		<force public="1" set="null"><x path="Float"/></force>
		<meta><m n=":native"><e>"Touch"</e></m></meta>
	</class>
	<class path="js.html.TouchList" params="" file="/usr/lib/haxe/std/js/html/TouchList.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<item public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="js.html.Touch"/>
</f></item>
		<identifiedTouch public="1" set="method"><f a="identifier">
	<x path="Int"/>
	<c path="js.html.Touch"/>
</f></identifiedTouch>
		<meta><m n=":native"><e>"TouchList"</e></m></meta>
	</class>
	<class path="js.html.TrackElement" params="" file="/usr/lib/haxe/std/js/html/TrackElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<NONE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<LOADING public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LOADING>
		<LOADED public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LOADED>
		<ERROR public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</ERROR>
		<kind public="1"><c path="String"/></kind>
		<src public="1"><c path="String"/></src>
		<srclang public="1"><c path="String"/></srclang>
		<label public="1"><c path="String"/></label>
		<default_ public="1">
			<x path="Bool"/>
			<meta><m n=":native"><e>"default"</e></m></meta>
		</default_>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<track public="1" set="null"><c path="js.html.TextTrack"/></track>
		<meta><m n=":native"><e>"HTMLTrackElement"</e></m></meta>
	</class>
	<class path="js.html.TreeWalker" params="" file="/usr/lib/haxe/std/js/html/TreeWalker.hx" extern="1">
		<root public="1" set="null"><c path="js.html.Node"/></root>
		<whatToShow public="1" set="null"><x path="Int"/></whatToShow>
		<filter public="1" set="null"><c path="js.html.NodeFilter"/></filter>
		<currentNode public="1"><c path="js.html.Node"/></currentNode>
		<parentNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</parentNode>
		<firstChild public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</firstChild>
		<lastChild public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</lastChild>
		<previousSibling public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousSibling>
		<nextSibling public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextSibling>
		<previousNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</previousNode>
		<nextNode public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</nextNode>
		<meta><m n=":native"><e>"TreeWalker"</e></m></meta>
	</class>
	<class path="js.html.UListElement" params="" file="/usr/lib/haxe/std/js/html/UListElement.hx" extern="1">
		<extends path="js.html.Element"/>
		<compact public="1"><x path="Bool"/></compact>
		<type public="1"><c path="String"/></type>
		<meta><m n=":native"><e>"HTMLUListElement"</e></m></meta>
	</class>
	<class path="js.html.URLSearchParams" params="" file="/usr/lib/haxe/std/js/html/URLSearchParams.hx" extern="1">
		<append public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></append>
		<delete_ public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
		</delete_>
		<get public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<getAll public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getAll>
		<has public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<set public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></set>
		<new public="1" set="method">
			<f a="init">
				<c path="js.html.URLSearchParams"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?init" v="&quot;&quot;">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<meta><m n=":value"><e>{init:""}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"URLSearchParams"</e></m></meta>
	</class>
	<class path="js.html.Uint8ClampedArray" params="" file="/usr/lib/haxe/std/js/html/Uint8ClampedArray.hx" extern="1">
		<extends path="js.html.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method">
			<f a="array:?offset">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<set public="1" set="method"><f a="index:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
				<set public="1" set="method"><f a="array:?offset">
	<c path="js.html.Uint8ClampedArray"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
			</overloads>
		</set>
		<subarray public="1" set="method"><f a="start:end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.Uint8ClampedArray"/>
</f></subarray>
		<new public="1" set="method">
			<f a="buffer:?byteOffset:?length">
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="length">
						<x path="Int"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="js.html.Uint8ClampedArray"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="array">
						<c path="Array"><x path="Int"/></c>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"Uint8ClampedArray"</e></m></meta>
	</class>
	<class path="js.html.VTTCue" params="" file="/usr/lib/haxe/std/js/html/VTTCue.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<track public="1" set="null"><c path="js.html.TextTrack"/></track>
		<id public="1"><c path="String"/></id>
		<startTime public="1"><x path="Float"/></startTime>
		<endTime public="1"><x path="Float"/></endTime>
		<pauseOnExit public="1"><x path="Bool"/></pauseOnExit>
		<region public="1"><c path="js.html.VTTRegion"/></region>
		<vertical public="1"><x path="js.html.DirectionSetting"/></vertical>
		<snapToLines public="1"><x path="Bool"/></snapToLines>
		<line public="1"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<d/>
</x></line>
		<lineAlign public="1"><x path="js.html.AlignSetting"/></lineAlign>
		<position public="1"><x path="Int"/></position>
		<positionAlign public="1"><x path="js.html.AlignSetting"/></positionAlign>
		<size public="1"><x path="Int"/></size>
		<align public="1"><x path="js.html.AlignSetting"/></align>
		<text public="1"><c path="String"/></text>
		<onenter public="1"><x path="haxe.Function"/></onenter>
		<onexit public="1"><x path="haxe.Function"/></onexit>
		<getCueAsHTML public="1" set="method"><f a=""><c path="js.html.DocumentFragment"/></f></getCueAsHTML>
		<new public="1" set="method">
			<f a="startTime:endTime:text">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"VTTCue"</e></m></meta>
	</class>
	<class path="js.html.VTTRegion" params="" file="/usr/lib/haxe/std/js/html/VTTRegion.hx" extern="1">
		<width public="1"><x path="Float"/></width>
		<lines public="1"><x path="Int"/></lines>
		<regionAnchorX public="1"><x path="Float"/></regionAnchorX>
		<regionAnchorY public="1"><x path="Float"/></regionAnchorY>
		<viewportAnchorX public="1"><x path="Float"/></viewportAnchorX>
		<viewportAnchorY public="1"><x path="Float"/></viewportAnchorY>
		<scroll public="1"><c path="String"/></scroll>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"VTTRegion"</e></m></meta>
	</class>
	<class path="js.html.ValidityState" params="" file="/usr/lib/haxe/std/js/html/ValidityState.hx" extern="1">
		<valueMissing public="1" set="null"><x path="Bool"/></valueMissing>
		<typeMismatch public="1" set="null"><x path="Bool"/></typeMismatch>
		<patternMismatch public="1" set="null"><x path="Bool"/></patternMismatch>
		<tooLong public="1" set="null"><x path="Bool"/></tooLong>
		<rangeUnderflow public="1" set="null"><x path="Bool"/></rangeUnderflow>
		<rangeOverflow public="1" set="null"><x path="Bool"/></rangeOverflow>
		<stepMismatch public="1" set="null"><x path="Bool"/></stepMismatch>
		<badInput public="1" set="null"><x path="Bool"/></badInput>
		<customError public="1" set="null"><x path="Bool"/></customError>
		<valid public="1" set="null"><x path="Bool"/></valid>
		<meta><m n=":native"><e>"ValidityState"</e></m></meta>
	</class>
	<class path="js.html.VideoElement" params="" file="/usr/lib/haxe/std/js/html/VideoElement.hx" extern="1">
		<extends path="js.html.MediaElement"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<poster public="1"><c path="String"/></poster>
		<getVideoPlaybackQuality public="1" set="method"><f a=""><c path="js.html.VideoPlaybackQuality"/></f></getVideoPlaybackQuality>
		<meta><m n=":native"><e>"HTMLVideoElement"</e></m></meta>
	</class>
	<class path="js.html.VideoPlaybackQuality" params="" file="/usr/lib/haxe/std/js/html/VideoPlaybackQuality.hx" extern="1">
		<creationTime public="1" set="null"><x path="Float"/></creationTime>
		<totalVideoFrames public="1" set="null"><x path="Int"/></totalVideoFrames>
		<droppedVideoFrames public="1" set="null"><x path="Int"/></droppedVideoFrames>
		<corruptedVideoFrames public="1" set="null"><x path="Int"/></corruptedVideoFrames>
		<meta><m n=":native"><e>"VideoPlaybackQuality"</e></m></meta>
	</class>
	<class path="js.html.VideoTrack" params="" file="/usr/lib/haxe/std/js/html/VideoTrack.hx" extern="1">
		<id public="1" set="null"><c path="String"/></id>
		<kind public="1" set="null"><c path="String"/></kind>
		<label public="1" set="null"><c path="String"/></label>
		<language public="1" set="null"><c path="String"/></language>
		<selected public="1"><x path="Bool"/></selected>
		<meta><m n=":native"><e>"VideoTrack"</e></m></meta>
	</class>
	<class path="js.html.VideoTrackList" params="" file="/usr/lib/haxe/std/js/html/VideoTrackList.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<length public="1" set="null"><x path="Int"/></length>
		<selectedIndex public="1" set="null"><x path="Int"/></selectedIndex>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onaddtrack public="1"><x path="haxe.Function"/></onaddtrack>
		<onremovetrack public="1"><x path="haxe.Function"/></onremovetrack>
		<getTrackById public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="js.html.VideoTrack"/>
</f></getTrackById>
		<meta><m n=":native"><e>"VideoTrackList"</e></m></meta>
	</class>
	<abstract path="js.html.VisibilityState" params="" file="/usr/lib/haxe/std/js/html/VisibilityState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._VisibilityState.VisibilityState_Impl_" params="" file="/usr/lib/haxe/std/js/html/VisibilityState.hx" private="1" module="js.html.VisibilityState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.Window" params="" file="/usr/lib/haxe/std/js/html/Window.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<window public="1" set="null"><c path="js.html.Window"/></window>
		<self public="1" set="null"><c path="js.html.Window"/></self>
		<document public="1" set="null"><c path="js.html.HTMLDocument"/></document>
		<name public="1"><c path="String"/></name>
		<location public="1" set="null"><c path="js.html.Location"/></location>
		<history public="1" set="null"><c path="js.html.History"/></history>
		<locationbar public="1" set="null"><c path="js.html.BarProp"/></locationbar>
		<menubar public="1" set="null"><c path="js.html.BarProp"/></menubar>
		<personalbar public="1" set="null"><c path="js.html.BarProp"/></personalbar>
		<scrollbars public="1" set="null"><c path="js.html.BarProp"/></scrollbars>
		<statusbar public="1" set="null"><c path="js.html.BarProp"/></statusbar>
		<toolbar public="1" set="null"><c path="js.html.BarProp"/></toolbar>
		<status public="1"><c path="String"/></status>
		<closed public="1" set="null"><x path="Bool"/></closed>
		<frames public="1" set="null"><c path="js.html.Window"/></frames>
		<length public="1" set="null"><x path="Int"/></length>
		<top public="1" set="null"><c path="js.html.Window"/></top>
		<opener public="1"><d/></opener>
		<parent public="1" set="null"><c path="js.html.Window"/></parent>
		<frameElement public="1" set="null"><c path="js.html.Element"/></frameElement>
		<navigator public="1" set="null"><c path="js.html.Navigator"/></navigator>
		<applicationCache public="1" set="null"><c path="js.html.ApplicationCache"/></applicationCache>
		<orientation public="1" set="null"><x path="Int"/></orientation>
		<onorientationchange public="1"><x path="haxe.Function"/></onorientationchange>
		<screen public="1" set="null"><c path="js.html.Screen"/></screen>
		<innerWidth public="1"><x path="Int"/></innerWidth>
		<innerHeight public="1"><x path="Int"/></innerHeight>
		<scrollX public="1" set="null"><x path="Int"/></scrollX>
		<pageXOffset public="1" set="null"><x path="Int"/></pageXOffset>
		<scrollY public="1" set="null"><x path="Int"/></scrollY>
		<pageYOffset public="1" set="null"><x path="Int"/></pageYOffset>
		<screenX public="1"><x path="Int"/></screenX>
		<screenY public="1"><x path="Int"/></screenY>
		<outerWidth public="1"><x path="Int"/></outerWidth>
		<outerHeight public="1"><x path="Int"/></outerHeight>
		<performance public="1" set="null"><c path="js.html.Performance"/></performance>
		<crypto public="1" set="null"><d/></crypto>
		<devicePixelRatio public="1" set="null"><x path="Float"/></devicePixelRatio>
		<scrollMaxX public="1" set="null"><x path="Int"/></scrollMaxX>
		<scrollMaxY public="1" set="null"><x path="Int"/></scrollMaxY>
		<fullScreen public="1"><x path="Bool"/></fullScreen>
		<onwheel public="1"><x path="haxe.Function"/></onwheel>
		<ondevicemotion public="1"><x path="haxe.Function"/></ondevicemotion>
		<ondeviceorientation public="1"><x path="haxe.Function"/></ondeviceorientation>
		<ondeviceproximity public="1"><x path="haxe.Function"/></ondeviceproximity>
		<onuserproximity public="1"><x path="haxe.Function"/></onuserproximity>
		<ondevicelight public="1"><x path="haxe.Function"/></ondevicelight>
		<content public="1" set="null"><d/></content>
		<console public="1" set="null"><c path="js.html.Console"/></console>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onblur public="1"><x path="haxe.Function"/></onblur>
		<onfocus public="1"><x path="haxe.Function"/></onfocus>
		<oncanplay public="1"><x path="haxe.Function"/></oncanplay>
		<oncanplaythrough public="1"><x path="haxe.Function"/></oncanplaythrough>
		<onchange public="1"><x path="haxe.Function"/></onchange>
		<onclick public="1"><x path="haxe.Function"/></onclick>
		<oncontextmenu public="1"><x path="haxe.Function"/></oncontextmenu>
		<ondblclick public="1"><x path="haxe.Function"/></ondblclick>
		<ondrag public="1"><x path="haxe.Function"/></ondrag>
		<ondragend public="1"><x path="haxe.Function"/></ondragend>
		<ondragenter public="1"><x path="haxe.Function"/></ondragenter>
		<ondragleave public="1"><x path="haxe.Function"/></ondragleave>
		<ondragover public="1"><x path="haxe.Function"/></ondragover>
		<ondragstart public="1"><x path="haxe.Function"/></ondragstart>
		<ondrop public="1"><x path="haxe.Function"/></ondrop>
		<ondurationchange public="1"><x path="haxe.Function"/></ondurationchange>
		<onemptied public="1"><x path="haxe.Function"/></onemptied>
		<onended public="1"><x path="haxe.Function"/></onended>
		<oninput public="1"><x path="haxe.Function"/></oninput>
		<oninvalid public="1"><x path="haxe.Function"/></oninvalid>
		<onkeydown public="1"><x path="haxe.Function"/></onkeydown>
		<onkeypress public="1"><x path="haxe.Function"/></onkeypress>
		<onkeyup public="1"><x path="haxe.Function"/></onkeyup>
		<onload public="1"><x path="haxe.Function"/></onload>
		<onloadeddata public="1"><x path="haxe.Function"/></onloadeddata>
		<onloadedmetadata public="1"><x path="haxe.Function"/></onloadedmetadata>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onmousedown public="1"><x path="haxe.Function"/></onmousedown>
		<onmouseenter public="1"><x path="haxe.Function"/></onmouseenter>
		<onmouseleave public="1"><x path="haxe.Function"/></onmouseleave>
		<onmousemove public="1"><x path="haxe.Function"/></onmousemove>
		<onmouseout public="1"><x path="haxe.Function"/></onmouseout>
		<onmouseover public="1"><x path="haxe.Function"/></onmouseover>
		<onmouseup public="1"><x path="haxe.Function"/></onmouseup>
		<onpause public="1"><x path="haxe.Function"/></onpause>
		<onplay public="1"><x path="haxe.Function"/></onplay>
		<onplaying public="1"><x path="haxe.Function"/></onplaying>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onratechange public="1"><x path="haxe.Function"/></onratechange>
		<onreset public="1"><x path="haxe.Function"/></onreset>
		<onscroll public="1"><x path="haxe.Function"/></onscroll>
		<onseeked public="1"><x path="haxe.Function"/></onseeked>
		<onseeking public="1"><x path="haxe.Function"/></onseeking>
		<onselect public="1"><x path="haxe.Function"/></onselect>
		<onshow public="1"><x path="haxe.Function"/></onshow>
		<onstalled public="1"><x path="haxe.Function"/></onstalled>
		<onsubmit public="1"><x path="haxe.Function"/></onsubmit>
		<onsuspend public="1"><x path="haxe.Function"/></onsuspend>
		<ontimeupdate public="1"><x path="haxe.Function"/></ontimeupdate>
		<onvolumechange public="1"><x path="haxe.Function"/></onvolumechange>
		<onwaiting public="1"><x path="haxe.Function"/></onwaiting>
		<onpointercancel public="1"><x path="haxe.Function"/></onpointercancel>
		<onpointerdown public="1"><x path="haxe.Function"/></onpointerdown>
		<onpointerup public="1"><x path="haxe.Function"/></onpointerup>
		<onpointermove public="1"><x path="haxe.Function"/></onpointermove>
		<onpointerout public="1"><x path="haxe.Function"/></onpointerout>
		<onpointerover public="1"><x path="haxe.Function"/></onpointerover>
		<onpointerenter public="1"><x path="haxe.Function"/></onpointerenter>
		<onpointerleave public="1"><x path="haxe.Function"/></onpointerleave>
		<ongotpointercapture public="1"><x path="haxe.Function"/></ongotpointercapture>
		<onlostpointercapture public="1"><x path="haxe.Function"/></onlostpointercapture>
		<onpointerlockchange public="1"><x path="haxe.Function"/></onpointerlockchange>
		<onpointerlockerror public="1"><x path="haxe.Function"/></onpointerlockerror>
		<indexedDB public="1" set="null"><c path="js.html.idb.Factory"/></indexedDB>
		<onerror public="1"><f a="::::">
	<x path="haxe.extern.EitherType">
		<c path="js.html.Event"/>
		<c path="String"/>
	</x>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<x path="Bool"/>
</f></onerror>
		<speechSynthesis public="1" set="null"><c path="js.html.SpeechSynthesis"/></speechSynthesis>
		<ontouchstart public="1"><x path="haxe.Function"/></ontouchstart>
		<ontouchend public="1"><x path="haxe.Function"/></ontouchend>
		<ontouchmove public="1"><x path="haxe.Function"/></ontouchmove>
		<ontouchcancel public="1"><x path="haxe.Function"/></ontouchcancel>
		<onafterprint public="1"><x path="haxe.Function"/></onafterprint>
		<onbeforeprint public="1"><x path="haxe.Function"/></onbeforeprint>
		<onbeforeunload public="1"><f a="">
	<c path="js.html.Event"/>
	<c path="String"/>
</f></onbeforeunload>
		<onhashchange public="1"><x path="haxe.Function"/></onhashchange>
		<onlanguagechange public="1"><x path="haxe.Function"/></onlanguagechange>
		<onmessage public="1"><x path="haxe.Function"/></onmessage>
		<onoffline public="1"><x path="haxe.Function"/></onoffline>
		<ononline public="1"><x path="haxe.Function"/></ononline>
		<onpagehide public="1"><x path="haxe.Function"/></onpagehide>
		<onpageshow public="1"><x path="haxe.Function"/></onpageshow>
		<onpopstate public="1"><x path="haxe.Function"/></onpopstate>
		<onresize public="1"><x path="haxe.Function"/></onresize>
		<onunload public="1"><x path="haxe.Function"/></onunload>
		<localStorage public="1" set="null"><c path="js.html.Storage"/></localStorage>
		<sessionStorage public="1" set="null"><c path="js.html.Storage"/></sessionStorage>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</close>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</stop>
		<focus public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</focus>
		<blur public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</blur>
		<open public="1" set="method">
			<f a="?url:?target:?features" v="&quot;&quot;:&quot;&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.Window"/>
			</f>
			<meta><m n=":value"><e>{features:"",target:"",url:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</open>
		<alert public="1" set="method">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><alert public="1" set="method">
	<f a=""><x path="Void"/></f>
	<haxe_doc>@throws DOMError</haxe_doc>
</alert></overloads>
		</alert>
		<confirm public="1" set="method">
			<f a="?message" v="&quot;&quot;">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</confirm>
		<prompt public="1" set="method">
			<f a="?message:?default_" v="&quot;&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{default_:"",message:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</prompt>
		<print public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</print>
		<postMessage public="1" set="method">
			<f a="message:targetOrigin:?transfer">
				<d/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</postMessage>
		<captureEvents public="1" set="method"><f a=""><x path="Void"/></f></captureEvents>
		<releaseEvents public="1" set="method"><f a=""><x path="Void"/></f></releaseEvents>
		<getSelection public="1" set="method">
			<f a=""><c path="js.html.Selection"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getSelection>
		<getComputedStyle public="1" set="method">
			<f a="elt:?pseudoElt" v=":&quot;&quot;">
				<c path="js.html.Element"/>
				<c path="String"/>
				<c path="js.html.CSSStyleDeclaration"/>
			</f>
			<meta><m n=":value"><e>{pseudoElt:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getComputedStyle>
		<matchMedia public="1" set="method">
			<f a="query">
				<c path="String"/>
				<c path="js.html.MediaQueryList"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</matchMedia>
		<moveTo public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</moveTo>
		<moveBy public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</moveBy>
		<resizeTo public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resizeTo>
		<resizeBy public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</resizeBy>
		<scroll public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scroll public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scroll></overloads>
		</scroll>
		<scrollTo public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollTo></overloads>
		</scrollTo>
		<scrollBy public="1" set="method">
			<f a="?options">
				<t path="js.html.ScrollToOptions"/>
				<x path="Void"/>
			</f>
			<overloads><scrollBy public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollBy></overloads>
		</scrollBy>
		<requestAnimationFrame public="1" set="method">
			<f a="callback">
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</requestAnimationFrame>
		<cancelAnimationFrame public="1" set="method">
			<f a="handle">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cancelAnimationFrame>
		<getDefaultComputedStyle public="1" set="method">
			<f a="elt:?pseudoElt" v=":&quot;&quot;">
				<c path="js.html.Element"/>
				<c path="String"/>
				<c path="js.html.CSSStyleDeclaration"/>
			</f>
			<meta><m n=":value"><e>{pseudoElt:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getDefaultComputedStyle>
		<scrollByLines public="1" set="method"><f a="numLines:?options">
	<x path="Int"/>
	<t path="js.html.ScrollOptions"/>
	<x path="Void"/>
</f></scrollByLines>
		<scrollByPages public="1" set="method"><f a="numPages:?options">
	<x path="Int"/>
	<t path="js.html.ScrollOptions"/>
	<x path="Void"/>
</f></scrollByPages>
		<sizeToContent public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sizeToContent>
		<updateCommands public="1" set="method">
			<f a="action:?sel:?reason" v="::0">
				<c path="String"/>
				<c path="js.html.Selection"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{reason:0}</e></m></meta>
		</updateCommands>
		<find public="1" set="method">
			<f a="?str:?caseSensitive:?backwards:?wrapAround:?wholeWord:?searchInFrames:?showDialog" v="&quot;&quot;:false:false:false:false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{showDialog:false,searchInFrames:false,wholeWord:false,wrapAround:false,backwards:false,caseSensitive:false,str:""}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</find>
		<dump public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></dump>
		<setResizable public="1" set="method"><f a="resizable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setResizable>
		<btoa public="1" set="method">
			<f a="btoa">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</btoa>
		<atob public="1" set="method">
			<f a="atob">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</atob>
		<setTimeout public="1" set="method">
			<f a="handler:?timeout:unused" v=":0:">
				<c path="String"/>
				<x path="Int"/>
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{timeout:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setTimeout public="1" set="method">
	<f a="handler:?timeout:arguments" v=":0:">
		<x path="haxe.Function"/>
		<x path="Int"/>
		<x path="haxe.extern.Rest"><d/></x>
		<x path="Int"/>
	</f>
	<meta><m n=":value"><e>{timeout:0}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</setTimeout></overloads>
		</setTimeout>
		<clearTimeout public="1" set="method">
			<f a="?handle" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{handle:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clearTimeout>
		<setInterval public="1" set="method">
			<f a="handler:?timeout:unused">
				<c path="String"/>
				<x path="Int"/>
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><setInterval public="1" set="method">
	<f a="handler:?timeout:arguments">
		<x path="haxe.Function"/>
		<x path="Int"/>
		<x path="haxe.extern.Rest"><d/></x>
		<x path="Int"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</setInterval></overloads>
		</setInterval>
		<clearInterval public="1" set="method">
			<f a="?handle" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{handle:0}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clearInterval>
		<meta><m n=":native"><e>"Window"</e></m></meta>
	</class>
	<class path="js.html.XMLHttpRequestEventTarget" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequestEventTarget.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<onloadstart public="1"><x path="haxe.Function"/></onloadstart>
		<onprogress public="1"><x path="haxe.Function"/></onprogress>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onload public="1"><x path="haxe.Function"/></onload>
		<ontimeout public="1"><x path="haxe.Function"/></ontimeout>
		<onloadend public="1"><x path="haxe.Function"/></onloadend>
		<meta><m n=":native"><e>"XMLHttpRequestEventTarget"</e></m></meta>
	</class>
	<class path="js.html.XMLHttpRequest" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequest.hx" extern="1">
		<extends path="js.html.XMLHttpRequestEventTarget"/>
		<UNSENT public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UNSENT>
		<OPENED public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</OPENED>
		<HEADERS_RECEIVED public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</HEADERS_RECEIVED>
		<LOADING public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LOADING>
		<DONE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</DONE>
		<onreadystatechange public="1"><x path="haxe.Function"/></onreadystatechange>
		<readyState public="1" set="null"><x path="Int"/></readyState>
		<timeout public="1"><x path="Int"/></timeout>
		<withCredentials public="1"><x path="Bool"/></withCredentials>
		<upload public="1" set="null"><c path="js.html.XMLHttpRequestUpload"/></upload>
		<responseURL public="1" set="null"><c path="String"/></responseURL>
		<status public="1" set="null"><x path="Int"/></status>
		<statusText public="1" set="null"><c path="String"/></statusText>
		<responseType public="1"><x path="js.html.XMLHttpRequestResponseType"/></responseType>
		<response public="1" set="null"><d/></response>
		<responseText public="1" set="null"><c path="String"/></responseText>
		<responseXML public="1" set="null"><c path="js.html.HTMLDocument"/></responseXML>
		<open public="1" set="method">
			<f a="method:url:async:?user:?password">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="method:url">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<setRequestHeader public="1" set="method">
			<f a="header:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</setRequestHeader>
		<send public="1" set="method">
			<f a="data">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<send public="1" set="method">
					<f a=""><x path="Void"/></f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.ArrayBuffer"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.Blob"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.HTMLDocument"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="String"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
				<send public="1" set="method">
					<f a="data">
						<c path="js.html.FormData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</send>
			</overloads>
		</send>
		<abort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</abort>
		<getResponseHeader public="1" set="method">
			<f a="header">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getResponseHeader>
		<getAllResponseHeaders public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getAllResponseHeaders>
		<overrideMimeType public="1" set="method">
			<f a="mime">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</overrideMimeType>
		<sendAsBinary public="1" set="method">
			<f a="body">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</sendAsBinary>
		<new public="1" set="method">
			<f a="ignored">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="?params">
		<d/>
		<x path="Void"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"XMLHttpRequest"</e></m></meta>
	</class>
	<abstract path="js.html.XMLHttpRequestResponseType" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequestResponseType.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html._XMLHttpRequestResponseType.XMLHttpRequestResponseType_Impl_" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequestResponseType.hx" private="1" module="js.html.XMLHttpRequestResponseType"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.XMLHttpRequestUpload" params="" file="/usr/lib/haxe/std/js/html/XMLHttpRequestUpload.hx" extern="1">
		<extends path="js.html.XMLHttpRequestEventTarget"/>
		<meta><m n=":native"><e>"XMLHttpRequestUpload"</e></m></meta>
	</class>
	<class path="js.html.XPathExpression" params="" file="/usr/lib/haxe/std/js/html/XPathExpression.hx" extern="1">
		<evaluate public="1" set="method">
			<f a="contextNode:type:result">
				<c path="js.html.Node"/>
				<x path="Int"/>
				<d/>
				<c path="js.html.XPathResult"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</evaluate>
		<meta><m n=":native"><e>"XPathExpression"</e></m></meta>
	</class>
	<class path="js.html.XPathNSResolver" params="" file="/usr/lib/haxe/std/js/html/XPathNSResolver.hx" extern="1">
		<lookupNamespaceURI public="1" set="method"><f a="prefix">
	<c path="String"/>
	<c path="String"/>
</f></lookupNamespaceURI>
		<meta><m n=":native"><e>"XPathNSResolver"</e></m></meta>
	</class>
	<class path="js.html.XPathResult" params="" file="/usr/lib/haxe/std/js/html/XPathResult.hx" extern="1">
		<ANY_TYPE public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ANY_TYPE>
		<NUMBER_TYPE public="1" get="inline" set="null" expr="1" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NUMBER_TYPE>
		<STRING_TYPE public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</STRING_TYPE>
		<BOOLEAN_TYPE public="1" get="inline" set="null" expr="3" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</BOOLEAN_TYPE>
		<UNORDERED_NODE_ITERATOR_TYPE public="1" get="inline" set="null" expr="4" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</UNORDERED_NODE_ITERATOR_TYPE>
		<ORDERED_NODE_ITERATOR_TYPE public="1" get="inline" set="null" expr="5" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ORDERED_NODE_ITERATOR_TYPE>
		<UNORDERED_NODE_SNAPSHOT_TYPE public="1" get="inline" set="null" expr="6" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</UNORDERED_NODE_SNAPSHOT_TYPE>
		<ORDERED_NODE_SNAPSHOT_TYPE public="1" get="inline" set="null" expr="7" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</ORDERED_NODE_SNAPSHOT_TYPE>
		<ANY_UNORDERED_NODE_TYPE public="1" get="inline" set="null" expr="8" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</ANY_UNORDERED_NODE_TYPE>
		<FIRST_ORDERED_NODE_TYPE public="1" get="inline" set="null" expr="9" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</FIRST_ORDERED_NODE_TYPE>
		<resultType public="1" set="null"><x path="Int"/></resultType>
		<numberValue public="1" set="null"><x path="Float"/></numberValue>
		<stringValue public="1" set="null"><c path="String"/></stringValue>
		<booleanValue public="1" set="null"><x path="Bool"/></booleanValue>
		<singleNodeValue public="1" set="null"><c path="js.html.Node"/></singleNodeValue>
		<invalidIteratorState public="1" set="null"><x path="Bool"/></invalidIteratorState>
		<snapshotLength public="1" set="null"><x path="Int"/></snapshotLength>
		<iterateNext public="1" set="method">
			<f a=""><c path="js.html.Node"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</iterateNext>
		<snapshotItem public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="js.html.Node"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</snapshotItem>
		<meta><m n=":native"><e>"XPathResult"</e></m></meta>
	</class>
	<class path="js.html.idb.Cursor" params="" file="/usr/lib/haxe/std/js/html/idb/Cursor.hx" extern="1">
		<source public="1" set="null"><x path="haxe.extern.EitherType">
	<c path="js.html.idb.ObjectStore"/>
	<c path="js.html.idb.Index"/>
</x></source>
		<direction public="1" set="null"><x path="js.html.idb.CursorDirection"/></direction>
		<key public="1" set="null"><d/></key>
		<primaryKey public="1" set="null"><d/></primaryKey>
		<update public="1" set="method">
			<f a="value">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</update>
		<advance public="1" set="method">
			<f a="count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</advance>
		<continue_ public="1" set="method">
			<f a="?key">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"continue"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</continue_>
		<delete_ public="1" set="method">
			<f a=""><c path="js.html.idb.Request"/></f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<meta><m n=":native"><e>"IDBCursor"</e></m></meta>
	</class>
	<abstract path="js.html.idb.CursorDirection" params="" file="/usr/lib/haxe/std/js/html/idb/CursorDirection.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._CursorDirection.CursorDirection_Impl_" params="" file="/usr/lib/haxe/std/js/html/idb/CursorDirection.hx" private="1" module="js.html.idb.CursorDirection"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.idb.Database" params="" file="/usr/lib/haxe/std/js/html/idb/Database.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<name public="1" set="null"><c path="String"/></name>
		<version public="1" set="null"><x path="Int"/></version>
		<objectStoreNames public="1" set="null"><c path="js.html.DOMStringList"/></objectStoreNames>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<onversionchange public="1"><x path="haxe.Function"/></onversionchange>
		<createObjectStore public="1" set="method">
			<f a="name:?optionalParameters">
				<c path="String"/>
				<t path="js.html.idb.ObjectStoreParameters"/>
				<c path="js.html.idb.ObjectStore"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createObjectStore>
		<deleteObjectStore public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteObjectStore>
		<transaction public="1" set="method">
			<f a="storeNames:?mode" v=":&quot;readonly&quot;">
				<c path="Array"><c path="String"/></c>
				<x path="js.html.idb.TransactionMode"/>
				<c path="js.html.idb.Transaction"/>
			</f>
			<meta><m n=":value"><e>{mode:"readonly"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><transaction public="1" set="method">
	<f a="storeName:?mode" v=":&quot;readonly&quot;">
		<c path="String"/>
		<x path="js.html.idb.TransactionMode"/>
		<c path="js.html.idb.Transaction"/>
	</f>
	<meta><m n=":value"><e>{mode:"readonly"}</e></m></meta>
	<haxe_doc>@throws DOMError</haxe_doc>
</transaction></overloads>
		</transaction>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<createMutableFile public="1" set="method">
			<f a="name:?type">
				<c path="String"/>
				<c path="String"/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</createMutableFile>
		<meta><m n=":native"><e>"IDBDatabase"</e></m></meta>
	</class>
	<class path="js.html.idb.Factory" params="" file="/usr/lib/haxe/std/js/html/idb/Factory.hx" extern="1">
		<open public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.idb.OpenDBOptions"/>
				<c path="js.html.idb.OpenDBRequest"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><open public="1" set="method">
	<f a="name:version">
		<c path="String"/>
		<x path="Int"/>
		<c path="js.html.idb.OpenDBRequest"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</open></overloads>
		</open>
		<deleteDatabase public="1" set="method">
			<f a="name:?options">
				<c path="String"/>
				<t path="js.html.idb.OpenDBOptions"/>
				<c path="js.html.idb.OpenDBRequest"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteDatabase>
		<cmp public="1" set="method">
			<f a="first:second">
				<d/>
				<d/>
				<x path="Int"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</cmp>
		<meta><m n=":native"><e>"IDBFactory"</e></m></meta>
	</class>
	<class path="js.html.idb.Index" params="" file="/usr/lib/haxe/std/js/html/idb/Index.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<objectStore public="1" set="null"><c path="js.html.idb.ObjectStore"/></objectStore>
		<keyPath public="1" set="null"><d/></keyPath>
		<multiEntry public="1" set="null"><x path="Bool"/></multiEntry>
		<unique public="1" set="null"><x path="Bool"/></unique>
		<openCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openCursor>
		<openKeyCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openKeyCursor>
		<get public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</get>
		<getKey public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getKey>
		<count public="1" set="method">
			<f a="?key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</count>
		<meta><m n=":native"><e>"IDBIndex"</e></m></meta>
	</class>
	<typedef path="js.html.idb.IndexParameters" params="" file="/usr/lib/haxe/std/js/html/idb/IndexParameters.hx"><a>
	<unique>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</unique>
	<multiEntry>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</multiEntry>
</a></typedef>
	<class path="js.html.idb.ObjectStore" params="" file="/usr/lib/haxe/std/js/html/idb/ObjectStore.hx" extern="1">
		<name public="1" set="null"><c path="String"/></name>
		<keyPath public="1" set="null"><d/></keyPath>
		<indexNames public="1" set="null"><c path="js.html.DOMStringList"/></indexNames>
		<transaction public="1" set="null"><c path="js.html.idb.Transaction"/></transaction>
		<autoIncrement public="1" set="null"><x path="Bool"/></autoIncrement>
		<put public="1" set="method">
			<f a="value:?key">
				<d/>
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</put>
		<add public="1" set="method">
			<f a="value:?key">
				<d/>
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</add>
		<delete_ public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":native"><e>"delete"</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</delete_>
		<get public="1" set="method">
			<f a="key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</get>
		<clear public="1" set="method">
			<f a=""><c path="js.html.idb.Request"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</clear>
		<openCursor public="1" set="method">
			<f a="?range:?direction" v=":&quot;next&quot;">
				<d/>
				<x path="js.html.idb.CursorDirection"/>
				<c path="js.html.idb.Request"/>
			</f>
			<meta><m n=":value"><e>{direction:"next"}</e></m></meta>
			<haxe_doc>@throws DOMError</haxe_doc>
		</openCursor>
		<createIndex public="1" set="method">
			<f a="name:keyPath:?optionalParameters">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<t path="js.html.idb.IndexParameters"/>
				<c path="js.html.idb.Index"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads><createIndex public="1" set="method">
	<f a="name:keyPath:?optionalParameters">
		<c path="String"/>
		<c path="String"/>
		<t path="js.html.idb.IndexParameters"/>
		<c path="js.html.idb.Index"/>
	</f>
	<haxe_doc>@throws DOMError</haxe_doc>
</createIndex></overloads>
		</createIndex>
		<index public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.idb.Index"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</index>
		<deleteIndex public="1" set="method">
			<f a="indexName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</deleteIndex>
		<count public="1" set="method">
			<f a="?key">
				<d/>
				<c path="js.html.idb.Request"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</count>
		<meta><m n=":native"><e>"IDBObjectStore"</e></m></meta>
	</class>
	<typedef path="js.html.idb.ObjectStoreParameters" params="" file="/usr/lib/haxe/std/js/html/idb/ObjectStoreParameters.hx"><a>
	<keyPath>
		<t path="Null"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</x></t>
		<meta><m n=":optional"/></meta>
	</keyPath>
	<autoIncrement>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoIncrement>
</a></typedef>
	<typedef path="js.html.idb.OpenDBOptions" params="" file="/usr/lib/haxe/std/js/html/idb/OpenDBOptions.hx"><a>
	<version>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</version>
	<storage>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</storage>
</a></typedef>
	<class path="js.html.idb.Request" params="" file="/usr/lib/haxe/std/js/html/idb/Request.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<result public="1" set="null"><d/></result>
		<error public="1" set="null"><c path="js.html.DOMError"/></error>
		<source public="1" set="null"><x path="haxe.extern.EitherType">
	<c path="js.html.idb.ObjectStore"/>
	<x path="haxe.extern.EitherType">
		<c path="js.html.idb.Index"/>
		<c path="js.html.idb.Cursor"/>
	</x>
</x></source>
		<transaction public="1" set="null"><c path="js.html.idb.Transaction"/></transaction>
		<readyState public="1" set="null"><x path="js.html.idb.RequestReadyState"/></readyState>
		<onsuccess public="1"><x path="haxe.Function"/></onsuccess>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<meta><m n=":native"><e>"IDBRequest"</e></m></meta>
	</class>
	<class path="js.html.idb.OpenDBRequest" params="" file="/usr/lib/haxe/std/js/html/idb/OpenDBRequest.hx" extern="1">
		<extends path="js.html.idb.Request"/>
		<onblocked public="1"><x path="haxe.Function"/></onblocked>
		<onupgradeneeded public="1"><x path="haxe.Function"/></onupgradeneeded>
		<meta><m n=":native"><e>"IDBOpenDBRequest"</e></m></meta>
	</class>
	<abstract path="js.html.idb.RequestReadyState" params="" file="/usr/lib/haxe/std/js/html/idb/RequestReadyState.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._RequestReadyState.RequestReadyState_Impl_" params="" file="/usr/lib/haxe/std/js/html/idb/RequestReadyState.hx" private="1" module="js.html.idb.RequestReadyState"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.idb.Transaction" params="" file="/usr/lib/haxe/std/js/html/idb/Transaction.hx" extern="1">
		<extends path="js.html.EventTarget"/>
		<mode public="1" set="null"><x path="js.html.idb.TransactionMode"/></mode>
		<db public="1" set="null"><c path="js.html.idb.Database"/></db>
		<error public="1" set="null"><c path="js.html.DOMError"/></error>
		<onabort public="1"><x path="haxe.Function"/></onabort>
		<oncomplete public="1"><x path="haxe.Function"/></oncomplete>
		<onerror public="1"><x path="haxe.Function"/></onerror>
		<objectStoreNames public="1" set="null"><c path="js.html.DOMStringList"/></objectStoreNames>
		<objectStore public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="js.html.idb.ObjectStore"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</objectStore>
		<abort public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</abort>
		<meta><m n=":native"><e>"IDBTransaction"</e></m></meta>
	</class>
	<abstract path="js.html.idb.TransactionMode" params="" file="/usr/lib/haxe/std/js/html/idb/TransactionMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.html.idb._TransactionMode.TransactionMode_Impl_" params="" file="/usr/lib/haxe/std/js/html/idb/TransactionMode.hx" private="1" module="js.html.idb.TransactionMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.html.svg.Matrix" params="" file="/usr/lib/haxe/std/js/html/svg/Matrix.hx" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<e public="1"><x path="Float"/></e>
		<f public="1"><x path="Float"/></f>
		<multiply public="1" set="method"><f a="secondMatrix">
	<c path="js.html.svg.Matrix"/>
	<c path="js.html.svg.Matrix"/>
</f></multiply>
		<inverse public="1" set="method">
			<f a=""><c path="js.html.svg.Matrix"/></f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</inverse>
		<translate public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></translate>
		<scale public="1" set="method"><f a="scaleFactor">
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></scale>
		<scaleNonUniform public="1" set="method"><f a="scaleFactorX:scaleFactorY">
	<x path="Float"/>
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></scaleNonUniform>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<c path="js.html.svg.Matrix"/>
</f></rotate>
		<rotateFromVector public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</rotateFromVector>
		<flipX public="1" set="method"><f a=""><c path="js.html.svg.Matrix"/></f></flipX>
		<flipY public="1" set="method"><f a=""><c path="js.html.svg.Matrix"/></f></flipY>
		<skewX public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</skewX>
		<skewY public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<c path="js.html.svg.Matrix"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</skewY>
		<meta><m n=":native"><e>"SVGMatrix"</e></m></meta>
	</class>
	<class path="js.html.webgl.ActiveInfo" params="" file="/usr/lib/haxe/std/js/html/webgl/ActiveInfo.hx" extern="1">
		<size public="1" set="null"><x path="Int"/></size>
		<type public="1" set="null"><x path="Int"/></type>
		<name public="1" set="null"><c path="String"/></name>
		<meta><m n=":native"><e>"WebGLActiveInfo"</e></m></meta>
	</class>
	<class path="js.html.webgl.Buffer" params="" file="/usr/lib/haxe/std/js/html/webgl/Buffer.hx" extern="1"><meta><m n=":native"><e>"WebGLBuffer"</e></m></meta></class>
	<typedef path="js.html.webgl.ContextAttributes" params="" file="/usr/lib/haxe/std/js/html/webgl/ContextAttributes.hx"><a>
	<stencil>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</stencil>
	<preserveDrawingBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</preserveDrawingBuffer>
	<premultipliedAlpha>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</premultipliedAlpha>
	<depth>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</depth>
	<antialias>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</antialias>
	<alpha>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</alpha>
</a></typedef>
	<class path="js.html.webgl.Framebuffer" params="" file="/usr/lib/haxe/std/js/html/webgl/Framebuffer.hx" extern="1"><meta><m n=":native"><e>"WebGLFramebuffer"</e></m></meta></class>
	<class path="js.html.webgl.Program" params="" file="/usr/lib/haxe/std/js/html/webgl/Program.hx" extern="1"><meta><m n=":native"><e>"WebGLProgram"</e></m></meta></class>
	<class path="js.html.webgl.Renderbuffer" params="" file="/usr/lib/haxe/std/js/html/webgl/Renderbuffer.hx" extern="1"><meta><m n=":native"><e>"WebGLRenderbuffer"</e></m></meta></class>
	<class path="js.html.webgl.RenderingContext" params="" file="/usr/lib/haxe/std/js/html/webgl/RenderingContext.hx" extern="1">
		<DEPTH_BUFFER_BIT public="1" get="inline" set="null" expr="256" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" get="inline" set="null" expr="1024" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" get="inline" set="null" expr="16384" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16384</e></m></meta>
		</COLOR_BUFFER_BIT>
		<POINTS public="1" get="inline" set="null" expr="0" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</POINTS>
		<LINES public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LINES>
		<LINE_LOOP public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LINE_LOOP>
		<LINE_STRIP public="1" get="inline" set="null" expr="3" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LINE_STRIP>
		<TRIANGLES public="1" get="inline" set="null" expr="4" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</TRIANGLES>
		<TRIANGLE_STRIP public="1" get="inline" set="null" expr="5" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" get="inline" set="null" expr="6" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</TRIANGLE_FAN>
		<ZERO public="1" get="inline" set="null" expr="0" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ZERO>
		<ONE public="1" get="inline" set="null" expr="1" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ONE>
		<SRC_COLOR public="1" get="inline" set="null" expr="768" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>768</e></m></meta>
		</SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="769" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>769</e></m></meta>
		</ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" expr="770" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>770</e></m></meta>
		</SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="771" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>771</e></m></meta>
		</ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" expr="772" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>772</e></m></meta>
		</DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="773" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>773</e></m></meta>
		</ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" expr="774" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>774</e></m></meta>
		</DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="775" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>775</e></m></meta>
		</ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="776" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>776</e></m></meta>
		</SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" get="inline" set="null" expr="32774" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32774</e></m></meta>
		</FUNC_ADD>
		<BLEND_EQUATION public="1" get="inline" set="null" expr="32777" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32777</e></m></meta>
		</BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" get="inline" set="null" expr="32777" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32777</e></m></meta>
		</BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" get="inline" set="null" expr="34877" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34877</e></m></meta>
		</BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" get="inline" set="null" expr="32778" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32778</e></m></meta>
		</FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" get="inline" set="null" expr="32779" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32779</e></m></meta>
		</FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" get="inline" set="null" expr="32968" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32968</e></m></meta>
		</BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" get="inline" set="null" expr="32969" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32969</e></m></meta>
		</BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" get="inline" set="null" expr="32970" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32970</e></m></meta>
		</BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" get="inline" set="null" expr="32971" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32971</e></m></meta>
		</BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" get="inline" set="null" expr="32769" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32769</e></m></meta>
		</CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" expr="32770" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32770</e></m></meta>
		</ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" get="inline" set="null" expr="32771" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32771</e></m></meta>
		</CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" expr="32772" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32772</e></m></meta>
		</ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" get="inline" set="null" expr="32773" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32773</e></m></meta>
		</BLEND_COLOR>
		<ARRAY_BUFFER public="1" get="inline" set="null" expr="34962" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34962</e></m></meta>
		</ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" get="inline" set="null" expr="34963" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34963</e></m></meta>
		</ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34964" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34964</e></m></meta>
		</ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34965" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34965</e></m></meta>
		</ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" get="inline" set="null" expr="35040" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35040</e></m></meta>
		</STREAM_DRAW>
		<STATIC_DRAW public="1" get="inline" set="null" expr="35044" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35044</e></m></meta>
		</STATIC_DRAW>
		<DYNAMIC_DRAW public="1" get="inline" set="null" expr="35048" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35048</e></m></meta>
		</DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" get="inline" set="null" expr="34660" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34660</e></m></meta>
		</BUFFER_SIZE>
		<BUFFER_USAGE public="1" get="inline" set="null" expr="34661" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34661</e></m></meta>
		</BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" get="inline" set="null" expr="34342" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34342</e></m></meta>
		</CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" get="inline" set="null" expr="1028" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1028</e></m></meta>
		</FRONT>
		<BACK public="1" get="inline" set="null" expr="1029" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1029</e></m></meta>
		</BACK>
		<FRONT_AND_BACK public="1" get="inline" set="null" expr="1032" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1032</e></m></meta>
		</FRONT_AND_BACK>
		<CULL_FACE public="1" get="inline" set="null" expr="2884" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2884</e></m></meta>
		</CULL_FACE>
		<BLEND public="1" get="inline" set="null" expr="3042" line="80" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3042</e></m></meta>
		</BLEND>
		<DITHER public="1" get="inline" set="null" expr="3024" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3024</e></m></meta>
		</DITHER>
		<STENCIL_TEST public="1" get="inline" set="null" expr="2960" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2960</e></m></meta>
		</STENCIL_TEST>
		<DEPTH_TEST public="1" get="inline" set="null" expr="2929" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2929</e></m></meta>
		</DEPTH_TEST>
		<SCISSOR_TEST public="1" get="inline" set="null" expr="3089" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3089</e></m></meta>
		</SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" get="inline" set="null" expr="32823" line="85" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32823</e></m></meta>
		</POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" get="inline" set="null" expr="32926" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32926</e></m></meta>
		</SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" get="inline" set="null" expr="32928" line="87" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32928</e></m></meta>
		</SAMPLE_COVERAGE>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_ENUM public="1" get="inline" set="null" expr="1280" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1280</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="1281" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1281</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" expr="1282" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1282</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="1285" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1285</e></m></meta>
		</OUT_OF_MEMORY>
		<CW public="1" get="inline" set="null" expr="2304" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2304</e></m></meta>
		</CW>
		<CCW public="1" get="inline" set="null" expr="2305" line="94" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2305</e></m></meta>
		</CCW>
		<LINE_WIDTH public="1" get="inline" set="null" expr="2849" line="95" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2849</e></m></meta>
		</LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" get="inline" set="null" expr="33901" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33901</e></m></meta>
		</ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" get="inline" set="null" expr="33902" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33902</e></m></meta>
		</ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" get="inline" set="null" expr="2885" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2885</e></m></meta>
		</CULL_FACE_MODE>
		<FRONT_FACE public="1" get="inline" set="null" expr="2886" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2886</e></m></meta>
		</FRONT_FACE>
		<DEPTH_RANGE public="1" get="inline" set="null" expr="2928" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2928</e></m></meta>
		</DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" get="inline" set="null" expr="2930" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2930</e></m></meta>
		</DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" get="inline" set="null" expr="2931" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2931</e></m></meta>
		</DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" get="inline" set="null" expr="2932" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2932</e></m></meta>
		</DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" get="inline" set="null" expr="2961" line="104" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2961</e></m></meta>
		</STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" get="inline" set="null" expr="2962" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2962</e></m></meta>
		</STENCIL_FUNC>
		<STENCIL_FAIL public="1" get="inline" set="null" expr="2964" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2964</e></m></meta>
		</STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" get="inline" set="null" expr="2965" line="107" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2965</e></m></meta>
		</STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" get="inline" set="null" expr="2966" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2966</e></m></meta>
		</STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" get="inline" set="null" expr="2967" line="109" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2967</e></m></meta>
		</STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" get="inline" set="null" expr="2963" line="110" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2963</e></m></meta>
		</STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" get="inline" set="null" expr="2968" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2968</e></m></meta>
		</STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" get="inline" set="null" expr="34816" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34816</e></m></meta>
		</STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" get="inline" set="null" expr="34817" line="113" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34817</e></m></meta>
		</STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" get="inline" set="null" expr="34818" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34818</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" get="inline" set="null" expr="34819" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34819</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" get="inline" set="null" expr="36003" line="116" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36003</e></m></meta>
		</STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" get="inline" set="null" expr="36004" line="117" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36004</e></m></meta>
		</STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" get="inline" set="null" expr="36005" line="118" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36005</e></m></meta>
		</STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" get="inline" set="null" expr="2978" line="119" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2978</e></m></meta>
		</VIEWPORT>
		<SCISSOR_BOX public="1" get="inline" set="null" expr="3088" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3088</e></m></meta>
		</SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" get="inline" set="null" expr="3106" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3106</e></m></meta>
		</COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" get="inline" set="null" expr="3107" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3107</e></m></meta>
		</COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" get="inline" set="null" expr="3317" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3317</e></m></meta>
		</UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" get="inline" set="null" expr="3333" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3333</e></m></meta>
		</PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" get="inline" set="null" expr="3379" line="125" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3379</e></m></meta>
		</MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" get="inline" set="null" expr="3386" line="126" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3386</e></m></meta>
		</MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" get="inline" set="null" expr="3408" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3408</e></m></meta>
		</SUBPIXEL_BITS>
		<RED_BITS public="1" get="inline" set="null" expr="3410" line="128" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3410</e></m></meta>
		</RED_BITS>
		<GREEN_BITS public="1" get="inline" set="null" expr="3411" line="129" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3411</e></m></meta>
		</GREEN_BITS>
		<BLUE_BITS public="1" get="inline" set="null" expr="3412" line="130" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3412</e></m></meta>
		</BLUE_BITS>
		<ALPHA_BITS public="1" get="inline" set="null" expr="3413" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3413</e></m></meta>
		</ALPHA_BITS>
		<DEPTH_BITS public="1" get="inline" set="null" expr="3414" line="132" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3414</e></m></meta>
		</DEPTH_BITS>
		<STENCIL_BITS public="1" get="inline" set="null" expr="3415" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3415</e></m></meta>
		</STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" get="inline" set="null" expr="10752" line="134" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10752</e></m></meta>
		</POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" get="inline" set="null" expr="32824" line="135" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32824</e></m></meta>
		</POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" get="inline" set="null" expr="32873" line="136" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32873</e></m></meta>
		</TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" get="inline" set="null" expr="32936" line="137" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32936</e></m></meta>
		</SAMPLE_BUFFERS>
		<SAMPLES public="1" get="inline" set="null" expr="32937" line="138" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32937</e></m></meta>
		</SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" get="inline" set="null" expr="32938" line="139" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32938</e></m></meta>
		</SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" get="inline" set="null" expr="32939" line="140" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32939</e></m></meta>
		</SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" get="inline" set="null" expr="34467" line="141" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34467</e></m></meta>
		</COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" get="inline" set="null" expr="4352" line="142" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4352</e></m></meta>
		</DONT_CARE>
		<FASTEST public="1" get="inline" set="null" expr="4353" line="143" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4353</e></m></meta>
		</FASTEST>
		<NICEST public="1" get="inline" set="null" expr="4354" line="144" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4354</e></m></meta>
		</NICEST>
		<GENERATE_MIPMAP_HINT public="1" get="inline" set="null" expr="33170" line="145" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33170</e></m></meta>
		</GENERATE_MIPMAP_HINT>
		<BYTE public="1" get="inline" set="null" expr="5120" line="146" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5120</e></m></meta>
		</BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" expr="5121" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5121</e></m></meta>
		</UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" expr="5122" line="148" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5122</e></m></meta>
		</SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" expr="5123" line="149" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5123</e></m></meta>
		</UNSIGNED_SHORT>
		<INT public="1" get="inline" set="null" expr="5124" line="150" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5124</e></m></meta>
		</INT>
		<UNSIGNED_INT public="1" get="inline" set="null" expr="5125" line="151" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5125</e></m></meta>
		</UNSIGNED_INT>
		<FLOAT public="1" get="inline" set="null" expr="5126" line="152" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5126</e></m></meta>
		</FLOAT>
		<DEPTH_COMPONENT public="1" get="inline" set="null" expr="6402" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6402</e></m></meta>
		</DEPTH_COMPONENT>
		<ALPHA public="1" get="inline" set="null" expr="6406" line="154" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6406</e></m></meta>
		</ALPHA>
		<RGB public="1" get="inline" set="null" expr="6407" line="155" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6407</e></m></meta>
		</RGB>
		<RGBA public="1" get="inline" set="null" expr="6408" line="156" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6408</e></m></meta>
		</RGBA>
		<LUMINANCE public="1" get="inline" set="null" expr="6409" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6409</e></m></meta>
		</LUMINANCE>
		<LUMINANCE_ALPHA public="1" get="inline" set="null" expr="6410" line="158" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6410</e></m></meta>
		</LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" get="inline" set="null" expr="32819" line="159" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32819</e></m></meta>
		</UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" get="inline" set="null" expr="32820" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32820</e></m></meta>
		</UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" get="inline" set="null" expr="33635" line="161" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33635</e></m></meta>
		</UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" get="inline" set="null" expr="35632" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35632</e></m></meta>
		</FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" get="inline" set="null" expr="35633" line="163" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35633</e></m></meta>
		</VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" get="inline" set="null" expr="34921" line="164" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34921</e></m></meta>
		</MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" get="inline" set="null" expr="36347" line="165" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36347</e></m></meta>
		</MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" get="inline" set="null" expr="36348" line="166" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36348</e></m></meta>
		</MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="35661" line="167" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35661</e></m></meta>
		</MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="35660" line="168" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35660</e></m></meta>
		</MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="34930" line="169" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34930</e></m></meta>
		</MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" get="inline" set="null" expr="36349" line="170" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36349</e></m></meta>
		</MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" get="inline" set="null" expr="35663" line="171" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35663</e></m></meta>
		</SHADER_TYPE>
		<DELETE_STATUS public="1" get="inline" set="null" expr="35712" line="172" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35712</e></m></meta>
		</DELETE_STATUS>
		<LINK_STATUS public="1" get="inline" set="null" expr="35714" line="173" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35714</e></m></meta>
		</LINK_STATUS>
		<VALIDATE_STATUS public="1" get="inline" set="null" expr="35715" line="174" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35715</e></m></meta>
		</VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" get="inline" set="null" expr="35717" line="175" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35717</e></m></meta>
		</ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" get="inline" set="null" expr="35718" line="176" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35718</e></m></meta>
		</ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" get="inline" set="null" expr="35721" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35721</e></m></meta>
		</ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" get="inline" set="null" expr="35724" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35724</e></m></meta>
		</SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" get="inline" set="null" expr="35725" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35725</e></m></meta>
		</CURRENT_PROGRAM>
		<NEVER public="1" get="inline" set="null" expr="512" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>512</e></m></meta>
		</NEVER>
		<LESS public="1" get="inline" set="null" expr="513" line="181" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>513</e></m></meta>
		</LESS>
		<EQUAL public="1" get="inline" set="null" expr="514" line="182" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>514</e></m></meta>
		</EQUAL>
		<LEQUAL public="1" get="inline" set="null" expr="515" line="183" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>515</e></m></meta>
		</LEQUAL>
		<GREATER public="1" get="inline" set="null" expr="516" line="184" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>516</e></m></meta>
		</GREATER>
		<NOTEQUAL public="1" get="inline" set="null" expr="517" line="185" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>517</e></m></meta>
		</NOTEQUAL>
		<GEQUAL public="1" get="inline" set="null" expr="518" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>518</e></m></meta>
		</GEQUAL>
		<ALWAYS public="1" get="inline" set="null" expr="519" line="187" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>519</e></m></meta>
		</ALWAYS>
		<KEEP public="1" get="inline" set="null" expr="7680" line="188" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7680</e></m></meta>
		</KEEP>
		<REPLACE public="1" get="inline" set="null" expr="7681" line="189" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7681</e></m></meta>
		</REPLACE>
		<INCR public="1" get="inline" set="null" expr="7682" line="190" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7682</e></m></meta>
		</INCR>
		<DECR public="1" get="inline" set="null" expr="7683" line="191" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7683</e></m></meta>
		</DECR>
		<INVERT public="1" get="inline" set="null" expr="5386" line="192" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5386</e></m></meta>
		</INVERT>
		<INCR_WRAP public="1" get="inline" set="null" expr="34055" line="193" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34055</e></m></meta>
		</INCR_WRAP>
		<DECR_WRAP public="1" get="inline" set="null" expr="34056" line="194" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34056</e></m></meta>
		</DECR_WRAP>
		<VENDOR public="1" get="inline" set="null" expr="7936" line="195" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7936</e></m></meta>
		</VENDOR>
		<RENDERER public="1" get="inline" set="null" expr="7937" line="196" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7937</e></m></meta>
		</RENDERER>
		<VERSION public="1" get="inline" set="null" expr="7938" line="197" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7938</e></m></meta>
		</VERSION>
		<NEAREST public="1" get="inline" set="null" expr="9728" line="198" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9728</e></m></meta>
		</NEAREST>
		<LINEAR public="1" get="inline" set="null" expr="9729" line="199" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9729</e></m></meta>
		</LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" get="inline" set="null" expr="9984" line="200" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9984</e></m></meta>
		</NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" get="inline" set="null" expr="9985" line="201" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9985</e></m></meta>
		</LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" get="inline" set="null" expr="9986" line="202" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9986</e></m></meta>
		</NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" get="inline" set="null" expr="9987" line="203" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9987</e></m></meta>
		</LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" get="inline" set="null" expr="10240" line="204" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10240</e></m></meta>
		</TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" get="inline" set="null" expr="10241" line="205" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10241</e></m></meta>
		</TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" get="inline" set="null" expr="10242" line="206" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10242</e></m></meta>
		</TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" get="inline" set="null" expr="10243" line="207" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10243</e></m></meta>
		</TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" get="inline" set="null" expr="3553" line="208" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3553</e></m></meta>
		</TEXTURE_2D>
		<TEXTURE public="1" get="inline" set="null" expr="5890" line="209" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5890</e></m></meta>
		</TEXTURE>
		<TEXTURE_CUBE_MAP public="1" get="inline" set="null" expr="34067" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34067</e></m></meta>
		</TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" get="inline" set="null" expr="34068" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34068</e></m></meta>
		</TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" get="inline" set="null" expr="34069" line="212" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34069</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" get="inline" set="null" expr="34070" line="213" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34070</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" get="inline" set="null" expr="34071" line="214" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34071</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" get="inline" set="null" expr="34072" line="215" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34072</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" get="inline" set="null" expr="34073" line="216" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34073</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" get="inline" set="null" expr="34074" line="217" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34074</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" get="inline" set="null" expr="34076" line="218" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34076</e></m></meta>
		</MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" get="inline" set="null" expr="33984" line="219" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33984</e></m></meta>
		</TEXTURE0>
		<TEXTURE1 public="1" get="inline" set="null" expr="33985" line="220" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33985</e></m></meta>
		</TEXTURE1>
		<TEXTURE2 public="1" get="inline" set="null" expr="33986" line="221" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33986</e></m></meta>
		</TEXTURE2>
		<TEXTURE3 public="1" get="inline" set="null" expr="33987" line="222" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33987</e></m></meta>
		</TEXTURE3>
		<TEXTURE4 public="1" get="inline" set="null" expr="33988" line="223" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33988</e></m></meta>
		</TEXTURE4>
		<TEXTURE5 public="1" get="inline" set="null" expr="33989" line="224" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33989</e></m></meta>
		</TEXTURE5>
		<TEXTURE6 public="1" get="inline" set="null" expr="33990" line="225" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33990</e></m></meta>
		</TEXTURE6>
		<TEXTURE7 public="1" get="inline" set="null" expr="33991" line="226" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33991</e></m></meta>
		</TEXTURE7>
		<TEXTURE8 public="1" get="inline" set="null" expr="33992" line="227" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33992</e></m></meta>
		</TEXTURE8>
		<TEXTURE9 public="1" get="inline" set="null" expr="33993" line="228" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33993</e></m></meta>
		</TEXTURE9>
		<TEXTURE10 public="1" get="inline" set="null" expr="33994" line="229" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33994</e></m></meta>
		</TEXTURE10>
		<TEXTURE11 public="1" get="inline" set="null" expr="33995" line="230" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33995</e></m></meta>
		</TEXTURE11>
		<TEXTURE12 public="1" get="inline" set="null" expr="33996" line="231" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33996</e></m></meta>
		</TEXTURE12>
		<TEXTURE13 public="1" get="inline" set="null" expr="33997" line="232" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33997</e></m></meta>
		</TEXTURE13>
		<TEXTURE14 public="1" get="inline" set="null" expr="33998" line="233" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33998</e></m></meta>
		</TEXTURE14>
		<TEXTURE15 public="1" get="inline" set="null" expr="33999" line="234" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33999</e></m></meta>
		</TEXTURE15>
		<TEXTURE16 public="1" get="inline" set="null" expr="34000" line="235" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34000</e></m></meta>
		</TEXTURE16>
		<TEXTURE17 public="1" get="inline" set="null" expr="34001" line="236" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34001</e></m></meta>
		</TEXTURE17>
		<TEXTURE18 public="1" get="inline" set="null" expr="34002" line="237" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34002</e></m></meta>
		</TEXTURE18>
		<TEXTURE19 public="1" get="inline" set="null" expr="34003" line="238" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34003</e></m></meta>
		</TEXTURE19>
		<TEXTURE20 public="1" get="inline" set="null" expr="34004" line="239" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34004</e></m></meta>
		</TEXTURE20>
		<TEXTURE21 public="1" get="inline" set="null" expr="34005" line="240" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34005</e></m></meta>
		</TEXTURE21>
		<TEXTURE22 public="1" get="inline" set="null" expr="34006" line="241" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34006</e></m></meta>
		</TEXTURE22>
		<TEXTURE23 public="1" get="inline" set="null" expr="34007" line="242" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34007</e></m></meta>
		</TEXTURE23>
		<TEXTURE24 public="1" get="inline" set="null" expr="34008" line="243" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34008</e></m></meta>
		</TEXTURE24>
		<TEXTURE25 public="1" get="inline" set="null" expr="34009" line="244" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34009</e></m></meta>
		</TEXTURE25>
		<TEXTURE26 public="1" get="inline" set="null" expr="34010" line="245" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34010</e></m></meta>
		</TEXTURE26>
		<TEXTURE27 public="1" get="inline" set="null" expr="34011" line="246" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34011</e></m></meta>
		</TEXTURE27>
		<TEXTURE28 public="1" get="inline" set="null" expr="34012" line="247" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34012</e></m></meta>
		</TEXTURE28>
		<TEXTURE29 public="1" get="inline" set="null" expr="34013" line="248" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34013</e></m></meta>
		</TEXTURE29>
		<TEXTURE30 public="1" get="inline" set="null" expr="34014" line="249" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34014</e></m></meta>
		</TEXTURE30>
		<TEXTURE31 public="1" get="inline" set="null" expr="34015" line="250" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34015</e></m></meta>
		</TEXTURE31>
		<ACTIVE_TEXTURE public="1" get="inline" set="null" expr="34016" line="251" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34016</e></m></meta>
		</ACTIVE_TEXTURE>
		<REPEAT public="1" get="inline" set="null" expr="10497" line="252" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10497</e></m></meta>
		</REPEAT>
		<CLAMP_TO_EDGE public="1" get="inline" set="null" expr="33071" line="253" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33071</e></m></meta>
		</CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" get="inline" set="null" expr="33648" line="254" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33648</e></m></meta>
		</MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" get="inline" set="null" expr="35664" line="255" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35664</e></m></meta>
		</FLOAT_VEC2>
		<FLOAT_VEC3 public="1" get="inline" set="null" expr="35665" line="256" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35665</e></m></meta>
		</FLOAT_VEC3>
		<FLOAT_VEC4 public="1" get="inline" set="null" expr="35666" line="257" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35666</e></m></meta>
		</FLOAT_VEC4>
		<INT_VEC2 public="1" get="inline" set="null" expr="35667" line="258" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35667</e></m></meta>
		</INT_VEC2>
		<INT_VEC3 public="1" get="inline" set="null" expr="35668" line="259" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35668</e></m></meta>
		</INT_VEC3>
		<INT_VEC4 public="1" get="inline" set="null" expr="35669" line="260" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35669</e></m></meta>
		</INT_VEC4>
		<BOOL public="1" get="inline" set="null" expr="35670" line="261" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35670</e></m></meta>
		</BOOL>
		<BOOL_VEC2 public="1" get="inline" set="null" expr="35671" line="262" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35671</e></m></meta>
		</BOOL_VEC2>
		<BOOL_VEC3 public="1" get="inline" set="null" expr="35672" line="263" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35672</e></m></meta>
		</BOOL_VEC3>
		<BOOL_VEC4 public="1" get="inline" set="null" expr="35673" line="264" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35673</e></m></meta>
		</BOOL_VEC4>
		<FLOAT_MAT2 public="1" get="inline" set="null" expr="35674" line="265" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35674</e></m></meta>
		</FLOAT_MAT2>
		<FLOAT_MAT3 public="1" get="inline" set="null" expr="35675" line="266" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35675</e></m></meta>
		</FLOAT_MAT3>
		<FLOAT_MAT4 public="1" get="inline" set="null" expr="35676" line="267" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35676</e></m></meta>
		</FLOAT_MAT4>
		<SAMPLER_2D public="1" get="inline" set="null" expr="35678" line="268" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35678</e></m></meta>
		</SAMPLER_2D>
		<SAMPLER_CUBE public="1" get="inline" set="null" expr="35680" line="269" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35680</e></m></meta>
		</SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" get="inline" set="null" expr="34338" line="270" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34338</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" get="inline" set="null" expr="34339" line="271" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34339</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" get="inline" set="null" expr="34340" line="272" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34340</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" get="inline" set="null" expr="34341" line="273" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34341</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" get="inline" set="null" expr="34922" line="274" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34922</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" get="inline" set="null" expr="34373" line="275" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34373</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="34975" line="276" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34975</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<IMPLEMENTATION_COLOR_READ_TYPE public="1" get="inline" set="null" expr="35738" line="277" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35738</e></m></meta>
		</IMPLEMENTATION_COLOR_READ_TYPE>
		<IMPLEMENTATION_COLOR_READ_FORMAT public="1" get="inline" set="null" expr="35739" line="278" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35739</e></m></meta>
		</IMPLEMENTATION_COLOR_READ_FORMAT>
		<COMPILE_STATUS public="1" get="inline" set="null" expr="35713" line="279" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35713</e></m></meta>
		</COMPILE_STATUS>
		<LOW_FLOAT public="1" get="inline" set="null" expr="36336" line="280" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36336</e></m></meta>
		</LOW_FLOAT>
		<MEDIUM_FLOAT public="1" get="inline" set="null" expr="36337" line="281" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36337</e></m></meta>
		</MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" get="inline" set="null" expr="36338" line="282" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36338</e></m></meta>
		</HIGH_FLOAT>
		<LOW_INT public="1" get="inline" set="null" expr="36339" line="283" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36339</e></m></meta>
		</LOW_INT>
		<MEDIUM_INT public="1" get="inline" set="null" expr="36340" line="284" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36340</e></m></meta>
		</MEDIUM_INT>
		<HIGH_INT public="1" get="inline" set="null" expr="36341" line="285" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36341</e></m></meta>
		</HIGH_INT>
		<FRAMEBUFFER public="1" get="inline" set="null" expr="36160" line="286" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36160</e></m></meta>
		</FRAMEBUFFER>
		<RENDERBUFFER public="1" get="inline" set="null" expr="36161" line="287" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36161</e></m></meta>
		</RENDERBUFFER>
		<RGBA4 public="1" get="inline" set="null" expr="32854" line="288" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32854</e></m></meta>
		</RGBA4>
		<RGB5_A1 public="1" get="inline" set="null" expr="32855" line="289" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32855</e></m></meta>
		</RGB5_A1>
		<RGB565 public="1" get="inline" set="null" expr="36194" line="290" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36194</e></m></meta>
		</RGB565>
		<DEPTH_COMPONENT16 public="1" get="inline" set="null" expr="33189" line="291" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33189</e></m></meta>
		</DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" get="inline" set="null" expr="6401" line="292" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6401</e></m></meta>
		</STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" get="inline" set="null" expr="36168" line="293" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36168</e></m></meta>
		</STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" get="inline" set="null" expr="34041" line="294" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34041</e></m></meta>
		</DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" get="inline" set="null" expr="36162" line="295" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36162</e></m></meta>
		</RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" get="inline" set="null" expr="36163" line="296" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36163</e></m></meta>
		</RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" get="inline" set="null" expr="36164" line="297" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36164</e></m></meta>
		</RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" get="inline" set="null" expr="36176" line="298" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36176</e></m></meta>
		</RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" get="inline" set="null" expr="36177" line="299" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36177</e></m></meta>
		</RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" get="inline" set="null" expr="36178" line="300" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36178</e></m></meta>
		</RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" get="inline" set="null" expr="36179" line="301" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36179</e></m></meta>
		</RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" get="inline" set="null" expr="36180" line="302" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36180</e></m></meta>
		</RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" get="inline" set="null" expr="36181" line="303" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36181</e></m></meta>
		</RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" get="inline" set="null" expr="36048" line="304" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36048</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" get="inline" set="null" expr="36049" line="305" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36049</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" get="inline" set="null" expr="36050" line="306" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36050</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" get="inline" set="null" expr="36051" line="307" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36051</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" expr="36064" line="308" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36064</e></m></meta>
		</COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" get="inline" set="null" expr="36096" line="309" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36096</e></m></meta>
		</DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" get="inline" set="null" expr="36128" line="310" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36128</e></m></meta>
		</STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" get="inline" set="null" expr="33306" line="311" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33306</e></m></meta>
		</DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" get="inline" set="null" expr="0" line="312" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FRAMEBUFFER_COMPLETE public="1" get="inline" set="null" expr="36053" line="313" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36053</e></m></meta>
		</FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" get="inline" set="null" expr="36054" line="314" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36054</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" get="inline" set="null" expr="36055" line="315" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36055</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" get="inline" set="null" expr="36057" line="316" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36057</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" get="inline" set="null" expr="36061" line="317" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36061</e></m></meta>
		</FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" get="inline" set="null" expr="36006" line="318" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36006</e></m></meta>
		</FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" get="inline" set="null" expr="36007" line="319" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36007</e></m></meta>
		</RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" get="inline" set="null" expr="34024" line="320" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34024</e></m></meta>
		</MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" get="inline" set="null" expr="1286" line="321" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1286</e></m></meta>
		</INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" get="inline" set="null" expr="37440" line="322" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37440</e></m></meta>
		</UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" get="inline" set="null" expr="37441" line="323" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37441</e></m></meta>
		</UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" get="inline" set="null" expr="37442" line="324" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37442</e></m></meta>
		</CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" get="inline" set="null" expr="37443" line="325" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37443</e></m></meta>
		</UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" get="inline" set="null" expr="37444" line="326" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37444</e></m></meta>
		</BROWSER_DEFAULT_WEBGL>
		<canvas public="1" set="null"><c path="js.html.CanvasElement"/></canvas>
		<drawingBufferWidth public="1" set="null"><x path="Int"/></drawingBufferWidth>
		<drawingBufferHeight public="1" set="null"><x path="Int"/></drawingBufferHeight>
		<getContextAttributes public="1" set="method"><f a=""><t path="js.html.webgl.ContextAttributes"/></f></getContextAttributes>
		<isContextLost public="1" set="method"><f a=""><x path="Bool"/></f></isContextLost>
		<getSupportedExtensions public="1" set="method"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getExtension public="1" set="method">
			<f a="name">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getExtension>
		<activeTexture public="1" set="method"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" set="method"><f a="program:shader">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" set="method"><f a="program:index:name">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" set="method"><f a="target:buffer">
	<x path="Int"/>
	<c path="js.html.webgl.Buffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" set="method"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" set="method"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" set="method"><f a="target:texture">
	<x path="Int"/>
	<c path="js.html.webgl.Texture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" set="method"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" set="method"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" set="method"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" set="method">
			<f a="target:data:usage">
				<x path="Int"/>
				<c path="js.html.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<bufferData public="1" set="method"><f a="target:size:usage">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
				<bufferData public="1" set="method"><f a="target:data:usage">
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
			</overloads>
		</bufferData>
		<bufferSubData public="1" set="method">
			<f a="target:offset:data">
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.ArrayBuffer"/>
				<x path="Void"/>
			</f>
			<overloads><bufferSubData public="1" set="method"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></bufferSubData></overloads>
		</bufferSubData>
		<checkFramebufferStatus public="1" set="method"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" set="method"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" set="method"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" set="method"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" set="method"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" set="method"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" set="method"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" set="method"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" set="method"><f a=""><c path="js.html.webgl.Buffer"/></f></createBuffer>
		<createFramebuffer public="1" set="method"><f a=""><c path="js.html.webgl.Framebuffer"/></f></createFramebuffer>
		<createProgram public="1" set="method"><f a=""><c path="js.html.webgl.Program"/></f></createProgram>
		<createRenderbuffer public="1" set="method"><f a=""><c path="js.html.webgl.Renderbuffer"/></f></createRenderbuffer>
		<createShader public="1" set="method"><f a="type">
	<x path="Int"/>
	<c path="js.html.webgl.Shader"/>
</f></createShader>
		<createTexture public="1" set="method"><f a=""><c path="js.html.webgl.Texture"/></f></createTexture>
		<cullFace public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" set="method"><f a="buffer">
	<c path="js.html.webgl.Buffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" set="method"><f a="framebuffer">
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" set="method"><f a="renderbuffer">
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" set="method"><f a="texture">
	<c path="js.html.webgl.Texture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" set="method"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" set="method"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" set="method"><f a="program:shader">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.Shader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" set="method"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" set="method"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" set="method"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" set="method"><f a=""><x path="Void"/></f></finish>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" set="method"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" set="method"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" set="method"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" set="method"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" set="method"><f a="program:index">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="js.html.webgl.ActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" set="method"><f a="program:index">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<c path="js.html.webgl.ActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<c path="Array"><c path="js.html.webgl.Shader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" set="method"><f a="program:name">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getBufferParameter>
		<getParameter public="1" set="method">
			<f a="pname">
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getParameter>
		<getError public="1" set="method"><f a=""><x path="Int"/></f></getError>
		<getFramebufferAttachmentParameter public="1" set="method">
			<f a="target:attachment:pname">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getFramebufferAttachmentParameter>
		<getProgramParameter public="1" set="method"><f a="program:pname">
	<c path="js.html.webgl.Program"/>
	<x path="Int"/>
	<d/>
</f></getProgramParameter>
		<getProgramInfoLog public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getRenderbufferParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getRenderbufferParameter>
		<getShaderParameter public="1" set="method"><f a="shader:pname">
	<c path="js.html.webgl.Shader"/>
	<x path="Int"/>
	<d/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" set="method"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<c path="js.html.webgl.ShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderInfoLog public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderSource public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
</f></getShaderSource>
		<getTexParameter public="1" set="method"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></getTexParameter>
		<getUniform public="1" set="method"><f a="program:location">
	<c path="js.html.webgl.Program"/>
	<c path="js.html.webgl.UniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" set="method"><f a="program:name">
	<c path="js.html.webgl.Program"/>
	<c path="String"/>
	<c path="js.html.webgl.UniformLocation"/>
</f></getUniformLocation>
		<getVertexAttrib public="1" set="method">
			<f a="index:pname">
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</getVertexAttrib>
		<getVertexAttribOffset public="1" set="method"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" set="method"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" set="method"><f a="buffer">
	<c path="js.html.webgl.Buffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" set="method"><f a="framebuffer">
	<c path="js.html.webgl.Framebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" set="method"><f a="renderbuffer">
	<c path="js.html.webgl.Renderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" set="method"><f a="shader">
	<c path="js.html.webgl.Shader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" set="method"><f a="texture">
	<c path="js.html.webgl.Texture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" set="method"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></linkProgram>
		<pixelStorei public="1" set="method"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" set="method"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<readPixels public="1" set="method">
			<f a="x:y:width:height:format:type:pixels">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.ArrayBufferView"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</readPixels>
		<renderbufferStorage public="1" set="method"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" set="method"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" set="method"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" set="method"><f a="shader:source">
	<c path="js.html.webgl.Shader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" set="method"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" set="method"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" set="method"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" set="method"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" set="method"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" set="method"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" set="method">
			<f a="target:level:internalformat:format:type:video">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.VideoElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:width:height:border:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:image">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
				<texImage2D public="1" set="method">
					<f a="target:level:internalformat:format:type:canvas">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.CanvasElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texImage2D>
			</overloads>
		</texImage2D>
		<texParameterf public="1" set="method"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" set="method"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" set="method">
			<f a="target:level:xoffset:yoffset:format:type:video">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="js.html.VideoElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
			<overloads>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ArrayBufferView"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:pixels">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageData"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:image">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.ImageElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
				<texSubImage2D public="1" set="method">
					<f a="target:level:xoffset:yoffset:format:type:canvas">
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="js.html.CanvasElement"/>
						<x path="Void"/>
					</f>
					<haxe_doc>@throws DOMError</haxe_doc>
				</texSubImage2D>
			</overloads>
		</texSubImage2D>
		<uniform1f public="1" set="method"><f a="location:x">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform1fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform1fv></overloads>
		</uniform1fv>
		<uniform1i public="1" set="method"><f a="location:x">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform1iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform1iv></overloads>
		</uniform1iv>
		<uniform2f public="1" set="method"><f a="location:x:y">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform2fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform2fv></overloads>
		</uniform2fv>
		<uniform2i public="1" set="method"><f a="location:x:y">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform2iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform2iv></overloads>
		</uniform2iv>
		<uniform3f public="1" set="method"><f a="location:x:y:z">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform3fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform3fv></overloads>
		</uniform3fv>
		<uniform3i public="1" set="method"><f a="location:x:y:z">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform3iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform3iv></overloads>
		</uniform3iv>
		<uniform4f public="1" set="method"><f a="location:x:y:z:w">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform4fv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniform4fv></overloads>
		</uniform4fv>
		<uniform4i public="1" set="method"><f a="location:x:y:z:w">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" set="method">
			<f a="location:v">
				<c path="js.html.webgl.UniformLocation"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniform4iv public="1" set="method"><f a="location:v">
	<c path="js.html.webgl.UniformLocation"/>
	<c path="js.html.Int32Array"/>
	<x path="Void"/>
</f></uniform4iv></overloads>
		</uniform4iv>
		<uniformMatrix2fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix2fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv></overloads>
		</uniformMatrix2fv>
		<uniformMatrix3fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix3fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv></overloads>
		</uniformMatrix3fv>
		<uniformMatrix4fv public="1" set="method">
			<f a="location:transpose:value">
				<c path="js.html.webgl.UniformLocation"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><uniformMatrix4fv public="1" set="method"><f a="location:transpose:value">
	<c path="js.html.webgl.UniformLocation"/>
	<x path="Bool"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv></overloads>
		</uniformMatrix4fv>
		<useProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" set="method"><f a="program">
	<c path="js.html.webgl.Program"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" set="method"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib1fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib1fv></overloads>
		</vertexAttrib1fv>
		<vertexAttrib2f public="1" set="method"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib2fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib2fv></overloads>
		</vertexAttrib2fv>
		<vertexAttrib3f public="1" set="method"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib3fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib3fv></overloads>
		</vertexAttrib3fv>
		<vertexAttrib4f public="1" set="method"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" set="method">
			<f a="indx:values">
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<overloads><vertexAttrib4fv public="1" set="method"><f a="indx:values">
	<x path="Int"/>
	<c path="js.html.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib4fv></overloads>
		</vertexAttrib4fv>
		<vertexAttribPointer public="1" set="method"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" set="method"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<meta><m n=":native"><e>"WebGLRenderingContext"</e></m></meta>
	</class>
	<class path="js.html.webgl.Shader" params="" file="/usr/lib/haxe/std/js/html/webgl/Shader.hx" extern="1"><meta><m n=":native"><e>"WebGLShader"</e></m></meta></class>
	<class path="js.html.webgl.ShaderPrecisionFormat" params="" file="/usr/lib/haxe/std/js/html/webgl/ShaderPrecisionFormat.hx" extern="1">
		<rangeMin public="1" set="null"><x path="Int"/></rangeMin>
		<rangeMax public="1" set="null"><x path="Int"/></rangeMax>
		<precision public="1" set="null"><x path="Int"/></precision>
		<meta><m n=":native"><e>"WebGLShaderPrecisionFormat"</e></m></meta>
	</class>
	<class path="js.html.webgl.Texture" params="" file="/usr/lib/haxe/std/js/html/webgl/Texture.hx" extern="1"><meta><m n=":native"><e>"WebGLTexture"</e></m></meta></class>
	<class path="js.html.webgl.UniformLocation" params="" file="/usr/lib/haxe/std/js/html/webgl/UniformLocation.hx" extern="1"><meta><m n=":native"><e>"WebGLUniformLocation"</e></m></meta></class>
	<class path="jsfps.stats.Stats" params="" file="/haxe/pixi-haxe/.haxelib/jsfps/1,0,1/jsfps/stats/Stats.hx" extern="1">
		<domElement public="1" set="null">
			<c path="js.html.DivElement"/>
			<haxe_doc>* Stats DOM element
	 * @property domElement
	 * @type DivElement</haxe_doc>
		</domElement>
		<begin public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Begin stats
	 *
	 * @method begin</haxe_doc>
		</begin>
		<end public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* End stats
	 *
	 * @method end</haxe_doc>
		</end>
		<update public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update stats
	 *
	 * @method update</haxe_doc>
		</update>
		<setMode public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the display mode.
	 *
	 * @method setMode
	 * @param value {Int} 0: simplefps, 1: ms</haxe_doc>
		</setMode>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* https://github.com/mrdoob/stats.js/ (JS stats)
	 * https://github.com/luizbills/stats.js.hx (Original Haxe Externs)</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Stats"</e></m>
		</meta>
	</class>
	<typedef path="msignal.AnySignal" params="" file="/haxe/pixi-haxe/.haxelib/msignal/1,2,2/msignal/Signal.hx" module="msignal.Signal">
		<c path="msignal.Signal">
			<d/>
			<d/>
		</c>
		<haxe_doc>A convenience type describing any kind of signal.</haxe_doc>
	</typedef>
	<class path="msignal.Signal" params="TSlot:TListener" file="/haxe/pixi-haxe/.haxelib/msignal/1,2,2/msignal/Signal.hx">
		<valueClasses public="1"><c path="Array"><d/></c></valueClasses>
		<slots><c path="msignal.SlotList">
	<c path="msignal.Signal.TSlot"/>
	<c path="msignal.Signal.TListener"/>
</c></slots>
		<priorityBased><x path="Bool"/></priorityBased>
		<add public="1" set="method" line="62">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a listener for the signal.
		
		@param listener A function matching the signature of TListener
		@return The added listener slot</haxe_doc>
		</add>
		<remove public="1" set="method" line="114">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Unsubscribes a listener from the signal.
		
		@param listener The listener to remove
		@return The removed listener slot</haxe_doc>
		</remove>
		<registerListener set="method" line="131"><f a="listener:?once:?priority">
	<c path="msignal.Signal.TListener"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="msignal.Signal.TSlot"/>
</f></registerListener>
		<registrationPossible set="method" line="147"><f a="listener:once">
	<c path="msignal.Signal.TListener"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></registrationPossible>
		<createSlot set="method" line="165">
			<f a="listener:?once:?priority">
				<c path="msignal.Signal.TListener"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<meta><m n=":IgnoreCover"/></meta>
		</createSlot>
		<new set="method" line="48"><f a="?valueClasses">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>A Signal manages a list of listeners, which are executed when the signal is 
	dispatched.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="msignal.Signal1" params="TValue" file="/haxe/pixi-haxe/.haxelib/msignal/1,2,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot1"><c path="msignal.Signal1.TValue"/></c>
			<f a="">
				<c path="msignal.Signal1.TValue"/>
				<x path="Void"/>
			</f>
		</extends>
		<dispatch public="1" set="method" line="219">
			<f a="value">
				<c path="msignal.Signal1.TValue"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Executes the signals listeners with one arguement.</haxe_doc>
		</dispatch>
		<createSlot set="method" line="230" override="1"><f a="listener:?once:?priority">
	<f a="">
		<c path="msignal.Signal1.TValue"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="msignal.Slot1"><c path="msignal.Signal1.TValue"/></c>
</f></createSlot>
		<new public="1" set="method" line="211"><f a="?type">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Signal that executes listeners with one arguments.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="msignal.AnySlot" params="" file="/haxe/pixi-haxe/.haxelib/msignal/1,2,2/msignal/Slot.hx" module="msignal.Slot">
		<c path="msignal.Slot">
			<d/>
			<d/>
		</c>
		<haxe_doc>A convenience type describing any kind of slot.</haxe_doc>
	</typedef>
	<class path="msignal.Slot" params="TSignal:TListener" file="/haxe/pixi-haxe/.haxelib/msignal/1,2,2/msignal/Slot.hx">
		<listener public="1" set="accessor">
			<c path="msignal.Slot.TListener"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>The listener associated with this slot.
		Note: for hxcpp 2.10 this requires a getter method to compile</haxe_doc>
		</listener>
		<once public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether this slot is automatically removed after it has been used once.</haxe_doc>
		</once>
		<priority public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The priority of this slot should be given in the execution order.
		An Signal will call higher numbers before lower ones.
		Defaults to 0.</haxe_doc>
		</priority>
		<enabled public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the listener is called on execution. Defaults to true.</haxe_doc>
		</enabled>
		<signal><c path="msignal.Slot.TSignal"/></signal>
		<remove public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes the slot from its signal.</haxe_doc>
		</remove>
		<set_listener set="method" line="101"><f a="value">
	<c path="msignal.Slot.TListener"/>
	<c path="msignal.Slot.TListener"/>
</f></set_listener>
		<new set="method" line="73"><f a="signal:listener:?once:?priority">
	<c path="msignal.Slot.TSignal"/>
	<c path="msignal.Slot.TListener"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Defines the basic properties of a listener associated with a Signal.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="msignal.Slot1" params="TValue" file="/haxe/pixi-haxe/.haxelib/msignal/1,2,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal1"><c path="msignal.Slot1.TValue"/></c>
			<f a="">
				<c path="msignal.Slot1.TValue"/>
				<x path="Void"/>
			</f>
		</extends>
		<param public="1">
			<c path="msignal.Slot1.TValue"/>
			<haxe_doc>Allows the slot to inject the argument to dispatch.</haxe_doc>
		</param>
		<execute public="1" set="method" line="148">
			<f a="value1">
				<c path="msignal.Slot1.TValue"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Executes a listener with one argument.
		If <code>param</code> is not null, it overrides the value provided.]]></haxe_doc>
		</execute>
		<new public="1" set="method" line="139"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal1"><c path="msignal.Slot1.TValue"/></c>
	<f a="">
		<c path="msignal.Slot1.TValue"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with one argument.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="msignal.SlotList" params="TSlot:TListener" file="/haxe/pixi-haxe/.haxelib/msignal/1,2,2/msignal/SlotList.hx">
		<NIL public="1" static="1">
			<c path="msignal.SlotList">
				<d/>
				<d/>
			</c>
			<haxe_doc>Represents an empty list. Used as the list terminator.</haxe_doc>
		</NIL>
		<head public="1"><c path="msignal.SlotList.TSlot"/></head>
		<tail public="1"><c path="msignal.SlotList">
	<c path="msignal.SlotList.TSlot"/>
	<c path="msignal.SlotList.TListener"/>
</c></tail>
		<nonEmpty public="1"><x path="Bool"/></nonEmpty>
		<prepend public="1" set="method" line="106">
			<f a="slot">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Prepends a slot to this list.
		@param	slot The item to be prepended.
		@return	A list consisting of slot followed by all elements of this list.</haxe_doc>
		</prepend>
		<insertWithPriority public="1" set="method" line="153">
			<f a="slot">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Insert a slot into the list in a position according to its priority.
		The higher the priority, the closer the item will be inserted to the 
		list head.
		@param slot The item to be inserted.</haxe_doc>
		</insertWithPriority>
		<filterNot public="1" set="method" line="191">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Returns the slots in this list that do not contain the supplied 
		listener. Note: assumes the listener is not repeated within the list.
		@param	listener The function to remove.
		@return A list consisting of all elements of this list that do not 
				have listener.</haxe_doc>
		</filterNot>
		<find public="1" set="method" line="244">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<c path="msignal.SlotList.TSlot"/>
			</f>
			<haxe_doc>Retrieves the Slot associated with a supplied listener within the SlotList.
		@param   listener The Function being searched for
		@return  The ISlot in this list associated with the listener parameter 
				 through the ISlot.listener property. Returns null if no such 
				 ISlot instance exists or the list is empty.</haxe_doc>
		</find>
		<new public="1" set="method" line="50">
			<f a="head:?tail">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Creates and returns a new SlotList object.

		<p>A user never has to create a SlotList manually. 
		Use the <code>NIL</code> element to represent an empty list. 
		<code>NIL.prepend(value)</code> would create a list containing 
		<code>value</code></p>.

		@param head The first slot in the list.
		@param tail A list containing all slots except head.]]></haxe_doc>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="pixi.core.Pixi" params="" file="pixi/core/Pixi.hx" extern="1">
		<VERSION public="1" static="1">
			<c path="String"/>
			<haxe_doc>* String of the current PIXI version
	 *
	 * @static
	 * @constant
	 * @property {string} VERSION</haxe_doc>
		</VERSION>
		<PI_2 public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* @property {number} PI_2 - Two Pi
     * @constant
     * @static</haxe_doc>
		</PI_2>
		<RAD_TO_DEG public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* @property {number} RAD_TO_DEG - Constant conversion factor for converting radians to degrees
     * @constant
     * @static</haxe_doc>
		</RAD_TO_DEG>
		<DEG_TO_RAD public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* @property {Number} DEG_TO_RAD - Constant conversion factor for converting degrees to radians
     * @constant
     * @static</haxe_doc>
		</DEG_TO_RAD>
		<TARGET_FPMS public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* Target frames per millisecond.
     *
     * @static
     * @constant
     * @property {number} TARGET_FPMS=0.06</haxe_doc>
		</TARGET_FPMS>
		<RENDERER_TYPE public="1" static="1">
			<t path="pixi.core.RendererType"/>
			<haxe_doc>* Constant to identify the Renderer Type.
	 *
	 * @static
	 * @constant
	 * @property {object} RENDERER_TYPE
	 * @property {number} RENDERER_TYPE.UNKNOWN
	 * @property {number} RENDERER_TYPE.WEBGL
	 * @property {number} RENDERER_TYPE.CANVAS</haxe_doc>
		</RENDERER_TYPE>
		<BLEND_MODES public="1" static="1">
			<t path="pixi.core.BlendModes"/>
			<haxe_doc>* various blend modes supported by PIXI. IMPORTANT - The WebGL renderer only supports
	 * the NORMAL, ADD, MULTIPLY and SCREEN blend modes. Anything else will silently act like
	 * NORMAL.
	 *
	 * @static
	 * @constant
	 * @property {object} BLEND_MODES
	 * @property {number} BLEND_MODES.NORMAL
	 * @property {number} BLEND_MODES.ADD
	 * @property {number} BLEND_MODES.MULTIPLY
	 * @property {number} BLEND_MODES.SCREEN
	 * @property {number} BLEND_MODES.OVERLAY
	 * @property {number} BLEND_MODES.DARKEN
	 * @property {number} BLEND_MODES.LIGHTEN
	 * @property {number} BLEND_MODES.COLOR_DODGE
	 * @property {number} BLEND_MODES.COLOR_BURN
	 * @property {number} BLEND_MODES.HARD_LIGHT
	 * @property {number} BLEND_MODES.SOFT_LIGHT
	 * @property {number} BLEND_MODES.DIFFERENCE
	 * @property {number} BLEND_MODES.EXCLUSION
	 * @property {number} BLEND_MODES.HUE
	 * @property {number} BLEND_MODES.SATURATION
	 * @property {number} BLEND_MODES.COLOR
	 * @property {number} BLEND_MODES.LUMINOSITY</haxe_doc>
		</BLEND_MODES>
		<SCALE_MODES public="1" static="1">
			<t path="pixi.core.ScaleModes"/>
			<haxe_doc>* The scale modes that are supported by pixi.
	 *
	 * The DEFAULT scale mode affects the default scaling mode of future operations.
	 * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
	 *
	 * @static
	 * @constant
	 * @property {object} SCALE_MODES
	 * @property {number} SCALE_MODES.DEFAULT=LINEAR
	 * @property {number} SCALE_MODES.LINEAR Smooth scaling
	 * @property {number} SCALE_MODES.NEAREST Pixelating scaling</haxe_doc>
		</SCALE_MODES>
		<RETINA_PREFIX public="1" static="1">
			<c path="String"/>
			<haxe_doc>* The prefix that denotes a URL is for a retina asset
	 *
	 * @static
	 * @constant
	 * @property {String} RETINA_PREFIX</haxe_doc>
		</RETINA_PREFIX>
		<RESOLUTION public="1" static="1"><x path="Float"/></RESOLUTION>
		<FILTER_RESOLUTION public="1" static="1"><x path="Float"/></FILTER_RESOLUTION>
		<DEFAULT_RENDER_OPTIONS public="1" static="1">
			<t path="pixi.core.DefaultRenderOptions"/>
			<haxe_doc>* The default render options if none are supplied to {@link PIXI.WebGLRenderer}
	 * or {@link PIXI.CanvasRenderer}.
	 *
	 * @static
	 * @constant
	 * @property {object} DEFAULT_RENDER_OPTIONS
	 * @property {HTMLCanvasElement} DEFAULT_RENDER_OPTIONS.view=null
	 * @property {boolean} DEFAULT_RENDER_OPTIONS.transparent=false
	 * @property {boolean} DEFAULT_RENDER_OPTIONS.antialias=false
	 * @property {boolean} DEFAULT_RENDER_OPTIONS.forceFXAA=false
	 * @property {boolean} DEFAULT_RENDER_OPTIONS.preserveDrawingBuffer=false
	 * @property {number} DEFAULT_RENDER_OPTIONS.resolution=1
	 * @property {number} DEFAULT_RENDER_OPTIONS.backgroundColor=0x000000
	 * @property {boolean} DEFAULT_RENDER_OPTIONS.clearBeforeRender=true
	 * @property {boolean} DEFAULT_RENDER_OPTIONS.autoResize=false</haxe_doc>
		</DEFAULT_RENDER_OPTIONS>
		<SHAPES public="1" static="1">
			<t path="pixi.core.Shapes"/>
			<haxe_doc>* Constants that identify shapes, mainly to prevent `instanceof` calls.
	 *
	 * @static
	 * @constant
	 * @property {object} SHAPES
	 * @property {object} SHAPES.POLY=0
	 * @property {object} SHAPES.RECT=1
	 * @property {object} SHAPES.CIRC=2
	 * @property {object} SHAPES.ELIP=3
	 * @property {object} SHAPES.RREC=4</haxe_doc>
		</SHAPES>
		<SPRITE_BATCH_SIZE public="1" static="1"><x path="Int"/></SPRITE_BATCH_SIZE>
		<meta><m n=":native"><e>"PIXI"</e></m></meta>
	</class>
	<typedef path="pixi.core.RendererType" params="" file="pixi/core/Pixi.hx" module="pixi.core.Pixi"><a>
	<WEBGL><x path="Int"/></WEBGL>
	<UNKNOWN><x path="Int"/></UNKNOWN>
	<CANVAS><x path="Int"/></CANVAS>
</a></typedef>
	<typedef path="pixi.core.DefaultRenderOptions" params="" file="pixi/core/Pixi.hx" module="pixi.core.Pixi"><a>
	<view>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</view>
	<transparent>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</transparent>
	<resolution>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</resolution>
	<preserveDrawingBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</preserveDrawingBuffer>
	<forceFXAA>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</forceFXAA>
	<clearBeforeRender>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</clearBeforeRender>
	<backgroundColor>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</backgroundColor>
	<autoResize>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoResize>
	<antialias>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</antialias>
</a></typedef>
	<typedef path="pixi.core.ScaleModes" params="" file="pixi/core/Pixi.hx" module="pixi.core.Pixi"><a>
	<NEAREST><x path="Int"/></NEAREST>
	<LINEAR><x path="Int"/></LINEAR>
	<DEFAULT><x path="Int"/></DEFAULT>
</a></typedef>
	<typedef path="pixi.core.BlendModes" params="" file="pixi/core/Pixi.hx" module="pixi.core.Pixi"><a>
	<SOFT_LIGHT><x path="Int"/></SOFT_LIGHT>
	<SCREEN><x path="Int"/></SCREEN>
	<SATURATION><x path="Int"/></SATURATION>
	<OVERLAY><x path="Int"/></OVERLAY>
	<NORMAL><x path="Int"/></NORMAL>
	<MULTIPLY><x path="Int"/></MULTIPLY>
	<LUMINOSITY><x path="Int"/></LUMINOSITY>
	<LIGHTEN><x path="Int"/></LIGHTEN>
	<HUE><x path="Int"/></HUE>
	<HARD_LIGHT><x path="Int"/></HARD_LIGHT>
	<EXCLUSION><x path="Int"/></EXCLUSION>
	<DIFFERENCE><x path="Int"/></DIFFERENCE>
	<DARKEN><x path="Int"/></DARKEN>
	<COLOR_DODGE><x path="Int"/></COLOR_DODGE>
	<COLOR_BURN><x path="Int"/></COLOR_BURN>
	<COLOR><x path="Int"/></COLOR>
	<ADD><x path="Int"/></ADD>
</a></typedef>
	<typedef path="pixi.core.Shapes" params="" file="pixi/core/Pixi.hx" module="pixi.core.Pixi"><a>
	<RREC><x path="Int"/></RREC>
	<RECT><x path="Int"/></RECT>
	<POLY><x path="Int"/></POLY>
	<ELIP><x path="Int"/></ELIP>
	<CIRC><x path="Int"/></CIRC>
</a></typedef>
	<class path="pixi.interaction.InteractionManager" params="" file="pixi/interaction/InteractionManager.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<renderer public="1">
			<c path="pixi.core.renderers.SystemRenderer"/>
			<haxe_doc>* The renderer this interaction manager works for.
     *
     * @member {SystemRenderer}</haxe_doc>
		</renderer>
		<autoPreventDefault public="1">
			<x path="Bool"/>
			<haxe_doc>* Should default browser actions automatically be prevented.
     *
     * @member {Bool}
     * @default true</haxe_doc>
		</autoPreventDefault>
		<interactionFrequency public="1">
			<x path="Int"/>
			<haxe_doc>* As this frequency increases the interaction events will be checked more often.
     *
     * @member {Int}
     * @default 10</haxe_doc>
		</interactionFrequency>
		<mouse public="1">
			<c path="pixi.interaction.InteractionData"/>
			<haxe_doc>* The mouse data
     *
     * @member {InteractionData}</haxe_doc>
		</mouse>
		<eventData public="1">
			<t path="pixi.interaction.EventTarget"/>
			<haxe_doc>* An event data object to handle all the event tracking/dispatching
     *
     * @member {EventTarget}</haxe_doc>
		</eventData>
		<interactiveDataPool public="1">
			<c path="Array"><c path="pixi.interaction.InteractionData"/></c>
			<haxe_doc>* Tiny little interactiveData pool !
     *
     * @member {Array}</haxe_doc>
		</interactiveDataPool>
		<onMouseUp public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onMouseUp>
		<onMouseDown public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onMouseDown>
		<onMouseMove public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onMouseMove>
		<onMouseOut public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onMouseOut>
		<onTouchStart public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onTouchStart>
		<onTouchEnd public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onTouchEnd>
		<onTouchMove public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</onTouchMove>
		<tap public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</tap>
		<click public="1">
			<f a="">
				<t path="pixi.interaction.EventTarget"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @member {function}</haxe_doc>
		</click>
		<last public="1">
			<x path="Int"/>
			<haxe_doc>* @member {Int}</haxe_doc>
		</last>
		<currentCursorStyle public="1">
			<c path="String"/>
			<haxe_doc>* The css style of the cursor that is being used
     * @member {String}</haxe_doc>
		</currentCursorStyle>
		<mapPositionToPoint public="1" set="method">
			<f a="point:x:y">
				<c path="pixi.core.math.Point"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Maps x and y coords from a DOM object and maps them correctly to the pixi view. The resulting value is stored in the point.
	 * This takes into account the fact that the DOM element could be scaled and positioned anywhere on the screen.
	 *
	 * @param  {Point} point the point that the result will be stored in
	 * @param  {Float} x the x coord of the position to map
	 * @param  {Float} y the y coord of the position to map</haxe_doc>
		</mapPositionToPoint>
		<processInteractive public="1" set="method">
			<f a="point:displayObject:func:hitTest:interactive">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.display.DisplayObject"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* This function is provides a neat way of crawling through the scene graph and running a specified 	function on all interactive objects it finds.
	 * It will also take care of hit testing the interactive objects and passes the hit across in the 	function.
	 *
	 * @param  {Point} point the point that is tested for collision
	 * @param  {Container|Sprite|TilingSprite} displayObject the displayObject that will be hit test (recurcsivly crawls its children)
	 * @param  {function} func the 	function that will be called on each interactive object. The displayObject and hit will be passed to the 	function
	 * @param  {Bool} hitTest this indicates if the objects inside should be hit test against the point
	 * @return {Bool} returns true if the displayObject hit the point</haxe_doc>
		</processInteractive>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
	 * if its interactive parameter is set to true
	 * This manager also supports multitouch.
	 *
	 * @class
	 * @memberof PIXI.interaction
	 * @param renderer {CanvasRenderer|WebGLRenderer} A reference to the current renderer
	 * @param [options] {object}
	 * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.
	 * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="renderer:?options">
		<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
		<t path="pixi.interaction.InteractionManagerOptions"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
	 * if its interactive parameter is set to true
	 * This manager also supports multitouch.
	 *
	 * @class
	 * @memberof PIXI.interaction
	 * @param renderer {CanvasRenderer|WebGLRenderer} A reference to the current renderer
	 * @param [options] {object}
	 * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.
	 * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"PIXI.interaction.InteractionManager"</e></m></meta>
	</class>
	<class path="pixi.core.display.DisplayObject" params="" file="pixi/core/display/DisplayObject.hx" extern="1">
		<extends path="pixi.interaction.InteractionManager"/>
		<getGlobalPosition public="1" set="method">
			<f a="point">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Returns the global position of the displayObject
	 *
	 * @param point {Point} the point to write the global value to. If null a new point will be returned
	 * @return {Point}</haxe_doc>
		</getGlobalPosition>
		<getBounds public="1" set="method">
			<f a="?matrix">
				<c path="pixi.core.math.Matrix"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
			</f>
			<haxe_doc>* Retrieves the bounds of the displayObject as a rectangle object
	 *
	 * @param matrix {Matrix}
	 * @return {Rectangle} the rectangular bounding area</haxe_doc>
		</getBounds>
		<getLocalBounds public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
			<haxe_doc>* Retrieves the local bounds of the displayObject as a rectangle object
	 *
	 * @return {Rectangle} the rectangular bounding area</haxe_doc>
		</getLocalBounds>
		<toGlobal public="1" set="method">
			<f a="position">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Calculates the global position of the display object
	 *
	 * @param position {Point} The world origin to calculate from
	 * @return {Point} A point object representing the position of this object</haxe_doc>
		</toGlobal>
		<toLocal public="1" set="method">
			<f a="position:?frm">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Calculates the local position of the display object relative to another point
	 *
	 * @param position {Point} The world origin to calculate from
	 * @param [from] {DisplayObject} The DisplayObject to calculate the global position from
	 * @return {Point} A point object representing the position of this object</haxe_doc>
		</toLocal>
		<generateTexture public="1" set="method">
			<f a="renderer:?resolution:?scaleMode">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Useful function that returns a texture of the display object that can then be used to create sprites
	 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
	 *
	 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.
	 * @param resolution {Number} The resolution of the texture being generated
	 * @param scaleMode {Number} See {@link SCALE_MODES} for possible values
	 * @return {Texture} a texture of the display object</haxe_doc>
			<overloads><generateTexture public="1" set="method">
	<f a="renderer:?resolution:?scaleMode">
		<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
		<x path="Float"/>
		<x path="Int"/>
		<c path="pixi.core.textures.Texture"/>
	</f>
	<haxe_doc>* Useful function that returns a texture of the display object that can then be used to create sprites
	 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
	 *
	 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.
	 * @param resolution {Number} The resolution of the texture being generated
	 * @param scaleMode {Number} See {@link SCALE_MODES} for possible values
	 * @return {Texture} a texture of the display object</haxe_doc>
</generateTexture></overloads>
		</generateTexture>
		<updateTransform public="1" set="method"><f a=""><x path="Void"/></f></updateTransform>
		<displayObjectUpdateTransform public="1" set="method"><f a=""><x path="Void"/></f></displayObjectUpdateTransform>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Base destroy method for generic display objects
	 * @param [destroyChildren] {Bool} if set to true, all the children will have their destroy method called as well (Container)
	 * @param [destroyTexture] {Bool} Should it destroy the current texture of the sprite as well (Sprite)
	 * @param [destroyBaseTexture] {Bool} whether to destroy the base texture as well (Text, Sprite)</haxe_doc>
			<overloads>
				<destroy public="1" set="method">
					<f a="?destroyTexture:?destroyBaseTexture">
						<x path="Bool"/>
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Base destroy method for generic display objects
	 * @param [destroyChildren] {Bool} if set to true, all the children will have their destroy method called as well (Container)
	 * @param [destroyTexture] {Bool} Should it destroy the current texture of the sprite as well (Sprite)
	 * @param [destroyBaseTexture] {Bool} whether to destroy the base texture as well (Text, Sprite)</haxe_doc>
				</destroy>
				<destroy public="1" set="method">
					<f a="?destroyChildren">
						<x path="Bool"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* Base destroy method for generic display objects
	 * @param [destroyChildren] {Bool} if set to true, all the children will have their destroy method called as well (Container)
	 * @param [destroyTexture] {Bool} Should it destroy the current texture of the sprite as well (Sprite)
	 * @param [destroyBaseTexture] {Bool} whether to destroy the base texture as well (Text, Sprite)</haxe_doc>
				</destroy>
			</overloads>
		</destroy>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The instance name of the object.
	 *
	 * @member {String}</haxe_doc>
		</name>
		<cacheAsBitmap public="1">
			<x path="Bool"/>
			<haxe_doc>* Set this to true if you want this display object to be cached as a bitmap.
	 * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.
	 * To remove simply set this property to 'null'
	 *
	 * @member {Bool}
	 * @memberof DisplayObject#</haxe_doc>
		</cacheAsBitmap>
		<position public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The coordinate of the object relative to the local coordinates of the parent.
	 *
	 * @member {Point}</haxe_doc>
		</position>
		<scale public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The scale factor of the object.
	 *
	 * @member {Point}</haxe_doc>
		</scale>
		<pivot public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The pivot point of the displayObject that it rotates around
	 *
	 * @member {Point}</haxe_doc>
		</pivot>
		<rotation public="1">
			<x path="Float"/>
			<haxe_doc>* The rotation of the object in radians.
	 *
	 * @member {Float}</haxe_doc>
		</rotation>
		<alpha public="1">
			<x path="Float"/>
			<haxe_doc>* The opacity of the object.
	 *
	 * @member {Float}</haxe_doc>
		</alpha>
		<visible public="1">
			<x path="Bool"/>
			<haxe_doc>* The visibility of the object. If false the object will not be drawn, and
	 * the updateTransform function will not be called.
	 *
	 * @member {Bool}</haxe_doc>
		</visible>
		<renderable public="1">
			<x path="Bool"/>
			<haxe_doc>* Can this object be rendered, if false the object will not be drawn but the updateTransform
	 * methods will still be called.
	 *
	 * @member {Bool}</haxe_doc>
		</renderable>
		<parent public="1">
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* The display object container that contains this display object.
	 *
	 * @member {Container}
	 * @readOnly</haxe_doc>
		</parent>
		<worldAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The multiplied alpha of the displayObject
	 *
	 * @member {Float}
	 * @readOnly</haxe_doc>
		</worldAlpha>
		<worldTransform public="1">
			<c path="pixi.core.math.Matrix"/>
			<haxe_doc>* Current transform of the object based on world (parent) factors
	 *
	 * @member {Matrix}
	 * @readOnly</haxe_doc>
		</worldTransform>
		<filterArea public="1">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* The area the filter is applied to. This is used as more of an optimisation
	 * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
	 *
	 * @member {Rectangle}</haxe_doc>
		</filterArea>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The position of the displayObject on the x axis relative to the local coordinates of the parent.
	 *
	 * @member {Float}
	 * @memberof DisplayObject#</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The position of the displayObject on the y axis relative to the local coordinates of the parent.
	 *
	 * @member {Float}
	 * @memberof DisplayObject#</haxe_doc>
		</y>
		<worldVisible public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the displayObject is globally visible.
	 *
	 * @member {Bool}
	 * @memberof DisplayObject#
	 * @readonly</haxe_doc>
		</worldVisible>
		<mask public="1">
			<d/>
			<haxe_doc>* Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
	 * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.
	 * To remove a mask, set this property to null.
	 *
	 * @member {Graphics}
	 * @memberof DisplayObject#</haxe_doc>
		</mask>
		<filters public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* Sets the filters for the displayObject.
	 * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
	 * To remove filters simply set this property to 'null'
	 *
	 * @member {Filter[]}
	 * @memberof DisplayObject#</haxe_doc>
		</filters>
		<interactive public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the displayObject is interactive or not.
	 *
	 * @member {Bool}
	 * @default false
	 * @memberof DisplayObject#</haxe_doc>
		</interactive>
		<buttonMode public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the displayObject uses button mode or normal mode.
	 *
	 * @member {Bool}
	 * @default false
	 * @memberof DisplayObject#</haxe_doc>
		</buttonMode>
		<interactiveChildren public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the children of displayObject are interactive or not.
	 *
	 * @member {Bool}
	 * @default true
	 * @memberof DisplayObject#</haxe_doc>
		</interactiveChildren>
		<defaultCursor public="1">
			<c path="String"/>
			<haxe_doc>* Default cursor.
	 *
	 * @member {String}
	 * @default pointer
	 * @memberof DisplayObject#</haxe_doc>
		</defaultCursor>
		<hitArea public="1">
			<d/>
			<haxe_doc>* Hit area
	 *
	 * @memberof DisplayObject#</haxe_doc>
		</hitArea>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The base class for all objects that are rendered on the screen.
	 * This is an abstract class and should not be used on its own rather it should be extended.
	 *
	 * @class
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.DisplayObject"</e></m></meta>
	</class>
	<class path="pixi.core.display.Container" params="" file="pixi/core/display/Container.hx" extern="1">
		<extends path="pixi.core.display.DisplayObject"/>
		<children public="1">
			<c path="Array"><c path="pixi.core.display.DisplayObject"/></c>
			<haxe_doc>* The array of children of this container.
	 *
	 * @member {DisplayObject[]}
	 * @readonly</haxe_doc>
		</children>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the Container, setting this will actually modify the scale to achieve the value set
	 *
	 * @member {Float}
	 * @memberof Container#</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the Container, setting this will actually modify the scale to achieve the value set
	 *
	 * @member {Float}
	 * @memberof Container#</haxe_doc>
		</height>
		<addChild public="1" set="method">
			<f a="child">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Adds a child to the container.
	 *
	 * @param child {DisplayObject} The DisplayObject to add to the container
	 * @return {DisplayObject} The child that was added.</haxe_doc>
		</addChild>
		<addChildAt public="1" set="method">
			<f a="child:index">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Int"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
	 *
	 * @param child {DisplayObject} The child to add
	 * @param index {Int} The index to place the child in
	 * @return {DisplayObject} The child that was added.</haxe_doc>
		</addChildAt>
		<swapChildren public="1" set="method">
			<f a="child1:child2">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Swaps the position of 2 Display Objects within this container.
	 *
	 * @param child1 {DisplayObject}
	 * @param child2 {DisplayObject}</haxe_doc>
		</swapChildren>
		<getChildIndex public="1" set="method">
			<f a="child">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the index position of a child DisplayObject instance
	 *
	 * @param child {DisplayObject} The DisplayObject instance to identify
	 * @return {Int} The index position of the child display object to identify</haxe_doc>
		</getChildIndex>
		<setChildIndex public="1" set="method">
			<f a="child:index">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Changes the position of an existing child in the display object container
	 *
	 * @param child {DisplayObject} The child DisplayObject instance for which you want to change the index number
	 * @param index {Int} The resulting index number for the child display object</haxe_doc>
		</setChildIndex>
		<getChildAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Returns the child at the specified index
	 *
	 * @param index {Int} The index to get the child from
	 * @return {DisplayObject} The child at the given index, if any.</haxe_doc>
		</getChildAt>
		<removeChild public="1" set="method">
			<f a="child">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Removes a child from the container.
	 *
	 * @param child {DisplayObject} The DisplayObject to remove
	 * @return {DisplayObject} The child that was removed.</haxe_doc>
		</removeChild>
		<removeChildAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Removes a child from the specified index position.
	 *
	 * @param index {Int} The index to get the child from
	 * @return {DisplayObject} The child that was removed.</haxe_doc>
		</removeChildAt>
		<removeChildren public="1" set="method">
			<f a="?beginIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes all children from this container that are within the begin and end indexes.
	 *
	 * @param beginIndex {Int} The beginning position. Default value is 0.
	 * @param endIndex {Int} The ending position. Default value is size of the container.</haxe_doc>
		</removeChildren>
		<getChildByName public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="pixi.core.display.DisplayObject"/>
			</f>
			<haxe_doc>* Returns the display object in the container
	*
	* @param name {string} instance name
	* @return {DisplayObject}</haxe_doc>
		</getChildByName>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* A Container represents a collection of display objects.
	 * It is the base class of all display objects that act as a container for other objects.
	 *
	 * @class
	 * @extends DisplayObject
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Container"</e></m>
		</meta>
	</class>
	<class path="pixi.core.graphics.Graphics" params="" file="pixi/core/graphics/Graphics.hx" extern="1">
		<extends path="pixi.core.display.Container"/>
		<fillAlpha public="1">
			<x path="Float"/>
			<haxe_doc>* The alpha value used when filling the Graphics object.
	 *
	 * @member {Float}
	 * @default 1</haxe_doc>
		</fillAlpha>
		<lineWidth public="1">
			<x path="Float"/>
			<haxe_doc>* The width (thickness) of any lines drawn.
	 *
	 * @member {Float}
	 * @default 0</haxe_doc>
		</lineWidth>
		<lineColor public="1">
			<x path="Int"/>
			<haxe_doc>* The color of any lines drawn.
	 *
	 * @member {Int}
	 * @default 0</haxe_doc>
		</lineColor>
		<tint public="1">
			<x path="Int"/>
			<haxe_doc>* The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.
	 *
	 * @member {Int}
	 * @default 0xFFFFFF</haxe_doc>
		</tint>
		<blendMode public="1">
			<x path="Int"/>
			<haxe_doc>* The blend mode to be applied to the graphic shape. Apply a value of blendModes.NORMAL to reset the blend mode.
	 *
	 * @member {Int}
	 * @default CONST.BLEND_MODES.NORMAL;</haxe_doc>
		</blendMode>
		<isMask public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether this shape is being used as a mask.
	 *
	 * @member {Bool}</haxe_doc>
		</isMask>
		<boundsPadding public="1">
			<x path="Float"/>
			<haxe_doc>* The bounds' padding used for bounds calculation.
	 *
	 * @member {Float}</haxe_doc>
		</boundsPadding>
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.graphics.Graphics"/></f>
			<haxe_doc>* Creates a new Graphics object with the same values as this one.
	 *
	 * @return {Graphics}</haxe_doc>
		</clone>
		<lineStyle public="1" set="method">
			<f a="?lineWidth:?color:?alpha">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
	 *
	 * @param lineWidth {Float} width of the line to draw, will update the objects stored style
	 * @param color {Int} color of the line to draw, will update the objects stored style
	 * @param alpha {Float} alpha of the line to draw, will update the objects stored style
	 * @return {Graphics}</haxe_doc>
		</lineStyle>
		<moveTo public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Moves the current drawing position to x, y.
	 *
	 * @param x {Float} the X coordinate to move to
	 * @param y {Float} the Y coordinate to move to
	 * @return {Graphics}</haxe_doc>
		</moveTo>
		<lineTo public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Draws a line using the current line style from the current drawing position to (x, y);
	 * The current drawing position is then set to (x, y).
	 *
	 * @param x {Float} the X coordinate to draw to
	 * @param y {Float} the Y coordinate to draw to
	 * @return {Graphics}</haxe_doc>
		</lineTo>
		<quadraticCurveTo public="1" set="method">
			<f a="cpX:cpY:toX:toY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Calculate the points for a quadratic bezier curve and then draws it.
	 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
	 *
	 * @param cpX {Float} Control point x
	 * @param cpY {Float} Control point y
	 * @param toX {Float} Destination point x
	 * @param toY {Float} Destination point y
	 * @return {Graphics}</haxe_doc>
		</quadraticCurveTo>
		<bezierCurveTo public="1" set="method">
			<f a="cpX:cpY:cpX2:cpY2:toX:toY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Calculate the points for a bezier curve and then draws it.
	 *
	 * @param cpX {Float} Control point x
	 * @param cpY {Float} Control point y
	 * @param cpX2 {Float} Second Control point x
	 * @param cpY2 {Float} Second Control point y
	 * @param toX {Float} Destination point x
	 * @param toY {Float} Destination point y
	 * @return {Graphics}</haxe_doc>
		</bezierCurveTo>
		<arcTo public="1" set="method">
			<f a="x1:y1:x2:y2:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* The arcTo() method creates an arc/curve between two tangents on the canvas.
	 *
	 * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
	 *
	 * @param x1 {Float} The x-coordinate of the beginning of the arc
	 * @param y1 {Float} The y-coordinate of the beginning of the arc
	 * @param x2 {Float} The x-coordinate of the end of the arc
	 * @param y2 {Float} The y-coordinate of the end of the arc
	 * @param radius {Float} The radius of the arc
	 * @return {Graphics}</haxe_doc>
		</arcTo>
		<arc public="1" set="method">
			<f a="cx:cy:radius:startAngle:endAngle:?anticlockwise">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* The arc method creates an arc/curve (used to create circles, or parts of circles).
	 *
	 * @param cx {Float} The x-coordinate of the center of the circle
	 * @param cy {Float} The y-coordinate of the center of the circle
	 * @param radius {Float} The radius of the circle
	 * @param startAngle {Float} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)
	 * @param endAngle {Float} The ending angle, in radians
	 * @param anticlockwise {Bool} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.
	 * @return {Graphics}</haxe_doc>
		</arc>
		<beginFill public="1" set="method">
			<f a="?color:?alpha">
				<x path="Int"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Specifies a simple one-color fill that subsequent calls to other Graphics methods
	 * (such as lineTo() or drawCircle()) use when drawing.
	 *
	 * @param color {Int} the color of the fill
	 * @param alpha {Float} the alpha of the fill
	 * @return {Graphics}</haxe_doc>
		</beginFill>
		<endFill public="1" set="method">
			<f a=""><c path="pixi.core.graphics.Graphics"/></f>
			<haxe_doc>* Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
	 *
	 * @return {Graphics}</haxe_doc>
		</endFill>
		<drawRect public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>*
	 * @param x {Float} The X coord of the top-left of the rectangle
	 * @param y {Float} The Y coord of the top-left of the rectangle
	 * @param width {Float} The width of the rectangle
	 * @param height {Float} The height of the rectangle
	 * @return {Graphics}</haxe_doc>
		</drawRect>
		<drawRoundedRect public="1" set="method">
			<f a="x:y:width:height:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>*
	 * @param x {Float} The X coord of the top-left of the rectangle
	 * @param y {Float} The Y coord of the top-left of the rectangle
	 * @param width {Float} The width of the rectangle
	 * @param height {Float} The height of the rectangle
	 * @param radius {Float} Radius of the rectangle corners</haxe_doc>
		</drawRoundedRect>
		<drawCircle public="1" set="method">
			<f a="x:y:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Draws a circle.
	 *
	 * @param x {Float} The X coordinate of the center of the circle
	 * @param y {Float} The Y coordinate of the center of the circle
	 * @param radius {Float} The radius of the circle
	 * @return {Graphics}</haxe_doc>
		</drawCircle>
		<drawEllipse public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Draws an ellipse.
	 *
	 * @param x {Float} The X coordinate of the center of the ellipse
	 * @param y {Float} The Y coordinate of the center of the ellipse
	 * @param width {Float} The half width of the ellipse
	 * @param height {Float} The half height of the ellipse
	 * @return {Graphics}</haxe_doc>
		</drawEllipse>
		<drawPolygon public="1" set="method">
			<f a="path">
				<c path="Array"><x path="Float"/></c>
				<c path="pixi.core.graphics.Graphics"/>
			</f>
			<haxe_doc>* Draws a polygon using the given path.
	 *
	 * @param path {Array} The path data used to construct the polygon.
	 * @return {Graphics}</haxe_doc>
		</drawPolygon>
		<clear public="1" set="method">
			<f a=""><c path="pixi.core.graphics.Graphics"/></f>
			<haxe_doc>* Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
	 *
	 * @return {Graphics}</haxe_doc>
		</clear>
		<updateLocalBounds public="1" set="method">
			<f a=""><c path="pixi.core.graphics.Graphics"/></f>
			<haxe_doc>* Update the bounds of the object
	 *</haxe_doc>
		</updateLocalBounds>
		<drawShape public="1" set="method">
			<f a="shape">
				<c path="pixi.core.math.shapes.Circle"/>
				<c path="pixi.core.graphics.GraphicsData"/>
			</f>
			<haxe_doc>* Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.
	 * @return {GraphicsData} The generated GraphicsData object.</haxe_doc>
			<overloads>
				<drawShape public="1" set="method">
					<f a="shape">
						<c path="pixi.core.math.shapes.Rectangle"/>
						<c path="pixi.core.graphics.GraphicsData"/>
					</f>
					<haxe_doc>* Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.
	 * @return {GraphicsData} The generated GraphicsData object.</haxe_doc>
				</drawShape>
				<drawShape public="1" set="method">
					<f a="shape">
						<c path="pixi.core.math.shapes.Ellipse"/>
						<c path="pixi.core.graphics.GraphicsData"/>
					</f>
					<haxe_doc>* Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.
	 * @return {GraphicsData} The generated GraphicsData object.</haxe_doc>
				</drawShape>
				<drawShape public="1" set="method">
					<f a="shape">
						<c path="pixi.core.math.shapes.Polygon"/>
						<c path="pixi.core.graphics.GraphicsData"/>
					</f>
					<haxe_doc>* Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
	 *
	 * @param {Circle|Rectangle|Ellipse|Line|Polygon} shape The Shape object to draw.
	 * @return {GraphicsData} The generated GraphicsData object.</haxe_doc>
				</drawShape>
			</overloads>
		</drawShape>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The Graphics class contains methods used to draw primitive shapes such as lines, circles and
	 * rectangles to the display, and color and fill them.
	 *
	 * @class
	 * @extends Container
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Graphics"</e></m>
		</meta>
	</class>
	<class path="pixi.core.graphics.GraphicsData" params="" file="pixi/core/graphics/GraphicsData.hx" extern="1">
		<lineWidth public="1"><x path="Float"/></lineWidth>
		<lineColor public="1"><c path="String"/></lineColor>
		<lineAlpha public="1"><x path="Float"/></lineAlpha>
		<fillColor public="1"><c path="String"/></fillColor>
		<fillAlpha public="1"><x path="Float"/></fillAlpha>
		<fill public="1"><c path="String"/></fill>
		<shape public="1"><d/></shape>
		<type public="1"><x path="Int"/></type>
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.graphics.GraphicsData"/></f>
			<haxe_doc>* Creates a new GraphicsData object with the same values as this one.
	 *
	 * @return {GraphicsData}</haxe_doc>
		</clone>
		<new public="1" set="method">
			<f a="lineWidth:lineColor:lineAlpha:fillColor:fillAlpha:fill:shape">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A GraphicsData object.
	 *
	 * @class
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.GraphicsData"</e></m></meta>
	</class>
	<class path="pixi.core.math.Matrix" params="" file="pixi/core/math/Matrix.hx" extern="1">
		<a public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 1</haxe_doc>
		</a>
		<b public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 0</haxe_doc>
		</b>
		<c public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 0</haxe_doc>
		</c>
		<d public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 1</haxe_doc>
		</d>
		<tx public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 0</haxe_doc>
		</tx>
		<ty public="1">
			<x path="Float"/>
			<haxe_doc>* @member {Float}
	 * @default 0</haxe_doc>
		</ty>
		<fromArray public="1" set="method">
			<f a="array">
				<c path="Array"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
	 *
	 * a = array[0]
	 * b = array[1]
	 * c = array[3]
	 * d = array[4]
	 * tx = array[2]
	 * ty = array[5]
	 *
	 * @param array {Float[]} The array that the matrix will be populated from.</haxe_doc>
		</fromArray>
		<toArray public="1" set="method">
			<f a="transpose">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Creates an array from the current Matrix object.
	 *
	 * @param transpose {Bool} Whether we need to transpose the matrix or not
	 * @return {Float[]} the newly created array which contains the matrix</haxe_doc>
		</toArray>
		<apply public="1" set="method">
			<f a="pos:?newPos">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Get a new position with the current transformation applied.
	 * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
	 *
	 * @param pos {Point} The origin
	 * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)
	 * @return {Point} The new point, transformed through this matrix</haxe_doc>
		</apply>
		<applyInverse public="1" set="method">
			<f a="pos:?newPos">
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* Get a new position with the inverse of the current transformation applied.
	 * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
	 *
	 * @param pos {Point} The origin
	 * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)
	 * @return {Point} The new point, inverse-transformed through this matrix</haxe_doc>
		</applyInverse>
		<translate public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Translates the matrix on the x and y.
	 *
	 * @param {Float} x
	 * @param {Float} y
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</translate>
		<scale public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Applies a scale transformation to the matrix.
	 *
	 * @param {Float} x The amount to scale horizontally
	 * @param {Float} y The amount to scale vertically
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</scale>
		<rotate public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Applies a rotation transformation to the matrix.
	 *
	 * @param {Float} angle - The angle in radians.
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</rotate>
		<append public="1" set="method">
			<f a="matrix">
				<c path="pixi.core.math.Matrix"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Appends the given Matrix to this Matrix.
	 *
	 * @param {Matrix} matrix
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</append>
		<prepend public="1" set="method">
			<f a="matrix">
				<c path="pixi.core.math.Matrix"/>
				<c path="pixi.core.math.Matrix"/>
			</f>
			<haxe_doc>* Prepends the given Matrix to this Matrix.
	 *
	 * @param {Matrix} matrix
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</prepend>
		<identity public="1" set="method">
			<f a=""><c path="pixi.core.math.Matrix"/></f>
			<haxe_doc>* Resets this Matix to an identity (default) matrix.
	 *
	 * @return {Matrix} This matrix. Good for chaining method calls.</haxe_doc>
		</identity>
		<invert public="1" set="method"><f a=""><c path="pixi.core.math.Matrix"/></f></invert>
		<clone public="1" set="method"><f a=""><c path="pixi.core.math.Matrix"/></f></clone>
		<copy public="1" set="method"><f a="matrix">
	<c path="pixi.core.math.Matrix"/>
	<c path="pixi.core.math.Matrix"/>
</f></copy>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The Matrix class is now an object, which makes it a lot faster,
	 * here is a representation of it :
	 * | a | b | tx|
	 * | c | d | ty|
	 * | 0 | 0 | 1 |
	 *
	 * @class
	 * @namespace PIXI</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.Matrix"</e></m></meta>
	</class>
	<class path="pixi.core.math.Point" params="" file="pixi/core/math/Point.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.Point"/></f>
			<haxe_doc>* Creates a clone of this point
	 *
	 * @return {Point} a copy of the point</haxe_doc>
		</clone>
		<set public="1" set="method">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the point to a new x and y position.
	 * If y is ommited, both x and y will be set to x.
	 *
	 * @method set
	 * @param [x=0] {Float} position of the point on the x axis
	 * @param [y=0] {Float} position of the point on the y axis</haxe_doc>
		</set>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<new public="1" set="method">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Point object represents a location in a two-dimensional coordinate system, where x represents
	 * the horizontal axis and y represents the vertical axis.
	 *
	 * @class
	 * @namespace PIXI
	 * @param [x=0] {number} position of the point on the x axis
	 * @param [y=0] {number} position of the point on the y axis</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.Point"</e></m></meta>
	</class>
	<class path="pixi.core.math.shapes.Circle" params="" file="pixi/core/math/shapes/Circle.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Circle"/></f>
			<haxe_doc>* Creates a clone of this Circle instance
	 *
	 * @method clone
	 * @return {Circle} a copy of the circle</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x, and y coordinates passed to this function are contained within this circle
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Bool} Whether the x/y coordinates are within this polygon</haxe_doc>
		</contains>
		<getBounds public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
			<haxe_doc>* Returns the framing rectangle of the circle as a PIXI.Rectangle object
	 *
	 * @method getBounds
	 * @return {Rectangle} the framing rectangle</haxe_doc>
		</getBounds>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<radius public="1">
			<x path="Float"/>
			<haxe_doc>* @property radius
	 * @type Float
	 * @default 0</haxe_doc>
		</radius>
		<new public="1" set="method">
			<f a="x:y:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Circle object can be used to specify a hit area for displayObjects
	 *
	 * @class Circle
	 * @constructor
	 * @param x {Float} The X coordinate of the center of this circle
	 * @param y {Float} The Y coordinate of the center of this circle
	 * @param radius {Float} The radius of the circle</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.Circle"</e></m></meta>
	</class>
	<class path="pixi.core.math.shapes.Ellipse" params="" file="pixi/core/math/shapes/Ellipse.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Ellipse"/></f>
			<haxe_doc>* Creates a clone of this Ellipse instance
	 *
	 * @method clone
	 * @return {Ellipse} a copy of the ellipse</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x and y coordinates passed to this function are contained within this ellipse
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Bool} Whether the x/y coords are within this ellipse</haxe_doc>
		</contains>
		<getBounds public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
			<haxe_doc>* Returns the framing rectangle of the circle as a PIXI.Rectangle object
	 *
	 * @method getBounds
	 * @return {Rectangle} the framing rectangle</haxe_doc>
		</getBounds>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* @property width
	 * @type Float
	 * @default 0</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* @property height
	 * @type Float
	 * @default 0</haxe_doc>
		</height>
		<new public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Ellipse object can be used to specify a hit area for displayObjects
	 *
	 * @class Ellipse
	 * @constructor
	 * @param x {Float} The X coordinate of the center of the ellipse
	 * @param y {Float} The Y coordinate of the center of the ellipse
	 * @param width {Float} The half width of this ellipse
	 * @param height {Float} The half height of this ellipse</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.Ellipse"</e></m></meta>
	</class>
	<class path="pixi.core.math.shapes.Polygon" params="" file="pixi/core/math/shapes/Polygon.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Polygon"/></f>
			<haxe_doc>* Creates a clone of this polygon
	 *
	 * @method clone
	 * @return {Polygon} a copy of the polygon</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x and y coordinates passed to this function are contained within this polygon
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Bool} Whether the x/y coordinates are within this polygon</haxe_doc>
		</contains>
		<points public="1">
			<c path="Array"><c path="pixi.core.math.Point"/></c>
			<haxe_doc><![CDATA[* An array of the points of this polygon
	 * @property points
	 * @type Array<Point>
	 *]]></haxe_doc>
		</points>
		<new public="1" set="method">
			<f a="points">
				<c path="Array"><c path="pixi.core.math.Point"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* @class Polygon
	 * @constructor
	 * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,
	 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
	 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
	 *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
	 *      Numbers.]]></haxe_doc>
			<overloads><new public="1" set="method">
	<f a="points">
		<c path="Array"><x path="Float"/></c>
		<x path="Void"/>
	</f>
	<haxe_doc><![CDATA[* @class Polygon
	 * @constructor
	 * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,
	 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
	 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
	 *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
	 *      Numbers.]]></haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"PIXI.Polygon"</e></m></meta>
	</class>
	<class path="pixi.core.math.shapes.Rectangle" params="" file="pixi/core/math/shapes/Rectangle.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.Rectangle"/></f>
			<haxe_doc>* Creates a clone of this Rectangle instance
	 *
	 * @method clone
	 * @return {Rectangle} a copy of the rectangle</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x and y coordinates passed to this function are contained within this Rectangle
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Bool} Whether the x/y coords are within this Rectangle</haxe_doc>
		</contains>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* @property width
	 * @type Float
	 * @default 0</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* @property height
	 * @type Float
	 * @default 0</haxe_doc>
		</height>
		<new public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
	 *
	 * @class Rectangle
	 * @constructor
	 * @param x {Float} The X coord of the upper-left corner of the rectangle
	 * @param y {Float} The Y coord of the upper-left corner of the rectangle
	 * @param width {Float} The overall width of this rectangle
	 * @param height {Float} The overall height of this rectangle</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Rectangle"</e></m>
		</meta>
	</class>
	<class path="pixi.core.math.shapes.RoundedRectangle" params="" file="pixi/core/math/shapes/RoundedRectangle.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="pixi.core.math.shapes.RoundedRectangle"/></f>
			<haxe_doc>* Creates a clone of this Rounded Rectangle
	 *
	 * @method clone
	 * @return {RoundedRectangle} a copy of the rounded rectangle</haxe_doc>
		</clone>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether the x and y coordinates given are contained within this Rounded Rectangle
	 *
	 * @method contains
	 * @param x {Float} The X coordinate of the point to test
	 * @param y {Float} The Y coordinate of the point to test
	 * @return {Boolean} Whether the x/y coordinates are within this Rounded Rectangle</haxe_doc>
		</contains>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @property x
	 * @type Float
	 * @default 0</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @property y
	 * @type Float
	 * @default 0</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* @property width
	 * @type Float
	 * @default 0</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* @property height
	 * @type Float
	 * @default 0</haxe_doc>
		</height>
		<radius public="1">
			<x path="Float"/>
			<haxe_doc>* @property radius
	 * @type Float
	 * @default 20</haxe_doc>
		</radius>
		<new public="1" set="method">
			<f a="x:y:width:height:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Rounded Rectangle object is an area defined by its position and has nice rounded corners, as indicated by its top-left corner point (x, y) and by its width and its height.
	 *
	 * @class RoundedRectangle
	 * @constructor
	 * @param x {Number} The X coordinate of the upper-left corner of the rounded rectangle
	 * @param y {Number} The Y coordinate of the upper-left corner of the rounded rectangle
	 * @param width {Number} The overall width of this rounded rectangle
	 * @param height {Number} The overall height of this rounded rectangle
	 * @param radius {Number} The overall radius of this corners of this rounded rectangle</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.RoundedRectangle"</e></m></meta>
	</class>
	<class path="pixi.core.particles.ParticleContainer" params="" file="pixi/core/particles/ParticleContainer.hx" extern="1">
		<extends path="pixi.core.display.Container"/>
		<setProperties public="1" set="method">
			<f a="properties">
				<c path="Array"><x path="Bool"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the private properties array to dynamic / static based on the passed properties object
	 *
	 * @param properties {object} The properties to be uploaded</haxe_doc>
		</setProperties>
		<new public="1" set="method">
			<f a="?size:?properties">
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* The ParticleContainer class is a really fast version of the Container built solely for speed,
	 * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced
	 * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).
	 * Any other functionality like tinting, masking, etc will not work on sprites in this batch.
	 *
	 * It's extremely easy to use :
	 *
	 * ```js
	 * var container = new ParticleContainer();
	 *
	 * for (var i = 0; i < 100; ++i)
	 * {
	 *     var sprite = new PIXI.Sprite.fromImage("myImage.png");
	 *     container.addChild(sprite);
	 * }
	 * ```
	 *
	 * And here you have a hundred sprites that will be renderer at the speed of light.
	 *
	 * @class
	 * @extends PIXI.Container
	 * @memberof PIXI
	 *
	 * @param [size=15000] {number} The number of images in the SpriteBatch before it flushes.
	 * @param [properties] {object} The properties of children that should be uploaded to the gpu and applied.
	 * @param [properties.scale=false] {boolean} When true, scale be uploaded and applied.
	 * @param [properties.position=true] {boolean} When true, position be uploaded and applied.
	 * @param [properties.rotation=false] {boolean} When true, rotation be uploaded and applied.
	 * @param [properties.uvs=false] {boolean} When true, uvs be uploaded and applied.
	 * @param [properties.alpha=false] {boolean} When true, alpha be uploaded and applied.]]></haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.ParticleContainer"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.Detector" params="" file="pixi/core/renderers/Detector.hx" extern="1">
		<autoDetectRenderer public="1" set="method" static="1">
			<f a="width:height:?options:?noWebGL">
				<x path="Float"/>
				<x path="Float"/>
				<t path="pixi.core.renderers.RenderingOptions"/>
				<x path="Bool"/>
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
			</f>
			<haxe_doc>* @class Detector</haxe_doc>
			<overloads><autoDetectRenderer public="1" set="method">
	<f a="width:height:?options:?noWebGL">
		<x path="Float"/>
		<x path="Float"/>
		<t path="pixi.core.renderers.RenderingOptions"/>
		<x path="Bool"/>
		<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
	</f>
	<haxe_doc>* @class Detector</haxe_doc>
</autoDetectRenderer></overloads>
		</autoDetectRenderer>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI"</e></m>
		</meta>
	</class>
	<typedef path="pixi.core.renderers.RenderingOptions" params="" file="pixi/core/renderers/Detector.hx" module="pixi.core.renderers.Detector"><a>
	<view>
		<t path="Null"><c path="js.html.CanvasElement"/></t>
		<meta><m n=":optional"/></meta>
	</view>
	<transparent>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</transparent>
	<resolution>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</resolution>
	<preserveDrawingBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</preserveDrawingBuffer>
	<forceFXAA>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</forceFXAA>
	<clearBeforeRender>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</clearBeforeRender>
	<backgroundColor>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</backgroundColor>
	<autoResize>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoResize>
	<antialias>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</antialias>
</a></typedef>
	<class path="pixi.core.renderers.SystemRenderer" params="" file="pixi/core/renderers/SystemRenderer.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<type public="1">
			<x path="Int"/>
			<haxe_doc>* The type of the renderer.
	 *
	 * @member {CONST.RENDERER_TYPE}
	 * @default CONT.RENDERER_TYPE.UNKNOWN</haxe_doc>
		</type>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the canvas view
	 *
	 * @member {Float}
	 * @default 800</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the canvas view
	 *
	 * @member {Float}
	 * @default 600</haxe_doc>
		</height>
		<view public="1">
			<c path="js.html.CanvasElement"/>
			<haxe_doc>* The canvas element that everything is drawn to
	 *
	 * @member {CanvasElement}</haxe_doc>
		</view>
		<resolution public="1">
			<x path="Float"/>
			<haxe_doc>* The resolution of the renderer
	 *
	 * @member {Float}
	 * @default 1</haxe_doc>
		</resolution>
		<transparent public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the render view is transparent
	 *
	 * @member {Bool}</haxe_doc>
		</transparent>
		<autoResize public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the render view should be resized automatically
	 *
	 * @member {Bool}</haxe_doc>
		</autoResize>
		<blendModes public="1">
			<d/>
			<haxe_doc><![CDATA[* Tracks the blend modes useful for this renderer.
	 *
	 * @member {object<string, mixed>}]]></haxe_doc>
		</blendModes>
		<preserveDrawingBuffer public="1">
			<x path="Bool"/>
			<haxe_doc>* The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
	 *
	 * @member {Bool}</haxe_doc>
		</preserveDrawingBuffer>
		<clearBeforeRender public="1">
			<x path="Bool"/>
			<haxe_doc>* This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
	 * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
	 * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.
	 * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
	 *
	 * @member {Bool}
	 * @default</haxe_doc>
		</clearBeforeRender>
		<backgroundColor public="1">
			<x path="Int"/>
			<haxe_doc>* The background color to fill if not transparent
	 *
	 * @member {Int}
	 * @default 0x000000</haxe_doc>
		</backgroundColor>
		<plugins public="1">
			<d/>
			<haxe_doc>* Plugins object</haxe_doc>
		</plugins>
		<resize public="1" set="method">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resizes the canvas view to the specified width and height
	 *
	 * @param width {Float} the new width of the canvas view
	 * @param height {Float} the new height of the canvas view</haxe_doc>
		</resize>
		<destroy public="1" set="method">
			<f a="?removeView" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{removeView:false}</e></m></meta>
			<haxe_doc>* Removes everything from the renderer and optionally removes the Canvas DOM element.
	 *
	 * @param [removeView=false] {Bool} Removes the Canvas element from the DOM.</haxe_doc>
		</destroy>
		<render public="1" set="method">
			<f a="object">
				<c path="pixi.core.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Renders the object to canvas/webGL view
	 *
	 * @param object {DisplayObject} the object to be rendered</haxe_doc>
		</render>
		<new public="1" set="method">
			<f a="system:?width:?height:?options" v=":800:600:">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="pixi.core.renderers.RenderingOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{height:600,width:800}</e></m></meta>
			<haxe_doc>* The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
	 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @namespace PIXI
	 * @param system {string} The name of the system this renderer is for.
	 * @param [width=800] {number} the width of the canvas view
	 * @param [height=600] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.SystemRenderer"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.canvas.CanvasRenderer" params="" file="pixi/core/renderers/canvas/CanvasRenderer.hx" extern="1">
		<extends path="pixi.core.renderers.SystemRenderer"/>
		<context public="1">
			<c path="js.html.CanvasRenderingContext2D"/>
			<haxe_doc>* The canvas 2d context that everything is drawn with.
	 *
	 * @member {CanvasRenderingContext2D}</haxe_doc>
		</context>
		<refresh public="1">
			<x path="Bool"/>
			<haxe_doc>* Boolean flag controlling canvas refresh.
	 *
	 * @member {Bool}</haxe_doc>
		</refresh>
		<maskManager public="1">
			<d/>
			<haxe_doc>* Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
	 *
	 * @member {CanvasMaskManager}</haxe_doc>
		</maskManager>
		<roundPixels public="1">
			<x path="Bool"/>
			<haxe_doc>* If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
	 * Handy for crisp pixel art and speed on legacy devices.
	 *
	 * @member {Bool}</haxe_doc>
		</roundPixels>
		<currentScaleMode public="1">
			<x path="Int"/>
			<haxe_doc>* Tracks the active scale mode for this renderer.
	 *
	 * @member {SCALE_MODE}</haxe_doc>
		</currentScaleMode>
		<currentBlendMode public="1">
			<x path="Int"/>
			<haxe_doc>* Tracks the active blend mode for this renderer.
	 *
	 * @member {BLEND_MODES}</haxe_doc>
		</currentBlendMode>
		<smoothProperty public="1">
			<c path="String"/>
			<haxe_doc>* The canvas property used to set the canvas smoothing property.
	 *
	 * @member {String}</haxe_doc>
		</smoothProperty>
		<new public="1" set="method">
			<f a="width:height:?options">
				<x path="Float"/>
				<x path="Float"/>
				<t path="pixi.core.renderers.RenderingOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
	 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @namespace PIXI
	 * @param system {string} The name of the system this renderer is for.
	 * @param [width=800] {number} the width of the canvas view
	 * @param [height=600] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.CanvasRenderer"</e></m>
		</meta>
	</class>
	<class path="pixi.core.renderers.canvas.utils.CanvasBuffer" params="" file="pixi/core/renderers/canvas/utils/CanvasBuffer.hx" extern="1">
		<canvas public="1">
			<c path="js.html.CanvasElement"/>
			<haxe_doc>* The Canvas object that belongs to this CanvasBuffer.
     *
     * @member {HTMLCanvasElement}</haxe_doc>
		</canvas>
		<context public="1">
			<c path="js.html.CanvasRenderingContext2D"/>
			<haxe_doc>* A CanvasRenderingContext2D object representing a two-dimensional rendering context.
	 *
	 * @member {CanvasRenderingContext2D}</haxe_doc>
		</context>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the canvas buffer in pixels.
	 *
	 * @member {number}
	 * @memberof CanvasBuffer#</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the canvas buffer in pixels.
	 *
	 * @member {number}
	 * @memberof CanvasBuffer#</haxe_doc>
		</height>
		<resize public="1" set="method">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resizes the canvas to the specified width and height.
	 *
	 * @param width {number} the new width of the canvas
	 * @param height {number} the new height of the canvas</haxe_doc>
		</resize>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroys this canvas.
	 *</haxe_doc>
		</destroy>
		<new public="1" set="method">
			<f a="width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a Canvas element of the given size.
	 *
	 * @class
	 * @memberof PIXI
	 * @param width {Float} the width for the newly created canvas
	 * @param height {Float} the height for the newly created canvas</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.CanvasBuffer"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.canvas.utils.CanvasGraphics" params="" file="pixi/core/renderers/canvas/utils/CanvasGraphics.hx" extern="1">
		<renderGraphics public="1" set="method" static="1"><f a="graphics:context">
	<c path="pixi.core.graphics.Graphics"/>
	<c path="js.html.CanvasRenderingContext2D"/>
	<x path="Void"/>
</f></renderGraphics>
		<meta><m n=":native"><e>"PIXI.CanvasGraphics"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.canvas.utils.CanvasMaskManager" params="" file="pixi/core/renderers/canvas/utils/CanvasMaskManager.hx" extern="1">
		<pushMask public="1" set="method">
			<f a="maskData:renderer">
				<d/>
				<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This method adds it to the current stack of masks.
	 *
	 * @param maskData {object} the maskData that will be pushed
	 * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.</haxe_doc>
			<overloads><pushMask public="1" set="method">
	<f a="maskData:renderer">
		<d/>
		<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* This method adds it to the current stack of masks.
	 *
	 * @param maskData {object} the maskData that will be pushed
	 * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.</haxe_doc>
</pushMask></overloads>
		</pushMask>
		<popMask public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Restores the current drawing context to the state it was before the mask was applied.
	 *
	 * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.</haxe_doc>
			<overloads><popMask public="1" set="method">
	<f a="renderer">
		<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* Restores the current drawing context to the state it was before the mask was applied.
	 *
	 * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.</haxe_doc>
</popMask></overloads>
		</popMask>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":native"><e>"PIXI.CanvasMaskManager"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.canvas.utils.CanvasTinter" params="" file="pixi/core/renderers/canvas/utils/CanvasTinter.hx" extern="1">
		<getTintedTexture public="1" set="method" static="1">
			<f a="sprite:color">
				<c path="pixi.core.sprites.Sprite"/>
				<x path="Int"/>
				<c path="js.html.CanvasElement"/>
			</f>
			<haxe_doc>* Basically this method just needs a sprite and a color and tints the sprite with the given color.
	 *
	 * @param sprite {Sprite} the sprite to tint
	 * @param color {Int} the color to use to tint the sprite with
	 * @return {HTMLCanvasElement} The tinted canvas</haxe_doc>
		</getTintedTexture>
		<tintWithMultiply public="1" set="method" static="1">
			<f a="texture:color:canvas">
				<c path="pixi.core.textures.Texture"/>
				<x path="Int"/>
				<c path="js.html.CanvasElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Tint a texture using the 'multiply' operation.
	 *
	 * @param texture {Texture} the texture to tint
	 * @param color {Int} the color to use to tint the sprite with
	 * @param canvas {HTMLCanvasElement} the current canvas</haxe_doc>
		</tintWithMultiply>
		<tintWithOverlay public="1" set="method" static="1">
			<f a="texture:color:canvas">
				<c path="pixi.core.textures.Texture"/>
				<x path="Int"/>
				<c path="js.html.CanvasElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Tint a texture using the 'overlay' operation.
	 *
	 * @param texture {Texture} the texture to tint
	 * @param color {Int} the color to use to tint the sprite with
	 * @param canvas {HTMLCanvasElement} the current canvas</haxe_doc>
		</tintWithOverlay>
		<tintWithPerPixel public="1" set="method" static="1">
			<f a="texture:color:canvas">
				<c path="pixi.core.textures.Texture"/>
				<x path="Int"/>
				<c path="js.html.CanvasElement"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Tint a texture pixel per pixel.
	 *
	 * @param texture {Texture} the texture to tint
	 * @param color {Int} the color to use to tint the sprite with
	 * @param canvas {HTMLCanvasElement} the current canvas</haxe_doc>
		</tintWithPerPixel>
		<roundColor public="1" set="method" static="1">
			<f a="color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
	 *
	 * @param color {Int} the color to round, should be a hex color</haxe_doc>
		</roundColor>
		<cacheStepsPerColorChannel public="1">
			<x path="Int"/>
			<haxe_doc>* Number of steps which will be used as a cap when rounding colors.
	 *
	 * @member</haxe_doc>
		</cacheStepsPerColorChannel>
		<convertTintToImage public="1">
			<x path="Bool"/>
			<haxe_doc>* Tint cache boolean flag.
	 *
	 * @member</haxe_doc>
		</convertTintToImage>
		<canUseMultiply public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
	 *
	 * @member</haxe_doc>
		</canUseMultiply>
		<tintMethod public="1">
			<d/>
			<haxe_doc>* The tinting method that will be used.
	 *</haxe_doc>
		</tintMethod>
		<meta><m n=":native"><e>"PIXI.CanvasTinter"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.webgl.WebGLRenderer" params="" file="pixi/core/renderers/webgl/WebGLRenderer.hx" extern="1">
		<extends path="pixi.core.renderers.SystemRenderer"/>
		<drawCount public="1">
			<x path="Int"/>
			<haxe_doc>* Counter for the number of draws made each frame
	 *
	 * @member {Int}</haxe_doc>
		</drawCount>
		<shaderManager public="1">
			<d/>
			<haxe_doc>* Deals with managing the shader programs and their attribs.
     *
     * @member {ShaderManager}</haxe_doc>
		</shaderManager>
		<maskManager public="1">
			<c path="pixi.core.renderers.webgl.managers.MaskManager"/>
			<haxe_doc>* Manages the masks using the stencil buffer.
     *
     * @member {MaskManager}</haxe_doc>
		</maskManager>
		<stencilManager public="1">
			<d/>
			<haxe_doc>* Manages the stencil buffer.
     *
     * @member {StencilManager}</haxe_doc>
		</stencilManager>
		<filterManager public="1">
			<c path="pixi.core.renderers.webgl.managers.FilterManager"/>
			<haxe_doc>* Manages the filters.
     *
     * @member {FilterManager}</haxe_doc>
		</filterManager>
		<blendModeManager public="1">
			<c path="pixi.core.renderers.webgl.managers.BlendModeManager"/>
			<haxe_doc>* Manages the blendModes
     * @member {BlendModeManager}</haxe_doc>
		</blendModeManager>
		<currentRenderTarget public="1">
			<d/>
			<haxe_doc>* Holds the current render target
     * @member {Object}</haxe_doc>
		</currentRenderTarget>
		<currentRenderer public="1">
			<d/>
			<haxe_doc>* object renderer @alvin
     * @member {ObjectRenderer}</haxe_doc>
		</currentRenderer>
		<new public="1" set="method">
			<f a="width:height:?options">
				<x path="Float"/>
				<x path="Float"/>
				<t path="pixi.core.renderers.RenderingOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
	 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
	 * So no need for Sprite Batches or Sprite Clouds.
	 * Don't forget to add the view to your DOM or you will not see anything :)
	 *
	 * @class
	 * @namespace PIXI
	 * @param [width=0] {number} the width of the canvas view
	 * @param [height=0] {number} the height of the canvas view
	 * @param [options] {object} The optional renderer parameters
	 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
	 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
	 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
	 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
	 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
	 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
	 *      not before the new render pass.
	 * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable var if
	 *      you need to call toDataUrl on the webgl context.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.WebGLRenderer"</e></m>
		</meta>
	</class>
	<class path="pixi.core.renderers.webgl.filters.AbstractFilter" params="" file="pixi/core/renderers/webgl/filters/AbstractFilter.hx" extern="1">
		<padding public="1">
			<x path="Float"/>
			<haxe_doc>* The extra padding that the filter might need
	 * @member {number}</haxe_doc>
		</padding>
		<getShader public="1" set="method"><f a="renderer">
	<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
	<d/>
</f></getShader>
		<applyFilter public="1" set="method"><f a="renderer:input:output:clear">
	<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
	<d/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></applyFilter>
		<syncUniform public="1" set="method">
			<f a="uniform">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Syncs a uniform between the class object and the shaders.
	 *</haxe_doc>
		</syncUniform>
		<new public="1" set="method">
			<f a="vertexSrc:fragmentSrc:uniforms">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is the base class for creating a PIXI filter. Currently only WebGL supports filters.
	 * If you want to make a custom filter this should be your base class.
	 *
	 * @class
	 * @memberof PIXI
	 * @param vertexSrc {String|String[]} The vertex shader source as an array of strings.
	 * @param fragmentSrc {String|String[]} The fragment shader source as an array of strings.
	 * @param uniforms {object} An object containing the uniforms for this filter.</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="vertexSrc:fragmentSrc:uniforms">
		<c path="Array"><c path="String"/></c>
		<c path="Array"><c path="String"/></c>
		<d/>
		<x path="Void"/>
	</f>
	<haxe_doc>* This is the base class for creating a PIXI filter. Currently only WebGL supports filters.
	 * If you want to make a custom filter this should be your base class.
	 *
	 * @class
	 * @memberof PIXI
	 * @param vertexSrc {String|String[]} The vertex shader source as an array of strings.
	 * @param fragmentSrc {String|String[]} The fragment shader source as an array of strings.
	 * @param uniforms {object} An object containing the uniforms for this filter.</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"PIXI.AbstractFilter"</e></m></meta>
	</class>
	<class path="pixi.core.renderers.webgl.managers.WebGLManager" params="" file="pixi/core/renderers/webgl/managers/WebGLManager.hx" extern="1">
		<onContextChange public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Generic method called when there is a WebGL context change.
	 *</haxe_doc>
		</onContextChange>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Generic destroy methods to be overridden by the subclass
	 *</haxe_doc>
		</destroy>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.renderers.webgl.managers.BlendModeManager" params="" file="pixi/core/renderers/webgl/managers/BlendModeManager.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.managers.WebGLManager"/>
		<setBlendMode public="1" set="method">
			<f a="blendMode">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets-up the given blendMode from WebGL's point of view.
	 *
	 * @param blendMode {number} the blendMode, should be a Pixi const, such as BlendModes.ADD</haxe_doc>
		</setBlendMode>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @extends WebGlManager
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.renderers.webgl.managers.FilterManager" params="" file="pixi/core/renderers/webgl/managers/FilterManager.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.managers.WebGLManager"/>
		<filterStack public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* @member {any[]}</haxe_doc>
		</filterStack>
		<texturePool public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* @member {any[]}</haxe_doc>
		</texturePool>
		<setFilterStack public="1" set="method">
			<f a="filterStack">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param renderer {WebGLRenderer}
	 * @param buffer {ArrayBuffer}</haxe_doc>
		</setFilterStack>
		<pushFilter public="1" set="method">
			<f a="target:filters">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the filter and adds it to the current filter stack.
	 *
	 * @param filterBlock {object} the filter that will be pushed to the current filter stack</haxe_doc>
		</pushFilter>
		<popFilter public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes the last filter from the filter stack and returns it.
	 *</haxe_doc>
		</popFilter>
		<getRenderTarget public="1" set="method">
			<f a="?clear">
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Grabs an render target from the internal pool
	 *
	 * @param clear {Bool} Whether or not we need to clear the RenderTarget
	 * @return {RenderTarget}</haxe_doc>
		</getRenderTarget>
		<returnRenderTarget public="1" set="method"><f a="renderTarget">
	<d/>
	<d/>
</f></returnRenderTarget>
		<applyFilter public="1" set="method"><f a="shader:inputTarget:outputTarget:?clear">
	<d/>
	<d/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></applyFilter>
		<capFilterArea public="1" set="method"><f a="filterArea">
	<c path="pixi.core.math.shapes.Rectangle"/>
	<x path="Void"/>
</f></capFilterArea>
		<resize public="1" set="method"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @extends WebGlManager
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.renderers.webgl.managers.MaskManager" params="" file="pixi/core/renderers/webgl/managers/MaskManager.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.managers.WebGLManager"/>
		<pushMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the Mask and adds it to the current filter stack.
	 *
	 * @param graphics {Graphics}
	 * @param webGLData {any[]}</haxe_doc>
		</pushMask>
		<popMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes the last mask from the mask stack and doesn't return it.
	 *
	 * @param target {RenderTarget}
	 * @param maskData {any[]}</haxe_doc>
		</popMask>
		<pushSpriteMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the Mask and adds it to the current filter stack.
	 *
	 * @param target {RenderTarget}
	 * @param maskData {any[]}</haxe_doc>
		</pushSpriteMask>
		<popSpriteMask public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes the last filter from the filter stack and doesn't return it.
	 *</haxe_doc>
		</popSpriteMask>
		<pushStencilMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the Mask and adds it to the current filter stack.
	 *
	 * @param target {RenderTarget}
	 * @param maskData {any[]}</haxe_doc>
		</pushStencilMask>
		<popStencilMask public="1" set="method">
			<f a="target:maskData">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes the last filter from the filter stack and doesn't return it.
	 * @param target {RenderTarget}
	 * @param maskData {any[]}</haxe_doc>
		</popStencilMask>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.renderers.webgl.managers.ShaderManager" params="" file="pixi/core/renderers/webgl/managers/ShaderManager.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.managers.WebGLManager"/>
		<maxAttibs public="1">
			<x path="Int"/>
			<haxe_doc>* @member {number}</haxe_doc>
		</maxAttibs>
		<attribState public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* @member {any[]}</haxe_doc>
		</attribState>
		<tempAttribState public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* @member {any[]}</haxe_doc>
		</tempAttribState>
		<stack public="1">
			<c path="Array"><d/></c>
			<haxe_doc>* @member {any[]}</haxe_doc>
		</stack>
		<setAttribs public="1" set="method">
			<f a="attribs">
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Takes the attributes given in parameters and uploads them.
	 *
	 * @param attribs {Array} attribs</haxe_doc>
		</setAttribs>
		<setShader public="1" set="method">
			<f a="shader">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the current shader.
	 *
	 * @param shader {Shader} the shader to upload</haxe_doc>
		</setShader>
		<new public="1" set="method">
			<f a="renderer">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @class
	 * @memberof PIXI
	 * @extends WebGLManager
	 * @param renderer {WebGLRenderer} The renderer this manager works for.</haxe_doc>
		</new>
	</class>
	<class path="pixi.core.sprites.Sprite" params="" file="pixi/core/sprites/Sprite.hx" extern="1">
		<extends path="pixi.core.display.Container"/>
		<fromFrame public="1" set="method" static="1">
			<f a="frameId">
				<c path="String"/>
				<c path="pixi.core.sprites.Sprite"/>
			</f>
			<haxe_doc>* Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
	 * The frame ids are created when a Texture packer file has been loaded
	 *
	 * @static
	 * @param frameId {String} The frame Id of the texture in the cache
	 * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId</haxe_doc>
		</fromFrame>
		<fromImage public="1" set="method" static="1">
			<f a="imageId:?crossorigin:?scaleMode">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="pixi.core.sprites.Sprite"/>
			</f>
			<haxe_doc>* Helper function that creates a sprite that will contain a texture based on an image url
	 * If the image is not in the texture cache it will be loaded
	 *
	 * @static
	 * @param imageId {String} The image url of the texture
	 * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id</haxe_doc>
		</fromImage>
		<anchor public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The anchor sets the origin point of the texture.
	 * The default is 0,0 this means the texture's origin is the top left
	 * Setting than anchor to 0.5,0.5 means the textures origin is centered
	 * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner
	 *
	 * @member {Point}</haxe_doc>
		</anchor>
		<texture public="1">
			<c path="pixi.core.textures.Texture"/>
			<haxe_doc>* The height of the sprite, setting this will actually modify the scale to achieve the value set
	 *
	 * @member
	 * @memberof Sprite#</haxe_doc>
		</texture>
		<tint public="1">
			<x path="Int"/>
			<haxe_doc>* The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
	 *
	 * @member {Int}
	 * @default 0xFFFFFF</haxe_doc>
		</tint>
		<blendMode public="1">
			<x path="Int"/>
			<haxe_doc>* The blend mode to be applied to the sprite. Set to CONST.blendModes.NORMAL to remove any blend mode.
	 *
	 * @member {Int}
	 * @default CONST.blendModes.NORMAL;</haxe_doc>
		</blendMode>
		<shader public="1">
			<d/>
			<haxe_doc>* The shader that will be used to render the sprite. Set to null to remove a current shader.
	 *
	 * @member {AbstractFilter}</haxe_doc>
		</shader>
		<renderCanvas public="1" set="method">
			<f a="renderer">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Renders the object using the Canvas renderer
	*
	* @param renderer {CanvasRenderer} The renderer</haxe_doc>
		</renderCanvas>
		<new public="1" set="method">
			<f a="texture">
				<c path="pixi.core.textures.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The Sprite object is the base for all textured objects that are rendered to the screen
	 *
	 * A sprite can be created directly from an image like this:
	 *
	 * ```js
	 * 	var sprite = new Sprite.fromImage('assets/image.png');
	 * ```
	 *
	 * @class Sprite
	 * @extends Container
	 * @namespace PIXI
	 * @param texture {Texture} The texture for this sprite</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.Sprite"</e></m></meta>
	</class>
	<class path="pixi.core.text.Text" params="" file="pixi/core/text/Text.hx" extern="1">
		<extends path="pixi.core.sprites.Sprite"/>
		<canvas public="1">
			<c path="js.html.CanvasElement"/>
			<haxe_doc>* The canvas element that everything is drawn to
	 *
	 * @member {HTMLCanvasElement}</haxe_doc>
		</canvas>
		<context public="1">
			<c path="js.html.CanvasRenderingContext2D"/>
			<haxe_doc>* The canvas 2d context that everything is drawn with
	 * @member {HTMLCanvasElement}</haxe_doc>
		</context>
		<resolution public="1">
			<x path="Float"/>
			<haxe_doc>* The resolution of the canvas.
	 * @member {number}</haxe_doc>
		</resolution>
		<style public="1">
			<t path="pixi.core.text.TextStyle"/>
			<haxe_doc>* Set the style of the text
     *
	 * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font
	 * @param [style.fill='black'] {String} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
	 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
	 * @param [style.stroke] {String} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
	 * @param [style.strokeThickness=0] {Float} A number that represents the thickness of the stroke. Default is 0 (no stroke)
	 * @param [style.wordWrap=false] {Bool} Indicates if word wrap should be used
	 * @param [style.wordWrapWidth=100] {Float} The width at which text will wrap, it needs wordWrap to be set to true
	 * @param [style.lineHeight] {Float} The line height, a number that represents the vertical space that a letter uses
	 * @param [style.dropShadow=false] {Bool} Set a drop shadow for the text
	 * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
	 * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow
	 * @param [style.dropShadowDistance=5] {Float} Set a distance of the drop shadow
	 * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
	 *      prevent this from happening by adding padding to the top and bottom of text height.
	 * @param [style.textBaseline='alphabetic'] {String} The baseline of the text that is rendered.
	 * @param [style.lineJoin='miter'] {String} The lineJoin property sets the type of corner created, it can resolve
	 *      spiked text issues. Default is 'miter' (creates a sharp corner).
	 * @param [style.miterLimit=10] {Int} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
	 *      or increase the spikiness of rendered text.
     * @memberof Text#</haxe_doc>
		</style>
		<text public="1">
			<c path="String"/>
			<haxe_doc>* Set the copy for the text object. To split a line you can use '\n'.
     *
     * @param text {String} The copy that you would like the text to display
     * @memberof Text#</haxe_doc>
		</text>
		<new public="1" set="method">
			<f a="text:?style:?resolution">
				<c path="String"/>
				<t path="pixi.core.text.TextStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
	 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
	 *
	 * A Text can be created directly from a string and a style object
	 *
	 * ```js
	 * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});
	 * ```
	 *
	 * @class
	 * @extends PIXI.Sprite
	 * @memberof PIXI
	 * @param text {string} The copy that you would like the text to display
	 * @param [style] {TextStyle} The style parameters
	 * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font
	 * @param [style.fill='black'] {String} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
	 * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
	 * @param [style.stroke] {String} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
	 * @param [style.strokeThickness=0] {Float} A number that represents the thickness of the stroke. Default is 0 (no stroke)
	 * @param [style.wordWrap=false] {Bool} Indicates if word wrap should be used
	 * @param [style.wordWrapWidth=100] {Float} The width at which text will wrap, it needs wordWrap to be set to true
	 * @param [style.lineHeight] {Float} The line height, a number that represents the vertical space that a letter uses
	 * @param [style.dropShadow=false] {Bool} Set a drop shadow for the text
	 * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
	 * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow
	 * @param [style.dropShadowDistance=5] {Float} Set a distance of the drop shadow
	 * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will
	 *      prevent this from happening by adding padding to the top and bottom of text height.
	 * @param [style.textBaseline='alphabetic'] {String} The baseline of the text that is rendered.
	 * @param [style.lineJoin='miter'] {String} The lineJoin property sets the type of corner created, it can resolve
	 *      spiked text issues. Default is 'miter' (creates a sharp corner).
	 * @param [style.miterLimit=10] {Int} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
	 *      or increase the spikiness of rendered text.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Text"</e></m>
		</meta>
	</class>
	<typedef path="pixi.core.text.TextStyle" params="" file="pixi/core/text/Text.hx" module="pixi.core.text.Text"><a>
	<wordWrapWidth>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</wordWrapWidth>
	<wordWrap>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</wordWrap>
	<textBaseline>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</textBaseline>
	<strokeThickness>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</strokeThickness>
	<stroke>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</stroke>
	<padding>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</padding>
	<miterLimit>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</miterLimit>
	<lineJoin>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</lineJoin>
	<lineHeight>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</lineHeight>
	<font>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</font>
	<fill>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</fill>
	<dropShadowDistance>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</dropShadowDistance>
	<dropShadowColor>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</dropShadowColor>
	<dropShadowAngle>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</dropShadowAngle>
	<dropShadow>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</dropShadow>
	<align>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</align>
</a></typedef>
	<class path="pixi.core.textures.BaseTexture" params="" file="pixi/core/textures/BaseTexture.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<fromImage public="1" set="method" static="1">
			<f a="imageUrl:?crossorigin:?scaleMode">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="pixi.core.textures.BaseTexture"/>
			</f>
			<haxe_doc>* Helper function that creates a base texture from the given image url.
	 * If the image is not in the base texture cache it will be created and loaded.
	 *
	 * @static
	 * @param imageUrl {String} The image url of the texture
	 * @param [crossorigin=(auto)] {Bool} Should use anonymouse CORS? Defaults to true if the URL is not a data-URI.
	 * @param [scaleMode=scaleModes.DEFAULT] {Int} See {@link scaleModes} for possible values
	 * @return BaseTexture</haxe_doc>
		</fromImage>
		<fromCanvas public="1" set="method" static="1">
			<f a="canvas:?scaleMode">
				<c path="js.html.CanvasElement"/>
				<x path="Int"/>
				<c path="pixi.core.textures.BaseTexture"/>
			</f>
			<haxe_doc>* Helper function that creates a base texture from the given canvas element.
	 *
	 * @static
	 * @param canvas {Canvas} The canvas element source of the texture
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return BaseTexture</haxe_doc>
		</fromCanvas>
		<resolution public="1">
			<x path="Float"/>
			<haxe_doc>* The Resolution of the texture.
	 *
	 * @member {Float}</haxe_doc>
		</resolution>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the base texture set when the image has loaded
	 *
	 * @member {Float}
	 * @readOnly</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the base texture set when the image has loaded
	 *
	 * @member {Float}
	 * @readOnly</haxe_doc>
		</height>
		<scaleMode public="1">
			<x path="Int"/>
			<haxe_doc>* The scale mode to apply when scaling this texture
	 *
	 * @member {Int}
	 * @default scaleModes.LINEAR</haxe_doc>
		</scaleMode>
		<hasLoaded public="1">
			<x path="Bool"/>
			<haxe_doc>* Set to true once the base texture has successfully loaded.
	 *
	 * This is never true if the underlying source fails to load or has no texture data.
	 *
	 * @member {Bool}
	 * @readOnly</haxe_doc>
		</hasLoaded>
		<isLoading public="1">
			<x path="Bool"/>
			<haxe_doc>* Set to true if the source is currently loading.
	 *
	 * If an Image source is loading the 'loaded' or 'error' event will be
	 * dispatched when the operation ends. An underyling source that is
	 * immediately-available bypasses loading entirely.
	 *
	 * @member {Bool}
	 * @readonly</haxe_doc>
		</isLoading>
		<source public="1">
			<d/>
			<haxe_doc>* The image source that is used to create the texture.
	 *
	 * @member {Image|Canvas}
	 * @readonly</haxe_doc>
		</source>
		<premultipliedAlpha public="1">
			<x path="Bool"/>
			<haxe_doc>* Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
	 *
	 * @member {Bool}
	 * @default true</haxe_doc>
		</premultipliedAlpha>
		<imageUrl public="1">
			<c path="String"/>
			<haxe_doc>* @member {String}</haxe_doc>
		</imageUrl>
		<mipmap public="1">
			<x path="Bool"/>
			<haxe_doc>*
	 * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
	 * Also the texture must be a power of two size to work
	 *
	 * @member {Bool}</haxe_doc>
		</mipmap>
		<update public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the texture on all the webgl renderers.
	 *
	 * @fires update</haxe_doc>
		</update>
		<destroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroys this base texture
	 *</haxe_doc>
		</destroy>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Frees the texture from WebGL memory without destroying this texture object.
	 * This means you can still use the texture later which will upload it to GPU
	 * memory again.
	 *</haxe_doc>
		</dispose>
		<loadSource public="1" set="method">
			<f a="source">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Load a source.
	 *
	 * If the source is not-immediately-available, such as an image that needs to be
	 * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
	 * and `hasLoaded` will remain false after this call.
	 *
	 * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
	 *
	 *     if (texture.hasLoaded) {
	 *        // texture ready for use
	 *     } else if (texture.isLoading) {
	 *        // listen to 'loaded' and/or 'error' events on texture
	 *     } else {
	 *        // not loading, not going to load UNLESS the source is reloaded
	 *        // (it may still make sense to listen to the events)
	 *     }
	 *
	 * @protected
	 * @param source {Image|Canvas} the source object of the texture.</haxe_doc>
		</loadSource>
		<updateSourceImage public="1" set="method">
			<f a="newSrc">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Changes the source image of the texture.
	 * The original source must be an Image element.
	 *
	 * @param newSrc {String} the path of the image</haxe_doc>
		</updateSourceImage>
		<new public="1" set="method">
			<f a="source:?scaleMode:?resolution">
				<c path="js.html.ImageElement"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A texture stores the information that represents an image. All textures have a base texture.
	 *
	 * @class
	 * @memberof PIXI
	 * @param source {Image|Canvas} the source object of the texture.
	 * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values
	 * @param resolution {number} the resolution of the texture for devices with different pixel ratios</haxe_doc>
			<overloads>
				<new public="1" set="method">
					<f a="source:?scaleMode:?resolution">
						<d/>
						<x path="Int"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* A texture stores the information that represents an image. All textures have a base texture.
	 *
	 * @class
	 * @memberof PIXI
	 * @param source {Image|Canvas} the source object of the texture.
	 * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values
	 * @param resolution {number} the resolution of the texture for devices with different pixel ratios</haxe_doc>
				</new>
				<new public="1" set="method">
					<f a="source:?scaleMode:?resolution">
						<c path="js.html.CanvasElement"/>
						<x path="Int"/>
						<x path="Float"/>
						<x path="Void"/>
					</f>
					<haxe_doc>* A texture stores the information that represents an image. All textures have a base texture.
	 *
	 * @class
	 * @memberof PIXI
	 * @param source {Image|Canvas} the source object of the texture.
	 * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values
	 * @param resolution {number} the resolution of the texture for devices with different pixel ratios</haxe_doc>
				</new>
			</overloads>
		</new>
		<meta><m n=":native"><e>"PIXI.BaseTexture"</e></m></meta>
	</class>
	<class path="pixi.core.textures.Texture" params="" file="pixi/core/textures/Texture.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<fromImage public="1" set="method" static="1">
			<f a="imageId:?crossorigin:?scaleMode">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a Texture object from the given image url.
	 * If the image is not in the texture cache it will be  created and loaded.
	 *
	 * @static
	 * @param imageUrl {String} The image url of the texture
	 * @param crossorigin {Bool} Whether requests should be treated as crossorigin
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return Texture</haxe_doc>
		</fromImage>
		<fromFrame public="1" set="method" static="1">
			<f a="frameId">
				<c path="String"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
	 * The frame ids are created when a Texture packer file has been loaded
	 *
	 * @static
	 * @param frameId {String} The frame Id of the texture in the cache
	 * @return {Texture} The newly created texture</haxe_doc>
		</fromFrame>
		<fromCanvas public="1" set="method" static="1">
			<f a="canvas:?scaleMode">
				<d/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a new Texture based on the given canvas element.
	 *
	 * @static
	 * @param canvas {Canvas} The canvas element source of the texture
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return {Texture}</haxe_doc>
		</fromCanvas>
		<fromVideo public="1" set="method" static="1">
			<f a="video:?scaleMode">
				<c path="js.html.VideoElement"/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a new Texture based on the given video element.
	 *
	 * @static
	 * @param video {VideoElement}
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return {Texture} A Texture</haxe_doc>
		</fromVideo>
		<fromVideoUrl public="1" set="method" static="1">
			<f a="videoUrl:?scaleMode">
				<c path="String"/>
				<x path="Int"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Helper function that creates a new Texture based on the video url.
	 *
	 * @static
	 * @param videoUrl {String}
	 * @param scaleMode {Int} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
	 * @return {Texture} A Texture</haxe_doc>
		</fromVideoUrl>
		<addTextureToCache public="1" set="method" static="1">
			<f a="texture:id">
				<c path="pixi.core.textures.Texture"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.
	 *
	 * @static
	 * @param texture {Texture} The Texture to add to the cache.
	 * @param id {String} The id that the texture will be stored against.</haxe_doc>
		</addTextureToCache>
		<removeTextureFromCache public="1" set="method" static="1">
			<f a="id">
				<c path="String"/>
				<c path="pixi.core.textures.Texture"/>
			</f>
			<haxe_doc>* Remove a texture from the global utils.TextureCache.
	 *
	 * @static
	 * @param id {String} The id of the texture to be removed
	 * @return {Texture} The texture that was removed</haxe_doc>
		</removeTextureFromCache>
		<noFrame public="1">
			<x path="Bool"/>
			<haxe_doc>* Does this Texture have any frame data assigned to it?
	 *
	 * @member {Bool}</haxe_doc>
		</noFrame>
		<baseTexture public="1">
			<c path="pixi.core.textures.BaseTexture"/>
			<haxe_doc>* The base texture that this texture uses.
	 *
	 * @member {BaseTexture}</haxe_doc>
		</baseTexture>
		<trim public="1">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* The texture trim data.
	 *
	 * @member {Rectangle}</haxe_doc>
		</trim>
		<valid public="1">
			<x path="Bool"/>
			<haxe_doc>* This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
	 *
	 * @member {Bool}</haxe_doc>
		</valid>
		<requiresUpdate public="1">
			<x path="Bool"/>
			<haxe_doc>* This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
	 *
	 * @member {Bool}</haxe_doc>
		</requiresUpdate>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the Texture in pixels.
	 *
	 * @member {Float}</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the Texture in pixels.
	 *
	 * @member {Float}</haxe_doc>
		</height>
		<crop public="1">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
	 * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
	 *
	 * @member {Rectangle}</haxe_doc>
		</crop>
		<spritePivot public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The pivot point to used for a sprite this texture belongs to.
	 *
	 * @member {Point}</haxe_doc>
		</spritePivot>
		<rotation public="1">
			<x path="Float"/>
			<haxe_doc>* The rotation value of the texture, copied to a sprite when assigned to it.
	 *
	 * @member {Float}</haxe_doc>
		</rotation>
		<frame public="1">
			<c path="pixi.core.math.shapes.Rectangle"/>
			<haxe_doc>* The frame specifies the region of the base texture that this texture uses
	 *
	 * @member {Rectangle}</haxe_doc>
		</frame>
		<destroy public="1" set="method">
			<f a="?destroyBase">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Destroys this texture
	 *
	 * @param destroyBase {Bool} Whether to destroy the base texture as well</haxe_doc>
		</destroy>
		<update public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates this texture on the gpu.
	 *</haxe_doc>
		</update>
		<new public="1" set="method">
			<f a="baseTexture:?frame:?crop:?trim:?rotate">
				<c path="pixi.core.textures.BaseTexture"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
				<c path="pixi.core.math.shapes.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A texture stores the information that represents an image or part of an image. It cannot be added
	 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
	 *
	 * You can directly create a texture from an image and then reuse it multiple times like this :
	 *
	 * ```js
	 * 	var texture = PIXI.Texture.fromImage('assets/image.png');
	 * 	var sprite1 = new PIXI.Sprite(texture);
	 * 	var sprite2 = new PIXI.Sprite(texture);
	 * ```
	 *
	 * @class
	 * @mixes eventTarget
	 * @memberof PIXI
	 * @param baseTexture {BaseTexture} The base texture source to create the texture from
	 * @param [frame] {Rectangle} The rectangle frame of the texture to show
	 * @param [crop] {Rectangle} The area of original texture
	 * @param [trim] {Rectangle} Trimmed texture rectangle
	 * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="baseTexture:?frame:?crop:?trim:?rotate">
		<c path="pixi.core.textures.VideoBaseTexture"/>
		<c path="pixi.core.math.shapes.Rectangle"/>
		<c path="pixi.core.math.shapes.Rectangle"/>
		<c path="pixi.core.math.shapes.Rectangle"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* A texture stores the information that represents an image or part of an image. It cannot be added
	 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
	 *
	 * You can directly create a texture from an image and then reuse it multiple times like this :
	 *
	 * ```js
	 * 	var texture = PIXI.Texture.fromImage('assets/image.png');
	 * 	var sprite1 = new PIXI.Sprite(texture);
	 * 	var sprite2 = new PIXI.Sprite(texture);
	 * ```
	 *
	 * @class
	 * @mixes eventTarget
	 * @memberof PIXI
	 * @param baseTexture {BaseTexture} The base texture source to create the texture from
	 * @param [frame] {Rectangle} The rectangle frame of the texture to show
	 * @param [crop] {Rectangle} The area of original texture
	 * @param [trim] {Rectangle} Trimmed texture rectangle
	 * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )</haxe_doc>
</new></overloads>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.Texture"</e></m>
		</meta>
	</class>
	<class path="pixi.core.textures.RenderTexture" params="" file="pixi/core/textures/RenderTexture.hx" extern="1">
		<extends path="pixi.core.textures.Texture"/>
		<resolution public="1">
			<x path="Float"/>
			<haxe_doc>* The Resolution of the texture.
	 *
	 * @member {Float}</haxe_doc>
		</resolution>
		<renderer public="1">
			<d/>
			<haxe_doc>* The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.
	 *
	 * @member {CanvasRenderer|WebGLRenderer}</haxe_doc>
		</renderer>
		<resize public="1" set="method">
			<f a="width:height:updateBase">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resizes the RenderTexture.
	 *
	 * @param width {Float} The width to resize to.
	 * @param height {Float} The height to resize to.
	 * @param updateBase {Bool} Should the baseTexture.width and height values be resized as well?</haxe_doc>
		</resize>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the RenderTexture.
	 *</haxe_doc>
		</clear>
		<getImage public="1" set="method">
			<f a=""><c path="js.html.Image"/></f>
			<haxe_doc>* Will return a HTML Image of the texture
	 *
	 * @return {Image}</haxe_doc>
		</getImage>
		<getBase64 public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.
	 *
	 * @return {String} A base64 encoded string of the texture.</haxe_doc>
		</getBase64>
		<getCanvas public="1" set="method">
			<f a=""><c path="js.html.CanvasElement"/></f>
			<haxe_doc>* Creates a Canvas element, renders this RenderTexture to it and then returns it.
	 *
	 * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.</haxe_doc>
		</getCanvas>
		<new public="1" set="method">
			<f a="renderer:?width:?height:?scaleMode:?resolution">
				<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
	 *
	 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
	 * otherwise black rectangles will be drawn instead.
	 *
	 * A RenderTexture takes a snapshot of any Display Object given to its render method. The position
	 * and rotation of the given Display Objects is ignored. For example:
	 *
	 * ```js
	 * 	var renderTexture = new PIXI.RenderTexture(800, 600);
	 * 	var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
	 *
	 * sprite.position.x = 800/2;
	 * sprite.position.y = 600/2;
	 * sprite.anchor.x = 0.5;
	 * sprite.anchor.y = 0.5;
	 *
	 * renderTexture.render(sprite);
	 * ```
	 *
	 * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual
	 * position a Container should be used:
	 *
	 * ```js
	 * 	var doc = new Container();
	 *
	 * doc.addChild(sprite);
	 *
	 * renderTexture.render(doc);  // Renders to center of renderTexture
	 * ```
	 *
	 * @class
	 * @extends Texture
	 * @namespace PIXI
	 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used for this RenderTexture
	 * @param [width=100] {number} The width of the render texture
	 * @param [height=100] {number} The height of the render texture
	 * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values
	 * @param [resolution=1] {number} The resolution of the texture being generated</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="renderer:?width:?height:?scaleMode:?resolution">
		<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
		<x path="Float"/>
		<x path="Float"/>
		<x path="Int"/>
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
	 *
	 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
	 * otherwise black rectangles will be drawn instead.
	 *
	 * A RenderTexture takes a snapshot of any Display Object given to its render method. The position
	 * and rotation of the given Display Objects is ignored. For example:
	 *
	 * ```js
	 * 	var renderTexture = new PIXI.RenderTexture(800, 600);
	 * 	var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
	 *
	 * sprite.position.x = 800/2;
	 * sprite.position.y = 600/2;
	 * sprite.anchor.x = 0.5;
	 * sprite.anchor.y = 0.5;
	 *
	 * renderTexture.render(sprite);
	 * ```
	 *
	 * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual
	 * position a Container should be used:
	 *
	 * ```js
	 * 	var doc = new Container();
	 *
	 * doc.addChild(sprite);
	 *
	 * renderTexture.render(doc);  // Renders to center of renderTexture
	 * ```
	 *
	 * @class
	 * @extends Texture
	 * @namespace PIXI
	 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used for this RenderTexture
	 * @param [width=100] {number} The width of the render texture
	 * @param [height=100] {number} The height of the render texture
	 * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values
	 * @param [resolution=1] {number} The resolution of the texture being generated</haxe_doc>
</new></overloads>
		</new>
		<meta><m n=":native"><e>"PIXI.RenderTexture"</e></m></meta>
	</class>
	<class path="pixi.core.textures.VideoBaseTexture" params="" file="pixi/core/textures/VideoBaseTexture.hx" extern="1">
		<extends path="pixi.core.textures.BaseTexture"/>
		<fromVideo public="1" set="method" static="1">
			<f a="video:?scaleMode">
				<c path="js.html.VideoElement"/>
				<x path="Int"/>
				<c path="pixi.core.textures.VideoBaseTexture"/>
			</f>
			<haxe_doc>* Mimic Pixi BaseTexture.from.... method.
	 *
	 * @static
	 * @param video {HTMLVideoElement}
	 * @param scaleMode {number} See {@link SCALE_MODES} for possible values
	 * @return {VideoBaseTexture}</haxe_doc>
		</fromVideo>
		<fromUrl public="1" set="method" static="1">
			<f a="videoSrc:?scaleMode">
				<c path="String"/>
				<x path="Int"/>
				<c path="pixi.core.textures.VideoBaseTexture"/>
			</f>
			<haxe_doc>* Mimic Pixi BaseTexture.from.... method.
	 *
	 * This can be used in a couple ways, such as:
	 *
	 * ```js
	 * 	var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
	 *
	 * 	var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
	 *
	 * 	var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
	 *
	 * 	var texture = PIXI.VideoBaseTexture.fromUrls([
	 *     { src: '/video.webm', mime: 'video/webm' },
	 *     { src: '/video.mp4', mime: 'video/mp4' }
	 * ]);
	 * ```
	 *
	 * @alias fromUrls
	 * @static
	 * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.
	 * @param [videoSrc.src] {string} One of the source urls for the video
	 * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified
	 *  the url's extension will be used as the second part of the mime type.
	 * @param scaleMode {number} See {@link SCALE_MODES} for possible values
	 * @return {VideoBaseTexture}</haxe_doc>
		</fromUrl>
		<fromUrls public="1" set="method" static="1"><f a="videoSrc:?scaleMode">
	<c path="Array"><c path="String"/></c>
	<x path="Int"/>
	<c path="pixi.core.textures.VideoBaseTexture"/>
</f></fromUrls>
		<new public="1" set="method">
			<f a="source:?scaleMode">
				<c path="js.html.VideoElement"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A texture of a [playing] Video.
	 *
	 * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.
	 *
	 * This can be used in several ways, such as:
	 *
	 * ```js
	 * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
	 *
	 * var texture = PIXI.VideoBaseTexture.fromUrls([
	 *     { src: '/video.webm', mime: 'video/webm' },
	 *     { src: '/video.mp4', mime: 'video/mp4' }
	 * ]);
	 * ```
	 *
	 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
	 *
	 * @class
	 * @extends BaseTexture
	 * @memberof PIXI
	 * @param source {HTMLVideoElement}
	 * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.VideoBaseTexture"</e></m></meta>
	</class>
	<class path="pixi.core.ticker.Ticker" params="" file="pixi/core/ticker/Ticker.hx" extern="1">
		<extends path="pixi.interaction.EventEmitter"/>
		<autoStart public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not this ticker should invoke the method
     * {@link PIXI.ticker.Ticker#start} automatically
     * when a listener is added.
     *
     * @member {Bool}
     * @default false</haxe_doc>
		</autoStart>
		<deltaTime public="1">
			<x path="Float"/>
			<haxe_doc>* Scalar time value from last frame to this frame.
     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
     * and is scaled with {@link PIXI.ticker.Ticker#speed}.
     * **Note:** The cap may be exceeded by scaling.
     *
     * @member {Float}
     * @default 1</haxe_doc>
		</deltaTime>
		<elapsedMS public="1">
			<x path="Float"/>
			<haxe_doc>* Time elapsed in milliseconds from last frame to this frame.
     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
     * is based, this value is neither capped nor scaled.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 s.
     *
     * @member {Float}
     * @default 1 / TARGET_FPMS</haxe_doc>
		</elapsedMS>
		<lastTime public="1">
			<x path="Float"/>
			<haxe_doc>* The last time {@link PIXI.ticker.Ticker#update} was invoked.
     * This value is also reset internally outside of invoking
     * update, but only when a new animation frame is requested.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 s.
     *
     * @member {Float}
     * @default 0</haxe_doc>
		</lastTime>
		<speed public="1">
			<x path="Float"/>
			<haxe_doc>* Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
     * @example
     *     // Scales ticker.deltaTime to what would be
     *     // the equivalent of approximately 120 FPS
     *     ticker.speed = 2;
     *
     * @member {Float}
     * @default 1</haxe_doc>
		</speed>
		<started public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not this ticker has been started.
     * `true` if {@link PIXI.ticker.Ticker#start} has been called.
     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
     * While `false`, this value may change to `true` in the
     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
     * and a listener is added.
     *
     * @member {Bool}
     * @default false</haxe_doc>
		</started>
		<FPS public="1">
			<x path="Int"/>
			<haxe_doc>* The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.ticker.Ticker#speed}, which is specific
     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
     *
     * @member
     * @memberof PIXI.ticker.Ticker#
     * @readonly</haxe_doc>
		</FPS>
		<minFPS public="1">
			<x path="Int"/>
			<haxe_doc>* Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.ticker.Ticker#update}.
     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.TARGET_FPMS * 1000`.
     *
     * @member
     * @memberof PIXI.ticker.Ticker#
     * @default 10</haxe_doc>
		</minFPS>
		<add public="1" set="method">
			<f a="fn:?context">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<c path="pixi.core.ticker.Ticker"/>
			</f>
			<haxe_doc>* Calls EventEmitter.on internally for the
	 * internal 'tick' event. It checks if the emitter has listeners,
	 * and if so it requests a new animation frame at this point.
	 *
	 * @param fn {Function} The listener function to be added for updates
	 * @param [context] {Function} The listener context
	 * @returns {Ticker} this</haxe_doc>
		</add>
		<addOnce public="1" set="method">
			<f a="fn:?context">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<c path="pixi.core.ticker.Ticker"/>
			</f>
			<haxe_doc>* Calls EventEmitter.once internally for the
	 * internal 'tick' event. It checks if the emitter has listeners,
	 * and if so it requests a new animation frame at this point.
	 *
	 * @param fn {Function} The listener function to be added for one update
	 * @param [context] {Function} The listener context
	 * @returns {Ticker} this</haxe_doc>
		</addOnce>
		<remove public="1" set="method">
			<f a="fn:?context">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<c path="pixi.core.ticker.Ticker"/>
			</f>
			<haxe_doc>* Calls EventEmitter.off internally for 'tick' event.
	 * It checks if the emitter has listeners for 'tick' event.
	 * If it does, then it cancels the animation frame.
	 *
	 * @param [fn] {Function} The listener function to be removed
	 * @param [context] {Function} The listener context to be removed
	 * @returns {Ticker} this</haxe_doc>
		</remove>
		<start public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Starts the ticker. If the ticker has listeners
	 * a new animation frame is requested at this point.</haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the ticker. If the ticker has requested
	 * an animation frame it is canceled at this point.</haxe_doc>
		</stop>
		<update public="1" set="method">
			<f a="?currentTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Triggers an update. An update entails setting the
	 * current elapsedMS,
	 * the current deltaTime,
	 * invoking all listeners with current deltaTime,
	 * and then finally setting lastTime
	 * with the value of currentTime that was provided.
	 * This method will be called automatically by animation
	 * frame callbacks if the ticker instance has been started
	 * and listeners are added.
	 *
	 * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution</haxe_doc>
		</update>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* A Ticker class that runs an update loop that other objects listen to.
	 * This class is composed around an EventEmitter object to add listeners
	 * meant for execution on the next requested animation frame.
	 * Animation frames are requested only when necessary,
	 * e.g. When the ticker is started and the emitter has listeners.
	 *
	 * @class
	 * @memberof PIXI.ticker</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.ticker.Ticker"</e></m></meta>
	</class>
	<class path="pixi.core.utils.Utils" params="" file="pixi/core/utils/Utils.hx" extern="1">
		<isWebGLSupported public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Helper for checking for webgl support
	 *
	 * @return {Bool}</haxe_doc>
		</isWebGLSupported>
		<getResolutionOfUrl public="1" set="method" static="1">
			<f a="url">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* get the resolution of an asset by looking for the prefix
	 * used by spritesheets and image urls
	 *
	 * @param url {String} the image path
	 * @return {Float}</haxe_doc>
		</getResolutionOfUrl>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"PIXI.utils"</e></m>
		</meta>
	</class>
	<class path="pixi.extras.BitmapText" params="" file="pixi/extras/BitmapText.hx" extern="1">
		<extends path="pixi.core.display.Container"/>
		<textWidth public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the overall text, different from fontSize,
	 * which is defined in the style object
	 *
	 * @member {Float}
	 * @readOnly</haxe_doc>
		</textWidth>
		<textHeight public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the overall text, different from fontSize,
	 * which is defined in the style object
	 *
	 * @member {Float}
	 * @readOnly</haxe_doc>
		</textHeight>
		<maxWidth public="1">
			<x path="Float"/>
			<haxe_doc>* The max width of this bitmap text in pixels. If the text provided is longer than the value provided, line breaks will be automatically inserted in the last whitespace.
	 * Disable by setting value to 0
	 *
	 * @member {Float}</haxe_doc>
		</maxWidth>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>* The dirty state of this object.
	 *
	 * @member {Bool}</haxe_doc>
		</dirty>
		<tint public="1">
			<x path="Int"/>
			<haxe_doc>* The tint of the BitmapText object
	 *
	 * @member {Int}
	 * @memberof BitmapText#</haxe_doc>
		</tint>
		<align public="1">
			<c path="String"/>
			<haxe_doc>* The alignment of the BitmapText object
	 *
	 * @member {String}
	 * @default 'left'
	 * @memberof BitmapText#</haxe_doc>
		</align>
		<font public="1">
			<d/>
			<haxe_doc>* The font descriptor of the BitmapText object
     *
     * @member {Dynamic}
     * @memberof BitmapText#</haxe_doc>
		</font>
		<text public="1">
			<c path="String"/>
			<haxe_doc>* The text of the BitmapText object
	 *
	 * @member {String}
	 * @memberof BitmapText#</haxe_doc>
		</text>
		<new public="1" set="method">
			<f a="text:?style">
				<c path="String"/>
				<t path="pixi.extras.BitmapTextStyle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A BitmapText object will create a line or multiple lines of text using bitmap font. To
	 * split a line you can use '\n', '\r' or '\r\n' in your string. You can generate the fnt files using:
	 *
	 * A BitmapText can only be created when the font is loaded
	 *
	 * ```js
	 * // in this case the font is in a file called 'desyrel.fnt'
	 * 	var bitmapText = new PIXI.BitmapText("text using a fancy font!", {font: "35px Desyrel", align: "right"});
	 * ```
	 *
	 *
	 * http://www.angelcode.com/products/bmfont/ for windows or
	 * http://www.bmglyph.com/ for mac.
	 *
	 * @class
	 * @extends Container
	 * @memberof PIXI.text
	 * @param text {String} The copy that you would like the text to display
	 * @param style {TextStyle} The style parameters
	 * @param style.font {string|object} The font descriptor for the object, can be passed as a string of form
	 * "24px FontName" or "FontName" or as an object with explicit name/size properties.
	 * @param [style.font.name] {string} The bitmap font id
	 * @param [style.font.size] {number} The size of the font in pixels, e.g. 24
	 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect
	 *      single line text
	 * @param [style.tint=0xFFFFFF] {number} The tint color</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.extras.BitmapText"</e></m></meta>
	</class>
	<typedef path="pixi.extras.BitmapTextStyle" params="" file="pixi/extras/BitmapText.hx" module="pixi.extras.BitmapText"><a>
	<tint>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</tint>
	<font>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</font>
	<align>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</align>
</a></typedef>
	<class path="pixi.extras.MovieClip" params="" file="pixi/extras/MovieClip.hx" extern="1">
		<extends path="pixi.core.sprites.Sprite"/>
		<fromFrames public="1" set="method" static="1">
			<f a="frames">
				<c path="Array"><c path="String"/></c>
				<c path="pixi.extras.MovieClip"/>
			</f>
			<haxe_doc><![CDATA[* A short hand way of creating a movieclip from an array of frame ids
	 *
	 * @static
	 * @param frames {Array<String>} the array of frames ids the movieclip will use as its texture frames]]></haxe_doc>
		</fromFrames>
		<fromImages public="1" set="method" static="1">
			<f a="images">
				<c path="Array"><c path="String"/></c>
				<c path="pixi.extras.MovieClip"/>
			</f>
			<haxe_doc><![CDATA[* A short hand way of creating a movieclip from an array of image ids
	 *
	 * @static
	 * @param images {Array<String>} the array of image urls the movieclip will use as its texture frames]]></haxe_doc>
		</fromImages>
		<animationSpeed public="1">
			<x path="Float"/>
			<haxe_doc>* The speed that the MovieClip will play at. Higher is faster, lower is slower
	 *
	 * @member {Float}
	 * @default 1</haxe_doc>
		</animationSpeed>
		<loop public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the movie clip repeats after playing.
	 *
	 * @member {Bool}
	 * @default true</haxe_doc>
		</loop>
		<onComplete public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* 	function to call when a MovieClip finishes playing
	 *
	 * @method
	 * @memberof MovieClip#</haxe_doc>
		</onComplete>
		<currentFrame public="1">
			<x path="Int"/>
			<haxe_doc>* The MovieClips current frame index (this may not have to be a whole number)
	 *
	 * @member {Int}
	 * @default 0
	 * @readonly</haxe_doc>
		</currentFrame>
		<playing public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates if the MovieClip is currently playing
	 *
	 * @member {Bool}
	 * @readonly</haxe_doc>
		</playing>
		<totalFrames public="1">
			<x path="Int"/>
			<haxe_doc>* totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
	 * assigned to the MovieClip.
	 *
	 * @member
	 * @memberof MovieClip#
	 * @default 0
	 * @readonly</haxe_doc>
		</totalFrames>
		<textures public="1">
			<c path="Array"><c path="pixi.core.textures.Texture"/></c>
			<haxe_doc>* The array of textures used for this MovieClip
	 *
	 * @member
	 * @memberof MovieClip#
	 *</haxe_doc>
		</textures>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the MovieClip
	 *</haxe_doc>
		</stop>
		<play public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Plays the MovieClip
	 *</haxe_doc>
		</play>
		<gotoAndStop public="1" set="method">
			<f a="frameNumber">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops the MovieClip and goes to a specific frame
	 *
	 * @param frameNumber {Int} frame index to stop at</haxe_doc>
		</gotoAndStop>
		<gotoAndPlay public="1" set="method">
			<f a="frameNumber">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Goes to a specific frame and begins playing the MovieClip
	 *
	 * @param frameNumber {Int} frame index to start at</haxe_doc>
		</gotoAndPlay>
		<new public="1" set="method">
			<f a="textures">
				<c path="Array"><c path="pixi.core.textures.Texture"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* A MovieClip is a simple way to display an animation depicted by a list of textures.
	 *
	 * ```js
	 * 	var alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
	 * 	var textureArray = [];
	 *
	 * for (	var i=0; i < 4; i++)
	 * {
	 *      	var texture = PIXI.Texture.fromImage(alienImages[i]);
	 *      textureArray.push(texture);
	 * };
	 *
	 * 	var mc = new PIXI.MovieClip(textureArray);
	 * ```
	 *
	 * @class
	 * @extends Sprite
	 * @memberof PIXI.extras
	 * @param textures {Texture[]} an array of {Texture} objects that make up the animation]]></haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.extras.MovieClip"</e></m></meta>
	</class>
	<class path="pixi.extras.TilingSprite" params="" file="pixi/extras/TilingSprite.hx" extern="1">
		<extends path="pixi.core.sprites.Sprite"/>
		<tileScale public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The scaling of the image that is being tiled
	 *
	 * @member {Point}</haxe_doc>
		</tileScale>
		<tilePosition public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The offset position of the image that is being tiled
	 *
	 * @member {Point}</haxe_doc>
		</tilePosition>
		<generateTilingTexture public="1" set="method">
			<f a="renderer:texture:forcePowerOfTwo">
				<c path="pixi.core.renderers.canvas.CanvasRenderer"/>
				<c path="pixi.core.textures.Texture"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates the tiling texture
	 * @param renderer {CanvasRenderer|WebGLRenderer} a reference to the current renderer
	 * @param texture {Texture} The texture to use to generate the tiling texture
	 * @param forcePowerOfTwo {Bool} Whether we want to force the texture to be a power of two</haxe_doc>
			<overloads><generateTilingTexture public="1" set="method">
	<f a="renderer:texture:forcePowerOfTwo">
		<c path="pixi.core.renderers.webgl.WebGLRenderer"/>
		<c path="pixi.core.textures.Texture"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* Creates the tiling texture
	 * @param renderer {CanvasRenderer|WebGLRenderer} a reference to the current renderer
	 * @param texture {Texture} The texture to use to generate the tiling texture
	 * @param forcePowerOfTwo {Bool} Whether we want to force the texture to be a power of two</haxe_doc>
</generateTilingTexture></overloads>
		</generateTilingTexture>
		<containsPoint public="1" set="method">
			<f a="point">
				<c path="pixi.core.math.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if a point is inside this tiling sprite
	 * @param point {Point} the point to check</haxe_doc>
		</containsPoint>
		<new public="1" set="method">
			<f a="texture:width:height">
				<c path="pixi.core.textures.Texture"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A tiling sprite is a fast way of rendering a tiling image
	 *
	 * @class
	 * @extends Sprite
	 * @memberof PIXI.extras
	 * @param texture {Texture} the texture of the tiling sprite
	 * @param width {Float}  the width of the tiling sprite
	 * @param height {Float} the height of the tiling sprite</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.extras.TilingSprite"</e></m></meta>
	</class>
	<class path="pixi.filters.ascii.AsciiFilter" params="" file="pixi/filters/ascii/AsciiFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<size public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* The pixel size used by the filter.
     *
     * @member {number}
     * @memberof AsciiFilter#</haxe_doc>
		</size>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* An ASCII filter.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.AsciiFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.blur.BlurFilter" params="" file="pixi/filters/blur/BlurFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<passes public="1">
			<x path="Int"/>
			<haxe_doc>* Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {Int}
     * @memberof BlurYFilter#
     * @default 1</haxe_doc>
		</passes>
		<blur public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {Float}
     * @memberOf BlurFilter#
     * @default 2</haxe_doc>
		</blur>
		<blurX public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength of the blurX property
     *
     * @member {Float}
     * @memberOf BlurFilter#
     * @default 2</haxe_doc>
		</blurX>
		<blurY public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength of the blurY property
     *
     * @member {Float}
     * @memberOf BlurFilter#
     * @default 2</haxe_doc>
		</blurY>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The BlurFilter applies a Gaussian blur to an object.
	 * The strength of the blur can be set for x- and y-axis separately.
	 *
	 * @class
	 * @extends AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.BlurFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.blur.BlurXFilter" params="" file="pixi/filters/blur/BlurXFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<passes public="1">
			<x path="Int"/>
			<haxe_doc>* Sets the number of passes for blur. More passes means higher quaility bluring.
	 *
	 * @member {Int}
	 * @memberof BlurXFilter#
	 * @default 1</haxe_doc>
		</passes>
		<strendth public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength for blur.
	 *
	 * @member {Float}
	 * @memberof BlurYFilter#
	 * @default 4</haxe_doc>
		</strendth>
		<blur public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength of both the blur.
	 *
	 * @member {Float}
	 * @memberof BlurXFilter#
	 * @default 2</haxe_doc>
		</blur>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The BlurXFilter applies a horizontal Gaussian blur to an object.
	 *
	 * @class
	 * @extends AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.BlurXFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.blur.BlurYFilter" params="" file="pixi/filters/blur/BlurYFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<passes public="1">
			<x path="Int"/>
			<haxe_doc>* Sets the number of passes for blur. More passes means higher quaility bluring.
	 *
	 * @member {Int}
	 * @memberof BlurYFilter#
	 * @default 1</haxe_doc>
		</passes>
		<blur public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength of both the blur.
	 *
	 * @member {Float}
	 * @memberof BlurYFilter#
	 * @default 2</haxe_doc>
		</blur>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* TheBlurYFilter applies a vertical Gaussian blur to an object.
	 *
	 * @class
	 * @extends AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.BlurYFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.blur.SmartBlurFilter" params="" file="pixi/filters/blur/SmartBlurFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* A Smart Blur Filter.
	 *
	 * @class
	 * @extends AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.SmartBlurFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.color.ColorMatrixFilter" params="" file="pixi/filters/color/ColorMatrixFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<matrix public="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* Sets the matrix of the color matrix filter
     *
     * @member {number[]}
     * @memberof ColorMatrixFilter#
     * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]</haxe_doc>
		</matrix>
		<brightness public="1" set="method">
			<f a="b:multiply">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adjusts brightness
	 *
	 * Multiply the current matrix
	 * @param b {Float} value of the brigthness (0 is black)
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</brightness>
		<greyscale public="1" set="method">
			<f a="scale:multiply">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the matrices in grey scales
	 *
	 * Multiply the current matrix
	 * @param scale {Float} value of the grey (0 is black)
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</greyscale>
		<blackAndWhite public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the black and white matrice
	 * Multiply the current matrix
	 *
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</blackAndWhite>
		<hue public="1" set="method">
			<f a="rotation:multiply">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the hue propertie of the color
	 *
	 * Multiply the current matrix
	 * @param rotation {Float} in degrees
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</hue>
		<contrast public="1" set="method">
			<f a="amount:multiply">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the contrast matrix, increase the separation between dark and bright
	 * Increase contrast : shadows darker and highlights brighter
	 * Decrease contrast : bring the shadows up and the highlights down
	 *
	 * @param amount {Float} value of the contrast
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</contrast>
		<saturation public="1" set="method">
			<f a="amount:multiply">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the saturation matrix, increase the separation between colors
	 * Increase saturation : increase contrast, brightness, and sharpness
	 * @param amount {Float}
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</saturation>
		<desaturate public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Desaturate image (remove color)
	 *
	 * Call the saturate function
	 *
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</desaturate>
		<negative public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Negative image (inverse of classic rgb matrix)
	 *
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</negative>
		<sepia public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sepia image
	 *
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</sepia>
		<technicolor public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Color motion picture process invented in 1916 (thanks Dominic Szablewski)
	 *
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</technicolor>
		<polaroid public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Polaroid filter
	 *
	 * @param multiply {boolean} refer to ._loadMatrix() method</haxe_doc>
		</polaroid>
		<toBGR public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Filter who transforms : Red -> Blue and Blue -> Red
	 *
	 * @param multiply {Bool} refer to ._loadMatrix() method]]></haxe_doc>
		</toBGR>
		<kodachrome public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
	 *
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</kodachrome>
		<browni public="1" set="method">
			<f a="multiply">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Brown delicious browni filter (thanks Dominic Szablewski)
	 *
	 * @param multiply {Bool} refer to ._loadMatrix() method</haxe_doc>
		</browni>
		<vintage public="1" set="method"><f a="multiply">
	<x path="Bool"/>
	<x path="Void"/>
</f></vintage>
		<colorTone public="1" set="method"><f a="desaturation:toned:lightColor:darkColor:multiply">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorTone>
		<night public="1" set="method"><f a="intensity:multiply">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></night>
		<predator public="1" set="method"><f a="amount:multiply">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></predator>
		<lsd public="1" set="method"><f a="multiply">
	<x path="Bool"/>
	<x path="Void"/>
</f></lsd>
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* The ColorMatrixFilter class lets you apply a 5x5 matrix transformation on the RGBA
	 * color and alpha values of every pixel on your displayObject to produce a result
	 * with a new set of RGBA color and alpha values. It's pretty powerful!
	 *
	 * ```js
	 *  var colorMatrix = new PIXI.ColorMatrixFilter();
	 *  container.filters = [colorMatrix];
	 *  colorMatrix.contrast(2);
	 * ```
	 * @author Clment Chenebault <clement@goodboydigital.com>
	 * @class
	 * @extends AbstractFilter
	 * @memberof PIXI.filters]]></haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.ColorMatrixFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.color.ColorStepFilter" params="" file="pixi/filters/color/ColorStepFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<step public="1">
			<x path="Int"/>
			<haxe_doc>* The number of steps to reduce the palette by.
     *
     * @member {Int}
     * @memberof ColorStepFilter#</haxe_doc>
		</step>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This lowers the color depth of your image by the given amount, producing an image with a smaller palette.
	 *
	 * @class
	 * @extends AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.ColorStepFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.dropshadow.DropShadowFilter" params="" file="pixi/filters/dropshadow/DropShadowFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<blur public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {Float}
     * @memberOf DropShadowFilter#
     * @default 2</haxe_doc>
		</blur>
		<blurX public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength of the blurX property
     *
     * @member {Float}
     * @memberOf DropShadowFilter#
     * @default 2</haxe_doc>
		</blurX>
		<blurY public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the strength of the blurY property
     *
     * @member {Float}
     * @memberOf DropShadowFilter#
     * @default 2</haxe_doc>
		</blurY>
		<color public="1">
			<x path="UInt"/>
			<haxe_doc>* Sets the color of the shadow
     *
     * @member {UInt}
     * @memberOf DropShadowFilter#
     * @default 0x000000</haxe_doc>
		</color>
		<alpha public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the alpha of the shadow
     *
     * @member {Float}
     * @memberOf DropShadowFilter#
     * @default 0.75</haxe_doc>
		</alpha>
		<distance public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the distance of the shadow
     *
     * @member {Float}
     * @memberOf DropShadowFilter#
     * @default 10</haxe_doc>
		</distance>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the angle of the shadow
     *
     * @member {Float}
     * @memberOf DropShadowFilter#
     * @default 45 * Math.PI / 180</haxe_doc>
		</angle>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The DropShadowFilter applies a Gaussian blur to an object.
	 * The strength of the blur can be set for x- and y-axis separately.
	 *
	 * @author goodboydigital
	 * @class
	 * @extends AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.DropShadowFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.gray.GrayFilter" params="" file="pixi/filters/gray/GrayFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<gray public="1">
			<x path="Float"/>
			<haxe_doc>* The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color.
     *
     * @member {number}
     * @memberof GrayFilter#</haxe_doc>
		</gray>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This filter applies a pixelate effect making display objects appear 'blocky'.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.GrayFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.pixelate.PixelateFilter" params="" file="pixi/filters/pixelate/PixelateFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<size public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* This a point that describes the size of the blocks.
     * x is the width of the block and y is the height.
     *
     * @member {Point}
     * @memberof PixelateFilter#</haxe_doc>
		</size>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This filter applies a pixelate effect making display objects appear 'blocky'.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.PixelateFilter"</e></m></meta>
	</class>
	<class path="pixi.filters.twist.TwistFilter" params="" file="pixi/filters/twist/TwistFilter.hx" extern="1">
		<extends path="pixi.core.renderers.webgl.filters.AbstractFilter"/>
		<offset public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* This point describes the the offset of the twist.
     *
     * @member {Point}
     * @memberof TwistFilter#</haxe_doc>
		</offset>
		<radius public="1">
			<x path="Float"/>
			<haxe_doc>* This radius of the twist.
     *
     * @member {number}
     * @memberof TwistFilter#</haxe_doc>
		</radius>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* This angle of the twist.
     *
     * @member {number}
     * @memberof TwistFilter#</haxe_doc>
		</angle>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This filter applies a twist effect making display objects appear twisted in the given direction.
	 *
	 * @class
	 * @extends PIXI.AbstractFilter
	 * @memberof PIXI.filters</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.filters.TwistFilter"</e></m></meta>
	</class>
	<typedef path="pixi.interaction.EventTarget" params="" file="pixi/interaction/EventTarget.hx"><a>
	<type><c path="String"/></type>
	<target><d/></target>
	<stopped><x path="Bool"/></stopped>
	<stopPropagation set="method"><f a=""><x path="Void"/></f></stopPropagation>
	<data><c path="pixi.interaction.InteractionData"/></data>
</a></typedef>
	<class path="pixi.interaction.InteractionData" params="" file="pixi/interaction/InteractionData.hx" extern="1">
		<global public="1">
			<c path="pixi.core.math.Point"/>
			<haxe_doc>* This point stores the global coords of where the touch/mouse event happened
     *
     * @member {Point}</haxe_doc>
		</global>
		<target public="1">
			<c path="pixi.core.sprites.Sprite"/>
			<haxe_doc>* The target Sprite that was interacted with
     *
     * @member {Sprite}</haxe_doc>
		</target>
		<originalEvent public="1">
			<c path="js.html.Event"/>
			<haxe_doc>* When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @member {Event}</haxe_doc>
		</originalEvent>
		<identifier public="1">
			<x path="Int"/>
			<haxe_doc>* Touch identifier
     *
     * @member {Event}</haxe_doc>
		</identifier>
		<getLocalPosition public="1" set="method">
			<f a="displayObject:?point">
				<c path="pixi.core.display.DisplayObject"/>
				<c path="pixi.core.math.Point"/>
				<c path="pixi.core.math.Point"/>
			</f>
			<haxe_doc>* This will return the local coordinates of the specified displayObject for this InteractionData
	 *
	 * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off
	 * @param [point] {Point} A Point object in which to store the value, optional (otherwise will create a new point)
	 * @return {Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject</haxe_doc>
		</getLocalPosition>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Holds all information related to an Interaction event
	 *
	 * @class
	 * @memberof PIXI.interaction</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.interaction.InteractionData"</e></m></meta>
	</class>
	<typedef path="pixi.interaction.InteractionManagerOptions" params="" file="pixi/interaction/InteractionManager.hx" module="pixi.interaction.InteractionManager"><a>
	<interactionFrequency>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</interactionFrequency>
	<autoPreventDefault>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</autoPreventDefault>
</a></typedef>
	<typedef path="pixi.loaders.LoaderOptions" params="" file="pixi/loaders/LoaderOptions.hx"><a>
	<xhrType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</xhrType>
	<loadType>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</loadType>
	<crossOrigin>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</crossOrigin>
</a></typedef>
	<class path="pixi.loaders.Resource" params="" file="pixi/loaders/Resource.hx" extern="1">
		<texture public="1"><c path="pixi.core.textures.Texture"/></texture>
		<textures public="1"><d/></textures>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of this resource.
     *
     * @member {string}
     * @readonly</haxe_doc>
		</name>
		<url public="1">
			<c path="String"/>
			<haxe_doc>* The url used to load this resource.
     *
     * @member {string}
     * @readonly</haxe_doc>
		</url>
		<data public="1">
			<d/>
			<haxe_doc>* The data that was loaded by the resource.
     *
     * @member {any}</haxe_doc>
		</data>
		<xhr public="1">
			<d/>
			<haxe_doc>* The XHR object that was used to load this resource. This is only set
     * when `loadType` is `Resource.LOAD_TYPE.XHR`.
     *
     * @member {XMLHttpRequest}</haxe_doc>
		</xhr>
		<xhrType public="1">
			<c path="String"/>
			<haxe_doc>* The type used to load the resource via XHR. If unset, determined automatically.
     *
     * @member {String}</haxe_doc>
		</xhrType>
		<crossOrigin public="1">
			<c path="String"/>
			<haxe_doc>* Is this request cross-origin? If unset, determined automatically.
     *
     * @member {string}</haxe_doc>
		</crossOrigin>
		<loadType public="1">
			<x path="Int"/>
			<haxe_doc>* The method of loading to use for this resource.
     *
     * @member {Resource.LOAD_TYPE}</haxe_doc>
		</loadType>
		<error public="1">
			<d/>
			<haxe_doc>* The error that occurred while loading (if any).
     *
     * @member {Error}
     * @readonly</haxe_doc>
		</error>
		<isJson public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as json. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isJson>
		<isXml public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as xml. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isXml>
		<isImage public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as an image tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isImage>
		<isAudio public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as an audio tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isAudio>
		<isVideo public="1">
			<x path="Bool"/>
			<haxe_doc>* Describes if this resource was loaded as a video tag. Only valid after the resource
     * has completely loaded.
     *
     * @member {Bool}</haxe_doc>
		</isVideo>
		<new public="1" set="method">
			<f a="name:url:?options">
				<c path="String"/>
				<c path="String"/>
				<t path="pixi.loaders.LoaderOptions"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Manages the state and loading of a single resource represented by
	 * a single URL.
	 *
	 * @class
	 * @param name {string} The name of the resource to load.
	 * @param url {string|string[]} The url for this resource, for audio/video loads you can pass an array of sources.
	 * @param [options] {object} The options for the load.
	 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
	 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.LOAD_TYPE} How should this resource be loaded?
	 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
	 *      loaded be interpreted when using XHR?</haxe_doc>
		</new>
	</class>
	<typedef path="pixi.loaders.LOAD_TYPE" params="" file="pixi/loaders/Resource.hx" module="pixi.loaders.Resource">
		<a>
			<XHR><x path="Int"/></XHR>
			<VIDEO><x path="Int"/></VIDEO>
			<IMAGE><x path="Int"/></IMAGE>
			<AUDIO><x path="Int"/></AUDIO>
		</a>
		<haxe_doc>* The types of loading a resource can use.
 *
 * @static
 * @constant
 * @property {object} LOAD_TYPE
 * @property {number} LOAD_TYPE.XHR - Uses XMLHttpRequest to load the resource.
 * @property {number} LOAD_TYPE.IMAGE - Uses an `Image` object to load the resource.
 * @property {number} LOAD_TYPE.AUDIO - Uses an `Audio` object to load the resource.
 * @property {number} LOAD_TYPE.VIDEO - Uses a `Video` object to load the resource.</haxe_doc>
	</typedef>
	<typedef path="pixi.loaders.XHR_READY_STATE" params="" file="pixi/loaders/Resource.hx" module="pixi.loaders.Resource">
		<a>
			<UNSENT><x path="Int"/></UNSENT>
			<OPENED><x path="Int"/></OPENED>
			<LOADING><x path="Int"/></LOADING>
			<HEADERS_RECEIVED><x path="Int"/></HEADERS_RECEIVED>
			<DONE><x path="Int"/></DONE>
		</a>
		<haxe_doc>* The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_READY_STATE
 * @property {number} XHR_READY_STATE.UNSENT - open()has not been called yet.
 * @property {number} XHR_READY_STATE.OPENED - send()has not been called yet.
 * @property {number} XHR_READY_STATE.HEADERS_RECEIVED - send() has been called, and headers and status are available.
 * @property {number} XHR_READY_STATE.LOADING - Downloading; responseText holds partial data.
 * @property {number} XHR_READY_STATE.DONE - The operation is complete.</haxe_doc>
	</typedef>
	<typedef path="pixi.loaders.XHR_RESPONSE_TYPE" params="" file="pixi/loaders/Resource.hx" module="pixi.loaders.Resource">
		<a>
			<TEXT><c path="String"/></TEXT>
			<JSON><c path="String"/></JSON>
			<DOCUMENT><c path="String"/></DOCUMENT>
			<DEFAULT><c path="String"/></DEFAULT>
			<BUFFER><c path="String"/></BUFFER>
			<BLOB><c path="String"/></BLOB>
		</a>
		<haxe_doc>* The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_RESPONSE_TYPE
 * @property {string} XHR_RESPONSE_TYPE.DEFAULT - defaults to text
 * @property {string} XHR_RESPONSE_TYPE.BUFFER - ArrayBuffer
 * @property {string} XHR_RESPONSE_TYPE.BLOB - Blob
 * @property {string} XHR_RESPONSE_TYPE.DOCUMENT - Document
 * @property {string} XHR_RESPONSE_TYPE.JSON - Object
 * @property {string} XHR_RESPONSE_TYPE.TEXT - String</haxe_doc>
	</typedef>
	<typedef path="pixi.loaders.ResourceObject" params="" file="pixi/loaders/ResourceLoader.hx" module="pixi.loaders.ResourceLoader"><a>
	<xhrType>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</xhrType>
	<url><c path="String"/></url>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<loadType>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</loadType>
	<crossOrigin>
		<t path="Null"><d/></t>
		<meta><m n=":optional"/></meta>
	</crossOrigin>
	<callback>
		<t path="Null"><f a="">
	<c path="pixi.loaders.Resource"/>
	<x path="Void"/>
</f></t>
		<meta><m n=":optional"/></meta>
	</callback>
</a></typedef>
	<class path="pixi.mesh.Mesh" params="" file="pixi/mesh/Mesh.hx" extern="1">
		<extends path="pixi.core.display.Container"/>
		<DRAW_MODES public="1" static="1">
			<t path="pixi.mesh.DrawModes"/>
			<haxe_doc>* Different drawing buffer modes supported
	 *
	 * @static
	 * @constant
	 * @property {object} DRAW_MODES
	 * @property {number} DRAW_MODES.TRIANGLE_MESH
	 * @property {number} DRAW_MODES.TRIANGLES</haxe_doc>
		</DRAW_MODES>
		<texture public="1">
			<c path="pixi.core.textures.Texture"/>
			<haxe_doc>* The texture of the Mesh
	 *
	 * @member {Texture}</haxe_doc>
		</texture>
		<uvs public="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc><![CDATA[* The Uvs of the Mesh
	 *
	 * @member {Array<Float>}]]></haxe_doc>
		</uvs>
		<vertices public="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc><![CDATA[* An array of vertices
	 *
	 * @member {Array<Float>}]]></haxe_doc>
		</vertices>
		<indices public="1"><c path="Array"><x path="Int"/></c></indices>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the Mesh is dirty or not
	 *
	 * @member {Bool}</haxe_doc>
		</dirty>
		<blendMode public="1">
			<x path="Int"/>
			<haxe_doc>* The blend mode to be applied to the sprite. Set to blendModes.NORMAL to remove any blend mode.
	 *
	 * @member {Int}
	 * @default CONST.BLEND_MODES.NORMAL;</haxe_doc>
		</blendMode>
		<canvasPadding public="1">
			<x path="Float"/>
			<haxe_doc>* Triangles in canvas mode are automatically antialiased, use var value to force triangles to overlap a bit with each other.
	 *
	 * @member {Float}</haxe_doc>
		</canvasPadding>
		<drawMode public="1">
			<x path="Int"/>
			<haxe_doc>* The way the Mesh should be drawn, can be any of the Mesh.DRAW_MODES consts
	 *
	 * @member {Int}</haxe_doc>
		</drawMode>
		<new public="1" set="method">
			<f a="texture:?vertices:?uvs:?indices:?drawMode">
				<c path="pixi.core.textures.Texture"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Base mesh class
	 * @class
	 * @extends Container
	 * @memberof PIXI.mesh
	 * @param texture {Texture} The texture to use
	 * @param [vertices] {Array<Float>} if you want to specify the vertices
	 * @param [uvs] {Array<Float>} if you want to specify the uvs
	 * @param [indices] {Array<Int>} if you want to specify the indices
	 * @param [drawMode] {Int} the drawMode, can be any of the Mesh.DRAW_MODES consts]]></haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.mesh.Mesh"</e></m></meta>
	</class>
	<typedef path="pixi.mesh.DrawModes" params="" file="pixi/mesh/Mesh.hx" module="pixi.mesh.Mesh"><a>
	<TRIANGLE_MESH><x path="Int"/></TRIANGLE_MESH>
	<TRIANGLES><x path="Int"/></TRIANGLES>
</a></typedef>
	<class path="pixi.mesh.Rope" params="" file="pixi/mesh/Rope.hx" extern="1">
		<extends path="pixi.mesh.Mesh"/>
		<points public="1"><c path="Array"><c path="pixi.core.math.Point"/></c></points>
		<colors public="1"><c path="Array"><x path="Float"/></c></colors>
		<refresh public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Refreshes
	 *</haxe_doc>
		</refresh>
		<new public="1" set="method">
			<f a="texture:?points">
				<c path="pixi.core.textures.Texture"/>
				<c path="Array"><c path="pixi.core.math.Point"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* The rope allows you to draw a texture across several points and them manipulate these points
	 *
	 *```js
	 * for (var i = 0; i < 20; i++) {
	 *     points.push(new PIXI.Point(i * 50, 0));
	 * };
	 * var rope = new PIXI.Rope(PIXI.Texture.fromImage("snake.png"), points);
	 *  ```
	 *
	 * @class
	 * @extends Mesh
	 * @memberof PIXI.mesh
	 * @param {Texture} texture - The texture to use on the rope.
	 * @param {Array} points - An array of {Point} objects to construct var rope.
	 *]]></haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.mesh.Rope"</e></m></meta>
	</class>
	<class path="pixi.plugins.app.Application" params="" file="pixi/plugins/app/Application.hx">
		<pixelRatio public="1">
			<x path="Float"/>
			<haxe_doc>* Sets the pixel ratio of the application.
     * default - 1</haxe_doc>
		</pixelRatio>
		<skipFrame public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Default frame rate is 60 FPS and this can be set to true to get 30 FPS.
	 * default - false</haxe_doc>
		</skipFrame>
		<fps public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Default frame rate is 60 FPS and this can be set to anything between 1 - 60.
	 * default - 60</haxe_doc>
		</fps>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* Width of the application.
	 * default - Browser.window.innerWidth</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* Height of the application.
	 * default - Browser.window.innerHeight</haxe_doc>
		</height>
		<transparent public="1">
			<x path="Bool"/>
			<haxe_doc>* Renderer transparency property.
	 * default - false</haxe_doc>
		</transparent>
		<antialias public="1">
			<x path="Bool"/>
			<haxe_doc>* Graphics antialias property.
	 * default - false</haxe_doc>
		</antialias>
		<forceFXAA public="1">
			<x path="Bool"/>
			<haxe_doc>* Force FXAA shader antialias instead of native (faster).
	 * default - false</haxe_doc>
		</forceFXAA>
		<roundPixels public="1">
			<x path="Bool"/>
			<haxe_doc>* Force round pixels.
	 * default - false</haxe_doc>
		</roundPixels>
		<autoResize public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether you want to resize the canvas and renderer on browser resize.
	 * Should be set to false when custom width and height are used for the application.
	 * default - true</haxe_doc>
		</autoResize>
		<backgroundColor public="1">
			<x path="Int"/>
			<haxe_doc>* Sets the background color of the stage.
	 * default - 0xFFFFFF</haxe_doc>
		</backgroundColor>
		<onUpdate public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Update listener 	function</haxe_doc>
		</onUpdate>
		<onResize public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Window resize listener 	function</haxe_doc>
		</onResize>
		<canvas public="1" set="null">
			<c path="js.html.CanvasElement"/>
			<haxe_doc>* Canvas Element
	 * Read-only</haxe_doc>
		</canvas>
		<renderer public="1" set="null">
			<d/>
			<haxe_doc>* Renderer
	 * Read-only</haxe_doc>
		</renderer>
		<stage public="1" set="null">
			<c path="pixi.core.display.Container"/>
			<haxe_doc>* Global Container.
	 * Read-only</haxe_doc>
		</stage>
		<_lastTime><c path="Date"/></_lastTime>
		<_currentTime><c path="Date"/></_currentTime>
		<_elapsedTime><x path="Float"/></_elapsedTime>
		<_frameCount><x path="Int"/></_frameCount>
		<_stats><c path="jsfps.stats.Stats"/></_stats>
		<set_fps set="method" line="144"><f a="val">
	<x path="Int"/>
	<x path="Int"/>
</f></set_fps>
		<set_skipFrame set="method" line="149"><f a="val">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_skipFrame>
		<start public="1" set="method" line="180">
			<f a="?rendererType:?parentDom">
				<c path="String"/>
				<c path="js.html.Element"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Starts pixi application setup using the properties set or default values
	 * @param [rendererType] - Renderer type to use AUTO (default) | CANVAS | WEBGL
	 * @param [stats] - Enable/disable stats for the application.
	 * Note that stats.js is not part of pixi so don't forget to include it you html page
	 * Can be found in libs folder. "libs/stats.min.js" <script type="text/javascript" src="libs/stats.min.js"></script>
	 * @param [parentDom] - By default canvas will be appended to body or it can be appended to custom element if passed]]></haxe_doc>
		</start>
		<_onWindowResize set="method" line="213">
			<f a="event">
				<c path="js.html.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_onWindowResize>
		<_onRequestAnimationFrame set="method" line="223">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_onRequestAnimationFrame>
		<_calculateElapsedTime set="method" line="238">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</_calculateElapsedTime>
		<_addStats set="method" line="244">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_addStats>
		<_addRenderStats get="inline" set="null" line="289"><f a="?top">
	<x path="Int"/>
	<x path="Void"/>
</f></_addRenderStats>
		<new public="1" set="method" line="139"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Pixi Boilerplate Helper class that can be used by any application
 * @author Adi Reddy Mora
 * http://adireddy.github.io
 * @license MIT
 * @copyright 2015</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="pixi.plugins.spine.Spine" params="" file="pixi/plugins/spine/Spine.hx" extern="1">
		<extends path="pixi.core.display.Container"/>
		<autoUpdate public="1">
			<x path="Bool"/>
			<haxe_doc>* Should the Spine object update its transforms
     *
     * @member {boolean}</haxe_doc>
		</autoUpdate>
		<spineData public="1">
			<d/>
			<haxe_doc>* The spineData object
     *
     * @member {object}</haxe_doc>
		</spineData>
		<skeleton public="1">
			<d/>
			<haxe_doc>* A spine Skeleton object
     *
     * @member {object}</haxe_doc>
		</skeleton>
		<stateData public="1">
			<d/>
			<haxe_doc>* A spine AnimationStateData object created from the spine data passed in the constructor
     *
     * @member {object}</haxe_doc>
		</stateData>
		<state public="1">
			<d/>
			<haxe_doc>* A spine AnimationState object created from the spine AnimationStateData object
     *
     * @member {object}</haxe_doc>
		</state>
		<slotContainers public="1">
			<c path="Array"><c path="pixi.core.display.Container"/></c>
			<haxe_doc>* An array of containers
     *
     * @member {Container[]}</haxe_doc>
		</slotContainers>
		<update public="1" set="method">
			<f a="dt">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Update the spine skeleton and its animations by delta time (dt)
	 *
	 * @param dt {number} Delta time. Time by which the animation should be updated</haxe_doc>
		</update>
		<new public="1" set="method">
			<f a="spineData">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A class that enables the you to import and run your spine animations in pixi.
	 * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class
	 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
	 *
	 * ```js
	 * var spineAnimation = new PIXI.Spine(spineData);
	 * ```
	 *
	 * @class
	 * @extends Container
	 * @memberof PIXI.spine
	 * @param spineData {object} The spine data loaded from a spine atlas.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"PIXI.spine.Spine"</e></m></meta>
	</class>
	<class path="samples.audio.Button" params="" file="samples/audio/Button.hx">
		<extends path="pixi.core.display.Container"/>
		<_data><d/></_data>
		<_label><c path="pixi.core.text.Text"/></_label>
		<_rect><c path="pixi.core.math.shapes.Rectangle"/></_rect>
		<_background><c path="pixi.core.graphics.Graphics"/></_background>
		<_enabled><x path="Bool"/></_enabled>
		<action public="1"><c path="msignal.Signal1"><d/></c></action>
		<_setupBackground set="method" line="36"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></_setupBackground>
		<_setupLabel set="method" line="54"><f a="width:height:fontSize">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></_setupLabel>
		<_redraw set="method" line="66"><f a="colour">
	<x path="Int"/>
	<x path="Void"/>
</f></_redraw>
		<_onMouseDown set="method" line="81"><f a="target">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></_onMouseDown>
		<_onMouseUp set="method" line="85"><f a="target">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></_onMouseUp>
		<_onMouseUpOutside set="method" line="92"><f a="target">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></_onMouseUpOutside>
		<_onMouseOver set="method" line="96"><f a="target">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></_onMouseOver>
		<_onMouseOut set="method" line="100"><f a="target">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></_onMouseOut>
		<_onTouchEndOutside set="method" line="104"><f a="target">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></_onTouchEndOutside>
		<_onTouchEnd set="method" line="108"><f a="target">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></_onTouchEnd>
		<_onTouchStart set="method" line="115"><f a="target">
	<t path="pixi.interaction.EventTarget"/>
	<x path="Void"/>
</f></_onTouchStart>
		<new public="1" set="method" line="27"><f a="label:width:height:?data:?fontSize">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="samples.audio.Main" params="" file="samples/audio/Main.hx">
		<extends path="pixi.plugins.app.Application"/>
		<main set="method" line="83" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<_loader><c path="core.AssetLoader"/></_loader>
		<_baseURL><c path="String"/></_baseURL>
		<_btnContainer><c path="pixi.core.display.Container"/></_btnContainer>
		<_bgSound><c path="core.AudioAsset"/></_bgSound>
		<_sound1><c path="core.AudioAsset"/></_sound1>
		<_sound2><c path="core.AudioAsset"/></_sound2>
		<_onLoadProgress set="method" line="43"><f a=""><x path="Void"/></f></_onLoadProgress>
		<_onLoaded set="method" line="47"><f a=""><x path="Void"/></f></_onLoaded>
		<_playSound1 get="inline" set="null" line="61"><f a=""><x path="Void"/></f></_playSound1>
		<_playSound2 get="inline" set="null" line="65"><f a=""><x path="Void"/></f></_playSound2>
		<_stopAll set="method" line="69"><f a=""><x path="Void"/></f></_stopAll>
		<_addButton set="method" line="75"><f a="label:x:y:width:height:callback">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<x path="Void"/>
</f></_addButton>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
</haxe>